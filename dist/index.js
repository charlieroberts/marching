(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
const SceneNode = require( './sceneNode.js' )
const { param_wrap, MaterialID } = require( './utils.js' )
const { Var, float_var_gen, vec2_var_gen, vec3_var_gen, vec4_var_gen, int_var_gen } = require( './var.js' )

const ops = { 
  Onion: {
    func( sdf,thickness ) { return `vec2( opOnion( ${sdf}.x, ${thickness} ), ${sdf}.y )` },
    variables:[['thickness', 'float', .03]]
  },
  Halve: {
    func( sdf, direction ) { return `vec2( opHalve( ${sdf}.x, p, ${direction} ), ${sdf}.y )` },
    variables:[['direction','int',0]]
  },
  Round: {
    func( sdf, amount ) { return `vec2( ${sdf}.x - ${amount}, ${sdf}.y )` },
    variables:[['amount','float',.1]]
  }
}


const Alterations= {}

for( let name in ops ) {

  // get codegen function
  let op = ops[ name ]

  // create constructor
  Alterations[ name ] = function( sdf, ...args ) {
    const __op = Object.create( Alterations[ name ].prototype )
    __op.sdf = sdf
    __op.variables = []
    __op.__desc = { parameters:[] }

    for( let i = 0; i < op.variables.length; i++ ) {
      const propArray = op.variables[ i ]
      const propName = propArray[ 0 ]
      const propType = propArray[ 1 ]
      const propValue = args[ i ] === undefined ? propArray[ 2 ] : args[ i ]

      __op.__desc.parameters.push({ name:propName, value:propValue })
      let param

      switch( propType ) {
        case 'int':
          param = int_var_gen( propValue )()
          break;
        default:
          param = float_var_gen( propValue )()
          break;
      }
      
      Object.defineProperty( __op, propName, {
        get() { return param },
        set(v) { param.set( v ) }
      })

      __op.variables.push( param )
    }
      
    __op.matId = MaterialID.alloc()

    return __op
  } 

  Alterations[ name ].prototype = SceneNode()

  Alterations[ name ].prototype.emit = function ( __name ) {
    const emitterA = this.sdf.emit( __name )
    //const emitterB = this.b.emit()

    const output = {
      out: op.func( emitterA.out, ...this.variables.map( v => v.emit() ) ), 
      preface: (emitterA.preface || '') 
    }

    return output
  }

  Alterations[name].prototype.emit_decl = function () {
    let str =  this.sdf.emit_decl() 
    for( let v of this.variables ) {
      str += v.emit_decl()
    }

    return str
  };

  Alterations[name].prototype.update_location = function(gl, program) {
    this.sdf.update_location( gl, program )
    for( let v of this.variables ) v.update_location( gl, program )
  }

  Alterations[name].prototype.upload_data = function(gl) {
    this.sdf.upload_data( gl )
    for( let v of this.variables ) v.upload_data( gl )
    
  }
}

Alterations.Halve.UP = 0
Alterations.Halve.DOWN = 1
Alterations.Halve.LEFT = 3
Alterations.Halve.RIGHT = 2

module.exports = Alterations

},{"./sceneNode.js":22,"./utils.js":27,"./var.js":28}],2:[function(require,module,exports){
const Audio = {
  __hasInput: false,
  ctx: null,

  start() {
    if( Audio.__hasInput === false ) {
      Audio.ctx = new AudioContext()
      Audio.createInput().then( input => {
        Audio.createFFT()
        input.connect( Audio.FFT )

        Audio.interval = setInterval( Audio.fftCallback, 1000/60 )
        //window.FFT = Audio.FFT
      })
    }
    Audio.__hasInput = true
  },

  createInput() {
    console.log( 'connecting audio input...' )
    
    const p = new Promise( resolve => {
      console.log( 'start?' )
      navigator.mediaDevices.getUserMedia({ audio:true, video:false })
        .then( stream => {
          console.log( 'audio input connected' )
          Audio.input = Audio.ctx.createMediaStreamSource( stream )
          //Audio.mediaStreamSource.connect( Gibberish.node )
          Audio.__hasInput = true
          resolve( Audio.input )
        })
        .catch( err => { 
          console.log( 'error opening audio input:', err )
        })
    })
    return p
  },

  createFFT() {
    Audio.FFT = Audio.ctx.createAnalyser()

    let __windowSize = 512
    Object.defineProperty( Audio, 'windowSize', {
      get() { return __windowSize },
      set(v){
        __windowSize = v
        Audio.FFT.fftSize = v 
        Audio.FFT.values = new Uint8Array( Audio.FFT.frequencyBinCount )
      }
    })

    Audio.windowSize = 512
  },

  fftCallback() {
    Audio.FFT.getByteFrequencyData( Audio.FFT.values )
    
    let lowSum, midSum, highSum, lowCount, midCount, highCount
    lowSum = midSum = highSum = lowCount = midCount = highCount = 0

    let frequencyCounter = 0

    // does this start at 0Hz? ack... can't remember... does it include DC offset?
    const hzPerBin = (Audio.ctx.sampleRate / 2) / Audio.FFT.frequencyBinCount
    const lowRange = 150, midRange = 1400, highRange = Audio.ctx.sampleRate / 2

    for( let i = 1; i < Audio.FFT.frequencyBinCount; i++ ) {
      if( frequencyCounter < lowRange ) {
        lowSum += Audio.FFT.values[ i ]
        lowCount++
      }else if( frequencyCounter < midRange ) {
        midSum += Audio.FFT.values[ i ]
        midCount++
      }else{
        highSum += Audio.FFT.values[ i ]
        highCount++
      }

      frequencyCounter += hzPerBin
    }

    Audio.low = (lowSum / lowCount) / 255
    Audio.mid = (midSum / midCount) / 255 || 0
    Audio.high = (highSum / highCount) / 255
  }
}

module.exports = Audio

},{}],3:[function(require,module,exports){
const SceneNode = require( './sceneNode.js' ),
      { param_wrap, MaterialID } = require( './utils.js' ),
      { Var, float_var_gen, vec2_var_gen, vec3_var_gen, vec4_var_gen } = require( './var.js' )

const { Vec2, Vec3, Vec4 } = require( './vec.js' )

const BG = function( Scene, SDF ) {

  const Background = function( color ) {
    if( SDF.memo.background === undefined ) {
      const bg = Object.create( Background.prototype )

      const __color = param_wrap( Vec3(color), vec3_var_gen( 0,0,0, 'bg' ), 'bg' )  
      
      Object.defineProperty( bg, 'color', {
        get() { return __color },
        set( v ) {
          __color.var.set( v )
        }
      })
      
      // this refers to the current scene via implicit binding in scene.js
      this.postprocessing.push( bg )

      SDF.memo.background = true
    }
    return this
  }

  Background.prototype = SceneNode()
 
  Object.assign( Background.prototype, {
    emit() {
      return ''//this.color.emit()
    },
   
    emit_decl() {
      let str = this.color.emit_decl()
      SDF.memo.background = true

      return str
    },

    update_location( gl, program ) {
      this.color.update_location( gl, program )
    },

    upload_data( gl ) {
      this.color.upload_data( gl )
    }
  })

  return Background
}

module.exports = BG 

},{"./sceneNode.js":22,"./utils.js":27,"./var.js":28,"./vec.js":29}],4:[function(require,module,exports){
const vec3 = require('gl-vec3')
const mat4 = require('gl-mat4')

// camera adapted from https://github.com/shama/first-person-camera
function FirstPersonCamera(opts) {
  if (!(this instanceof FirstPersonCamera)) return new FirstPersonCamera(opts)
  opts = opts || {}
  this.position = opts.position || vec3.create()
  this.rotation = opts.rotation || vec3.create()
  this.positionSpeed = opts.positionSpeed || -.5
  this.rotationSpeed = opts.rotationSpeed || .01
}
module.exports = FirstPersonCamera

FirstPersonCamera.prototype.view = function(out) {
  if (!out) out = mat4.create()
  // altered x/y ordering from original
  mat4.rotateY(out, out, this.rotation[1])
  mat4.rotateX(out, out, this.rotation[0])
  mat4.rotateZ(out, out, this.rotation[2] - Math.PI)
  mat4.translate(out, out, [-this.position[0], -this.position[1], -this.position[2]])

  return out
}

FirstPersonCamera.prototype.control = function(dt, move, mouse, prevMouse) {
  var speed = (this.positionSpeed / 1000) * dt
  var dir = [0,0,0]
  if (move[0]) dir[2] -= speed * (Marching.keys.Alt ? 4 : 1 )
  else if (move[1]) dir[2] += speed * (Marching.keys.Alt ? 4 : 1 )
  if (move[2]) dir[0] += speed * (Marching.keys.Alt ? 4 : 1 )
  else if (move[3]) dir[0] -= speed * (Marching.keys.Alt ? 4 : 1 )
  if (move[4]) dir[1] -= speed * (Marching.keys.Alt ? 4 : 1 )
  else if (move[5]) dir[1] += speed * (Marching.keys.Alt ? 4 : 1 )
  this.move(dir)
  // just use arrow keys instead of mouse
  // this.pointer(mouse, prevMouse)
}

FirstPersonCamera.prototype.move = function(dir) {
  if (dir[0] !== 0 || dir[1] !== 0 || dir[2] !== 0) {
    var cam = mat4.create()
    mat4.rotateY(cam, cam, this.rotation[1])
    mat4.rotateX(cam, cam, this.rotation[0])
    vec3.transformMat4(dir, dir, cam)
    vec3.add(this.position, this.position, dir)
    this.parent.pos.dirty = true

  }
}

//FirstPersonCamera.prototype.pointer = function(da, db) {
//  var dt = [da[0] - db[0], da[1]- db[1]]
//  var rot = this.rotation
//  rot[1] -= dt[0] * this.rotationSpeed
//  if (rot[1] < 0) rot[1] += Math.PI * 2
//  if (rot[1] >= Math.PI * 2) rot[1] -= Math.PI * 2
//  rot[0] -= dt[1] * this.rotationSpeed
//  if (rot[0] < -Math.PI * .5) rot[0] = -Math.PI*0.5
//  if (rot[0] > Math.PI * .5) rot[0] = Math.PI*0.5
//}

const Camera = {
  init( gl, program, handler ) {

    const camera = FirstPersonCamera({
      fov: 190,
      near:.01,
      far:10,
      direction:[0,0,1],
      viewport:[1,1,1,-1]
    })
    camera.rotation = [0,Math.PI,Math.PI] 
    Camera.__camera = camera
    camera.parent = this

    const camera_pos    = gl.getUniformLocation( program, 'camera_pos' )
    const camera_normal = gl.getUniformLocation( program, 'camera_normal' )
    const camera_rot    = gl.getUniformLocation( program, 'camera_rot' )
    const ucamera       = gl.getUniformLocation( program, 'camera' )

    this.pos = { dirty:false }
    this.dir = { dirty:true }
    this.__rot = { dirty:true, value:0 }

    Object.defineProperty( this, 'rotation', {
      configurable:true,
      get() { return this.__rot.value },
      set(v) { 
        this.__rot.value = v 
        this.__rot.dirty = true
      }
    })

    let px = 0, py =0, pz = 5, nx = 0, ny = 0, nz = 0
    Object.defineProperties( this.pos, {
      x: {
        get()  { return px },
        set(v) { px = camera.position[0] = v;this.dirty = true; }
      },

      y: {
        get()  { return py },
        set(v) { py = camera.position[1] = v; this.dirty = true; }
      },

      z: {
        get()  { return pz },
        set(v) { pz = camera.position[2] = v; this.dirty = true; }
      },
    })

    Object.defineProperties( this.dir, {
      x: {
        get()  { return nx },
        set(v) { nx = camera.rotation[0] = v; this.dirty = true; }
      },

      y: {
        get()  { return ny },
        set(v) { ny = camera.rotation[1] = v; this.dirty = true; }
      },

      z: {
        get()  { return nz },
        set(v) { nz = camera.rotation[2] = v; this.dirty = true; }
      },
    })

    let init = false
    gl.uniform3f( camera_normal, this.dir.x, this.dir.y, this.dir.z )
    camera.position = [this.pos.x, this.pos.y, this.pos.z ] 
    //camera.update()
    gl.uniform3f( camera_pos, this.pos.x, this.pos.y, this.pos.z )
    gl.uniformMatrix4fv( ucamera, false, camera.view() )
    gl.uniform1f( camera_rot, this.rot ) 

    Camera.move = (x,y,z) => {
      // XXX does this need to update property values?
      camera.move([x,y,z])
      Camera.update()
    }
    Camera.moveTo = (x,y,z) => {
      Camera.pos.x = x
      Camera.pos.y = y
      Camera.pos.z = z
    }
    Camera.update = ()=> {
      const pos = camera.position
      gl.uniform3f( camera_pos, pos[0], pos[1], pos[2]  )
      gl.uniformMatrix4fv( ucamera, false, camera.view() )
    }

    // determine an offset from the current camera position based
    // on the current camera rotation e.g. to always position a light
    // behind the camera.
    Camera.offset = (amt=[0,0,3]) => {
      const cam = mat4.create()
      mat4.rotateY(cam, cam, camera.rotation[1])
      mat4.rotateX(cam, cam, camera.rotation[0])
      vec3.transformMat4(amt, amt, cam)
      return amt
    }

    let prvx = 0, prvy = 0, x = 0, y = 0
    Camera.__mousemovefnc = e => {
      prvx = x
      prvy = y
      x = e.pageX
      y = e.pageY
    }

    let prevTime = 0
    let k  = Marching.keys
    Camera.__framefnc = t => {
      if( k.ArrowLeft ) camera.rotation[1] += camera.rotationSpeed
      if( k.ArrowRight ) camera.rotation[1] -= camera.rotationSpeed
      if( k.ArrowUp && !k.Shift ) camera.rotation[0] -= camera.rotationSpeed
      if( k.ArrowDown && !k.Shift) camera.rotation[0] += camera.rotationSpeed
      
      if( Marching.cameraEnabled ) { 
        camera.control( 
          t*1000 - prevTime,
          [k.w,k.s,k.d,k.a,k.ArrowUp && k.Shift, k.ArrowDown && k.Shift], 
          [x,y], [prvx,prvy] 
        )
        Camera.update()
        prvx = x
        prvy = y
        prevTime = t*1000
      }
    }

    Camera.__mousemove = null
    Camera.on = ()=> {
      if( Camera.__mousemove === null ) {
        window.addEventListener( 'mousemove', Camera.__mousemovefnc )
        Camera.__mousemove = true
      }
      if( Marching.callbacks.indexOf( Camera.__framefnc ) === -1 ) {
        Marching.callbacks.push( Camera.__framefnc )
      }
    }

    handler( ()=> {
      if( this.pos.dirty === true ) {

        //camera.position = [this.pos.x, this.pos.y, this.pos.z ]
 
        //camera.position = [this.pos.x, this.pos.y, this.pos.z ]
        //camera.update()
        const pos = camera.position
        gl.uniform3f( camera_pos, pos[0], pos[1], pos[2] )
        gl.uniformMatrix4fv( ucamera, false, camera.view() )
        this.pos.dirty = false


      }

      // XXX this is broken and needs to be fixed
      if( this.dir.dirty === true ) {
        gl.uniform3f( camera_normal, this.dir.x, this.dir.y, this.dir.z )
        gl.uniformMatrix4fv( ucamera, false, camera.view() )
        this.dir.dirty = false
      }
      if( this.__rot.dirty === true ) {
        gl.uniform1f( camera_rot, this.__rot.value )
        this.__rot.dirty = false
      }
      if( typeof this.onmove === 'function' ) {
        this.onmove( this )
      }
    })

  }
}

module.exports = Camera

},{"gl-mat4":58,"gl-vec3":92}],5:[function(require,module,exports){
const SceneNode = require( './sceneNode.js' )
const { param_wrap, MaterialID } = require( './utils.js' )
const { Var, float_var_gen, vec2_var_gen, vec3_var_gen, vec4_var_gen, int_var_gen, VarAlloc } = require( './var.js' )
const Transform = require( './transform.js' )

const ops = { 
  // this needs to create an opOut, not return a vec2
  Displace( __name ) {
    let name = __name === undefined ? 'p' : __name
    const sdf = this.sdf.emit( name );

    const sdfStr = `float d1${this.id} = ${sdf.out}.x;\n`

    let displaceString = `float d2${this.id} = sin( ${this.amount.emit()}.x * ${name}.x ) * `  
    displaceString += `sin( ${this.amount.emit()}.y * ${name}.y ) * `
    displaceString += `sin( ${this.amount.emit()}.z * ${name}.z );\n`
    displaceString += `${sdf.out}.x = (d1${this.id} + d2${this.id}*${this.size.emit()})*.5;\n`

    const output = {
      out: `${sdf.out}`, 
      preface: sdf.preface + sdfStr + displaceString 
    }

    return output
  },

  Bend( __name ) {
    let name = __name === undefined ? 'p' : __name
    const sdf = this.sdf.emit( 'q'+this.id );

    let preface=`        float c${this.id} = cos( ${this.amount.emit()}.x * ${name}.x );
        float s${this.id} = sin( ${this.amount.emit()}.x * ${name}.x );
        mat2  m${this.id} = mat2( c${this.id},-s${this.id},s${this.id},c${this.id} );
        vec4  q${this.id} = vec4( m${this.id} * ${name}.xy, ${name}.z, 1. );\n`

    if( typeof sdf.preface === 'string' ) {
      preface += sdf.preface
    }

    return { preface, out:sdf.out }
  },

  Twist( __name ) {
    let name = __name === undefined ? 'p' : __name
    const sdf = this.sdf.emit( 'q'+this.id );

    let preface=`        float c${this.id} = cos( ${this.amount.emit()}.x * ${name}.y );
        float s${this.id} = sin( ${this.amount.emit()}.x * ${name}.y );
        mat2  m${this.id} = mat2( c${this.id},-s${this.id},s${this.id},c${this.id} );
        vec4  q${this.id} = vec4( m${this.id} * ${name}.xz, ${name}.y, 1. );\n`

    if( typeof sdf.preface === 'string' ) {
      preface += sdf.preface
    }

    return { preface, out:sdf.out }
  },
  __Bump( __name ) {
    let name = __name === undefined ? 'p' : __name

    const bumpString =  `        vec4 transformBump${this.id} = ${name} * ${this.transform.emit()};\n`
    const tex = this.amount.emit( name )

    const pointString = `(transformBump${this.id} * ${this.sdf.transform.emit()})`

    const sdf = this.sdf.emit( pointString, this.transform, `tex${this.id}` ) 

    Marching.textures.addTexture( this.amount.value )

    let preface=`  vec3 tex${this.id} = getTexture( ${this.amount.value.id}, ${pointString}.xyz ) * ${this.size.emit()};\n
        //vec4 displaceBump${this.id} = vec4((${pointString} - tex${this.id}), 1.);
    `
        //${sdf.out}.x = (tex${this.id}.x + tex${this.id}.y + tex${this.id}.z ) / 3. * .5 + ${sdf.out}.x;\n`
        //vec4 ${'p'+this.id} = vec4(${pointString} + tex${this.id}, 1.);\n`

    //sdf.preface += `\n        
    //    ${sdf.out}.x -= min(tex${this.id}.x, min(tex${this.id}.y, tex${this.id}.z));\n` 

    if( typeof sdf.preface === 'string' ) {
      preface = preface + sdf.preface
    }

    preface =  bumpString + preface

    return { preface, out:sdf.out }
  },
  // XXX todo: something like https://www.shadertoy.com/view/ldSGzR
  // https://www.dropbox.com/s/l1yl164jb3rhomq/mm_sfgrad_bump.pdf?dl=0
  Bump( __name ) {
    let name = __name === undefined ? 'p' : __name

    const bumpString =  `        vec4 transformBump${this.id} = ${name} * ${this.transform.emit()};\n`
    const tex = this.amount.emit( name )

    const pointString = `(transformBump${this.id} * ${this.sdf.transform.emit()}).xyz`

    const sdf = this.sdf.emit( `transformBump${this.id}`, this.transform ) 

    Marching.textures.addTexture( this.amount.value )

    let preface=`  vec3 tex${this.id} = getTexture( ${this.amount.value.id}, ${pointString}) * ${this.size.emit()};
        ${sdf.out}.x = (tex${this.id}.x + tex${this.id}.y + tex${this.id}.z)/3. + ${sdf.out}.x;\n`

    if( typeof sdf.preface === 'string' ) {
      preface = sdf.preface + preface
    }

    preface = bumpString + preface

    return { preface, out:sdf.out }
  },
}

const DistanceOps = {}

for( let name in ops ) {

  // get codegen function
  let __op = ops[ name ]

  // create constructor
  DistanceOps[ name ] = function( a,b,c ) {
    const op = Object.create( DistanceOps[ name ].prototype )
    op.sdf = a
    op.amount = b
    op.emit = __op
    op.name = name
    op.transform = Transform()

    const defaultValues = [.5,.5,.5]

    op.id = VarAlloc.alloc()
    const isArray = true 
    
    if( typeof b === 'number' ) {
      b = [b,b,b]
      b.type = 'vec3'
    }
    
    if( name !== 'Bumpz' ) {
      let __var =  param_wrap( 
        b, 
        vec3_var_gen( ...defaultValues ) 
      )

      // for assigning entire new vectors to property
      Object.defineProperty( op, 'amount', {
        get() { return __var },
        set(v) {
          if( typeof v === 'object' ) {
            __var.set( v )
          }else{
            __var.value.x = v
            __var.value.y = v
            __var.value.z = v
            __var.value.w = v
            __var.dirty = true
          }
        }
      })

      op.params = [{ name:'amount' }]
    }else{
      op.params = []
      op.emit_decl = function() {}
      op.emit = function() {}
      op.update_data= function() {}
      op.upload_location = function() {}
    }
    op.__setMaterial = function(mat) {
      if( typeof mat === 'string' ) mat = Marching.Material[ mat ]
      this.__material = this.mat = Marching.materials.addMaterial( mat )
      op.sdf.material( this.__material )
    }
    if( name === 'Displace' || name === 'Bump' ) {
      let __var2 =  param_wrap( 
        c, 
        float_var_gen( .03 ) 
      )
      Object.defineProperty( op, 'size', {
        get() { return __var2 },
        set(v) {
          __var2.set( v )
          __var2.dirty = true
        }
      })

      op.params.push({ name:'size' })
    }
    op.__desc = { parameters:op.params }
    return op
  } 

  DistanceOps[ name ].prototype = SceneNode()

  DistanceOps[name].prototype.emit_decl = function () {
    let str =  this.sdf.emit_decl() + (this.name !== 'Bump' ? this.amount.emit_decl() : '')
    str += this.transform.emit_decl()
    if( this.name === 'Displace' || this.name === 'Bump' ) str += this.size.emit_decl()  

    return str
  };

  DistanceOps[name].prototype.update_location = function(gl, program) {
    this.sdf.update_location( gl, program )
    if( this.name !== 'Bump' ) this.amount.update_location( gl, program )
    if( this.name === 'Displace' || this.name === 'Bump') this.size.update_location( gl, program ) 
    this.transform.update_location( gl, program )
  }

  DistanceOps[name].prototype.upload_data = function(gl) {
    this.sdf.upload_data( gl )
    if( this.name !== 'Bump' ) this.amount.upload_data( gl )
    if( this.name === 'Displace' || this.name === 'Bump') this.size.upload_data( gl )
    this.transform.upload_data( gl )
  }
}

module.exports = DistanceOps


},{"./sceneNode.js":22,"./transform.js":26,"./utils.js":27,"./var.js":28}],6:[function(require,module,exports){
const SceneNode = require( './sceneNode.js' )
const { param_wrap, MaterialID } = require( './utils.js' )
const { Var, float_var_gen, vec2_var_gen, vec3_var_gen, vec4_var_gen, int_var_gen, VarAlloc } = require( './var.js' )
const Transform = require( './transform.js' )
const glslops = require( './distanceOperationsGLSL.js' )

const opslen = { 
  Union:2,
  Intersection:2,
  Difference:2,
  StairsUnion:4,
  StairsIntersection:4,
  StairsDifference:4,
  RoundUnion:3,
  RoundDifference:3,
  RoundIntersection:3,
  ChamferUnion:3,
  ChamferDifference:3,
  ChamferIntersection:3,
  Pipe:3,
  Engrave:3,
  Groove:4,
  Tongue:4,
  
  // these two do not currently have support for transforms or repeats...
  Onion:2,
  Switch:2
}

const ops = { 
  Union( ...args ) { return `opU( ${args.join(',')} )` },
  SmoothUnion( ...args  ) { return `opSmoothUnion( ${args.join(',')} )` },
  Intersection( ...args ) { return `opI( ${args.join(',')} )` },
  SmoothIntersection( ...args ) { return `opSmoothIntersection( ${args.join(',')} )` },  
  Difference( ...args ) { return `opS( ${args.join(',')} )` },  
  SmoothDifference( ...args ) { return `opSmoothSubtraction( ${args.join(',')} )` },  
  StairsUnion(  ...args ) { return `fOpUnionStairs( ${args.join(',')} )`  },
  StairsIntersection( ...args ) { return `fOpIntersectionStairs( ${args.join(',')} )` },
  StairsDifference( ...args ) { return `fOpSubstractionStairs( ${args.join(',')} )` },
  RoundUnion( ...args ) { return `fOpUnionRound( ${args.join(',')} )` },
  RoundDifference( ...args ) { return `fOpDifferenceRound( ${args.join(',')} )` },
  RoundIntersection( ...args ) { return `fOpIntersectionRound( ${args.join(',')} )` },
  ChamferUnion( ...args ) { return `fOpUnionChamfer( ${args.join(',')} )` },
  ChamferDifference( ...args ) { return `fOpDifferenceChamfer( ${args.join(',')} )` },
  ChamferIntersection( ...args ) { return `fOpIntersectionChamfer( ${args.join(',')} )` },
  Pipe( ...args ) { return `fOpPipe( ${args.join(',')} )` },
  Engrave( ...args ) { return `fOpEngrave( ${args.join(',')} )` },
  Groove( ...args ) { return `fOpGroove( ${args.join(',')} )` },
  Tongue( ...args ) { return `fOpTongue( ${args.join(',')} )` },
  
  // these two do not currently have support for transforms or repeats...
  Onion( a,b ) { return `opOnion( ${a}, ${b} )` },
  Switch( a,b,c,d,e,f ) { return `opSwitch( ${a}, ${b}, ${c} )` }
}

const emit_float = function( a ) {
	if (a % 1 === 0)
		return a.toFixed( 1 )
	else
		return a
}

const DistanceOps = {
  __glsl:[],
  __getGLSL() {
    return this.__glsl.join('\n')
  },
  __clear() { this.__glsl.length = 0 }
}


for( let name in ops ) {

  // get codegen function
  let op = ops[ name ]
  const name2 = name + '2'

  // create constructor
  DistanceOps[ name ] = function( a,b,c,d ) {
    const op = Object.create( DistanceOps[ name ].prototype )
    op.a = a
    op.b = b
    op.transform = Transform( false )
    op.id = VarAlloc.alloc()
    op.type = 'distance_op'
    op.name = name

    let __c = param_wrap( c, float_var_gen(.3) )

    op.__len = opslen[ name ]
    if( op.__len > 2 ) {
      Object.defineProperty( op, 'c', {
        get() { return __c },
        set(v) {
          __c.set( v )
        }
      })
      
      if( op.__len > 3 ) {
        let __d = param_wrap( d, float_var_gen(4) )

        Object.defineProperty( op, 'd', {
          get() { return __d },
          set(v) {
            __d.set( v )
          }
        })
      }
    }

    op.__setTexture = function(tex,props) {
      if( typeof tex === 'string' ) {
        this.texture = op.texture.bind( this )
        this.__textureObj = this.tex = Marching.Texture( tex,props,this.texture )
        this.__textureID = this.__textureObj.id
      }else{
        this.__textureObj = this.tex = Object.assign( tex, props )
        this.__textureID = this.__textureObj.id
      }
    }
    op.__setMaterial = function(mat) {
      if( typeof mat === 'string' ) mat = Marching.Material[ mat ]
      this.__material = this.mat = Marching.materials.addMaterial( mat )
    }
    op.__setBump = function(tex,props) {
      //this.bump = p.bump.bind( this )
      const b = this.bump = this.__bumpObj = Marching.Bump( this, tex, props )
      this.bump.texture = this.bump.amount.value
      this.__bumpID = this.__bumpObj.id
      this.rotate = this.bump.rotate
      this.translate = this.bump.translate
      this.scale = this.bump.scale
      Object.defineProperty( this.bump, 'strength', {
        get() { return b.size },
        set(v){ b.size = v }
      })
    }
    Object.assign( op, {
      renderingBump : false,
      emittingDecl  : false,
      uploading     : false,
      updating      : false
    })

    let repeat = null
    Object.defineProperty( op, 'repeat', {
      get() { return repeat },
      set(v){ 
        repeat = v
        this.a.repeat = v
        this.b.repeat = v
      }
    })

    op.matId = MaterialID.alloc()

    op.params = [{name:'c'},{ name:'d'}]
    op.__desc = { parameters: op.params }

    return op
  } 
  
  DistanceOps[ name2 ] = function( ...args ) {
    // accepts unlimited arguments, but the last one could be a blending coefficient
    let blend = .25, coeff=4, u

    if( typeof args[ args.length - 1 ] === 'number' ) {
      blend = args.pop()

      // if there are two non-sdf arguments to the function...
      if( typeof args[ args.length - 1 ] === 'number' ) {
        coeff = blend
        blend = args.pop()
      }

      u = args.reduce( (state,next) => DistanceOps[ name ]( state, next, blend, coeff ) )
    }else{
      u = args.reduce( (state,next) => DistanceOps[ name ]( state, next ) )
    }

    return u
  }

  DistanceOps[ name ].prototype = SceneNode()

  DistanceOps[ name ].prototype.texture = function( ...args ) {
    this.__setTexture( ...args )
    this.a.texture( this.__textureObj )
    this.b.texture( this.__textureObj )

    return this
  }
  DistanceOps[ name ].prototype.material = function( ...args ) {
    this.__setMaterial( ...args )
    this.a.material( this.__material )
    this.b.material( this.__material )

    return this
  }

  const pushString = function( name ) {
    const glslobj = glslops[ name ]
    
    // some definitions are a single string, and not split into
    // separate float and opOut functions
    if( typeof glslobj === 'string' ) {
      if( DistanceOps.__glsl.indexOf( glslobj ) === -1 ) {
        DistanceOps.__glsl.push( glslobj )
      }
    }else{
      // some distance operations are dependent on other ones...
      // if this one has dependencies add them.
      // dependencies must be added before adding other functions
      // so that they're above them in the final GLSL code.
      if( glslobj.dependencies !== undefined ) {
        for( let dname of glslobj.dependencies ) {
          const d = glslops[ dname ]
          if( DistanceOps.__glsl.indexOf( d.float ) === -1 ) {
            DistanceOps.__glsl.push( d.float )
          }
        }
      }  
      if( DistanceOps.__glsl.indexOf( glslobj.float ) === -1 ) {
        DistanceOps.__glsl.push( glslobj.float )
      }
      if( DistanceOps.__glsl.indexOf( glslobj.vec2) === -1 ) {
        DistanceOps.__glsl.push( glslobj.vec2 )
      }
    }
  }

  DistanceOps[ name ].prototype.emit = function ( pname='p', transform = null ){
    if( this.__bumpObj !== undefined && this.renderingBump === false) {
      this.renderingBump = true
      return this.__bumpObj.emit( pname, transform )
    }
    pushString( name )

    if( transform !== null ) this.transform.apply( transform, false )
    //this.transform.internal()

    // first two args are fixed, rest are variable
    let emitters = []
    const a = this.a.emit( pname, this.transform ), 
          b = this.b.emit( pname, this.transform ) 

    emitters[0] = a.out
    emitters[1] = b.out
    if( this.__len > 2 ) emitters.push( this.c.emit() )
    if( this.__len > 3 ) emitters.push( this.d.emit() )
    
    const body = `
        vec2 do${this.id} = ${op( ...emitters )};
        do${this.id}.x *= ${this.transform.emit()}_scale;
    `

    const output = {
      out: 'do'+this.id,
      preface: (a.preface || '') + (b.preface || '') + body
    }

    this.renderingBump = false
    return output
  }

  DistanceOps[name].prototype.emit_decl = function () {
    if( this.__bumpObj !== undefined && this.emittingDecl === false) {
      this.emittingDecl = true
      return this.__bumpObj.emit_decl() 
    }
    let str =  this.transform.emit_decl() + this.a.emit_decl() + this.b.emit_decl()
    if( this.c !== undefined ) str += this.c.emit_decl()
    if( this.d !== undefined ) str += this.d.emit_decl()

    if( ops[ name ].code !== undefined ) {
      //str += ops[ name ].code
      if( Marching.requiredOps.indexOf( ops[ name ].code ) === - 1 ) {
        Marching.requiredOps.push( ops[ name ].code )
      }
    }

    this.emittingDecl = false
    return str
  };

  DistanceOps[name].prototype.update_location = function(gl, program) {
    if( this.__bumpObj !== undefined && this.updating === false) {
      this.updating = true
      return this.__bumpObj.update_location( gl, program )
    }
    this.a.update_location( gl, program )
    this.transform.update_location( gl, program )
    this.b.update_location( gl, program )
    if( this.c !== undefined ) this.c.update_location( gl, program )
    if( this.d !== undefined ) this.d.update_location( gl, program )

    this.updating = false
  }

  DistanceOps[name].prototype.upload_data = function(gl) {
    if( this.__bumpObj !== undefined && this.uploading  === false ) {
      this.uploading = true
      return this.__bumpObj.upload_data( gl )
    }
    this.transform.internal()
    this.transform.upload_data( gl )
    this.a.transform.apply( this.transform )
    this.b.transform.apply( this.transform )
    this.a.upload_data( gl )
    this.b.upload_data( gl )
    if( this.c !== undefined ) this.c.upload_data( gl )
    if( this.d !== undefined ) this.d.upload_data( gl )
    this.uploading = false
    
  }
}

module.exports = DistanceOps

},{"./distanceOperationsGLSL.js":7,"./sceneNode.js":22,"./transform.js":26,"./utils.js":27,"./var.js":28}],7:[function(require,module,exports){
module.exports = {
  Union:{
    float:`
      float opU( float d1, float d2 ) {
        return min(d1,d2);
      }
      `,
    vec2:`
      vec2 opU( vec2 d1, vec2 d2 ) {
        vec2 o;

        if( d1.x < d2.x ) {
          o = d1;
        }else{
          o = d2; 
        }

        return o;
      }
      `
  },
  Intersection:{
    float:`
      float opI( float d1, float d2 ) {
        return max(d1,d2);
      }
      `,
    vec2:`
      vec2 opI( vec2 d1, vec2 d2  ) {
        vec2 o;

        if( d1.x > d2.x ) {
          o = d1; 
        }else{
          o = d2; 
        }

        return o;
      }
      `
  },

  Difference:{
    float:`
      float opS( float d1, float d2 ) { return max(d1,-d2); }
      `,
    vec2:`
      vec2 opS( vec2 d1, vec2 d2  ) {
        vec2 o;

        if( d1.x >= -d2.x ) {
          o = d1; 
        }else{
          d2.x *= -1.;
          o = d2;
        }

        return o;
      }
      `
  },

  StairsUnion:{
    float:`
      float fOpUnionStairs(float a, float b, float r, float n) {
        float s = r/n;
        float u = b-r;
        return min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));
      }`,
    vec2:`
      vec2 fOpUnionStairs( vec2 d1, vec2 d2, float r, float n  ) {
        vec2 o = vec2( 0., d1.y ); 

        if( d1.x <= d2.x ) {
          o.y = d1.y; 
        }else{
          o.y = d2.y; 
        }

        o.x = fOpUnionStairs( d1.x, d2.x, r, n );

        return o;
      }
      `
  },
  StairsIntersection:{
    dependencies: ['StairsUnion'],
    float:`
      // We can just call Union since stairs are symmetric.
      float fOpIntersectionStairs(float a, float b, float r, float n) {
        return -fOpUnionStairs(-a, -b, r, n);
      }
      `,
    vec2:`
      vec2 fOpIntersectionStairs( vec2 d1, vec2 d2, float r, float n  ) {
        vec2 o = vec2( 0., d1.y ); 
        o.x = -fOpUnionStairs( -d1.x, -d2.x, r, n );

        if( -d1.x <= -d2.x ) {
          o.y = d1.y;
        }else{
          o.y = d2.y;
        }

        return o;
      }
      `
  },
  StairsDifference:{
    dependencies: ['StairsUnion'],
    float:`
      float fOpSubstractionStairs(float a, float b, float r, float n) {
        return -fOpUnionStairs(-a, b, r, n);
      }`,
    vec2:`
      vec2 fOpSubstractionStairs( vec2 d1, vec2 d2, float r, float n  ) {
        vec2 o = vec2( 0., d1.y ); 
        o.x = -fOpUnionStairs( -d1.x, d2.x, r, n );

        if( -d1.x <= d2.x ) {
          o.y = d1.y;
        }else{
          o.y = d2.y;
        }

        return o;
      }
      `
  },

  RoundUnion:{
    float:`
      float fOpUnionRound(float a, float b, float r) {
        vec2 u = max(vec2(r - a,r - b), vec2(0));
        return max(r, min (a, b)) - length(u);
      }`,

    vec2:`
      vec2 fOpUnionRound( vec2 d1, vec2 d2, float r  ) {
        vec2 o = vec2( 0., d1.y ); 
        o.x = fOpUnionRound( d1.x, d2.x, r );

        if( d1.x <= d2.x ) {
          o.y = d1.y;
        }else{
          o.y = d2.y;
        }

        return o;
      }
      `
  },
  RoundIntersection:{
    float:`
      float fOpIntersectionRound(float a, float b, float r) {
        vec2 u = max(vec2(r + a,r + b), vec2(0));
        return min(-r, max (a, b)) + length(u);
      }`,
    vec2:`
      vec2 fOpIntersectionRound( vec2 d1, vec2 d2, float r  ) {
        vec2 o = vec2( 0., d1.y ); 
        o.x = fOpIntersectionRound( d1.x, d2.x, r );

        if( d1.x >= d2.x ) {
          o.y = d1.y;
        }else{
          o.y = d2.y;
        }

        return o;
      }
      `
  },

  RoundDifference:{
    dependencies: ['RoundIntersection'],
    float:`
      float fOpDifferenceRound (float a, float b, float r) {
        return fOpIntersectionRound(a, -b, r);
      }`,
    vec2:`
      vec2 fOpDifferenceRound( vec2 d1, vec2 d2, float r  ) {
        vec2 o = vec2( 0., d1.y ); 
        o.x = fOpDifferenceRound( d1.x, d2.x, r );

        if( d1.x >= -d2.x ) {
          o.y = d1.y; 
        }else{
          o.y = d2.y;
        }

        return o;
      }
      `
  },
  ChamferUnion:{
    float:`
      float fOpUnionChamfer(float a, float b, float r) {
        return min(min(a, b), (a - r + b)*sqrt(0.5));
      }`,
    vec2:`
      vec2 fOpUnionChamfer( vec2 d1, vec2 d2, float r  ) {
        vec2 o = vec2( 0., d1.y ); 
        o.x = fOpUnionChamfer( d1.x, d2.x, r );

        if( d1.x <= d2.x ) {
          o.y = d1.y;
        }else{
          o.y = d2.y;
        }

        return o;
      }
      `
  },
  ChamferIntersection:{
    float:`
      float fOpIntersectionChamfer(float a, float b, float r) {
        return max(max(a, b), (a + r + b)*sqrt(0.5));
      }`,
    vec2:`
      vec2 fOpIntersectionChamfer( vec2 d1, vec2 d2, float r   ) {
        vec2 o = vec2( 0., d1.y ); 
        o.x = fOpIntersectionChamfer( d1.x, d2.x, r );

        if( d1.x >= d2.x ) {
          o.y = d1.y;
        }else{
          o.y = d2.y;
        }

        return o;
      }
      `
  },

  ChamferDifference:{
    dependencies:['ChamferIntersection'],
    float:`
      float fOpDifferenceChamfer (float a, float b, float r) {
        return fOpIntersectionChamfer(a, -b, r);
      }`,
    vec2:`
      vec2 fOpDifferenceChamfer( vec2 d1, vec2 d2, float r  ) {
        vec2 o = vec2( 0., d1.y ); 
        o.x = fOpDifferenceChamfer( d1.x, d2.x, r );

        if( d1.x >= -d2.x ) {
          o.y = d1.y;
        }else{
          o.y = d2.y;
        }

        return o;
      }
      `
  },
  Pipe:`
      float fOpPipe(float a, float b, float r) {
        return length(vec2(a, b)) - r;
      }
      vec2 fOpPipe( vec2 d1, vec2 d2, float r   ) {
        vec2 o = vec2( 0., d1.y ); 
        o.x = fOpPipe( d1.x, d2.x, r );

        return o;
      }
      `,

  Engrave:`
      float fOpEngrave(float a, float b, float r) {
        return max(a, (a + r - abs(b))*sqrt(0.5));
      }
      vec2 fOpEngrave( vec2 d1, vec2 d2, float r  ) {
        vec2 o = vec2( 0., d1.y ); 
        o.x = fOpEngrave( d1.x, d2.x, r );

        return o;
      }
      `,
  Groove:`
      float fOpGroove(float a, float b, float ra, float rb) {
        return max(a, min(a + ra, rb - abs(b)));
      }
      vec2 fOpGroove( vec2 d1, vec2 d2, float r, float n  ) {
        vec2 o = vec2( 0., d1.y ); 
        o.x = fOpGroove( d1.x, d2.x, r, n );

        return o;
      }
      `,

  Tongue:`
      float fOpTongue(float a, float b, float ra, float rb) {
        return min(a, max(a - ra, abs(b) - rb));
      }
      vec2 fOpTongue( vec2 d1, vec2 d2, float r, float n  ) {
        vec2 o = vec2( 0., d1.y ); 
        o.x = fOpTongue( d1.x, d2.x, r, n );

        return o;
      }
      `,
  Onion:`
      float opOnion( in float sdf, in float thickness ){
        return abs(sdf)-thickness;
      }

      float opHalve( in float sdf, vec3 p, in int dir ){
        float _out = 0.;
        switch( dir ) {
          case 0:  
            _out = max( sdf, p.y );
            break;
          case 1:
            _out = max( sdf, -p.y );
            break;
          case 2:
            _out = max( sdf, p.x );
            break;
          case 3:
            _out = max( sdf, -p.x );
            break;
        }

        return _out;
      }
      `,

  Switch:`
      vec2 opSwitch( vec2 a, vec2 b, float c ) {
        if( c < .5 ) {
          return a;
        }else{
          return b;
        } 
      }
      `
}

},{}],8:[function(require,module,exports){
const { Var, float_var_gen, vec2_var_gen, vec3_var_gen, vec4_var_gen, int_var_gen, VarAlloc } = require( './var.js' )
const SceneNode = require( './sceneNode.js' )
const { param_wrap, MaterialID } = require( './utils.js' )
const { Vec2, Vec3, Vec4 } = require( './vec.js' )
const Transform = require( './transform.js' )

const descriptions = {
  Elongation: {
    parameters:[ { name:'distance', type:'vec3', default:Vec3(0) } ],
    func:`
      vec4 opElongate( in vec3 p, in vec3 h ) {
        //return vec4( p-clamp(p,-h,h), 0.0 ); // faster, but produces zero in the interior elongated box
        
        vec3 q = abs(p)-h;
        return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );
      }`,
    emit( name='p' ) {
      const pId = this.getID()
      const pName = 'p' + pId

      let preface =
        `        vec4 ${pName}_xyzw = opElongate( ${name}, ${this.distance.emit()} );\n
        vec3 ${pName} = ${pName}_xyzw.xyz;\n`


      const sdf = this.sdf.emit( pName )

      if( typeof sdf.preface === 'string' ) preface += sdf.preface 

      return { out:`vec2(${pName}_xyzw.w + ${sdf.out}.x, ${sdf.out}.y)`, preface }
    }
  },
  PolarRepetition: {
    parameters:[ 
      { name:'count', type:'float', default:5 },
      { name:'distance', type:'vec3', default:Vec3(.25) },

    ],
    emit( name='p', transform=null) {
      const pId = VarAlloc.alloc()
      const pName = 'p' + pId
      const pointString =  `( ${name} * ${this.transform.emit()} ).xyz`

      if( transform !== null ) this.transform.apply( transform, false )
      this.transform.invert()

      let preface =`
          vec4 ${pName} = vec4( polarRepeat( ${pointString}, ${this.__target.count.emit() } ), 1. ); 
          ${pName} -= vec4(${this.__target.distance.emit()}.x,0.,0.,0.);\n`

      const sdf = this.sdf.emit( pName )

      if( typeof sdf.preface === 'string' ) preface += sdf.preface

      return { out:sdf.out, preface }
    }
  },
  Mirror: {
    parameters: [ { name:'distance', type:'vec3', default:Vec3(0) } ],
    extra:[{ name:'dims', type:'local', default:'xyz' }],

    emit( name='p', transform=null, notused=null, scale=null ) {
      const pId = VarAlloc.alloc()
      const pName = 'p' + pId

      if( transform !== null ) {
        this.transform.apply( transform, false )
      }
      this.transform.invert()
     
      const pointString =  `( ${name} * ${this.transform.emit()} ).xyz`,
            s = scale === null ? this.transform.emit_scale() : `${this.transform.emit_scale()} * ${scale}`
 
      let preface =`
        vec4 ${pName} = vec4( ( ${pointString} ) , 1.);\n
        ${pName}.${this.dims} = abs( ${pName}.${this.dims} );\n`

      const sdf = this.sdf.emit( pName, null, null, s )

      if( typeof sdf.preface === 'string' ) preface += sdf.preface 

      return { out:sdf.out, preface }
    }
  },
  //let preface = `         vec3 ${pName} = ${name} / ${this.amount.emit()};\n`

  //let sdf = this.sdf.emit( pName )
  //let out = sdf.out 

  //sdf.preface += `      ${out}.x = ${out}.x * ${this.amount.emit()};\n`

  //if( typeof sdf.preface === 'string' ) preface += sdf.preface
  Repetition: {
    parameters: [ { name:'distance', type:'vec3', default:Vec3(0) } ],
    emit( name='p', transform=null ) {
      const pId = VarAlloc.alloc()
      const pName = 'p' + pId

      if( transform !== null ) this.transform.apply( transform, false )
      
      this.transform.invert()
     
      const pointString =  `( ${name} * ${this.transform.emit()} ).xyz`;

      let preface =`
        vec4 ${pName} = vec4( (mod( ${pointString}, ${this.__target.distance.emit()} ) - .5 * ${this.__target.distance.emit()}) * ${this.transform.emit_scale()}, 1.);\n`

      const sdf = this.sdf.emit( pName )//, this.transform )//, 1, this.__target.distance )

      if( typeof sdf.preface === 'string' ) preface += sdf.preface 

      return { out:sdf.out, preface }
    }
  },
}
  
const getDomainOps = function( SDF ) {
  const ops = {}

  for( let key in descriptions ) {
    const opDesc = descriptions[ key ]
    
    ops[ key ] = function( sdf, ...args ) {
      const op = Object.create( ops[ key ].prototype )
      op.sdf = sdf
      op.parameters = []
      op.transform = Transform()
      op.name = key
      const target = op.__target = op // sdf.__target !== undefined ? sdf.__target : op

      let count = 0
      for( let prop of opDesc.parameters ) {
        op.parameters.push( prop )

        let arg = args[ count ]
        let __var

        switch( prop.type ) {
          case 'vec2':
            if( typeof arg === 'number' ) arg = Vec2( arg )
            if( arg === undefined ) arg = prop.default.copy()

            __var = param_wrap( 
              arg, 
              vec2_var_gen( prop.default )    
            )

            Object.defineProperty( target, prop.name, {
              get() { return __var },
              set(v) {
                if( typeof v === 'object' ) {
                  __var.set( v )
                }else{
                  __var.value.x = v
                  __var.value.y = v
                  __var.dirty = true
                }
              }
            })  

            break;
          case 'vec3':
            if( typeof arg === 'number' ) arg = Vec3( arg )
            if( arg === undefined ) arg = prop.default.copy()

            __var = param_wrap( 
              arg, 
              vec3_var_gen( prop.default )
            )

            Object.defineProperty( target, prop.name, {
              get() { return __var },
              set(v) {
                if( typeof v === 'object' ) {
                  __var.set( v )
                }else{
                  __var.value.x = v
                  __var.value.y = v
                  __var.value.z = v
                  __var.dirty = true
                }
              }
            })  

            break;
          case 'vec4':
            if( typeof arg === 'number' ) arg = Vec4( arg )
              __var = param_wrap( 
              arg, 
              vec4_var_gen( prop.default )  
            )

            if( arg === undefined ) arg = prop.default.copy()

            Object.defineProperty( target, prop.name, {
              get() { return __var },
              set(v) {
                if( typeof v === 'object' ) {
                  __var.set( v )
                }else{
                  __var.value.x = v
                  __var.value.y = v
                  __var.value.z = v
                  __var.value.w = v
                  __var.dirty = true
                }
              }
            })  

            break;
          default: // float
            __var =  param_wrap( 
              arg, 
              float_var_gen( prop.default )
            )

            Object.defineProperty( target, prop.name, {
              get() { return __var },
              set(v) {
                __var.set( v ) 
              }
            })
            break;
          }
        count++
      }
      
      if( opDesc.extra !== undefined ) {
        for( let extra of opDesc.extra ) {
          op[ extra.name ] = args[ count - 1 ] || extra.default
        }
      }

      op.__setTexture = function(tex,props) {
        if( typeof tex === 'string' ) {
          this.texture = op.texture.bind( this )
          this.__textureObj = this.tex = Marching.Texture( tex,props,this.texture )
          this.__textureID = this.__textureObj.id
        }else{
          this.__textureObj = this.tex = Object.assign( tex, props )
          this.__textureID = this.__textureObj.id
        }
      }
      op.__setMaterial = function(mat) {
        if( typeof mat === 'string' ) mat = Marching.Material[ mat ]
        this.__material = this.mat = Marching.materials.addMaterial( mat )
      }
      op.__desc = opDesc

      if( key !== 'Mirror' ) op.sdf.repeat = op
      return op
    }

    ops[ key ].prototype = SceneNode()
    ops[ key ].prototype.emit = opDesc.emit
    
    ops[ key ].prototype.texture = function( ...args ) {
      this.__setTexture( ...args )
      this.sdf.texture( this.__textureObj )

      return this
    }
    ops[ key ].prototype.material = function( ...args ) {
      this.__setMaterial( ...args )
      this.sdf.material( this.__material )

      return this
    }

    ops[ key ].prototype.emit_decl = function( shouldEmitSDF=true ) {
      let decl = ''
      decl += this.transform.emit_decl()
      for( let param of this.parameters ) {
        decl += this.__target[ param.name ].emit_decl() 
      }
      if( shouldEmitSDF ) decl += this.sdf.emit_decl()
      
      // for rotation etc... any extra glsl function that needs to
      // be added to the shader
      if( opDesc.glsl !== undefined && SDF.memo[ key ] === undefined ) {
        decl += opDesc.glsl
        SDF.memo[ key ] = true
      }

      return decl
    }
    ops[ key ].prototype.update_location = function( gl, program, shouldUpdateSDF=true ) {
      for( let param of this.parameters ) this.__target[ param.name ].update_location( gl, program)
      if( shouldUpdateSDF ) this.sdf.update_location( gl, program )
      this.transform.update_location( gl, program )
    }
    ops[ key ].prototype.upload_data = function( gl, shouldUploadSDF=true ) {
      for( let param of this.parameters ) this.__target[ param.name ].upload_data( gl )
      this.transform.upload_data( gl )
      if( shouldUploadSDF ) this.sdf.upload_data( gl )
    }
  }
  
  ops.Repeat = ops.Repetition
  ops.RepeatScale = ops.RepetitionShrink
  ops.PolarRepeat = ops.PolarRepetition

  return ops
}

module.exports = getDomainOps

},{"./sceneNode.js":22,"./transform.js":26,"./utils.js":27,"./var.js":28,"./vec.js":29}],9:[function(require,module,exports){
// matrix.js - taken from https://github.com/evanw/lightgl.js/

// Represents a 4x4 matrix stored in row-major order that uses Float32Arrays
// when available. Matrix operations can either be done using convenient
// methods that return a new matrix for the result or optimized methods
// that store the result in an existing matrix to avoid generating garbage.

var hasFloat32Array = (typeof Float32Array != 'undefined');

// ### new GL.Matrix([elements])
//
// This constructor takes 16 arguments in row-major order, which can be passed
// individually, as a list, or even as four lists, one for each row. If the
// arguments are omitted then the identity matrix is constructed instead.
function Matrix() {
  var m = Array.prototype.concat.apply([], arguments);
  if (!m.length) {
    m = [
      1, 0, 0, 0,
      0, 1, 0, 0,
      0, 0, 1, 0,
      0, 0, 0, 1
    ];
  }
  this.m = hasFloat32Array ? new Float32Array(m) : m;
}

Matrix.prototype = {
  // ### .inverse()
  //
  // Returns the matrix that when multiplied with this matrix results in the
  // identity matrix.
  inverse: function() {
    return Matrix.inverse(this, new Matrix());
  },

  // ### .transpose()
  //
  // Returns this matrix, exchanging columns for rows.
  transpose: function() {
    return Matrix.transpose(this, new Matrix());
  },

  // ### .multiply(matrix)
  //
  // Returns the concatenation of the transforms for this matrix and `matrix`.
  // This emulates the OpenGL function `glMultMatrix()`.
  multiply: function(matrix) {
    return Matrix.multiply(this, matrix, new Matrix());
  },

  // ### .transformPoint(point)
  //
  // Transforms the vector as a point with a w coordinate of 1. This
  // means translations will have an effect, for example.
  transformPoint: function(v) {
    var m = this.m;
    return new Vector(
      m[0] * v.x + m[1] * v.y + m[2] * v.z + m[3],
      m[4] * v.x + m[5] * v.y + m[6] * v.z + m[7],
      m[8] * v.x + m[9] * v.y + m[10] * v.z + m[11]
    ).divide(m[12] * v.x + m[13] * v.y + m[14] * v.z + m[15]);
  },

  // ### .transformPoint(vector)
  //
  // Transforms the vector as a vector with a w coordinate of 0. This
  // means translations will have no effect, for example.
  transformVector: function(v) {
    var m = this.m;
    return new Vector(
      m[0] * v.x + m[1] * v.y + m[2] * v.z,
      m[4] * v.x + m[5] * v.y + m[6] * v.z,
      m[8] * v.x + m[9] * v.y + m[10] * v.z
    );
  }
};

// ### GL.Matrix.inverse(matrix[, result])
//
// Returns the matrix that when multiplied with `matrix` results in the
// identity matrix. You can optionally pass an existing matrix in `result`
// to avoid allocating a new matrix. This implementation is from the Mesa
// OpenGL function `__gluInvertMatrixd()` found in `project.c`.
Matrix.inverse = function(matrix, result) {
  result = result || new Matrix();
  var m = matrix.m, r = result.m;

  r[0] = m[5]*m[10]*m[15] - m[5]*m[14]*m[11] - m[6]*m[9]*m[15] + m[6]*m[13]*m[11] + m[7]*m[9]*m[14] - m[7]*m[13]*m[10];
  r[1] = -m[1]*m[10]*m[15] + m[1]*m[14]*m[11] + m[2]*m[9]*m[15] - m[2]*m[13]*m[11] - m[3]*m[9]*m[14] + m[3]*m[13]*m[10];
  r[2] = m[1]*m[6]*m[15] - m[1]*m[14]*m[7] - m[2]*m[5]*m[15] + m[2]*m[13]*m[7] + m[3]*m[5]*m[14] - m[3]*m[13]*m[6];
  r[3] = -m[1]*m[6]*m[11] + m[1]*m[10]*m[7] + m[2]*m[5]*m[11] - m[2]*m[9]*m[7] - m[3]*m[5]*m[10] + m[3]*m[9]*m[6];

  r[4] = -m[4]*m[10]*m[15] + m[4]*m[14]*m[11] + m[6]*m[8]*m[15] - m[6]*m[12]*m[11] - m[7]*m[8]*m[14] + m[7]*m[12]*m[10];
  r[5] = m[0]*m[10]*m[15] - m[0]*m[14]*m[11] - m[2]*m[8]*m[15] + m[2]*m[12]*m[11] + m[3]*m[8]*m[14] - m[3]*m[12]*m[10];
  r[6] = -m[0]*m[6]*m[15] + m[0]*m[14]*m[7] + m[2]*m[4]*m[15] - m[2]*m[12]*m[7] - m[3]*m[4]*m[14] + m[3]*m[12]*m[6];
  r[7] = m[0]*m[6]*m[11] - m[0]*m[10]*m[7] - m[2]*m[4]*m[11] + m[2]*m[8]*m[7] + m[3]*m[4]*m[10] - m[3]*m[8]*m[6];

  r[8] = m[4]*m[9]*m[15] - m[4]*m[13]*m[11] - m[5]*m[8]*m[15] + m[5]*m[12]*m[11] + m[7]*m[8]*m[13] - m[7]*m[12]*m[9];
  r[9] = -m[0]*m[9]*m[15] + m[0]*m[13]*m[11] + m[1]*m[8]*m[15] - m[1]*m[12]*m[11] - m[3]*m[8]*m[13] + m[3]*m[12]*m[9];
  r[10] = m[0]*m[5]*m[15] - m[0]*m[13]*m[7] - m[1]*m[4]*m[15] + m[1]*m[12]*m[7] + m[3]*m[4]*m[13] - m[3]*m[12]*m[5];
  r[11] = -m[0]*m[5]*m[11] + m[0]*m[9]*m[7] + m[1]*m[4]*m[11] - m[1]*m[8]*m[7] - m[3]*m[4]*m[9] + m[3]*m[8]*m[5];

  r[12] = -m[4]*m[9]*m[14] + m[4]*m[13]*m[10] + m[5]*m[8]*m[14] - m[5]*m[12]*m[10] - m[6]*m[8]*m[13] + m[6]*m[12]*m[9];
  r[13] = m[0]*m[9]*m[14] - m[0]*m[13]*m[10] - m[1]*m[8]*m[14] + m[1]*m[12]*m[10] + m[2]*m[8]*m[13] - m[2]*m[12]*m[9];
  r[14] = -m[0]*m[5]*m[14] + m[0]*m[13]*m[6] + m[1]*m[4]*m[14] - m[1]*m[12]*m[6] - m[2]*m[4]*m[13] + m[2]*m[12]*m[5];
  r[15] = m[0]*m[5]*m[10] - m[0]*m[9]*m[6] - m[1]*m[4]*m[10] + m[1]*m[8]*m[6] + m[2]*m[4]*m[9] - m[2]*m[8]*m[5];

  var det = m[0]*r[0] + m[1]*r[4] + m[2]*r[8] + m[3]*r[12];
  for (var i = 0; i < 16; i++) r[i] /= det;
  return result;
};

// ### GL.Matrix.transpose(matrix[, result])
//
// Returns `matrix`, exchanging columns for rows. You can optionally pass an
// existing matrix in `result` to avoid allocating a new matrix.
Matrix.transpose = function(matrix, result) {
  result = result || new Matrix();
  var m = matrix.m, r = result.m;
  r[0] = m[0]; r[1] = m[4]; r[2] = m[8]; r[3] = m[12];
  r[4] = m[1]; r[5] = m[5]; r[6] = m[9]; r[7] = m[13];
  r[8] = m[2]; r[9] = m[6]; r[10] = m[10]; r[11] = m[14];
  r[12] = m[3]; r[13] = m[7]; r[14] = m[11]; r[15] = m[15];
  return result;
};

// ### GL.Matrix.multiply(left, right[, result])
//
// Returns the concatenation of the transforms for `left` and `right`. You can
// optionally pass an existing matrix in `result` to avoid allocating a new
// matrix. This emulates the OpenGL function `glMultMatrix()`.
Matrix.multiply = function(left, right, result) {
  result = result || new Matrix();
  var a = left.m, b = right.m, r = result.m;

  r[0] = a[0] * b[0] + a[1] * b[4] + a[2] * b[8] + a[3] * b[12];
  r[1] = a[0] * b[1] + a[1] * b[5] + a[2] * b[9] + a[3] * b[13];
  r[2] = a[0] * b[2] + a[1] * b[6] + a[2] * b[10] + a[3] * b[14];
  r[3] = a[0] * b[3] + a[1] * b[7] + a[2] * b[11] + a[3] * b[15];

  r[4] = a[4] * b[0] + a[5] * b[4] + a[6] * b[8] + a[7] * b[12];
  r[5] = a[4] * b[1] + a[5] * b[5] + a[6] * b[9] + a[7] * b[13];
  r[6] = a[4] * b[2] + a[5] * b[6] + a[6] * b[10] + a[7] * b[14];
  r[7] = a[4] * b[3] + a[5] * b[7] + a[6] * b[11] + a[7] * b[15];

  r[8] = a[8] * b[0] + a[9] * b[4] + a[10] * b[8] + a[11] * b[12];
  r[9] = a[8] * b[1] + a[9] * b[5] + a[10] * b[9] + a[11] * b[13];
  r[10] = a[8] * b[2] + a[9] * b[6] + a[10] * b[10] + a[11] * b[14];
  r[11] = a[8] * b[3] + a[9] * b[7] + a[10] * b[11] + a[11] * b[15];

  r[12] = a[12] * b[0] + a[13] * b[4] + a[14] * b[8] + a[15] * b[12];
  r[13] = a[12] * b[1] + a[13] * b[5] + a[14] * b[9] + a[15] * b[13];
  r[14] = a[12] * b[2] + a[13] * b[6] + a[14] * b[10] + a[15] * b[14];
  r[15] = a[12] * b[3] + a[13] * b[7] + a[14] * b[11] + a[15] * b[15];

  return result;
};

// ### GL.Matrix.identity([result])
//
// Returns an identity matrix. You can optionally pass an existing matrix in
// `result` to avoid allocating a new matrix. This emulates the OpenGL function
// `glLoadIdentity()`.
Matrix.identity = function(result) {
  result = result || new Matrix();
  var m = result.m;
  m[0] = m[5] = m[10] = m[15] = 1;
  m[1] = m[2] = m[3] = m[4] = m[6] = m[7] = m[8] = m[9] = m[11] = m[12] = m[13] = m[14] = 0;
  return result;
};

// ### GL.Matrix.perspective(fov, aspect, near, far[, result])
//
// Returns a perspective transform matrix, which makes far away objects appear
// smaller than nearby objects. The `aspect` argument should be the width
// divided by the height of your viewport and `fov` is the top-to-bottom angle
// of the field of view in degrees. You can optionally pass an existing matrix
// in `result` to avoid allocating a new matrix. This emulates the OpenGL
// function `gluPerspective()`.
Matrix.perspective = function(fov, aspect, near, far, result) {
  var y = Math.tan(fov * Math.PI / 360) * near;
  var x = y * aspect;
  return Matrix.frustum(-x, x, -y, y, near, far, result);
};

// ### GL.Matrix.frustum(left, right, bottom, top, near, far[, result])
//
// Sets up a viewing frustum, which is shaped like a truncated pyramid with the
// camera where the point of the pyramid would be. You can optionally pass an
// existing matrix in `result` to avoid allocating a new matrix. This emulates
// the OpenGL function `glFrustum()`.
Matrix.frustum = function(l, r, b, t, n, f, result) {
  result = result || new Matrix();
  var m = result.m;

  m[0] = 2 * n / (r - l);
  m[1] = 0;
  m[2] = (r + l) / (r - l);
  m[3] = 0;

  m[4] = 0;
  m[5] = 2 * n / (t - b);
  m[6] = (t + b) / (t - b);
  m[7] = 0;

  m[8] = 0;
  m[9] = 0;
  m[10] = -(f + n) / (f - n);
  m[11] = -2 * f * n / (f - n);

  m[12] = 0;
  m[13] = 0;
  m[14] = -1;
  m[15] = 0;

  return result;
};

// ### GL.Matrix.ortho(left, right, bottom, top, near, far[, result])
//
// Returns an orthographic projection, in which objects are the same size no
// matter how far away or nearby they are. You can optionally pass an existing
// matrix in `result` to avoid allocating a new matrix. This emulates the OpenGL
// function `glOrtho()`.
Matrix.ortho = function(l, r, b, t, n, f, result) {
  result = result || new Matrix();
  var m = result.m;

  m[0] = 2 / (r - l);
  m[1] = 0;
  m[2] = 0;
  m[3] = -(r + l) / (r - l);

  m[4] = 0;
  m[5] = 2 / (t - b);
  m[6] = 0;
  m[7] = -(t + b) / (t - b);

  m[8] = 0;
  m[9] = 0;
  m[10] = -2 / (f - n);
  m[11] = -(f + n) / (f - n);

  m[12] = 0;
  m[13] = 0;
  m[14] = 0;
  m[15] = 1;

  return result;
};

// ### GL.Matrix.scale(x, y, z[, result])
//
// This emulates the OpenGL function `glScale()`. You can optionally pass an
// existing matrix in `result` to avoid allocating a new matrix.
Matrix.scale = function(x, y, z, result) {
  result = result || new Matrix();
  var m = result.m;

  m[0] = x;
  m[1] = 0;
  m[2] = 0;
  m[3] = 0;

  m[4] = 0;
  m[5] = y;
  m[6] = 0;
  m[7] = 0;

  m[8] = 0;
  m[9] = 0;
  m[10] = z;
  m[11] = 0;

  m[12] = 0;
  m[13] = 0;
  m[14] = 0;
  m[15] = 1;

  return result;
};

// ### GL.Matrix.translate(x, y, z[, result])
//
// This emulates the OpenGL function `glTranslate()`. You can optionally pass
// an existing matrix in `result` to avoid allocating a new matrix.
Matrix.translate = function(x, y, z, result) {
  result = result || new Matrix();
  var m = result.m;

  m[0] = 1;
  m[1] = 0;
  m[2] = 0;
  m[3] = x;

  m[4] = 0;
  m[5] = 1;
  m[6] = 0;
  m[7] = y;

  m[8] = 0;
  m[9] = 0;
  m[10] = 1;
  m[11] = z;

  m[12] = 0;
  m[13] = 0;
  m[14] = 0;
  m[15] = 1;

  return result;
};

// ### GL.Matrix.rotate(a, x, y, z[, result])
//
// Returns a matrix that rotates by `a` degrees around the vector `x, y, z`.
// You can optionally pass an existing matrix in `result` to avoid allocating
// a new matrix. This emulates the OpenGL function `glRotate()`.
Matrix.rotate = function(a, x, y, z, result) {
  if (!a || (!x && !y && !z)) {
    return Matrix.identity(result);
  }

  result = result || new Matrix();
  var m = result.m;

  var d = Math.sqrt(x*x + y*y + z*z);
  a *= Math.PI / 180; x /= d; y /= d; z /= d;
  var c = Math.cos(a), s = Math.sin(a), t = 1 - c;

  m[0] = x * x * t + c;
  m[1] = x * y * t - z * s;
  m[2] = x * z * t + y * s;
  m[3] = 0;

  m[4] = y * x * t + z * s;
  m[5] = y * y * t + c;
  m[6] = y * z * t - x * s;
  m[7] = 0;

  m[8] = z * x * t - y * s;
  m[9] = z * y * t + x * s;
  m[10] = z * z * t + c;
  m[11] = 0;

  m[12] = 0;
  m[13] = 0;
  m[14] = 0;
  m[15] = 1;

  return result;
};

// ### GL.Matrix.lookAt(ex, ey, ez, cx, cy, cz, ux, uy, uz[, result])
//
// Returns a matrix that puts the camera at the eye point `ex, ey, ez` looking
// toward the center point `cx, cy, cz` with an up direction of `ux, uy, uz`.
// You can optionally pass an existing matrix in `result` to avoid allocating
// a new matrix. This emulates the OpenGL function `gluLookAt()`.
Matrix.lookAt = function(ex, ey, ez, cx, cy, cz, ux, uy, uz, result) {
  result = result || new Matrix();
  var m = result.m;

  var e = new Vector(ex, ey, ez);
  var c = new Vector(cx, cy, cz);
  var u = new Vector(ux, uy, uz);
  var f = e.subtract(c).unit();
  var s = u.cross(f).unit();
  var t = f.cross(s).unit();

  m[0] = s.x;
  m[1] = s.y;
  m[2] = s.z;
  m[3] = -s.dot(e);

  m[4] = t.x;
  m[5] = t.y;
  m[6] = t.z;
  m[7] = -t.dot(e);

  m[8] = f.x;
  m[9] = f.y;
  m[10] = f.z;
  m[11] = -f.dot(e);

  m[12] = 0;
  m[13] = 0;
  m[14] = 0;
  m[15] = 1;

  return result;
};

module.exports = Matrix

},{}],10:[function(require,module,exports){
const emit_float = function( a ) {
	if (a % 1 === 0)
		return a.toFixed( 1 )
	else
		return a
}

const FloatPrototype = {
  type: 'float',
	emit() { return emit_float( this.x ) },
	emit_decl() { return "" }
}


const Float = function( x=0 ) {
  const f = Object.create( FloatPrototype )
  f.x = x
  return f
}

module.exports = Float

},{}],11:[function(require,module,exports){
const SceneNode = require( './sceneNode.js' ),
      { param_wrap, MaterialID } = require( './utils.js' ),
      { Var, float_var_gen, vec2_var_gen, vec3_var_gen, vec4_var_gen, int_var_gen, VarAlloc } = require( './var.js' )

const { Vec2, Vec3, Vec4 } = require( './vec.js' )

const Fogger = function( Scene, SDF ) {

  const Fog = function( amount=0.055, color ) {
    const fog = Object.create( Fog.prototype )
    const __amount = param_wrap( amount, float_var_gen( amount ) )  
    
    Object.defineProperty( fog, 'amount', {
      get() { return __amount },
      set( v ) {
        __amount.set( v )
      }
    })

    const __color = param_wrap( Vec3(color), vec3_var_gen( 0,0,0 ) )  
    
    Object.defineProperty( fog, 'color', {
      get() { return __color },
      set( v ) {
        __color.var.set( v )
      }
    })
    
    // this refers to the current scene via implicit binding in scene.js
    this.postprocessing.push( fog )

    return this
  }

  Fog.prototype = SceneNode()
 
  Object.assign( Fog.prototype, {
    emit() {
      return `  color = applyFog( color, t.x, ${this.amount.emit()} );`
    },
   
    emit_decl() {
      let str = this.amount.emit_decl() + this.color.emit_decl()
      const preface = `  vec3 applyFog( in vec3 rgb, in float distance, in float amount ) {
    float fogAmount = 1. - exp( -distance * amount );
    vec3  fogColor  = ${this.color.emit()};
    return mix( rgb, fogColor, fogAmount );
  }
  `
      if( SDF.memo.fog === undefined ) {
        str = str + preface
        SDF.memo.fog = true
      }else{
        str = ''
      }

      return str
    },

    update_location( gl, program ) {
      this.amount.update_location( gl, program )
      this.color.update_location( gl, program )
    },

    upload_data( gl ) {
      this.amount.upload_data( gl )
      this.color.upload_data( gl )
    }
  })

  return Fog
}

module.exports = Fogger

},{"./sceneNode.js":22,"./utils.js":27,"./var.js":28,"./vec.js":29}],12:[function(require,module,exports){
'use strict'

const Marching = require( './main.js' )

Marching.__export = Marching.export
Marching.export = obj => {
  obj.march = Marching.createScene.bind( Marching )
  Marching.__export( obj )
}

window.Marching = Marching

module.exports = Marching

},{"./main.js":15}],13:[function(require,module,exports){
const emit_int = function( a ) {
	if( a % 1 !== 0 )
		return Math.round( a )
	else
		return a
}

const IntPrototype = {
  type: 'int',
	emit() { return emit_int( this.x ) },
	emit_decl() { return "" }
}


const Int = function( x=0 ) {
  const f = Object.create( IntPrototype )
  f.x = x
  return f
}

module.exports = Int

},{}],14:[function(require,module,exports){
const SceneNode = require( './sceneNode.js' ),
      { param_wrap, MaterialID } = require( './utils.js' ),
      { Var, float_var_gen, vec2_var_gen, vec3_var_gen, vec4_var_gen } = require( './var.js' ),
      { Vec2, Vec3, Vec4 } = require( './vec.js' )

const glsl = require( 'glslify' )

const Lights = function( SDF ) {

  const Light = {
    lights:[],
    materials:[],

    defaultLights:`
      Light lights[2] = Light[2](
        Light( vec3( 2.,2.,3. ),  vec3(0.25,0.25,.25), 1. ),
        Light( vec3( -2.,2.,3. ), vec3(.25,0.25,0.25), 1. )
      );
    `,

    defaultMaterials:`
      Material materials[2] = Material[2](
        Material( 0, vec3( 1. ), vec3(0.,0.,0.), vec3(1.), 8., Fresnel( 0., 1., 2.), 0 ),
        Material( 0, vec3( 1. ), vec3(1.,0.,0.), vec3(1.), 8., Fresnel( 0., 1., 2.), 0 )
      );
    `,

    light( __pos=Vec3(2,2,3), __color=Vec3(0,0,1), attenuation=1 ) {
      const light = { 
        __attenuation: param_wrap( attenuation, float_var_gen( 1 ) ),
      }

      pos = typeof __pos === 'number' ? Vec3( __pos ) : __pos

      const __varpos = param_wrap( 
        pos, 
        vec3_var_gen( [2,2,3] )
      )

      Object.defineProperty( light, 'pos', {
        get() { return __varpos },
        set(v) {
          if( typeof v === 'object' ) {
            __varpos.set( v )
          }else{
            __varpos.value.x = v
            __varpos.value.y = v
            __varpos.value.z = v
            __varpos.dirty = true
          }
        }
      })  

      color = typeof __color === 'number' ? Vec3( __color ) : __color

      const __varcol = param_wrap( 
        color, 
        vec3_var_gen( [0,0,1] )
      )

      Object.defineProperty( light, 'color', {
        get() { return __varcol },
        set(v) {
          if( typeof v === 'object' ) {
            __varcol.set( v )
          }else{
            __varcol.value.x = v
            __varcol.value.y = v
            __varcol.value.z = v
            __varcol.dirty = true
          }
        }
      })  

      Object.defineProperty( light, 'attenuation', {
        get() { return light.__attenuation.value },
        set(v){
          light.__attenuation.value = v
          light.__attenuation.dirty = true
        }
      })

      return light
    },

    emit_lights() {
      if( this.lights.length === 0 ) return this.defaultLights

      let str = `Light lights[${this.lights.length}] = Light[${this.lights.length}](`

      for( let light of this.lights ) {
        str += `\n        Light( ${light.pos.emit()}, ${light.color.emit()}, ${light.__attenuation.emit()}),` 
      }
      
      str = str.slice(0,-1) // remove trailing comma

      str += '\n      );'

      return str
    },

    mode:'global',

    gen( shadows=8, geometries ) {
      //const str = this.modes[ this.mode ]( this.lights.length || 2, this.emit_lights(), SDF.materials.emit_materials(), shadows )
   
      const modeConstants = SDF.materials.modeConstants
      this.modesEmployed.length = 0

      let lightingFunctions = []

      // loop through all materials used and add corresponding lighting functions as needed
      for( let mat of SDF.materials.materials ) {
        if( this.modesEmployed.indexOf( mat.mode ) === -1 ) {
          lightingFunctions.push( this.modes[ mat.mode ]() )  

          this.modesEmployed.push( mat.mode )
        }
      }

      // check all modes to see if they're lighting function has been added to the shader,
      // if not, add their function stub
      for( let mode of modeConstants ) {
        // key is iterated as string, must use parseInt
        if( this.modesEmployed.indexOf( mode ) === -1 ) {
          lightingFunctions.push( this.defaultFunctionDeclarations[ modeConstants.indexOf( mode ) ] )
        }
      }

      const textures = Marching.textures.__emitFunction()
      const lighting = this.shell( 
        this.lights.length || 2, 
        this.emit_lights(), 
        SDF.materials.emit_materials(), 
        shadows,
        geometries, 
        textures.glsldefs,
        textures.mainfunc
      )

      let lightingFuncStr = lightingFunctions.join('\n')
      lightingFuncStr = lightingFuncStr.replace( /(MAX\_LIGHTS)/g, this.lights.length || 2 )
      return lighting[0] + lightingFuncStr + lighting[1]
    },

    emit_decl() {
      let str = ''
      for( let light of this.lights ) {
        str += light.pos.emit_decl()
        str += light.color.emit_decl()
        str += light.__attenuation.emit_decl()
      }

      return str
    },

    update_location( gl, program ) {
      for( let light of this.lights ) {
        if( light.pos.dirty === true )  light.pos.update_location( gl, program )
        if( light.color.dirty === true )  light.color.update_location( gl, program )
        if( light.__attenuation.dirty === true ) light.__attenuation.update_location( gl, program )
      }

    },

    upload_data( gl, program='' ) {
      for( let light of this.lights ) {
        if( light.pos.dirty === true )   light.pos.upload_data( gl, program )
        if( light.color.dirty === true )  light.color.upload_data( gl, program )
        if( light.__attenuation.dirty === true )  light.__attenuation.upload_data( gl, program )
      }
    },

    modesEmployed:[],

    // these stubs are placed in the shader by default as placeholders so that they can be referenced in 
    // a switch statement selecting lighting. They are overridden by actual lighting functions if any
    // material in the scene uses a corresponding function.
    defaultFunctionDeclarations: [
      '    vec3 global( vec3 surfacePosition, vec3 normal, vec3 rayOrigin, vec3 rayDirection, Material mat, Light lights[MAX_LIGHTS], vec3 textureColor ) { return vec3(0.); }',
      '    vec3 normal( vec3 surfacePosition, vec3 normal, vec3 rayOrigin, vec3 rayDirection, Material mat, Light lights[MAX_LIGHTS] ) { return vec3(0.); }',
      '    vec3 directional( vec3 surfacePosition, vec3 normal, vec3 rayOrigin, vec3 rayDirection, Material mat, Light lights[MAX_LIGHTS], vec3 textureColor ) { return vec3(0.); }',
      '    vec3 orenn( vec3 surfacePosition, vec3 normal, vec3 rayOrigin, vec3 rayDirection, Material mat, Light lights[MAX_LIGHTS] ) { return vec3(0.); }',
    ],

    shell( numlights, lights, materials, shadow=0, sdfs, texturePreface, textureBody ) {
      const __shadow = shadow > 0
        ? `diffuseCoefficient *= softshadow( surfacePosition, normalize( light.position ), 0.02, 2.5, ${shadow.toFixed(1)} );` 
        : ''


      let preface = glsl(["#define GLSLIFY 1\n  int MAX_LIGHTS = ",";\n    float ao( in vec3 pos, in vec3 nor ){\n      float occ = 0.0;\n      float sca = 1.0;\n      for( int i=0; i<5; i++ )\n      {\n          float hr = 0.01 + 0.12 * float( i ) / 4.0;\n          vec3 aopos =  nor * hr + pos;\n          float dd = scene ( aopos ).x;\n          occ += -(dd-hr)*sca;\n          sca *= 0.95;\n      }\n      return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n    }\n\n    \n    ","\n    ","\n    ",""],numlights,texturePreface,textureBody)
      let func = `

    vec3 lighting( vec3 surfacePosition, vec3 normal, vec3 rayOrigin, vec3 rayDirection, float sdfID, bool useTextureTransform ) {
      ${sdfs}
      SDF sdf = sdfs[ int( sdfID ) ];

      ${materials}
      Material mat = materials[ sdf.materialID ];

      int MAX_LIGHTS = ${numlights};     

      ${lights}
 
      vec3 tex = getTexture( int(sdf.textureID), surfacePosition, normal, sdf, useTextureTransform );

      vec3 clr;
      switch( mat.mode ) {
        case 0: clr = global( surfacePosition, normal, rayOrigin, rayDirection, mat, lights, tex ); break;
        case 1: clr = normal; break;
        case 2: clr = directional( surfacePosition, normal, rayOrigin, rayDirection, mat, lights, tex ); break;
        case 3: clr = orenn( surfacePosition, normal, rayOrigin, rayDirection, mat, lights ); break;
        default:
          clr = normal;
      }

      return clr; 
    }
`
      return [ preface, func ]
    }, 

    modes:{
      global() {
        const shadow = SDF.__scene.__shadow

        const str = glsl(["#define GLSLIFY 1\n\n\n        vec3 global( vec3 pos, vec3 nor, vec3 ro, vec3 rd, Material mat, Light lights[MAX_LIGHTS], vec3 textureColor ) {\n          Light light = lights[ 0 ];\n          vec3  ref = reflect( rd, nor ); // reflection angle\n          float occ = ao( pos, nor );\n          vec3  lig = normalize( light.position ); // light position\n          float amb = clamp( 0.5 + 0.5 * nor.y, 0.0, 1.0 );\n          float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n\n          // simulated backlight\n          float bac = clamp( dot( nor, normalize( vec3( -lig.x, 0.0 , -lig.z ))), 0.0, 1.0 ) * clamp( 1.0-pos.y, 0.0 ,1.0 );\n\n          // simulated skydome light\n          float dom = smoothstep( -0.1, 0.1, ref.y );\n          float fre = pow( clamp( 1.0 + dot( nor,rd ),0.0,1.0 ), 3.0);\n          float spe = pow( clamp( dot( ref, lig ), 0.0, 1.0 ), 8.0 );\n\n          dif *= softshadow( pos, lig, 0.02, 2.5, "," );\n          dom *= softshadow( pos, ref, 0.02, 2.5, "," );\n\n          vec3 brdf = textureColor;//vec3( 0.0 );\n          brdf += 1.20 * dif * vec3( 1.00,0.90,0.60 ) * mat.diffuse * light.color;\n          brdf += 2.20 * spe * vec3( 1.00,0.90,0.60 ) * dif * mat.specular * light.color;\n          brdf += 0.30 * amb * vec3( 0.50,0.70,1.00 ) * occ * mat.ambient * light.color;\n          brdf += 0.40 * dom * vec3( 0.50,0.70,1.00 );\n          brdf += 0.70 * bac * vec3( 0.25 );\n          brdf += 0.40 * (fre * light.color);\n\n          return brdf;\n        }\n        ",""],shadow.toFixed(1),shadow.toFixed(1))

        return str
      },

      phong( numlights, lights, materials ) {
        const shadow = SDF.__scene.__shadow

        const __shadow = shadow > 0
          ? `diffuseCoefficient *= softshadow( surfacePosition, normalize( light.position ), 0.02, 2.5, ${shadow.toFixed(1)} );` 
          : ''

        const str = glsl(["#define GLSLIFY 1\n  \n        \n        vec3 directional( vec3 surfacePosition, vec3 normal, vec3 rayOrigin, vec3 rayDirection, Material mat, Light lights[MAX_LIGHTS], vec3 textureColor ) {\n          vec3  outputColor   = textureColor;//vec3( 0. );\n   \n          // applies to all lights\n          float occlusion = ao( surfacePosition, normal );\n\n          for( int i = 0; i < 20000; i++ ) {\n            if( i >= MAX_LIGHTS ) break;\n\n            Light light = lights[ i ];\n\n            vec3 surfaceToLightDirection = normalize( light.position - surfacePosition );\n            \n            // get similarity between normal and direction to light\n            float diffuseCoefficient = dot( normal, surfaceToLightDirection ); \n\n            // get reflection angle for light striking surface\n            vec3 angleOfReflection = reflect( -surfaceToLightDirection, normal );\n\n            // see if reflected light travels to camera and generate coefficient accordingly\n            float specularAngle = clamp( dot( angleOfReflection, -rayDirection ), 0., 1. );\n            float specularCoefficient = pow( specularAngle, mat.shininess );\n\n            // lights should have an attenuation factor\n            float attenuation = 1. / ( light.attenuation * pow( length( light.position - surfacePosition ), 2. ) ); \n\n            // bias, scale, power\n            float fresnel = mat.fresnel.x + mat.fresnel.y * pow( 1.0 + dot( rayDirection, normal ), mat.fresnel.z ); \n\n            ","\n\n            vec3 color = vec3( 0. );\n            color += 1.2 * diffuseCoefficient * mat.diffuse * light.color;\n            color += 2.2 * specularCoefficient * mat.specular * light.color;\n            color += 0.3 * (mat.ambient * light.color) * occlusion;\n            color += (fresnel * light.color);\n\n            // texture\n            //color *= textureColor.xyz;\n\n            // gamma correction must occur before light attenuation\n            // which means it must be applied on a per-light basis unfortunately\n            vec3 gammaCorrectedColor = pow( color, vec3( 1./2.2 ) );\n            vec3 attenuatedColor = 2. * gammaCorrectedColor * attenuation; \n\n            outputColor += attenuatedColor;\n          }\n\n          return outputColor;\n        }\n        ",""],__shadow)

        return str
      }, 
      phongT( numlights, lights, materials ) {
        const shadow = SDF.__scene.__shadow

        const __shadow = shadow > 0
          ? `diffuseCoefficient *= softshadow( surfacePosition, normalize( light.position ), 0.02, 2.5, ${shadow.toFixed(1)} );` 
          : ''

        const str = glsl(["#define GLSLIFY 1\n  \n\n        vec3 directional( vec3 surfacePosition, vec3 normal, vec3 rayOrigin, vec3 rayDirection, Material mat, Light lights[MAX_LIGHTS] ) {\n          vec3  outputColor   = vec3( 0. );\n   \n          // applies to all lights\n          float occlusion = ao( surfacePosition, normal );\n\n          vec4 textureColor;\n          if( mat.textureID > -1 ) {\n            //textureColor = texcube( textures[ mat.textureID ], surfacePosition, normal, 1. );//texture( textures[ mat.textureID ], surfacePosition.xy - normal.xy ); \n            vec2 uv = getUVCubic( surfacePosition, vec3(0.) );//surfacePosition.xz*vec2(0.03,0.07);\n            textureColor = texture( textures[ mat.textureID ], uv );\n          }else{\n            textureColor = vec4(0.);\n          }\n\n          outputColor = 0;//textureColor.xyz;\n\n          for( int i = 0; i < 20000; i++ ) {\n            if( i >= MAX_LIGHTS ) break;\n\n            Light light = lights[ i ];\n\n            vec3 surfaceToLightDirection = normalize( light.position - surfacePosition );\n            \n            // get similarity between normal and direction to light\n            float diffuseCoefficient = dot( normal, surfaceToLightDirection ); \n\n            // get reflection angle for light striking surface\n            vec3 angleOfReflection = reflect( -surfaceToLightDirection, normal );\n\n            // see if reflected light travels to camera and generate coefficient accordingly\n            float specularAngle = clamp( dot( angleOfReflection, -rayDirection ), 0., 1. );\n            float specularCoefficient = pow( specularAngle, mat.shininess );\n\n            // lights should have an attenuation factor\n            float attenuation = 1. / ( light.attenuation * pow( length( light.position - surfacePosition ), 2. ) ); \n\n            // bias, scale, power\n            float fresnel = mat.fresnel.x + mat.fresnel.y * pow( 1.0 + dot( rayDirection, normal ), mat.fresnel.z ); \n\n            ","\n\n            vec3 color = vec3( 0. );\n            color += 1.2 * diffuseCoefficient * textureColor.xyz * light.color;\n            color += 2.2 * specularCoefficient * textureColor.xyz * light.color;\n            color += 0.3 * (mat.ambient * light.color) * occlusion;\n            color += (fresnel * light.color);\n\n            // texture\n            //color *= textureColor.xyz;\n\n            // gamma correction must occur before light attenuation\n            // which means it must be applied on a per-light basis unfortunately\n            vec3 gammaCorrectedColor = pow( color, vec3( 1./2.2 ) );\n            vec3 attenuatedColor = 2. * gammaCorrectedColor * attenuation; \n\n            outputColor += attenuatedColor;\n          }\n\n          return outputColor;\n        }\n        ",""],__shadow)

        return str
      }, 


      orenn( numlights, lights, materials ) {
        const shadow = SDF.__scene.__shadow
        const __shadow = shadow > 0
          ? `diffuseCoefficient *= softshadow( surfacePosition, normalize( light.position ), 0.02, 2.5, ${shadow.toFixed(1)} );` 
          : ''

        const str = glsl(["#define GLSLIFY 1\n  \n        float orenNayarDiffuse(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float roughness,\n  float albedo) {\n  \n  float LdotV = dot(lightDirection, viewDirection);\n  float NdotL = dot(lightDirection, surfaceNormal);\n  float NdotV = dot(surfaceNormal, viewDirection);\n\n  float s = LdotV - NdotL * NdotV;\n  float t = mix(1.0, max(NdotL, NdotV), step(0.0, s));\n\n  float sigma2 = roughness * roughness;\n  float A = 1.0 + sigma2 * (albedo / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));\n  float B = 0.45 * sigma2 / (sigma2 + 0.09);\n\n  return albedo * max(0.0, NdotL) * (A + B * s / t) / 3.14159265;\n}\n\n        float gaussianSpecular(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float shininess) {\n  vec3 H = normalize(lightDirection + viewDirection);\n  float theta = acos(dot(H, surfaceNormal));\n  float w = theta / shininess;\n  return exp(-w*w);\n}\n\n        vec3 orenn( vec3 surfacePosition, vec3 normal, vec3 rayOrigin, vec3 rayDirection, Material mat, Light lights[MAX_LIGHTS] ) {\n          vec3  outputColor   = vec3( 0. );\n   \n          // applies to all lights\n          float occlusion = ao( surfacePosition, normal );\n\n          for( int i = 0; i < 20000; i++ ) {\n            if( i >= MAX_LIGHTS ) break;\n\n            Light light = lights[ i ];\n\n            vec3 surfaceToLightDirection = normalize( light.position - surfacePosition );\n            \n            // get similarity between normal and direction to light\n            float diffuseCoefficient = orenNayarDiffuse( surfaceToLightDirection, -rayDirection, normal, 0.15, 4.0);\n\n            // get reflection angle for light striking surface\n            vec3 angleOfReflection = reflect( -surfaceToLightDirection, normal );\n\n            // see if reflected light travels to camera and generate coefficient accordingly\n            float specularAngle = clamp( dot( angleOfReflection, -rayDirection ), 0., 1. );\n            float specularCoefficient = gaussianSpecular( surfaceToLightDirection, -rayDirection, normal, .5 ); \n\n            // lights should have an attenuation factor\n            float attenuation = 1. / ( light.attenuation * pow( length( light.position - surfacePosition ), 2. ) ); \n\n            float fresnel = mat.fresnel.x + mat.fresnel.y * pow( 1.0 + dot( rayDirection, normal ), mat.fresnel.z ); \n\n            ","\n\n            vec3 color = vec3( 0. );\n            color += 1.2 * diffuseCoefficient * mat.diffuse * light.color;\n            color += 2.2 * specularCoefficient * mat.specular * light.color;\n            color += 0.3 * (mat.ambient * light.color) * occlusion;\n            color += (fresnel * light.color);\n\n            // gamma correction must occur before light attenuation\n            // which means it must be applied on a per-light basis unfortunately\n            vec3 gammaCorrectedColor = pow( color, vec3( 1./2.2 ) );\n            vec3 attenuatedColor = 2. * gammaCorrectedColor * attenuation; \n\n            outputColor += attenuatedColor;\n          }\n\n          return outputColor;\n        }",""],__shadow)

        return str
      }, 


      global_save( numlights, lights, materials, shadow='' ) {
        const str = glsl(["#define GLSLIFY 1\n\n        float ao( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12 * float( i ) / 4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = scene ( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n        ","\n\n        ","\n\n        vec3 lighting( vec3 pos, vec3 nor, vec3 ro, vec3 rd, float materialID ) {\n          Light light = lights[ 0 ];\n          vec3  ref = reflect( rd, nor ); // reflection angle\n          float occ = ao( pos, nor );\n          vec3  lig = normalize( light.position ); // light position\n          float amb = clamp( 0.5 + 0.5 * nor.y, 0.0, 1.0 );\n          float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n\n          // simulated backlight\n          float bac = clamp( dot( nor, normalize( vec3( -lig.x, 0.0 , -lig.z ))), 0.0, 1.0 ) * clamp( 1.0-pos.y, 0.0 ,1.0 );\n\n          // simulated skydome light\n          float dom = smoothstep( -0.1, 0.1, ref.y );\n          float fre = pow( clamp( 1.0 + dot( nor,rd ),0.0,1.0 ), 2.0 );\n          float spe = pow( clamp( dot( ref, lig ), 0.0, 1.0 ), 8.0 );\n\n          dif *= softshadow( pos, lig, 0.02, 2.5, 8. );\n          dom *= softshadow( pos, ref, 0.02, 2.5, 8. );\n\n          Material mat = materials[ int(materialID) ];\n\n          vec3 brdf = vec3( 0.0 );\n          brdf += 1.20 * dif * vec3( 1.00,0.90,0.60 ) * mat.diffuse * light.color;\n          brdf += 2.20 * spe * vec3( 1.00,0.90,0.60 ) * dif * mat.specular * light.color;\n          brdf += 0.30 * amb * vec3( 0.50,0.70,1.00 ) * occ * mat.ambient * light.color;\n          brdf += 0.40 * dom * vec3( 0.50,0.70,1.00 ) * occ;\n          brdf += 0.70 * bac * vec3( 0.25 ) * occ;\n          brdf += 0.40 * (fre * light.color) * occ;\n\n          return brdf;\n        }",""],materials,lights)

        return str

      },

      normal() { return '' },
      noise() { return '' }
    },
  }

  return Light
}

module.exports = Lights

// old lighting
/*
*/

},{"./sceneNode.js":22,"./utils.js":27,"./var.js":28,"./vec.js":29,"glslify":120}],15:[function(require,module,exports){
const MP   = require( '../node_modules/merge-pass/dist/index.js' )
const SDF = {
  camera:           require( './camera.js' ),
  __primitives:     require( './primitives.js' ),
  vectors:          require( './vec.js' ),
  distanceOps:      require( './distanceOperations.js' ),
  alterations:      require( './alterations.js' ),
  distanceDeforms:  require( './distanceDeformations.js' ),
  __domainOps:      require( './domainOperations.js' ),
  __noise:          require( './noise.js' ),
  __scene:          require( './scene.js' ),
  __lighting:       require( './lighting.js' ),
  __materials:      require( './material.js' ),
  __textures:       require( './texture.js' ),
  Var:              require( './var.js' ).Var,
  //Color:            require( './color.js' ),
  FFT:              require( './audio.js' ),

  // a function that generates the fragment shader
  renderFragmentShader: require( './renderFragmentShader.js' ),

  // additional callbacks that are run once per frame
  callbacks: [],
  geometries: [],

  // the main drawing callback
  render: null,

  // the scene is a chain of Unions combining all elements together
  scene:  null,

  // a speed of 1 corresponds to 60 fps.
  delay: 0,
  __isPaused:false,

  defaultVertexSource:`    #version 300 es
    in vec3 a_pos;
		in vec2 a_uv;
		out vec2 v_uv;

		void main() {
			v_uv = a_uv;
			gl_Position = vec4(a_pos, 1.0);
    }`
  ,

  export( obj ) {
    Object.assign( 
      obj, 
      this.primitives,
      this.vectors,
      this.distanceOps,
      this.domainOps,
      this.distanceDeforms,
      this.alterations
    )

    obj.Light = this.Light
    obj.Material = this.Material
    obj.Texture  = this.Texture
    obj.camera = this.camera
    obj.callbacks = this.callbacks // XXX remove once API stops using callbacks
    obj.FFT = this.FFT
  },

  init( canvas, shouldInit = false ) {
    this.primitives = this.__primitives( this )
    this.Scene      = this.__scene( this )
    this.domainOps  = this.__domainOps( this )
    this.noise     = this.__noise( this )
    this.export( this )

    this.canvas = canvas//document.createElement('canvas')
    this.canvasMP = canvas

    this.lighting   = this.__lighting( this )
    this.Light = this.lighting.light
    this.materials  = this.__materials( this )
    this.Material = this.materials.material
    this.textures = this.__textures( this )
    this.Texture = this.textures.texture

    this.canvas.width = this.canvasMP.width = window.innerWidth 
    this.canvas.height = this.canvasMP.height = window.innerHeight
    this.gl = this.canvas.getContext( 'webgl2', { antialias:true, alpha:true })
    //this.glMP = this.canvasMP.getContext( 'webgl2', { antialias:true, alpha:true })
  },
  // generate shaders, initialize camera, start rendering loop 
  createScene( ...args ) {
    const scene = this.Scene( args, this.canvas )

    this.requiredGeometries = []
    this.requiredOps = []
    this.memo = {}

    return scene
  },

  start( fs, width, height, shouldAnimate ) {
    if( this.render !== null ) this.render.running = false

    this.fs = fs
    this.callbacks.length = 0

    this.render = this.initWebGL( this.defaultVertexSource, fs, width, height, shouldAnimate )
    this.render.running = true

    this.camera.init( this.gl, this.program, cb => { 
      this.callbacks.push( cb )
    })

    setTimeout( ()=> this.render( 0.0 ), 0 )
  },

  generateSDF( __scene ) {
    let scene = { preface:'' }

    /* if there is more than one object in our scene, chain pairs of objects
       in Unions. So, given objects a,b,c, and d create:

       Union( a, Union( b, Union( c,d ) ) )

       ... or something like that. If there is only a single object,
       use that object as the entire scene.
     */

    let objs = __scene.objs
    if( objs.length > 1 ) {
      // reduce objects to nested Unions
      scene.output = objs.reduce( ( current, next ) => this.Union( current, next ) )
    }else{
      scene.output = objs[0]
    }

    // create an fancy emit() function that wraps the scene
    // with an id #.

    scene.output.__emit = scene.output.emit.bind( scene.output )
    scene.output.emit = function( ...args ) {
      const emitted = scene.output.__emit(...args)
      const output = {
        out:     emitted.out,
        preface: emitted.preface || '' 
      }

      return output 
    }

    this.scene = scene.output

    let variablesDeclaration = scene.output.emit_decl()
    const sceneRendering = scene.output.emit()

    // fog etc. maybe msaa?
    let pp = ''
    for( let processor of __scene.postprocessing ) {
      pp += processor.emit()
      variablesDeclaration += processor.emit_decl()
    }
    
    this.postprocessing = __scene.postprocessing

    return [ variablesDeclaration, sceneRendering, pp ]
  },

	compile( type, source ) {
    const gl = this.gl

		const shader = this.shader = gl.createShader( type );
		gl.shaderSource( shader, source )
		gl.compileShader( shader )

		if( gl.getShaderParameter( shader, gl.COMPILE_STATUS) !== true ) {
			let log = gl.getShaderInfoLog( shader )
			gl.deleteShader( shader )

			console.log( source )
			console.log( log )

			return null
		}

		return shader
	},

  createProgram( vs_source, fs_source ) {
    const gl = this.gl
		const vs = this.compile( gl.VERTEX_SHADER, vs_source )
		const fs = this.compile( gl.FRAGMENT_SHADER, fs_source )

		if( null === vs || null === fs ) return null

		const program = gl.createProgram()
		gl.attachShader( program, vs )
		gl.attachShader( program, fs )
		gl.linkProgram( program )

		if( gl.getProgramParameter( program, gl.LINK_STATUS ) !== true ){
			const log = gl.getProgramInfoLog( program )
			gl.deleteShader(vs)
			gl.deleteShader(fs)
			gl.deleteProgram(program)

			console.error( log )
			return null
		}

    const drawProgram = gl.createProgram()
    const fragSource = ` #version 300 es
  precision mediump float;

  uniform sampler2D uSampler;
  uniform vec2 resolution;

  out vec4 col;
  void main() {
    // copy color info from texture
    col = vec4( texture( uSampler, gl_FragCoord.xy / resolution ).rgb, 1. );
  }`

    const fs_draw = this.compile( gl.FRAGMENT_SHADER, fragSource )
    const vs_draw = this.compile( gl.VERTEX_SHADER, vs_source )

    gl.attachShader( drawProgram, vs_draw )
		gl.attachShader( drawProgram, fs_draw )
		gl.linkProgram( drawProgram )

    return [ program, drawProgram ]
  },

  clear() {
    if( this.callbacks !== undefined ) this.callbacks.length = 0
    if( this.render !== null ) this.render.running = false
    this.geometries.length = 0

    const gl = this.gl
    gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT )
  },

  pause() {
    this.__isPaused = !this.__isPaused
  },

  initBuffers( width, height ) {
    const gl = this.gl
    gl.clearColor( 0.0, 0.0, 0.0, 0.0 )
    gl.clear(gl.COLOR_BUFFER_BIT)

    const vbo = gl.createBuffer()

    const vertices = new Float32Array([
      -1.0, -1.0, 0.0, 0.0, 0.0,
      1.0, -1.0, 0.0, 1.0, 0.0,
      -1.0, 1.0, 0.0, 0.0, 1.0,
      1.0, 1.0, 0.0, 1.0, 1.0
    ])

    gl.bindBuffer (gl.ARRAY_BUFFER, vbo )
    gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW )

    const ibo = gl.createBuffer()

    const indices = new Uint16Array( [0, 1, 2, 2, 1, 3] )

    gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, ibo )
    gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW )
    
    return { vbo, ibo, vertices, indices }
  },

  initWebGL( vs_source, fs_source, width, height,shouldAnimate=false ) {
    const gl = this.gl
    //if( shouldInit === true ) this.initBuffers()
    
    // XXX clean all this up!
    const colorTexture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, colorTexture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

    const depthTexture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, depthTexture);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);

    const lenExpr = MP.op(MP.len(MP.ncfcoord()), "*", 3);
    //const merger = new MP.Merger([MP.blur2d(lenExpr, lenExpr, 6)], sourceCanvas, gl);
    window.MP = MP
    window.fl = MP.float(MP.mut(1));
    window.fl2 = MP.float(MP.mut(1));
    window.dof = MP.dof()
    const m = new MP.Merger([

      dof
      //MP.blur2d(lenExpr, lenExpr, 2)     
      //MP.fxaa()
      //MP.blur2d(fl, fl2)
      //MP.hsv2rgb((c = MP.changecomp(MP.rgb2hsv(MP.fcolor()), MP.mut(0.5), "r", "+")))
      //MP.hsv2rgb(MP.changecomp(MP.rgb2hsv(MP.fcolor()), MP.op(MP.time(), '/', 5), "r", "+"))
    ], colorTexture, this.gl, { channels: [depthTexture] });
    
    const programs = this.createProgram( vs_source, fs_source )
    const program = this.program = programs[0]
    gl.useProgram( this.program )

    const { vbo, ibo, vertices, indices } = this.initBuffers( width, height )

    const framebuffer = gl.createFramebuffer()
 
    const loc_a_pos = gl.getAttribLocation(program, "a_pos");
    const loc_a_uv = gl.getAttribLocation(program, "a_uv");

    const loc_u_time = gl.getUniformLocation(program, "time");
    const loc_u_resolution = gl.getUniformLocation(program, "resolution" )

    this.postprocessing.forEach( pp => pp.update_location( gl, program ) )

    this.scene.update_location( gl, program )
    this.textures.update_location( gl, program )
    this.materials.update_location( gl, program )
    this.lighting.update_location( gl, program )

    //gl.enableVertexAttribArray(loc_a_pos)
    //gl.enableVertexAttribArray(loc_a_uv)

    //gl.vertexAttribPointer(loc_a_pos, 3, gl.FLOAT, false, 20, 0)
    //gl.vertexAttribPointer(loc_a_uv, 2, gl.FLOAT, false, 20, 12)

    gl.viewport( 0,0,width,height )
    gl.uniform2f( loc_u_resolution, width, height )

    let total_time = 0.0;

    let frameCount = 0
    const render = function( timestamp ){
      gl.useProgram( this.program )
      gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, colorTexture, 0);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT1, gl.TEXTURE_2D, depthTexture, 0);

      if( render.running === true && shouldAnimate === true ) {
        window.requestAnimationFrame( render )
      }else if( render.running === false ) {
        gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT )
        return
      }

      if( this.__isPaused === false ) {
        this.currentTime = timestamp

        if( this.delay !== 0 && this.delay >= frameCount ) {
          frameCount++
          return
        }else if( this.delay !== 0 ) {
          frameCount = 0
        }

        total_time = timestamp / 1000.0
        gl.uniform1f( loc_u_time, total_time )

        this.callbacks.forEach( cb => cb( total_time, this.currentTime ) )

        if( typeof window.onframe === 'function' ) {
          window.onframe( total_time )
        }
      }

      this.materials.upload_data( gl )
      this.textures.upload_data( gl )
      this.scene.upload_data( gl )
      this.lighting.upload_data( gl )
      this.postprocessing.forEach( pp => pp.upload_data( gl ) )

      gl.bindBuffer (gl.ARRAY_BUFFER, vbo )
      gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW )
      gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, ibo )
      gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW )
      gl.enableVertexAttribArray(loc_a_pos)
      gl.enableVertexAttribArray(loc_a_uv)

      gl.vertexAttribPointer(loc_a_pos, 3, gl.FLOAT, false, 20, 0)
      gl.vertexAttribPointer(loc_a_uv, 2, gl.FLOAT, false, 20, 12)

      gl.drawBuffers([
        gl.COLOR_ATTACHMENT0,
        gl.COLOR_ATTACHMENT1 
      ])
      // Create a color texture
      gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 )

      //gl.bindBuffer (gl.ARRAY_BUFFER, null )
      //gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, null )
      gl.bindFramebuffer(gl.FRAMEBUFFER, null );
      //gl.viewport(0, 0, width, height )

      gl.activeTexture( gl.TEXTURE0 )
      gl.bindTexture( gl.TEXTURE_2D, colorTexture )
      gl.useProgram( programs[1] )
      //gl.vertexAttribPointer(loc_a_pos, 3, gl.FLOAT, false, 20, 0)
      //gl.vertexAttribPointer(loc_a_uv, 2, gl.FLOAT, false, 20, 12)
      ////this.initBuffers()
      const u_resolution = gl.getUniformLocation(programs[1], "resolution" )
      gl.uniform2f( u_resolution, width, height )
      gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 )

      //gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, colorTexture, 0);
      m.draw( total_time )
    }.bind( SDF )

    render.running = true

    return render    
  }
}

module.exports = SDF

},{"../node_modules/merge-pass/dist/index.js":159,"./alterations.js":1,"./audio.js":2,"./camera.js":4,"./distanceDeformations.js":5,"./distanceOperations.js":6,"./domainOperations.js":8,"./lighting.js":14,"./material.js":16,"./noise.js":17,"./primitives.js":19,"./renderFragmentShader.js":20,"./scene.js":21,"./texture.js":23,"./var.js":28,"./vec.js":29}],16:[function(require,module,exports){
const SceneNode = require( './sceneNode.js' ),
      { param_wrap, MaterialID } = require( './utils.js' ),
      { Var, float_var_gen, vec2_var_gen, vec3_var_gen, vec4_var_gen } = require( './var.js' ),
      { Vec2, Vec3, Vec4 } = require( './vec.js' )


const glsl = require( 'glslify' )

const __Materials = function( SDF ) {

  const Materials = {
    materials:[],
    __materials:[],
    modeConstants : [
      'global',
      'normal',
      'phong',
      'orenn',
      'noise'
    ],

    default: 'global',

    //defaultMaterials:`
    //  Material materials[2] = Material[2](
    //    Material( 0, vec3( 1. ), vec3(0.,0.,0.), vec3(1.), 8., Fresnel( 0., 1., 2.) ),
    //    Material( 0, vec3( 1. ), vec3(1.,0.,0.), vec3(1.), 8., Fresnel( 0., 1., 2.) )
    //  );
    //`,

    addMaterial( mat ) {
      if( mat === undefined ) mat = Materials.material.default

      if( Materials.materials.indexOf( mat ) === -1 ) {
        mat.id = MaterialID.alloc()

        // we have to dirty the material so that its data
        // will be uploaded to new shaders, otherwise the
        // material will only work the first time it's used, when
        // it's dirty on initialization.
        Materials.dirty( mat )

        Materials.materials.push( mat )
      } 

      return mat
    },

    material( mode='global', __ambient, __diffuse, __specular, __shininess, __fresnel, __texture=null ){
      let modeIdx = Materials.modeConstants.indexOf( mode )
      if( modeIdx === -1 ) {
        console.warn( `There is no material type named ${mode}. Using the default material, ${Materials.default}, instead.` )
        mode = Materials.default
        modeIdx = Materials.modeConstants.indexOf( mode )
      }

      if( typeof __ambient === 'number' ) __ambient = Vec3( __ambient )
      const ambient = param_wrap( __ambient, vec3_var_gen(.1,.1,.1) )
      if( typeof __diffuse=== 'number' ) __diffuse= Vec3( __diffuse )
      const diffuse = param_wrap( __diffuse, vec3_var_gen(0,0,1) )
      if( typeof __specular === 'number' ) __specular = Vec3( __specular )
      const specular = param_wrap( __specular, vec3_var_gen(1,1,1) )
      const shininess = param_wrap( __shininess, float_var_gen(8) )
      if( typeof __fresnel === 'number' ) __fresnel = Vec3( __fresnel )
      const fresnel = param_wrap( __fresnel, vec3_var_gen(0,1,2) )

      const mat = { shininess, mode, texture:__texture, type:'material' }

      Object.defineProperty( mat, 'ambient', {
        get() { return ambient },
        set(v) {
          if( typeof v === 'object' ) {
            ambient.set( v )
          }else{
            ambient.value.x = v
            ambient.value.y = v
            ambient.value.z = v
            ambient.dirty = true
          }
        }
      })  
      Object.defineProperty( mat, 'diffuse', {
        get() { return diffuse },
        set(v) {
          if( typeof v === 'object' ) {
            diffuse.set( v )
          }else{
            diffuse.value.x = v
            diffuse.value.y = v
            diffuse.value.z = v
            diffuse.dirty = true
          }
        }
      })  
      Object.defineProperty( mat, 'specular', {
        get() { return specular },
        set(v) {
          if( typeof v === 'object' ) {
            specular.set( v )
          }else{
            specular.value.x = v
            specular.value.y = v
            specular.value.z = v
            specular.dirty = true
          }
        }
      })  
      Object.defineProperty( mat, 'fresnel', {
        get() { return fresnel },
        set(v) {
          if( typeof v === 'object' ) {
            fresnel.set( v )
          }else{
            fresnel.value.x = v
            fresnel.value.y = v
            fresnel.value.z = v
            fresnel.dirty = true
          }
        }
      })  
      //Object.defineProperty( mat, 'shininess', {
      //  get() { return mat.shininess.value },
      //  set(v){
      //    mat.shininess.value = v
      //    mat.shininess.dirty = true
      //  }
      //})     //
      
      return mat 
    },

    dirty( mat ) {
      mat.ambient.dirty = true
      mat.diffuse.dirty = true
      mat.specular.dirty = true
      mat.shininess.dirty = true
      mat.fresnel.dirty = true
      if( mat.texture !== null ) mat.texture.dirty = true
    },
   
    emit_materials() {
      if( this.materials.length === 0 ) {
        console.log( 'returning undefined?', this.defaultMaterials )
        return this.defaultMaterials//this.addMaterial() 
      }

      let str = `Material materials[${this.materials.length}] = Material[${this.materials.length}](`

      this.materials.sort( (a,b) => a.id > b.id ? 1 : -1 ) 

      for( let mat of this.materials ) {
        const fresnel = `Fresnel( ${f(mat.fresnel.x)}, ${f(mat.fresnel.y)}, ${f(mat.fresnel.z)} )`

        const texid = 0//SDF.textures.textures.indexOf( mat.texture )
        str += mat.texture === null 
          ? `\n        Material( ${this.modeConstants.indexOf( mat.mode )}, ${mat.ambient.emit()}, ${mat.diffuse.emit()}, ${mat.specular.emit()}, ${mat.shininess.emit()}, ${mat.fresnel.emit()}, ${ texid } ),` 
          : `\n        Material( ${this.modeConstants.indexOf( mat.mode )}, ${mat.ambient.emit()}, ${mat.diffuse.emit()}, ${mat.specular.emit()}, ${mat.shininess.emit()}, ${mat.fresnel.emit()}, ${ texid } ),` 
      }
      
      str = str.slice(0,-1) // remove trailing comma

      str += '\n      );'

      this.__materials = this.materials.slice( 0 )
      this.materials.length = 0

      return str
    },

    emit_decl() {
      let str = ''
      for( let mat of this.__materials ) {
        str += mat.ambient.emit_decl()
        str += mat.diffuse.emit_decl()
        str += mat.specular.emit_decl()
        str += mat.shininess.emit_decl()
        str += mat.fresnel.emit_decl()
      }

      return str
    },

    update_location( gl, program ) {
      for( let mat of this.__materials ) {
        if( mat.ambient.dirty === true )   mat.ambient.update_location( gl, program )
        if( mat.diffuse.dirty === true )   mat.diffuse.update_location( gl, program )
        if( mat.specular.dirty === true )  mat.specular.update_location( gl, program )
        if( mat.shininess.dirty === true ) mat.shininess.update_location( gl, program )
        if( mat.fresnel.dirty === true )   mat.fresnel.update_location( gl, program )
      }
    },

    upload_data( gl, program='' ) {
      for( let mat of this.__materials ) {
        if( mat.ambient.dirty === true )   mat.ambient.upload_data( gl, program )
        if( mat.diffuse.dirty === true )   mat.diffuse.upload_data( gl, program )
        if( mat.specular.dirty === true )  mat.specular.upload_data( gl, program )
        if( mat.shininess.dirty === true ) mat.shininess.upload_data( gl, program )
        if( mat.fresnel.dirty === true )   mat.fresnel.upload_data( gl, program )
      }
    }

  }

  const f = value => value % 1 === 0 ? value.toFixed(1) : value 

  Object.assign( Materials.material, {
    default : Materials.material( 'global', Vec3( .15 ), Vec3(0), Vec3(1), 8, Vec3( 0, 1, .5 ) ),  
    red     : Materials.material( 'global', Vec3(.25,0,0), Vec3(1,0,0), Vec3(0), 2, Vec3(0) ),
    green   : Materials.material( 'global', Vec3(0,.25,0), Vec3(0,1,0), Vec3(0), 2, Vec3(0) ),
    blue    : Materials.material( 'global', Vec3(0,0,.25), Vec3(0,0,1), Vec3(0), 2, Vec3(0) ),
    cyan    : Materials.material( 'global', Vec3(0,.25,.25), Vec3(0,1,1), Vec3(0), 2, Vec3(0) ),
    magenta : Materials.material( 'global', Vec3(.25,0,.25), Vec3(1,0,1), Vec3(0), 2, Vec3(0) ),
    yellow  : Materials.material( 'global', Vec3(.25,.25,.0), Vec3(1,1,0), Vec3(0), 2, Vec3(0) ),
    black   : Materials.material( 'global', Vec3(0, 0, 0), Vec3(0,0,0), Vec3(0), 2, Vec3(0) ),
    white   : Materials.material( 'global', Vec3(.25), Vec3(1), Vec3(1), 2, Vec3(0) ),
    grey    : Materials.material( 'global', Vec3(.25), Vec3(.33), Vec3(1), 2, Vec3(0) ),

    'white glow' : Materials.material( 'phong',  Vec3(.015), Vec3(1), Vec3(1), 16, Vec3(0,200,5) ),
    glue    : Materials.material( 'phong',  Vec3(.015), Vec3(1), Vec3(1), 16, Vec3(0,15,-.1) ),
    inverse : Materials.material( 'phong', 1, .5, 1, 16, Vec3(1,.5,-2) ),

    normal  : Materials.material( 'normal' ),
    noise   : Materials.material( 'noise',  Vec3( .15 ), Vec3(1,0,0), Vec3(1), 8, Vec3( 0, 1, .5 ))
  })

  return Materials
}

module.exports = __Materials

},{"./sceneNode.js":22,"./utils.js":27,"./var.js":28,"./vec.js":29,"glslify":120}],17:[function(require,module,exports){
const glsl = require( 'glslify' )
const SceneNode = require( './sceneNode.js' )
const { param_wrap, MaterialID } = require( './utils.js' )
const { Var, float_var_gen, vec2_var_gen, vec3_var_gen, vec4_var_gen } = require( './var.js' )

const getNoise = function( SDF ) {
Noise = function( strength=.25, bias=1, timeMod=1 ) {
  const op = Object.create( Noise.prototype )
  op.type = 'string'
  op.isGen = true

  const defaultValues = [.5,.5,.5]

  op.matId = MaterialID.alloc()

  const __strength = param_wrap( strength, float_var_gen( strength ) )
  const __timeMod  = param_wrap( timeMod, float_var_gen( timeMod ) )

  Object.defineProperty( op, 'strength', {
    get() { return __strength },
    set(v) {
     __strength.var.set( v )
    }
  })
  Object.defineProperty( op, 'timeMod', {
    get() { return __timeMod },
    set(v) {
     __timeMod.var.set( v )
    }
  })
  const __bias  = param_wrap( bias, float_var_gen( bias ) )

  Object.defineProperty( op, 'bias', {
    get() { return __bias},
    set(v) {
     __bias.var.set( v )
    }
  })
  return op
} 

Noise.prototype = SceneNode()

Noise.prototype.emit = function ( __name ) {
  let name = __name === undefined ? 'p' : __name

  const out = `(${this.bias.emit()} + snoise( vec4( p.xyz, time * ${this.timeMod.emit()} )) * ${this.strength.emit()})`  

  const output = {
    out,
    preface:''
  }

  return output
}
Noise.prototype.glsl = glsl(["#define GLSLIFY 1\n    //\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nfloat mod289(float x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat permute(float x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat taylorInvSqrt(float r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 grad4(float j, vec4 ip)\n  {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n\n  return p;\n  }\n\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\n\nfloat snoise(vec4 v)\n  {\n  const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                        0.276393202250021,  // 2 * G4\n                        0.414589803375032,  // 3 * G4\n                       -0.447213595499958); // -1 + 4 * G4\n\n// First corner\n  vec4 i  = floor(v + dot(v, vec4(F4)) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n//  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n  //  x1 = x0 - i1  + 1.0 * C.xxxx\n  //  x2 = x0 - i2  + 2.0 * C.xxxx\n  //  x3 = x0 - i3  + 3.0 * C.xxxx\n  //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n  vec4 x1 = x0 - i1 + C.xxxx;\n  vec4 x2 = x0 - i2 + C.yyyy;\n  vec4 x3 = x0 - i3 + C.zzzz;\n  vec4 x4 = x0 + C.wwww;\n\n// Permutations\n  i = mod289(i);\n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n  }\n\n"])

Noise.prototype.emit_decl = function () {
  let str = this.strength.emit_decl() + this.timeMod.emit_decl() + this.bias.emit_decl()

  if( SDF.memo.noise === undefined ) {
    str = Noise.prototype.glsl + str
    SDF.memo.noise = true
  }

  return str
};

Noise.prototype.update_location = function(gl, program) {
  this.strength.update_location( gl, program )
  this.timeMod.update_location( gl, program )
  this.bias.update_location( gl, program )
}

Noise.prototype.upload_data = function(gl) {
  this.strength.upload_data( gl )
  this.timeMod.upload_data( gl )
  this.bias.upload_data( gl )
}

return Noise

}

module.exports = getNoise 

},{"./sceneNode.js":22,"./utils.js":27,"./var.js":28,"glslify":120}],18:[function(require,module,exports){
const glsl = require( 'glslify' )

module.exports = {
  Box: {
    parameters:[
      { name:'size', type:'vec3', default:[1,1,1], min:.001, max:5 },
    ],

    primitiveString( pName ) { 
	    return `sdBox( ${pName}, ${this.size.emit()} )`;
    },

    glslify:glsl(["#define GLSLIFY 1\n    float sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n"])
  }, 

  // XXX we should normalize dimensions in the shader... 
  Cone: {
    parameters:[
      { name:'dimensions', type:'vec3', default:[.8,.6,.3], min:.001, max:5 },
    ],

    primitiveString( pName ) { 
      return `sdCone( ${pName}, ${this.dimensions.emit()} )`
    },
    glslify:glsl(["#define GLSLIFY 1\n    float sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -p.y-c.z;\n    float d2 = max( dot(q,c.xy), p.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n"])
  }, 

	Cylinder: {
    parameters:[
      { name:'dimensions', type:'vec2', default:[.8,.6], min:.001, max:5 },
    ],

    primitiveString( pName ) { 
      return `sdCappedCylinder( ${pName}, ${this.dimensions.emit()} )`
    },

    glslify:`    float sdCappedCylinder( vec3 p, vec2 h ) {
    vec2 d = abs(vec2(length(p.xz),p.y)) - h;
    return min(max(d.x,d.y),0.0) + length(max(d,0.0));
  }`
  }, 

  Capsule: {	
    parameters:[
      { name:'start', type:'vec3', default:[0,0,0], min:0, max:.5 },
      { name:'end', type:'vec3', default:[.8,1,0], min:.5, max:1 },
      { name:'radius', type:'float', default:.5, min:.001, max:5 },
    ],

    primitiveString( pName ) { 
      return `sdCapsule( ${pName}, ${this.start.emit()}, ${this.end.emit()}, ${this.radius.emit()} )`
    },
    glslify:glsl(["#define GLSLIFY 1\n      float sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n"])

  },

  // XXX No cylinder description
  //` #pragma glslify: sdCylinder	= require('glsl-sdf-primitives/sdCylinder')`
 	HexPrism: {
    parameters:[
      { name:'dimensions', type:'vec2', default:[.8,.6], min:.001, max:5 },
    ],

    primitiveString( pName ) { 
      return `sdHexPrism( ${pName}, ${this.dimensions.emit()} )`
    },
    glslify:glsl(["#define GLSLIFY 1\n      float sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\n"])
  },

  Julia: {
    parameters:[
      { name:'fold', type:'float', default:0, min:0, max:10 },
    ],

    primitiveString( pName ) { 
      return `julia( ${pName}, ${this.fold.emit()} )`
    },

    // https://www.shadertoy.com/view/MsfGRr
    glslify:glsl(["#define GLSLIFY 1\n  vec4 qsqr( in vec4 a ) {\n    return vec4( a.x*a.x - a.y*a.y - a.z*a.z - a.w*a.w,\n                 2.0*a.x*a.y,\n                 2.0*a.x*a.z,\n                 2.0*a.x*a.w );\n  }\n\n  float julia( in vec3 p, float atime ){\n    vec4 c = 0.45*cos( vec4(0.5,3.9,1.4,1.1) + atime * vec4(1.2,1.7,1.3,2.5) ) - vec4(0.3,0.0,0.0,0.0);\n    vec4 z = vec4(p,0.);\n    float md2 = 1.0;\n    float mz2 = dot(z,z);\n\n    for( int i=0; i<11; i++ ){\n      md2 *= 4.0*mz2;   \n      // dz -> 2zdz, meaning |dz| -> 2|z||dz| (can take the 4 out of the loop and do an exp2() afterwards)\n      z = qsqr(z) + c;  // z  -> z^2 + c\n\n      mz2 = dot(z,z);\n      if(mz2>4.0) break;\n    }\n    \n    return 0.25*sqrt(mz2/md2)*log(mz2);  // d = 0.5|z|log|z| / |dz|\n  }",""]),
  },
  KIFS: {
    parameters:[
      { name:'count', type:'float', default:8 },
      { name:'fold', type:'float', default:0 },
      { name:'radius', type:'float', default:.01 },
      { name:'threshold', type:'float', default:.004 },
      { name:'scale', type:'float', default:2 },
    ],

    primitiveString( pName ) { 
      return `kifs( ${pName}, ${this.count.emit()}, ${this.fold.emit()}, ${this.radius.emit()}, ${this.threshold.emit()}, ${this.scale.emit()} )`
    },

    // adapted from http://roy.red/folding-the-koch-snowflake-.html
    glslify:glsl(["#define GLSLIFY 1\n      float box( vec3 p, vec3 b ){\n      vec3 d = abs(p) - b;\n      return min(max(d.x,max(d.y,d.z)),0.0) +\n             length(max(d,0.0));\n    }\n    vec2 fold(vec2 p, float ang){    \n        vec2 n=vec2(cos(-ang),sin(-ang));\n        p-=2.*min(0.,dot(p,n))*n;\n        return p;\n    }\n    #define KPI 3.14159\n    vec3 tri_fold(vec3 pt, float foldamt) {\n        pt.xy = fold(pt.xy,KPI/3. + foldamt );\n        pt.xy = fold(pt.xy,-KPI/3. + foldamt );\n        pt.yz = fold(pt.yz,KPI/6.+.7 + foldamt );\n        pt.yz = fold(pt.yz,-KPI/6. + foldamt );\n        return pt;\n    }\n    vec3 tri_curve(vec3 pt, float iter, float fold, float scale ) {\n        int count = int(iter);\n        for(int i=0;i<count;i++){\n            pt*=scale;\n            pt.x-=2.6;\n            pt=tri_fold(pt,fold);\n        }\n        return pt;\n    }\n    float kifs(in vec3 p, float a, float fold, float radius, float thresh, float scale ){\n        p.x+=1.5;\n        p=tri_curve(p,a,fold,scale);\n        // uncomment below line to use spheres instead of boxes\n        return (length( p*thresh ) - radius );\n        //return box( p*thresh, vec3(radius) );\n    }\n",""]),
  },

  Mandalay: {
    parameters:[
      { name:'size', type:'float', default:5, min:1, max:10 },
      { name:'minrad', type:'float', default:1/3, min:0, max:1 },    
      { name:'iterations', type:'float', default:5, min:1, max:10, step:1 },    
    ],
    glslify:`                 
  float sr = 4.0;
  vec3 fo =vec3 (0.7,.9528,.9);
  vec3 gh = vec3 (.8,.7,0.5638);
  vec3 gw = vec3 (.3, 0.5 ,.2);
  vec4 X = vec4( .1,0.5,0.1,.3);
  vec4 Y = vec4(.1, 0.8, .1, .1);
  vec4 Z = vec4(.2,0.2,.2,.45902);
  vec4 R = vec4(0.19,.1,.1,.2);
  vec4 orbitTrap = vec4(40000.0);
  float DBFold( vec3 p, float fo, float g, float w ){
      if(p.z>p.y) p.yz=p.zy;
      float vx=p.x-2.*fo;
      float vy=p.y-4.*fo;
      float v=max(abs(vx+fo)-fo,vy);
      float v1=max(vx-g,p.y-w);
      v=min(v,v1);
      v1=max(v1,-abs(p.x));
      return min(v,p.x);
  }
   
  vec3 DBFoldParallel(vec3 p, vec3 fo, vec3 g, vec3 w){
    vec3 p1=p;
    p.x=DBFold(p1,fo.x,g.x,w.x);
    p.y=DBFold(p1.yzx,fo.y,g.y,w.y);
    p.z=DBFold(p1.zxy,fo.z,g.z,w.z);
    return p;
  }

  vec3 DBFoldSerial(vec3 p, vec3 fo, vec3 g,vec3 w){
    p.x=DBFold(p,fo.x,g.x,w.x);
    p.y=DBFold(p.yzx,fo.y,g.y,w.y);
    p.z=DBFold(p.zxy,fo.z,g.z,w.z);
    return p;
  }
  float sineSponge(vec3 p, float scale, float minrad, float iterations ) {
    vec4 JC=vec4(p,1.);
    float r2=dot(p,p);
    float dd = 1.;
    for(int i = 0; i<int(iterations); i++){
      p = p - clamp(p.xyz, -1.0, 1.0) * 2.0;  // mandelbox's box fold
   
      vec3 signs=sign(p);//Save 	the original signs
      p=abs(p);
      p=DBFoldParallel(p,fo,gh,gw);
      
      p*=signs;//resore signs: this way the mandelbrot set won't extend in negative directions
      

      r2=dot(p,p);
      float  t = clamp(1./r2, 1., 1./minrad);
      p*=t; dd*=t;
       

      p=p*scale+JC.xyz; dd=dd*scale+JC.w;
      p=vec3(1.0,1.0,.92)*p;
   
      r2=dot(p,p);
      orbitTrap = min(orbitTrap, abs(vec4(p.x,p.y,p.z,r2)));	
    }
    dd=abs(dd);
      #if 0
        return (sqrt(r2)-sr)/dd;//bounding volume is a sphere
      #else
        p=abs(p); return (max(p.x,max(p.y,p.z))-sr)/dd;//bounding volume is a cube
      #endif
    }
    `,
   
    primitiveString( pName ) { 
      return `sineSponge( ${pName}, ${this.size.emit()}, ${this.minrad.emit()}, ${this.iterations.emit()} )`
    }
  },  
  Mandelbulb: {
    parameters:[
      { name:'fold', type:'float', default:8, min:1, max:15 },
      { name:'iterations', type:'float', default:4, min:1, max:6, step:1 },    
    ],

    primitiveString( pName ) { 
      return `mandelbulb( ${pName}, ${this.fold.emit()}, ${this.iterations.emit()} )`
    },

    // adapted from: https://www.shadertoy.com/view/ltfSWn
    glslify:glsl(["#define GLSLIFY 1\n      float mandelbulb( in vec3 p, in float aa, float iterations ){\n        vec3 w = p;\n        float m = dot(w,w);\n\n        vec4 trap = vec4(abs(w),m);\n        float dz = 1.0;\n                \n        for( int i=0; i<int(iterations); i++ ) {\n          dz = aa*pow(sqrt(m),aa - 1.)*dz + 1.0;\n\n          float r = length(w);\n          float b = aa*acos( w.y /r);\n          float a = aa*atan( w.x, w.z );\n          w = p + pow(r,aa) * vec3( sin(b)*sin(a), cos(b), sin(b)*cos(a) );\n\n          trap = min( trap, vec4(abs(w),m) );\n\n          m = dot(w,w);\n          if( m > 256.0 ) {\n            break;\n          }\n        }\n\n        return 0.25*log(m)*sqrt(m)/dz;\n      }\n    ",""]),
  },

  // adapted from https://www.shadertoy.com/view/llGXDR
  Mandelbox: {
    parameters:[
      { name:'fold', type:'float', default:.1 },
      { name:'scale', type:'float', default:3., min:1, max:10 },
      { name:'iterations', type:'float', default:5, min:1, max:10, step:1 },
    ],

    glslify:`float mandelbox( float MR2, float SCALE, float ITER, vec3 position ){
      vec4 scalevec = vec4(SCALE, SCALE, SCALE, abs(SCALE)) / MR2;
      float C1 = abs(SCALE-1.0), C2 = pow(abs(SCALE), 1.-ITER); // 10 is ITERS
      vec4 p = vec4(position.xyz, 1.0), p0 = vec4(position.xyz, 1.0);  // p.w is knighty's DEfactor
      for (int i=0; i<int(ITER); i++) {
        p.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;  // box fold: min3, max3gg, mad3
        float r2 = dot(p.xyz, p.xyz);  // dp3
        p.xyzw *= clamp(max(MR2/r2, MR2), 0.0, 1.0);  // sphere fold: div1, max1.sat, mul4
        p.xyzw = p*scalevec + p0;  // mad4
      }
      return (length(p.xyz) - C1) / p.w - C2;
  }`,

    primitiveString( pName ) {
      return `mandelbox( ${this.fold.emit()}, ${this.scale.emit()}, ${this.iterations.emit()}, ${pName} )`
    }
  },

	Octahedron: {
    parameters:[
      { name:'radius', type:'float', default:1, min:0, max:4 },
    ],

    primitiveString( pName ) { 
      return `sdOctahedron( ${pName}, ${this.radius.emit()} )`
    },

    glslify:`    float sdOctahedron(vec3 p, float h) {
    p.y = p.y + h; // center vertically... is it centered on the z-axis?
    vec2 d = .5*(abs(p.xz)+p.y) - min(h,p.y);
    return length(max(d,0.)) + min(max(d.x,d.y), 0.);
  }`
  }, 

 	Plane: {
    parameters:[
      { name:'normal', type:'vec3', default:[0,1,0], min:0, max:1 },
      { name:'distance', type:'float', default:1, min:0, max:5 },
    ],

    primitiveString( pName ) { 
      return `sdPlane( ${pName}, vec4( ${this.normal.emit()}, ${this.distance.emit()} ))`
    },
    
    glslify:glsl(["#define GLSLIFY 1\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n"])
    
  },  
 	Quad: {
    parameters:[
      { name:'v1', type:'vec3', default:[-.5,-.5,0] },
      { name:'v2', type:'vec3', default:[.5,-.5,0] },
      { name:'v3', type:'vec3', default:[.5,.5,0] },
      { name:'v4', type:'vec3', default:[-.5,.5,0] },
    ],

    primitiveString( pName ) { 
      return `udQuad( ${pName}, ${this.v1.emit()}, ${this.v2.emit()}, ${this.v3.emit()}, ${this.v4.emit()} )`
    },
    glslify:glsl(["#define GLSLIFY 1\n    float dot2( in vec3 v ) { return dot(v,v); }\nfloat udQuad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 dc = d - c; vec3 pc = p - c;\n    vec3 ad = a - d; vec3 pd = p - d;\n    vec3 nor = cross( ba, ad );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n"])
  }, 

  RoundBox: {
    parameters:[
      { name:'size', type:'vec3', default:[1,1,1], min:0, max:3 },
      { name:'radius', type:'float', default:1, min:0, max:3 },
    ],

    primitiveString( pName ) { 
      return `udRoundBox( ${pName}, ${this.size.emit()},  ${this.radius.emit()} )`
    }, 
    glslify:glsl(["#define GLSLIFY 1\n    float udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\n"])
  }, 
  Sphere:{
    parameters:[
      { name:'radius', type:'float', default:1, min:0, max:3 },
    ],

    primitiveString( pName ) { 
      return `(length(${pName}) - ${this.radius.emit()})`
    },
    glslify:glsl(["#define GLSLIFY 1\n    float sdSphere( vec3 p, float s )\n{\n  return length( p ) - s;\n}\n\n"])
  },
  // phi, m, n1, n2, n3, a, b
  SuperFormula:{
    parameters:[
      { name:'m_1', type:'float',  default:1, min:-Math.PI*4, max:Math.PI*4 },
      { name:'n1_1', type:'float', default:1, min:-Math.PI*4, max:Math.PI*4 },
      { name:'n2_1', type:'float', default:1, min:-Math.PI*4, max:Math.PI*4 },
      { name:'n3_1', type:'float', default:1, min:-Math.PI*4, max:Math.PI*4 },
      { name:'a_1', type:'float',  default:1, min:-Math.PI*4, max:Math.PI*4 },
      { name:'b_1', type:'float',  default:1, min:-Math.PI*4, max:Math.PI*4 },
      { name:'m_2', type:'float',  default:1, min:-Math.PI*4, max:Math.PI*4 },
      { name:'n1_2', type:'float', default:1, min:-Math.PI*4, max:Math.PI*4 },
      { name:'n2_2', type:'float', default:1, min:-Math.PI*4, max:Math.PI*4 },
      { name:'n3_2', type:'float', default:1, min:-Math.PI*4, max:Math.PI*4 },
      { name:'a_2', type:'float',  default:1, min:-Math.PI*4, max:Math.PI*4 },
      { name:'b_2', type:'float',  default:1, min:-Math.PI*4, max:Math.PI*4 },
    ],

    primitiveString( pName ) { 
      return `superformula( ${pName}, ${this.m_1.emit()}, ${this.n1_1.emit()},${this.n2_1.emit()},${this.n3_1.emit()},${this.a_1.emit()},${this.b_1.emit()}, ${this.m_2.emit()}, ${this.n1_2.emit()},${this.n2_2.emit()},${this.n3_2.emit()},${this.a_2.emit()},${this.b_2.emit()} )`
    },
    glslify:glsl(["#define GLSLIFY 1\n    float SuperFormula( float phi, float m, float n1, float n2, float n3, float a, float b ){\n\t\n\tfloat t1 = abs((1.0 / a) * cos(m * phi / 4.0));\n\tt1 = pow(t1, n2);\n\n\tfloat t2 = abs((a / b) * sin(m * phi / 4.0));\n\tt2 = pow(t2, n3);\n\n\tfloat t3 = t1 + t2;\n\n\tfloat r = pow(t3, -1.0 / n1);\n\n\treturn r;\n}\n\n float superformula( vec3 p, float m_1, float n1_1, float n2_1, float n3_1, float a_1, float b_1, float m_2, float n1_2, float n2_2, float n3_2, float a_2, float b_2 ) {\n    float d = length( p );\n    float theta = atan(p.y, p.x);\n    float phi = d == 0. ? 0. : asin(p.z / d);\n    float r1 = SuperFormula( theta, m_1, n1_1, n2_1, n3_1, a_1, b_1 );\n    float r2 = SuperFormula( phi, m_2, n1_2, n2_2, n3_2, a_2, b_2 );\n    vec3 q = r2 * vec3(r1 * cos(theta) * cos(phi), r1 * sin(theta) * cos(phi), sin(phi));\n    d = d - length(q);\n\n    return d;\n  }    \n",""]) },
 
  Torus:{
    parameters:[
      { name:'radii',  type:'vec2', default:[.5,.1], min:0, max:3 },
    ],

    primitiveString( pname ) { 
      return `sdTorus( ${pname}, ${this.radii.emit()} )`
    },
    glslify:glsl(["#define GLSLIFY 1\n    float sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n"])

  },  
  Torus88:{
    parameters:[
      { name:'radii',  type:'vec2', default:[.5,.1], min:0, max:3 },
    ],

    primitiveString( pname ) { 
      return `sdTorus88( ${pname}, ${this.radii.emit()} )`
    },
    glslify:`float sdTorus88( vec3 p, vec2 t ) {
        vec2 q = vec2( length8( p.xz ) - t.x, p.y );
        return length8( q ) - t.y;
      }\n`,
  },
  Torus82:{
    parameters:[
      { name:'radii',  type:'vec2', default:[.5,.1], min:0, max:3 },
    ],

    primitiveString( pname ) { 
      return `sdTorus82( ${pname}, ${this.radii.emit()} )`
    },
    glslify:`float sdTorus82( vec3 p, vec2 t ) {
        vec2 q = vec2( length( p.xz ) - t.x, p.y );
        return length8( q ) - t.y;
      }\n`
  },
 	Triangle: {
    parameters:[
      { name:'v1', type:'vec3', default:[0,-.5,0] },
      { name:'v2', type:'vec3', default:[-.5,.0,0] },
      { name:'v3', type:'vec3', default:[.5,.0,0] },
    ],

    primitivestring( pname ) { 
      return `udtriangle( ${pname}, ${this.v1.emit()}, ${this.v2.emit()}, ${this.v3.emit()} )`
    },
    glslify:glsl(["#define GLSLIFY 1\n    float dot2( in vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n"])
  }, 

  TriPrism: {
    parameters:[
      { name:'dimensions', type:'vec2', default:[.5,.5], min:0, max:3 },
    ],

    primitiveString( pName ) { 
      return `sdTriPrism( ${pName}, ${this.dimensions.emit()})`
    },
    glslify:glsl(["#define GLSLIFY 1\n      float sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n"])

  },

}

},{"glslify":120}],19:[function(require,module,exports){
const { Var, float_var_gen, vec2_var_gen, vec3_var_gen, vec4_var_gen, int_var_gen, VarAlloc }  = require( './var.js' )
const SceneNode = require( './sceneNode.js' )
const { param_wrap, MaterialID } = require( './utils.js' )
const { Vec2, Vec3, Vec4 } = require( './vec.js' )
const Transform = require( './transform.js' )

const createPrimitives = function( SDF ) {

  const gens = { 
    int:   int_var_gen,
    float: float_var_gen,
    vec2: vec2_var_gen,
    vec3: vec3_var_gen,
    vec4: vec4_var_gen,
  }

  const vars = { 
    vec2: Vec2,
    vec3: Vec3,
    vec4: Vec4
  }

  // load descriptions of all primtives
  const descriptions = require( './primitiveDescriptions.js' )

  const Primitives = { 
    descriptions,

    textureMemo: [],

    emit_geometries() {
      const head = Array.isArray( SDF.__scene.__prerender ) ? SDF.__scene.__prerender[0] : SDF.__scene.__prerender
      const geos = Primitives.crawlNode( head, [] )

      geos.forEach( (geo,i) => {
        geo.__sdfID = i 
        if( geo.__textureObj !== undefined ) {
          SDF.textures.addTexture( geo.__textureObj )
        }
      })

      const length = geos.length
      const materials = SDF.materials.materials

      let decl = `SDF sdfs[${length}] = SDF[${length}](\n`
      geos.forEach( (geo, i) => {
        const textureID = geo.__textureObj === undefined ? 50000 : geo.__textureObj.id
        const hasRepeat = geo.repeat !== null && geo.repeat !== undefined
        decl += `        SDF( ${materials.indexOf( geo.__material )}, ${geo.transform.varName}, ${textureID}, ${hasRepeat ? geo.repeat.distance.emit() : 'vec3(0.)'}, ${hasRepeat ? geo.repeat.transform.emit() : `mat4(1.)`} )`
        if( i < geos.length - 1 ) decl += ','
        decl += '\n'
      })

      decl += `      );\n`

      this.geometries = geos

      return decl
    },

    crawlNode( node, arr ) {
      if( node.type === 'geometry' ) {
        arr.push( node )
      }else{
        if( node.a !== undefined ) Primitives.crawlNode( node.a, arr )
        if( node.b !== undefined ) Primitives.crawlNode( node.b, arr )
        if( node.sdf !== undefined ) Primitives.crawlNode( node.sdf, arr )
      }

      return arr
    }
  }

  const createPrimitive = function( name, desc ) {

    const params = desc.parameters
    // create constructor
    Primitives[ name ] = function( ...args ) {
      const p = Object.create( Primitives[ name ].prototype )
      p.params = params
      p.transform = Transform()
      p.transform.shouldInvert = true
      p.type = 'geometry'
      p.name = name
      p.repeat = null//Var( vars.vec3( 0 ), null, 'vec3' )

      p.__material = null
      p.__textureID  = 500000
      
      let count = 0

      // wrap each param in a Var object for codegen
      for( let param of params ) {
        if( param.name === 'color' ) {
          p.color = args[ count ] === undefined ? param.default : args[ count++ ]
          continue
        }
        if( param.type === 'obj' ) {
          let __value = args[ count++ ]
          p[ param.name ] = {
            get value() { return __value },
            set value(v){ __value = v },
            emit() {
              const output =  p[ param.name ].value.emit()
              return output
            },
            emit_decl() {
              return p[ param.name ].value.a.emit_decl() + p[param.name].value.b.emit_decl()
            }
          }
          continue
        }
        const defaultValues = param.default
        const isArray = Array.isArray( defaultValues )

        if( isArray ) {
          let val = args[ count++ ], __var

          if( typeof val === 'number' ) {
            __var = Var( vars[ param.type ]( val ), null, 'vec3' )
          }else{
            __var =  param_wrap(
              val,
              gens[ param.type ]( ...defaultValues ) 
            )
          }

          // for assigning entire new vectors to property
          Object.defineProperty( p, param.name, {
            configurable:true,
            get() { return __var },
            set(v) {
              if( typeof v === 'object' ) {
                __var.set( v )
              }else{
                __var.value.x = v
                __var.value.y = v
                __var.value.z = v
                __var.value.w = v
                __var.dirty = true
              }
            }
          })

        }else{
          let __var  = param_wrap( 
            args[ count++ ], 
            gens[ param.type ]( defaultValues ) 
          )

          //__var.set( defaultValues )
          Object.defineProperty( p, param.name, {
            configurable:true,
            get() { return __var },
            set(v) {
              __var.set( v )
            }
          })
        }
      }

      p.id = VarAlloc.alloc()

      p.__desc = desc
      p.__setMaterial = function(mat) {
        if( typeof mat === 'string' ) mat = SDF.Material[ mat ]
        this.__material = this.mat = SDF.materials.addMaterial( mat )
      }

      p.__setTexture = function(tex,props) {
        if( typeof tex === 'string' ) {
          this.texture = p.texture.bind( this )
          this.__textureObj = this.tex = SDF.Texture( tex,props,this.texture )
          this.__textureID = this.__textureObj.id
        }else{
          this.__textureObj = this.tex = Object.assign( tex, props )
          this.__textureID = this.__textureObj.id
        }
      }
      p.__setBump = function(tex,props) {
        //this.bump = p.bump.bind( this )
        const b = this.bump = this.__bumpObj = SDF.Bump( this, tex, props )
        this.bump.texture = this.bump.amount.value
        this.__bumpID = this.__bumpObj.id
        this.rotate = this.bump.rotate
        this.translate = this.bump.translate
        this.scale = this.bump.scale
        Object.defineProperty( this.bump, 'strength', {
          get() { return b.size },
          set(v){ b.size = v }
        })
      }

      Object.assign( p, {
        renderingBump : false,
        emittingDecl  : false,
        uploading     : false,
        updating      : false
      })

      if( p.__material === null ) p.__setMaterial()

      SDF.geometries.push( p )

      return p
    }

    // define prototype to use
    Primitives[ name ].prototype = SceneNode()
    Primitives[ name ].prototype.type = 'geometry'
    
    // create codegen string


    Primitives[ name ].prototype.emit = function ( __name, transform = null, bump=null, scale=null ) {
      if( SDF.memo[ this.id ] !== undefined ) return { preface:'', out:name+this.matId }
      if( this.__bumpObj !== undefined && this.renderingBump === false) {
        this.renderingBump = true
        return this.__bumpObj.emit( __name, transform )
      }
      
      const shaderCode = desc.glslify.indexOf('#') > -1 
        ? desc.glslify.slice(18) 
        : desc.glslify

      if( SDF.requiredGeometries.indexOf( shaderCode ) === - 1 ) {
        SDF.requiredGeometries.push( shaderCode )
      } 

      if( transform !== null ) this.transform.apply( transform, false )
      //this.transform.invert( true )
      this.transform.internal()

      const pname = typeof __name !== 'string' ? 'p' : __name,
            id = this.__sdfID,
            s = scale === null ? this.transform.emit_scale() : `${this.transform.emit_scale()} * ${scale}`,
            tstring = `( ${pname} * ${this.transform.emit()} ).xyz`
      
      const primitive = `
        vec2 ${name}${this.id} = vec2( ${desc.primitiveString.call( this, tstring, bump )} * ${s}, ${id}.);
      `
      SDF.memo[ this.id ] = name + this.id

      this.renderingBump = false
      return { preface:primitive, out:name+this.id  }
    }
    
    // declare any uniform variables
    Primitives[ name ].prototype.emit_decl = function() {
      if( this.__bumpObj !== undefined && this.emittingDecl === false) {
        this.emittingDecl = true
        return this.__bumpObj.emit_decl() 
      }
      let decl = ''
      decl += this.transform.emit_decl()

      //debugger
      if( this.__repeat !== undefined ) decl += this.__repeat.emit_decl( false )
      if( this.__polarRepeat !== undefined ) decl += this.__polarRepeat.emit_decl( false )

      for( let param of params ) {
        if( param.name !== 'material' )
          decl += this[ param.name ].emit_decl( )
      }

      this.emittingDecl = false
      return decl
    }

    Primitives[ name ].prototype.update_location = function( gl, program ) {
      if( this.__bumpObj !== undefined && this.updating === false) {
        this.updating = true
        return this.__bumpObj.update_location( gl, program )
      }

      for( let param of params ) {
        if( param.type !== 'obj' ) {
          if( param.name !== 'material' ) 
            this[ param.name ].update_location( gl,program )
        }
      }

      if( this.__repeat !== undefined ) this.__repeat.update_location( gl, program, false )
      if( this.__polarRepeat !== undefined ) this.__polarRepeat.update_location( gl, program, false )
      this.transform.update_location( gl, program )
      this.updating = false
    }

    Primitives[ name ].prototype.upload_data = function( gl ) {
      if( this.__bumpObj !== undefined && this.uploading  === false ) {
        this.uploading = true
        return this.__bumpObj.upload_data( gl )
      }
      for( let param of params ) {
        if( param.type !== 'obj' && param.name !== 'material' )
          this[ param.name ].upload_data( gl )
      }

      if( this.__polarRepeat !== undefined ) this.__polarRepeat.upload_data( gl, false )
      this.transform.upload_data( gl )
      this.uploading = false
    }
    
    return Primitives[ name ]
  }
  
  for( let name in descriptions ) {
    const desc = descriptions[ name ]
    createPrimitive( name, desc )
  }

  Primitives.create = createPrimitive

  return Primitives
}

module.exports = createPrimitives

},{"./primitiveDescriptions.js":18,"./sceneNode.js":22,"./transform.js":26,"./utils.js":27,"./var.js":28,"./vec.js":29}],20:[function(require,module,exports){
const glsl = require( 'glslify' )

const getMainContinuous = function( steps, minDistance, maxDistance, postprocessing ) {
  const out = `
  // adapted from https://www.shadertoy.com/view/ldfSWs
  vec3 calcNormal(vec3 pos, float eps) {
    const vec3 v1 = vec3( 1.0,-1.0,-1.0);
    const vec3 v2 = vec3(-1.0,-1.0, 1.0);
    const vec3 v3 = vec3(-1.0, 1.0,-1.0);
    const vec3 v4 = vec3( 1.0, 1.0, 1.0);

    return normalize( v1 * scene ( pos + v1*eps ).x+
                      v2 * scene ( pos + v2*eps ).x+
                      v3 * scene ( pos + v3*eps ).x+
                      v4 * scene ( pos + v4*eps ).x);
  }

  vec3 calcNormal(vec3 pos) {
    return calcNormal(pos, 0.002);
  }

  // Adapted from from https://www.shadertoy.com/view/ldfSWs
  vec2 calcRayIntersection( vec3 rayOrigin, vec3 rayDir, float maxd, float precis ) {
    float latest = precis * 2.0;
    float dist   = +0.0;
    float type   = -1.0;
    vec2 result;
    vec2 res = vec2(-50000., -1.);;

    for (int i = 0; i < ${steps} ; i++) {
      if (latest < precis || dist > maxd) break;

      result = scene(rayOrigin + rayDir * dist);

      latest = result.x;
      dist  += latest;
    }

    if( dist < maxd ) {
      result.x = dist;
      res = result;
    }

    return res;
  }

  layout(location = 0) out vec4 col;
  layout(location = 1) out vec4 depth;
  void main() {
    vec2 pos = v_uv * 2.0 - 1.0;

    // not sure why I need the -y axis but without it
    // everything is flipped using perspective-camera
    pos.x *= ( resolution.x / -resolution.y );

    vec3 color = bg; 
    vec3 ro = camera_pos;
    vec3 rd = normalize( mat3(camera) * vec3( pos, 2. ) ); 
    
    vec2 t = calcRayIntersection( ro, rd, ${maxDistance}, ${minDistance} );

    vec3 samplePos = vec3(100.f);
    float zdist = 100000.;//vec3(100000.f);
    if( t.x > -0.5 ) {
      samplePos = ro + rd * t.x;
      zdist = rd.z * t.x;
      vec3 nor = calcNormal( samplePos );

      color = lighting( samplePos, nor, ro, rd, t.y, true ); 
    }

    ${postprocessing}
    
    col = clamp( vec4( color, 1.0 ), 0., 1. );
    //float normalizedDepth = 1.- ((samplePos.z) / ${maxDistance});

    float normalizedDepth = 1. / (1. - samplePos.z);
    depth = samplePos.z < ${maxDistance} ? vec4( vec3( normalizedDepth ), 1. ) : vec4(0.);
    //depth = samplePos.z < ${maxDistance} ? vec4( vec3( 1./(1.+normalizedDepth) * 255. ), 1. ) : vec4(0.);
////vec4(1./(1. + zdist ));
  }`

  return out
}

const getMainVoxels = function( steps, postprocessing, voxelSize = .1 ) {
  const out = `
  struct VoxelDistance {
    bvec3 mask;
    vec3  distance;
    float fogCoeff;
    int   id;
  };

  VoxelDistance calcRayIntersection( vec3 rayOrigin, vec3 rayDir ) {
    vec2 result;

    float m = ${voxelSize};
    rayOrigin *= 1./m;
    vec3 mapPos = vec3(floor(rayOrigin));
    vec3 diff = mapPos - rayOrigin;

    vec3 deltaDist = abs(vec3(length(rayDir)) / rayDir);
    vec3 rayStep = vec3(sign(rayDir));
    vec3 sideDist = (sign(rayDir) * diff + (sign(rayDir) * 0.5) + 0.5) * deltaDist; 

    bvec3 mask;
    vec3 d = vec3(-100000.);
    float fogCoeff = 0.;

    for (int i = 0; i < ${Math.round(steps*1/voxelSize)} ; i++) {
      result = scene(mapPos*m);
      if( result.x <= 0. ) {
        d = mapPos*m+result.x;
        break;
      }

      mask = bvec3( lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy)) );
      sideDist += vec3( mask ) * deltaDist; 
      mapPos += vec3(mask) * rayStep;
      fogCoeff += result.x * m;
    }

    VoxelDistance vd = VoxelDistance( mask, d, fogCoeff, int(result.y) );
    return vd;
  }

  out vec4 col;
  void main() {
    vec2 pos = v_uv * 2.0 - 1.0;

    // not sure why I need the -y axis but without it
    // everything is flipped using perspective-camera
    pos.x *= ( resolution.x / -resolution.y );
    
    vec3 color = bg; 
    vec3 ro = camera_pos;
    vec3 rd = normalize( mat3(camera) * vec3( pos, 2. ) ); 
                 
    VoxelDistance vd = calcRayIntersection( ro, rd );
    bvec3 mask = vd.mask;
    
    vec3 nor;
    if (mask.x) {
      color = vec3(0.5);
      nor = vec3(1.,0.,0.);
    }
    if (mask.y) {
      color = vec3(1.0);
      nor = vec3(0.,1.,0.);
    }
    if (mask.z) {
      color = vec3(0.75);
      nor = vec3(0.,0.,1.);
    }
    if( vd.distance.x == -100000. ) {
      color = bg;
    }
    
    float modAmount = ${(1./voxelSize).toFixed(1)};
    if( color != bg ) {
      vec3 pos = vd.distance; 
      //vec3 pos = ro + rd * vd.fogCoeff;

      color *= lighting( pos * modAmount, nor, ro, rd, float(vd.id), false ); 
      //color *= lighting( pos, nor, ro, rd, float(vd.id), false ); 
      //color = min(color,1.);
      //color = getTexture( 0, pos );
      
    }
    
    vec2 t = vec2( vd.fogCoeff, vd.id );
  ${postprocessing}; 
    col = vec4( color, 1. ); 
  }`

  return out
}

module.exports = function( variables, scene, preface, geometries, lighting, postprocessing, steps=90, minDistance=.001, maxDistance=20, ops, voxelSize=0 ) {

  const main = voxelSize === 0
    ? getMainContinuous( steps, minDistance, maxDistance, postprocessing ) 
    : getMainVoxels( steps, postprocessing, voxelSize )

    const fs_source = glsl(["     #version 300 es\n      precision mediump float;\n#define GLSLIFY 1\n\n\n      float PI = 3.141592653589793;\n\n      in vec2 v_uv;\n\n      struct Light {\n        vec3 position;\n        vec3 color;\n        float attenuation;\n      };\n\n      int rotationCount = 1;\n\n      mat4 rotations[4] = mat4[4](\n        mat4(0.), mat4(0.), mat4(0.), mat4(0.)\n      );\n\n      struct Material {\n        int  mode;\n        vec3 ambient;\n        vec3 diffuse;\n        vec3 specular;\n        float shininess;\n        vec3 fresnel;\n        int textureID;\n      };     \n\n      struct SDF {\n        int materialID;\n        mat4 transform;\n        int textureID;\n        vec3 repeat;\n        mat4 repeatTransform;\n      };\n\n      uniform float time;\n      uniform vec2 resolution;\n      uniform vec3 camera_pos;\n      uniform vec3 camera_normal;\n      uniform float camera_rot;\n      uniform mat4 camera;\n\n      ","\n\n      // must be before geometries!\n      float length8( vec2 p ) { \n        return float( pow( pow(p.x,8.)+pow(p.y,8.), 1./8. ) ); \n      }\n\n      ","\n\n      /* GEOMETRIES */\n      ","\n\n      vec2 scene(vec3 p);\n\n      // XXX todo put this in domainOperations.js\n      vec3 polarRepeat(vec3 p, float repetitions) {\n        float angle = 2.*PI/repetitions;\n        float a = atan(p.z, p.x) + angle/2.;\n        float r = length(p.xz);\n        float c = floor(a/angle);\n        a = mod(a,angle) - angle/2.;\n        vec3 _p = vec3( cos(a) * r, p.y,  sin(a) * r );\n        // For an odd number of repetitions, fix cell index of the cell in -x direction\n        // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n        if (abs(c) >= (repetitions/2.)) c = abs(c);\n        return _p;\n      }\n\n      // added k value to glsl-sdf-ops/soft-shadow\n      float softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, in float k ){\n        float res = 1.0;\n        float t = mint;\n\n        for( int i = 0; i < 12; i++ ) {\n          float h = scene( ro + rd * t ).x;\n          res = min( res, k * h / t );\n          t += clamp( h, 0.02, 0.10 );\n          if( h<0.001 || t>tmax ) break;\n        }\n\n        return clamp( res, 0.0, 1.0 );\n      }\n\n","\n\n    vec2 scene(vec3 _p ) {\n      vec4 p = vec4( _p, 1. );\n","\n      return ",";\n    }\n \n","\n",""],variables,ops,geometries,lighting,preface,scene,main)

    return fs_source
  }

},{"glslify":120}],21:[function(require,module,exports){
const getFog = require( './fog.js' )
const vignette = require( './vignette.js' )
const { param_wrap, MaterialID } = require( './utils.js' )
const __lighting = require( './lighting.js' )
const { Var, float_var_gen, vec2_var_gen, vec3_var_gen, vec4_var_gen, int_var_gen, VarAlloc } = require('./var.js')

const getScene = function( SDF ) {

  Scene = function( objs, canvas, steps=100, minDistance=.001, maxDistance=40, size=2, shouldAnimate=false ) {
    const scene  = Object.create( Scene.prototype )

    MaterialID.clear()

    SDF.lighting.lights = []

    scene.__prerender = objs
    if( objs.length > 1 ) {
      // reduce objects to nested Unions
      scene.__prerender = objs.reduce( ( current, next ) => SDF.Union( current, next ) )
    }

    Object.assign( scene, { 
      objs, 
      canvas,
      postprocessing:[],
      __shadow:8,
      __followLight:null
    })

    scene.animate( shouldAnimate )
      .steps( steps )
      .threshold( minDistance )
      .farPlane( maxDistance )
      .resolution( 1 )

    scene.useQuality = true
    scene.useVoxels  = false

    SDF.__scene = scene

    return scene
  }

  Scene.prototype = {
    animate( v ) { this.__animate = v; return this },  
    resolution( v ) { 
      this.width = Math.floor( this.canvas.width = window.innerWidth * v )
      this.height = Math.floor( this.canvas.height = window.innerHeight * v )
      
      this.__resolution = v;
      this.useQuality = false
      return this 
    },  
    voxel( v = .1 ) { 
      this.useVoxels = true
      this.__voxelSize = v
      return this
    },
    threshold( v ) { this.__threshold = v; this.useQuality = false; return this },  
    steps( v ) { this.__steps = v; this.useQuality = false; return this },  
    farPlane( v ) { this.__farPlane = v; this.useQuality = false;  return this },  
    camera( x=0, y=0, z=5, speed=1 ) {
      SDF.camera.__camera.position[0] = x
      SDF.camera.__camera.position[1] = y
      SDF.camera.__camera.position[2] = z
      SDF.camera.__camera.rotationSpeed = speed * .01
      SDF.camera.__camera.positionSpeed = speed * -.25
      SDF.camera.update()
      return this
    },
    shadow( k=0 ) {
      this.__shadow = k;
      return this;
    },
    quality( quality=10 ) {
      this.threshold( .1 / (quality * quality * quality ) )
      this.steps( quality * 20 )
      this.farPlane( quality * 5 )
      this.resolution( Math.min( .2 * quality, 2 ) )

      return this
    },
    follow( light, distance=3 ) {
      this.__followLight = light
      SDF.camera.onmove = function( camera ) {
        const offset = SDF.camera.offset()
        light.pos.x = SDF.camera.__camera.position[0] - offset[0]
        light.pos.y = SDF.camera.__camera.position[1] - offset[1]
        light.pos.z = SDF.camera.__camera.position[2] - offset[2]
        light.dirty = true
      }
      SDF.lighting.lights = [light]
      return this
    },
    light( ...lights ) {
      SDF.lighting.lights = SDF.lighting.lights.concat( lights )
      if( this.__followLight !== null ) SDF.lighting.lights.push( this.__followLight )
      return this
    },
    fog: getFog( Scene, SDF ),
    vignette: vignette( Scene, SDF ),
    background: require( './background.js' )( Scene, SDF ),
    presets: {
      'fractal.close': {
        farPlane:1,
        resolution:1,
        steps:150,
        animated:true,
        threshold:.000125
      },
      'fractal.kindaclose': {
        farPlane:2,
        resolution:1,
        steps:250,
        animated:true,
        threshold:.000125/2
      },
      'fractal.med': {
        farPlane:5,
        resolution:.75,
        steps:80,
        animated:true,
        threshold:.001,
      },
      'fractal.low': {
        farPlane:3.0,
        resolution:.5,
        animated:true,
        steps:50,
        threshold:.005,
      },
      'fractal.high': {
        farPlane:10,
        resolution:1,
        animated:true,
        steps:100,
        threshold:.001,
      },
      'repeat.low': {
        farPlane:25,
        resolution:.5,
        animated:true,
        steps:50
      },
      'repeat.med': {
        farPlane:35,
        resolution:1,
        animated:true,
        steps:75
      },
      'repeat.high': {
        farPlane:40,
        resolution:1,
        animated:true,
        steps:100
      },
      'voxel.high': {
        resolution:1,
        animated:true,
        steps:30
      },
      'voxel.med': {
        resolution:1,
        animated:true,
        steps:20
      },
      'voxel.low': {
        resolution:.5,
        animated:true,
        steps:10
      },
      low: {
        threshold:.05,
        steps:45,
        farPlane:12,
        resolution:.4,
        animated:true
      },
      medium: {
        threshold:.01,
        steps:80,
        farPlane:18,
        resolution:.5,
        animated:true
      },
      med: {
        threshold:.01,
        steps:80,
        farPlane:18,
        resolution:.5,
        animated:true
      },
      high: {
        threshold:.005,
        steps:90,
        farPlane:20,
        resolution:1,
        animated:true
      }
    },

    applyPreset( presetName ) {
      const preset = this.presets[ presetName ]
      if( preset.farPlane !== undefined ) this.farPlane( preset.farPlane )
      this.steps( preset.steps )
      this.resolution( preset.resolution )
      this.threshold( preset.threshold || .001 )

      return preset.animated
    },
    render( quality=10, animate=false, useQuality=true ) {
      this.background() // adds default if none has been specified
      if( typeof quality === 'string' ) {
        animate = this.applyPreset( quality )
      }else if( this.useQuality === true ) {
        this.quality( quality )
      }
      this.animate( animate )

      SDF.distanceOps.__clear()
      SDF.textures.clear()
      const geometries = SDF.primitives.emit_geometries()

      let [ variablesDeclaration, sceneRendering, postprocessing ] = SDF.generateSDF( this )

      const lighting = SDF.lighting.gen( this.__shadow, geometries )
      variablesDeclaration += SDF.materials.emit_decl() 
      variablesDeclaration += SDF.textures.emit_decl() 
      variablesDeclaration += SDF.lighting.emit_decl() 

      this.fs = SDF.renderFragmentShader( 
        variablesDeclaration, 
        sceneRendering.out, 
        sceneRendering.preface,
        SDF.requiredGeometries.join('\n') + SDF.requiredOps.join('\n'),
        lighting,
        postprocessing, 
        this.__steps, this.__threshold, this.__farPlane.toFixed(1),
        SDF.distanceOps.__getGLSL(),
        this.useVoxels ? this.__voxelSize : 0
      )

      SDF.start( this.fs, this.width, this.height, this.__animate )

      //SDF.materials.materials.length = 0

      this.useQuality = true

      return this
    },

  }

  return Scene

}

module.exports = getScene 

},{"./background.js":3,"./fog.js":11,"./lighting.js":14,"./utils.js":27,"./var.js":28,"./vignette.js":30}],22:[function(require,module,exports){
const SceneNode = ()=> Object.create( SceneNode.prototype )
const Matrix = require( './external/matrix.js' )

SceneNode.prototype = {
	emit() { return "#NotImplemented#"; },

	emit_decl() { return ""; },

	update_location(gl, program) {},

  upload_data(gl) {},

  getID() {
    let id = this.id

    if( id === undefined && this.sdf !== undefined ) {
      id = this.sdf.getID()
    }

    return id
  },

  getCenter() {
    let center = this.center

    if( center === undefined && this.sdf !== undefined ) {
      if( this.sdf.getCenter === undefined ) {
        center = this.sdf.__wrapped.getCenter()
      }else{
        center = this.sdf.getCenter()
      }
    }

    return center
  },

  move( ...args ) {
    return this.translate( ...args )
  },

  rotate( angle, x,y,z ) {
    this.transform.rotation.angle = angle
    if( x !== undefined ) this.transform.rotation.axis.x = x
    if( y !== undefined ) this.transform.rotation.axis.y = y
    if( z !== undefined ) this.transform.rotation.axis.z = z
  
    return this
  },

  rotateBy( angle,x,y,z ) {
    this.transform.__rotations.push( Matrix.rotate( angle,x,y,z ) )
    return this
  },

  translate( x,y,z ) {
    if( x !== undefined && x !== null ) this.transform.translation.x = x
    if( y !== undefined && y !== null ) this.transform.translation.y = y
    if( z !== undefined && z !== null ) this.transform.translation.z = z
  
    return this
  },

  scale( amount ) {
    if( amount !== undefined ) this.transform.scale = amount
    return this
  },

  material( mat ) {
    this.__setMaterial( mat )
    return this
  },

  texture( tex,props ) {
    this.__setTexture( tex,props )
    return this
  },

  bump( tex,strength ) {
    this.__setBump( tex,strength )
    return this
  }
}

const ops = [ 'repeat', 'polarRepeat', 'elongation' ]

ops.forEach( op => {
  const constructorName = op[0].toUpperCase() + op.slice(1)
  SceneNode.prototype[ op ] = function( ...args ) {
    this[ op ] = this[ op ].bind( this )
    Object.assign( this[ op ], SceneNode.prototype )
    this.__target = this[ op ]
    this[ '__'+op ] = Marching[ constructorName ]( this, ...args, this[ op ] )
    this[ op ].transform = this[ '__'+op ].transform
    return this
  }
})

module.exports = SceneNode

},{"./external/matrix.js":9}],23:[function(require,module,exports){
const SceneNode = require( './sceneNode.js' ),
      getPixels = require( 'get-pixels' ),
      createTexture = require( 'gl-texture2d' ),
      { param_wrap, MaterialID } = require( './utils.js' ),
      { Var, float_var_gen, vec2_var_gen, vec3_var_gen, vec4_var_gen, int_var_gen, VarAlloc }  = require( './var.js' ), 
      { Vec2, Vec3, Vec4 } = require( './vec.js' )


const __Textures = function( SDF ) {
  const gens = { 
    int:   int_var_gen,
    float: float_var_gen,
    vec2: vec2_var_gen,
    vec3: vec3_var_gen,
    vec4: vec4_var_gen,
  }

  const vars = { 
    vec2: Vec2,
    vec3: Vec3,
    vec4: Vec4
  }

  const Textures = {
    textures:[],
    __textures:[],

    __texturePrefaces:[],
    __textureBodies:  [],

    __types: require( './textureDescriptions.js' ),
    __wrap : require( './textureWrap.js' ), 
    
    __emitFunction() {
      let pushedWrap = false

      let decl = `
      vec3 getTexture( int id, vec3 pos ) {
        vec3 tex;
        vec2 pos2;

        switch( id ) {\n`
      
      Textures.__textureBodies.length = 0

      let funcdefs = ''
      this.textures.forEach( (t,i) => {
        const mode = t.mode !== '2d' && t.glsl !== undefined ? '3d' : '2d'

        // add texture wrap function if needed
        if( mode === '2d' && pushedWrap === false ) {
          Textures.__textureBodies.push( Textures.__wrap )
          pushedWrap = true
        }

        const glsl = mode === '3d' ? t.glsl : t.glsl2d 
        if( Textures.__textureBodies.indexOf( glsl ) === -1 ) { 
          Textures.__textureBodies.push( glsl )
        }

        const args = t.parameters.map( p => t.__target[ p.name ].emit() ) 
        const functionName = mode === '2d' ? t.name + '2d' : t.name 

        //decl += `
        //  case ${i}:
        //      ${mode === '2d' 
        //      ? `    
        //      vec3 n = normalize( pos );
        //      vec4 texx =  vec4(${functionName}( .5*n.yz+.5 ${ args.length > 0 ? ',' + args.join(',') : ''} ), 1.);
        //      vec4 texy =  vec4(${functionName}( .5*n.zx+.5 ${ args.length > 0 ? ',' + args.join(',') : ''} ), 1.);
        //      vec4 texz =  vec4(${functionName}( .5*n.xy+.5 ${ args.length > 0 ? ',' + args.join(',') : ''} ), 1.);
        //      tex = triplanar( n, texx, texy,texz,false,false ).xyz;`
        //      : ` 
        //      tex = ${functionName}( pos ${ args.length > 0 ? ',' + args.join(',') : ''} );
        //   `}
        //    break;\n`


        decl +=`
          case ${i}:
            ${mode === '2d' ? `     pos2 = getUVCubic( pos );\n` : ''} 
            tex = ${functionName}( ${mode === '2d' ?'pos2':'pos'} ${ args.length > 0 ? ',' + args.join(',') : ''} );
            break;\n`            

      })

      decl += `
          default:
            tex = vec3(0.);
            break;
        }

        return tex;
      }

      vec3 getTexture( int id, vec3 pos, vec3 nor, SDF sdf, bool useTransform ) {
        vec3 tex;
        vec2 pos2;
        vec3 tpos = pos;
        if( useTransform == true ) {
          if( length(sdf.repeat) != 0. ) {
            tpos = mod( (vec4(pos,1.) * sdf.repeatTransform).xyz, sdf.repeat) - .5 * sdf.repeat;
            tpos = ( vec4(tpos, 1.) * sdf.transform).xyz;
          }else{
            tpos = (vec4(tpos,1.) * sdf.transform).xyz;
          }
        }

        return getTexture( id, tpos );
      }
      `
     
      return { glsldefs: Textures.__textureBodies.join( '\n' ), mainfunc:decl }
    },

    clear() {
      Textures.textures.length = 0
    },

    addTexture( tex ) {
      // we have to dirty the texture so that its data
      // will be uploaded to new shaders, otherwise the
      // texture will only work the first time it's used, when
      // it's dirty on initialization.
      Textures.dirty( tex )

      // if texture with same name is already found, replace it,
      // otherwise push texture
      //const oldTex = Textures.textures.find( __tex => tex.name === __tex.name )
      //if( oldTex !== undefined ) {
      //  const idx = Textures.textures.indexOf( oldTex )
      //  Textures.textures.splice( idx, 1, tex )

      //  tex.id = idx 
      //}else{
        tex.id = Textures.textures.length
        Textures.textures.push( tex )
      //}

      return tex
    },

    texture( presetName='noise', props={}, target=null ){
      //const isPreset = filenameOrPreset.indexOf( '.' ) === -1
      //const defaults = { wrap:SDF.gl.MIRRORED_REPEAT }

      if( Textures.__types[ presetName ] === undefined ) {
        console.log( `the texture type '${presetName}' does not exist.` )
      }
      const tex = Object.assign( { mode:'3d' }, Textures.__types[ presetName ], props )

      if( target === null ) target = tex
      tex.__target = target

      for( let param of tex.parameters ) {
        const defaultValues = param.default
        const isArray = Array.isArray( defaultValues )

        let count = 0
        if( isArray ) {
          let val = props[ param.name ], __var

          if( typeof val === 'number' ) {
            __var = Var( vars[ param.type ]( val ), null, 'vec3' )
          }else{
            const initvalues = val !== undefined ? val : defaultValues
            __var = Var( vars[ param.type ]( ...initvalues ), null, param.type )
          }

          // for assigning entire new vectors to property
          Object.defineProperty( target, param.name, {
            configurable:true,
            get() { return __var },
            set(v) {
              if( typeof v === 'object' ) {
                __var.set( v )
              }else{
                __var.value.x = v
                __var.value.y = v
                __var.value.z = v
                __var.value.w = v
                __var.dirty = true
              }
            }
          })

        }else{
          let __var  = param_wrap( 
            props[ param.name ], 
            gens[ param.type ]( defaultValues ) 
          )

          //__var.set( defaultValues )
          Object.defineProperty( target, param.name, {
            configurable:true,
            get() { return __var },
            set(v) {
              __var.set( v )
            }
          })
        }
      }

      if( presetName === 'image' ) {
        if( props.filename !== undefined ) {
          tex.image = getPixels( props.filename, (err,pixels) => {
            if( err !== null ) {
              console.error( err )
              return
            }
            tex.pixels = pixels
            tex.gltexture = createTexture( SDF.gl, pixels )
            tex.gltexture.wrap = props.wrap === undefined ? Marching.gl.REPEAT : props.wrap
          })
        }else{
          tex.image = null
          console.error('You must specify a filename when using the iamge preset.')
        }
      }else if( presetName === 'canvas' ) {
        if( props.canvas === undefined ) {
          tex.canvas = tex.image = document.createElement('canvas')
          tex.ctx    = tex.canvas.getContext('2d')
        }else{
          tex.image = props.canvas
        }

        tex.update = function() {
          tex.gltexture.setPixels( tex.image )
        }

        tex.gltexture = createTexture( SDF.gl, tex.image )
        tex.gltexture.wrap = props.wrap === undefined ? Marching.gl.REPEAT : props.wrap

        tex.update()
      }


      Object.defineProperty( tex, 'wrap', {
        get() { return this.gltexture.wrap },
        set(v){ this.gltexture.wrap = v }
      })

      tex.name = presetName

      return tex 
    },

    dirty( tex ) {},
   
    emit_decl() {
      if( this.textures.length === 0 ) return '' 

      let decl = ''

      const memo = []
      let imageCount = 0;
      this.textures.forEach( (tex,i) => {
        if( memo.indexOf( tex ) === -1 ) {
          for( let param of tex.parameters ) {
            if( param.name !== 'material' )
              decl += tex.__target[ param.name ].emit_decl()
          }
          memo.push( tex )
        }
        if( tex.name === 'image' || tex.name === 'canvas' ) {
          imageCount++

          // for some reason can't immediately call update... 
          // have to wait for some type of dom initialization?
          // so call here
          if( tex.update ) tex.update()
        }
      })

      if( imageCount > 0 ) {
        decl += `\n      uniform sampler2D textures[${imageCount}];\n`
      }
      return decl
    },
    
    update_location( gl, program ) {
      if( this.textures.length > 0 ) {
        this.textures.forEach( (tex,i) => {
          for( let param of tex.parameters ) {
            if( param.type !== 'obj' ) {
              if( param.name !== 'material' ) 
                tex.__target[ param.name ].update_location( gl,program )
            }
          }
          if( tex.name === 'image' || tex.name === 'canvas' ) {
            tex.loc = gl.getUniformLocation( program, `textures[${tex.id}]` )
            tex.gltexture.bind( i )
          }
        })
      }

      //if( this.textures.length > 0 ) {
      //  this.textures.sort( (a,b) => a.id > b.id ? 1 : -1 ) 

      //  for( let tex of this.textures ) {
      //    tex.loc = gl.getUniformLocation( program, `textures[${tex.id}]` )
      //    tex.gltexture.bind( tex.id )
      //  }

      //  this.__textures = this.textures.slice( 0 )
      //  this.textures.length = 0
      //}
    },

    upload_data( gl, program ) {
      if( this.textures.length > 0 ) {
        this.textures.forEach( (tex,i) => {
          for( let param of tex.parameters ) {
            if( param.type !== 'obj' && param.name !== 'material' )
              tex.__target[ param.name ].upload_data( gl )
          }
          if( tex.name === 'image' || tex.name === 'canvas' ) {
            gl.uniform1i( tex.loc, i )
          }
        })
      }
    }

  }

  Textures.texture.create = function( props ) {
    Textures.__types[ props.name ] = props
  }

  Object.defineProperties( Textures.texture, {
    'repeat': { get() { return Marching.gl.REPEAT } },
    'mirror': { get() { return Marching.gl.MIRRORED_REPEAT } },
    'clamp': { get() { return Marching.gl.CLAMP_TO_EDGE } },
  })

  const f = value => value % 1 === 0 ? value.toFixed(1) : value 

  return Textures
}

module.exports = __Textures

},{"./sceneNode.js":22,"./textureDescriptions.js":24,"./textureWrap.js":25,"./utils.js":27,"./var.js":28,"./vec.js":29,"get-pixels":42,"gl-texture2d":73}],24:[function(require,module,exports){
const glsl = require( 'glslify' )

const textures = {
  image: {
    name:'image',
    glsl2d:`
      vec3 image2d( vec2 uv, float scale, float strength ) {
        return texture( textures[ 0 ], uv*scale ).xyz * strength;
      }
    `,
    parameters:[
      { name:'scale', type:'float', default:1 },
      { name:'strength', type:'float', default:1 },   
    ]
  },
  canvas: {
    name:'canvas',
    glsl2d:`
      vec3 canvas2d( vec2 uv, float scale, float strength ) {
        return texture( textures[ 0 ], uv*scale ).xyz * strength;
      }
    `,
    parameters:[
      { name:'scale', type:'float', default:1 },
      { name:'strength', type:'float', default:1 },   
    ]
  },
  rainbow: {
    name:'rainbow',
    parameters: [
      { name:'strength', type:'float', default:1 },
      { name:'shift', type:'float', default:0 },
      { name:'scale', type:'float', default:1 },
    ],
    glsl:` 
    vec3 rainbow( vec3 pos, float strength, float shift, float scale ) {
      pos = pos * scale;
      vec3 a = vec3(0.5,0.5,0.5), b = vec3(0.5,0.5,0.5), c = vec3(1.0,1.0,1.0),d = vec3(0.0,0.33,0.67);
      return a + b * cos( 6.283818 * ( c * mod(length(pos) + shift, 1. ) + d ) ) * strength;
    }` 
  },
  checkers: {
    name:'checkers',
    glsl:`          
        vec3 checkers( vec3 pos, float size, vec3 color1, vec3 color2 ) {
          vec3 tex;
          pos  = pos * size;
          if ((int(floor(pos.x) + floor(pos.y) + floor(pos.z)) & 1) == 0) {
            tex = color1;
          }else{
            tex = color2;
          }

          return tex;
        }`,
    glsl2d:`
        vec3 checkers2d( vec2 uv, float size, vec3 color1, vec3 color2 ) {
          float fmodResult = mod(floor(size * uv.x) + floor(size * uv.y), 2.0);
          float fin = max(sign(fmodResult), 0.0); 

          return vec3(fin);
        }
    `,
    parameters: [
      { name:'scale',  type:'float', default:5 },
      { name:'color1', type:'vec3', default:[1,1,1] },
      { name:'color2', type:'vec3', default:[0,0,0] }
    ],
  },
  noise: {
    name:'noise',
    glsl:glsl(["#define GLSLIFY 1\n          \n        //\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nfloat mod289(float x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat permute(float x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat taylorInvSqrt(float r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 grad4(float j, vec4 ip)\n  {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n\n  return p;\n  }\n\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\n\nfloat snoise(vec4 v)\n  {\n  const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                        0.276393202250021,  // 2 * G4\n                        0.414589803375032,  // 3 * G4\n                       -0.447213595499958); // -1 + 4 * G4\n\n// First corner\n  vec4 i  = floor(v + dot(v, vec4(F4)) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n//  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n  //  x1 = x0 - i1  + 1.0 * C.xxxx\n  //  x2 = x0 - i2  + 2.0 * C.xxxx\n  //  x3 = x0 - i3  + 3.0 * C.xxxx\n  //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n  vec4 x1 = x0 - i1 + C.xxxx;\n  vec4 x2 = x0 - i2 + C.yyyy;\n  vec4 x3 = x0 - i3 + C.zzzz;\n  vec4 x4 = x0 + C.wwww;\n\n// Permutations\n  i = mod289(i);\n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n  }\n\n        vec3 noise( vec3 pos, float scale, float strength, float time ) {\n          float n = snoise( vec4(pos*scale, time) );\n          return vec3( n ) * strength;\n        }",""]),
    glsl2d:glsl(["#define GLSLIFY 1\n    \n        //\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n        vec3 noise2d( vec2 st, float scale, float strength, float time ) {\n          float col = snoise( vec3( st, time ) * scale );\n\n          return vec3(col) * strength;\n        }\n",""]) ,
    parameters: [
      { name:'scale', type:'float', default:2 },
      { name:'strength', type:'float', default:.1 },
      { name:'time', type:'float', default:1 }
    ],
  },
  // adapted from https://thebookofshaders.com/10/
  truchet: {
    name:'truchet',
    glsl2d:`    
        float random_truchet(in vec2 _st) {
          return fract(sin(dot(_st.xy,
                         vec2(12.9898,78.233)))*
                        43758.5453123);
        }

        vec2 truchetPattern(in vec2 _st, in float _index){
            _index = fract(((_index-0.5)*2.0));
            if (_index > 0.75) {
                _st = vec2(1.0) - _st;
            } else if (_index > 0.5) {
                _st = vec2(1.0-_st.x,_st.y);
            } else if (_index > 0.25) {
                _st = 1.0-vec2(1.0-_st.x,_st.y);
            }
            return _st;
        }

        vec3 truchet2d( vec2 st, float scale, vec3 color ) {
            st = st * scale;
            vec2 ipos = floor(st);  // integer
            vec2 fpos = fract(st);  // fraction

            vec2 tile = truchetPattern(fpos, random_truchet( ipos ));

            float col = smoothstep(tile.x-0.3,tile.x,tile.y)-smoothstep(tile.x,tile.x+.3,tile.y);
            return color * col;
        }

` ,
    parameters: [
      { name:'scale', type:'float', default:10 },
      { name:'color', type:'vec3', default:[1,1,1] }
    ],
  },
  dots: {
    name:'dots',
    glsl:`          
        vec3 dots( vec3 pos, float count, float radius, vec3 color ) {
          vec3 tex;
          tex = vec3( color - smoothstep( radius, radius+.02, length(fract(pos*(round(count/2.)+.5)) -.5 )) );
          return tex;
        }` ,
    glsl2d:`
      vec2 tile(vec2 _st, float _zoom){
        _st *= _zoom;
        return fract(_st);
      }

      float circle(vec2 _st, float _radius){
        vec2 pos = vec2(0.5)-_st;
        _radius *= 0.75;
        return 1.-smoothstep(_radius-(_radius*0.05),_radius+(_radius*0.05),dot(pos,pos)*3.14);
      }
    
      vec3 dots2d( vec2 _st, float scale, float radius, vec3 color ) {
        vec2 st = tile(_st,scale);
        vec3 fin = vec3(circle(st, radius)) * color;
        return fin;
      }
    `,
    parameters: [
      { name:'scale', type:'float', default:5 },
      { name:'radius', type:'float', default:.3 },
      { name:'color', type:'vec3', default:[1,1,1] }
    ],
  },
  stripes: {
    name:'stripes',
    glsl:`          
        vec3 stripes( vec3 pos, float scale, vec3 color ) {
          vec3 tex;
          tex = vec3( color - smoothstep(0.3, 0.32, length(fract((pos.x+pos.y+pos.z)*scale) -.5 )) );
          return tex;
        }` ,
    parameters: [
      { name:'scale', type:'float', default:5 },
      { name:'color', type:'vec3', default:[1,1,1] }
    ],
  },
  cellular: {
    name:'cellular',
    glsl:glsl(["#define GLSLIFY 1\n\n        // Permutation polynomial: (34x^2 + x) mod 289\nvec3 permute(vec3 x) {\n  return mod((34.0 * x + 1.0) * x, 289.0);\n}\n\nvec3 dist(vec3 x, vec3 y, vec3 z,  bool manhattanDistance) {\n  return manhattanDistance ?  abs(x) + abs(y) + abs(z) :  (x * x + y * y + z * z);\n}\n\nvec2 worley(vec3 P, float jitter, bool manhattanDistance) {\nfloat K = 0.142857142857; // 1/7\nfloat Ko = 0.428571428571; // 1/2-K/2\nfloat  K2 = 0.020408163265306; // 1/(7*7)\nfloat Kz = 0.166666666667; // 1/6\nfloat Kzo = 0.416666666667; // 1/2-1/6*2\n\n\tvec3 Pi = mod(floor(P), 289.0);\n \tvec3 Pf = fract(P) - 0.5;\n\n\tvec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0);\n\tvec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0);\n\tvec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0);\n\n\tvec3 p = permute(Pi.x + vec3(-1.0, 0.0, 1.0));\n\tvec3 p1 = permute(p + Pi.y - 1.0);\n\tvec3 p2 = permute(p + Pi.y);\n\tvec3 p3 = permute(p + Pi.y + 1.0);\n\n\tvec3 p11 = permute(p1 + Pi.z - 1.0);\n\tvec3 p12 = permute(p1 + Pi.z);\n\tvec3 p13 = permute(p1 + Pi.z + 1.0);\n\n\tvec3 p21 = permute(p2 + Pi.z - 1.0);\n\tvec3 p22 = permute(p2 + Pi.z);\n\tvec3 p23 = permute(p2 + Pi.z + 1.0);\n\n\tvec3 p31 = permute(p3 + Pi.z - 1.0);\n\tvec3 p32 = permute(p3 + Pi.z);\n\tvec3 p33 = permute(p3 + Pi.z + 1.0);\n\n\tvec3 ox11 = fract(p11*K) - Ko;\n\tvec3 oy11 = mod(floor(p11*K), 7.0)*K - Ko;\n\tvec3 oz11 = floor(p11*K2)*Kz - Kzo; // p11 < 289 guaranteed\n\n\tvec3 ox12 = fract(p12*K) - Ko;\n\tvec3 oy12 = mod(floor(p12*K), 7.0)*K - Ko;\n\tvec3 oz12 = floor(p12*K2)*Kz - Kzo;\n\n\tvec3 ox13 = fract(p13*K) - Ko;\n\tvec3 oy13 = mod(floor(p13*K), 7.0)*K - Ko;\n\tvec3 oz13 = floor(p13*K2)*Kz - Kzo;\n\n\tvec3 ox21 = fract(p21*K) - Ko;\n\tvec3 oy21 = mod(floor(p21*K), 7.0)*K - Ko;\n\tvec3 oz21 = floor(p21*K2)*Kz - Kzo;\n\n\tvec3 ox22 = fract(p22*K) - Ko;\n\tvec3 oy22 = mod(floor(p22*K), 7.0)*K - Ko;\n\tvec3 oz22 = floor(p22*K2)*Kz - Kzo;\n\n\tvec3 ox23 = fract(p23*K) - Ko;\n\tvec3 oy23 = mod(floor(p23*K), 7.0)*K - Ko;\n\tvec3 oz23 = floor(p23*K2)*Kz - Kzo;\n\n\tvec3 ox31 = fract(p31*K) - Ko;\n\tvec3 oy31 = mod(floor(p31*K), 7.0)*K - Ko;\n\tvec3 oz31 = floor(p31*K2)*Kz - Kzo;\n\n\tvec3 ox32 = fract(p32*K) - Ko;\n\tvec3 oy32 = mod(floor(p32*K), 7.0)*K - Ko;\n\tvec3 oz32 = floor(p32*K2)*Kz - Kzo;\n\n\tvec3 ox33 = fract(p33*K) - Ko;\n\tvec3 oy33 = mod(floor(p33*K), 7.0)*K - Ko;\n\tvec3 oz33 = floor(p33*K2)*Kz - Kzo;\n\n\tvec3 dx11 = Pfx + jitter*ox11;\n\tvec3 dy11 = Pfy.x + jitter*oy11;\n\tvec3 dz11 = Pfz.x + jitter*oz11;\n\n\tvec3 dx12 = Pfx + jitter*ox12;\n\tvec3 dy12 = Pfy.x + jitter*oy12;\n\tvec3 dz12 = Pfz.y + jitter*oz12;\n\n\tvec3 dx13 = Pfx + jitter*ox13;\n\tvec3 dy13 = Pfy.x + jitter*oy13;\n\tvec3 dz13 = Pfz.z + jitter*oz13;\n\n\tvec3 dx21 = Pfx + jitter*ox21;\n\tvec3 dy21 = Pfy.y + jitter*oy21;\n\tvec3 dz21 = Pfz.x + jitter*oz21;\n\n\tvec3 dx22 = Pfx + jitter*ox22;\n\tvec3 dy22 = Pfy.y + jitter*oy22;\n\tvec3 dz22 = Pfz.y + jitter*oz22;\n\n\tvec3 dx23 = Pfx + jitter*ox23;\n\tvec3 dy23 = Pfy.y + jitter*oy23;\n\tvec3 dz23 = Pfz.z + jitter*oz23;\n\n\tvec3 dx31 = Pfx + jitter*ox31;\n\tvec3 dy31 = Pfy.z + jitter*oy31;\n\tvec3 dz31 = Pfz.x + jitter*oz31;\n\n\tvec3 dx32 = Pfx + jitter*ox32;\n\tvec3 dy32 = Pfy.z + jitter*oy32;\n\tvec3 dz32 = Pfz.y + jitter*oz32;\n\n\tvec3 dx33 = Pfx + jitter*ox33;\n\tvec3 dy33 = Pfy.z + jitter*oy33;\n\tvec3 dz33 = Pfz.z + jitter*oz33;\n\n\tvec3 d11 = dist(dx11, dy11, dz11, manhattanDistance);\n\tvec3 d12 =dist(dx12, dy12, dz12, manhattanDistance);\n\tvec3 d13 = dist(dx13, dy13, dz13, manhattanDistance);\n\tvec3 d21 = dist(dx21, dy21, dz21, manhattanDistance);\n\tvec3 d22 = dist(dx22, dy22, dz22, manhattanDistance);\n\tvec3 d23 = dist(dx23, dy23, dz23, manhattanDistance);\n\tvec3 d31 = dist(dx31, dy31, dz31, manhattanDistance);\n\tvec3 d32 = dist(dx32, dy32, dz32, manhattanDistance);\n\tvec3 d33 = dist(dx33, dy33, dz33, manhattanDistance);\n\n\tvec3 d1a = min(d11, d12);\n\td12 = max(d11, d12);\n\td11 = min(d1a, d13); // Smallest now not in d12 or d13\n\td13 = max(d1a, d13);\n\td12 = min(d12, d13); // 2nd smallest now not in d13\n\tvec3 d2a = min(d21, d22);\n\td22 = max(d21, d22);\n\td21 = min(d2a, d23); // Smallest now not in d22 or d23\n\td23 = max(d2a, d23);\n\td22 = min(d22, d23); // 2nd smallest now not in d23\n\tvec3 d3a = min(d31, d32);\n\td32 = max(d31, d32);\n\td31 = min(d3a, d33); // Smallest now not in d32 or d33\n\td33 = max(d3a, d33);\n\td32 = min(d32, d33); // 2nd smallest now not in d33\n\tvec3 da = min(d11, d21);\n\td21 = max(d11, d21);\n\td11 = min(da, d31); // Smallest now in d11\n\td31 = max(da, d31); // 2nd smallest now not in d31\n\td11.xy = (d11.x < d11.y) ? d11.xy : d11.yx;\n\td11.xz = (d11.x < d11.z) ? d11.xz : d11.zx; // d11.x now smallest\n\td12 = min(d12, d21); // 2nd smallest now not in d21\n\td12 = min(d12, d22); // nor in d22\n\td12 = min(d12, d31); // nor in d31\n\td12 = min(d12, d32); // nor in d32\n\td11.yz = min(d11.yz,d12.xy); // nor in d12.yz\n\td11.y = min(d11.y,d12.z); // Only two more to go\n\td11.y = min(d11.y,d11.z); // Done! (Phew!)\n\treturn sqrt(d11.xy); // F1, F2\n\n}\n\n        vec3 cellular( vec3 pos, float scale, float jitter, float mode, float strength, float time ) {\n          vec2 w = worley( pos * scale + time, jitter, false );\n          vec3 o;\n          if( mode == 0. ) {\n            o = vec3( w.x );\n          } else if ( mode == 1. ) {\n            o = vec3( w.y );\n          } else{\n            o = vec3( w.y - w.x );\n          }\n\n          return o * strength;\n        }\n    ",""]),
    glsl2d:glsl(["#define GLSLIFY 1\n\n        // Permutation polynomial: (34x^2 + x) mod 289\nvec3 permute(vec3 x) {\n  return mod((34.0 * x + 1.0) * x, 289.0);\n}\n\nvec3 dist(vec3 x, vec3 y, vec3 z,  bool manhattanDistance) {\n  return manhattanDistance ?  abs(x) + abs(y) + abs(z) :  (x * x + y * y + z * z);\n}\n\nvec2 worley(vec3 P, float jitter, bool manhattanDistance) {\nfloat K = 0.142857142857; // 1/7\nfloat Ko = 0.428571428571; // 1/2-K/2\nfloat  K2 = 0.020408163265306; // 1/(7*7)\nfloat Kz = 0.166666666667; // 1/6\nfloat Kzo = 0.416666666667; // 1/2-1/6*2\n\n\tvec3 Pi = mod(floor(P), 289.0);\n \tvec3 Pf = fract(P) - 0.5;\n\n\tvec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0);\n\tvec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0);\n\tvec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0);\n\n\tvec3 p = permute(Pi.x + vec3(-1.0, 0.0, 1.0));\n\tvec3 p1 = permute(p + Pi.y - 1.0);\n\tvec3 p2 = permute(p + Pi.y);\n\tvec3 p3 = permute(p + Pi.y + 1.0);\n\n\tvec3 p11 = permute(p1 + Pi.z - 1.0);\n\tvec3 p12 = permute(p1 + Pi.z);\n\tvec3 p13 = permute(p1 + Pi.z + 1.0);\n\n\tvec3 p21 = permute(p2 + Pi.z - 1.0);\n\tvec3 p22 = permute(p2 + Pi.z);\n\tvec3 p23 = permute(p2 + Pi.z + 1.0);\n\n\tvec3 p31 = permute(p3 + Pi.z - 1.0);\n\tvec3 p32 = permute(p3 + Pi.z);\n\tvec3 p33 = permute(p3 + Pi.z + 1.0);\n\n\tvec3 ox11 = fract(p11*K) - Ko;\n\tvec3 oy11 = mod(floor(p11*K), 7.0)*K - Ko;\n\tvec3 oz11 = floor(p11*K2)*Kz - Kzo; // p11 < 289 guaranteed\n\n\tvec3 ox12 = fract(p12*K) - Ko;\n\tvec3 oy12 = mod(floor(p12*K), 7.0)*K - Ko;\n\tvec3 oz12 = floor(p12*K2)*Kz - Kzo;\n\n\tvec3 ox13 = fract(p13*K) - Ko;\n\tvec3 oy13 = mod(floor(p13*K), 7.0)*K - Ko;\n\tvec3 oz13 = floor(p13*K2)*Kz - Kzo;\n\n\tvec3 ox21 = fract(p21*K) - Ko;\n\tvec3 oy21 = mod(floor(p21*K), 7.0)*K - Ko;\n\tvec3 oz21 = floor(p21*K2)*Kz - Kzo;\n\n\tvec3 ox22 = fract(p22*K) - Ko;\n\tvec3 oy22 = mod(floor(p22*K), 7.0)*K - Ko;\n\tvec3 oz22 = floor(p22*K2)*Kz - Kzo;\n\n\tvec3 ox23 = fract(p23*K) - Ko;\n\tvec3 oy23 = mod(floor(p23*K), 7.0)*K - Ko;\n\tvec3 oz23 = floor(p23*K2)*Kz - Kzo;\n\n\tvec3 ox31 = fract(p31*K) - Ko;\n\tvec3 oy31 = mod(floor(p31*K), 7.0)*K - Ko;\n\tvec3 oz31 = floor(p31*K2)*Kz - Kzo;\n\n\tvec3 ox32 = fract(p32*K) - Ko;\n\tvec3 oy32 = mod(floor(p32*K), 7.0)*K - Ko;\n\tvec3 oz32 = floor(p32*K2)*Kz - Kzo;\n\n\tvec3 ox33 = fract(p33*K) - Ko;\n\tvec3 oy33 = mod(floor(p33*K), 7.0)*K - Ko;\n\tvec3 oz33 = floor(p33*K2)*Kz - Kzo;\n\n\tvec3 dx11 = Pfx + jitter*ox11;\n\tvec3 dy11 = Pfy.x + jitter*oy11;\n\tvec3 dz11 = Pfz.x + jitter*oz11;\n\n\tvec3 dx12 = Pfx + jitter*ox12;\n\tvec3 dy12 = Pfy.x + jitter*oy12;\n\tvec3 dz12 = Pfz.y + jitter*oz12;\n\n\tvec3 dx13 = Pfx + jitter*ox13;\n\tvec3 dy13 = Pfy.x + jitter*oy13;\n\tvec3 dz13 = Pfz.z + jitter*oz13;\n\n\tvec3 dx21 = Pfx + jitter*ox21;\n\tvec3 dy21 = Pfy.y + jitter*oy21;\n\tvec3 dz21 = Pfz.x + jitter*oz21;\n\n\tvec3 dx22 = Pfx + jitter*ox22;\n\tvec3 dy22 = Pfy.y + jitter*oy22;\n\tvec3 dz22 = Pfz.y + jitter*oz22;\n\n\tvec3 dx23 = Pfx + jitter*ox23;\n\tvec3 dy23 = Pfy.y + jitter*oy23;\n\tvec3 dz23 = Pfz.z + jitter*oz23;\n\n\tvec3 dx31 = Pfx + jitter*ox31;\n\tvec3 dy31 = Pfy.z + jitter*oy31;\n\tvec3 dz31 = Pfz.x + jitter*oz31;\n\n\tvec3 dx32 = Pfx + jitter*ox32;\n\tvec3 dy32 = Pfy.z + jitter*oy32;\n\tvec3 dz32 = Pfz.y + jitter*oz32;\n\n\tvec3 dx33 = Pfx + jitter*ox33;\n\tvec3 dy33 = Pfy.z + jitter*oy33;\n\tvec3 dz33 = Pfz.z + jitter*oz33;\n\n\tvec3 d11 = dist(dx11, dy11, dz11, manhattanDistance);\n\tvec3 d12 =dist(dx12, dy12, dz12, manhattanDistance);\n\tvec3 d13 = dist(dx13, dy13, dz13, manhattanDistance);\n\tvec3 d21 = dist(dx21, dy21, dz21, manhattanDistance);\n\tvec3 d22 = dist(dx22, dy22, dz22, manhattanDistance);\n\tvec3 d23 = dist(dx23, dy23, dz23, manhattanDistance);\n\tvec3 d31 = dist(dx31, dy31, dz31, manhattanDistance);\n\tvec3 d32 = dist(dx32, dy32, dz32, manhattanDistance);\n\tvec3 d33 = dist(dx33, dy33, dz33, manhattanDistance);\n\n\tvec3 d1a = min(d11, d12);\n\td12 = max(d11, d12);\n\td11 = min(d1a, d13); // Smallest now not in d12 or d13\n\td13 = max(d1a, d13);\n\td12 = min(d12, d13); // 2nd smallest now not in d13\n\tvec3 d2a = min(d21, d22);\n\td22 = max(d21, d22);\n\td21 = min(d2a, d23); // Smallest now not in d22 or d23\n\td23 = max(d2a, d23);\n\td22 = min(d22, d23); // 2nd smallest now not in d23\n\tvec3 d3a = min(d31, d32);\n\td32 = max(d31, d32);\n\td31 = min(d3a, d33); // Smallest now not in d32 or d33\n\td33 = max(d3a, d33);\n\td32 = min(d32, d33); // 2nd smallest now not in d33\n\tvec3 da = min(d11, d21);\n\td21 = max(d11, d21);\n\td11 = min(da, d31); // Smallest now in d11\n\td31 = max(da, d31); // 2nd smallest now not in d31\n\td11.xy = (d11.x < d11.y) ? d11.xy : d11.yx;\n\td11.xz = (d11.x < d11.z) ? d11.xz : d11.zx; // d11.x now smallest\n\td12 = min(d12, d21); // 2nd smallest now not in d21\n\td12 = min(d12, d22); // nor in d22\n\td12 = min(d12, d31); // nor in d31\n\td12 = min(d12, d32); // nor in d32\n\td11.yz = min(d11.yz,d12.xy); // nor in d12.yz\n\td11.y = min(d11.y,d12.z); // Only two more to go\n\td11.y = min(d11.y,d11.z); // Done! (Phew!)\n\treturn sqrt(d11.xy); // F1, F2\n\n}\n\n        vec3 cellular( vec3 pos, float scale, float jitter, float mode, float strength ) {\n          vec2 w = worley( pos, jitter, false );\n          vec3 o;\n          if( mode == 0. ) {\n            o = vec3( w.x );\n          } else if ( mode == 1. ) {\n            o = vec3( w.y );\n          } else{\n            o = vec3( w.y - w.x );\n          }\n\n          return o * strength;\n        }\n\n        vec3 cellular2d( vec2 st, float scale, float jitter, float mode, float strength, float time ) {\n          return cellular( vec3(st * scale, time), nor, scale, jitter, mode, strength );\n        }\n    ",""]),
    parameters: [
      { name:'scale', type:'float', default:1 },
      { name:'jitter', type:'float', default:1 },
      { name:'type',  type:'float', default: 0 },
      { name:'strength', type:'float', default:2 },
      { name:'time', type:'float', default:1 }
    ],     
  },

  voronoi: {
    name:'voronoi',
    parameters: [
      { name:'scale', type:'float', default:1 },
      { name:'res', type:'float', default:100 },
      { name:'time', type:'float', default:1 },
      { name:'mode', type:'float', default:0 }
    ],
    glsl:`
    vec3 voronoi_hash(vec3 p) {
      return fract(
          sin(vec3(dot(p, vec3(1.0, 57.0, 113.0)), dot(p, vec3(57.0, 113.0, 1.0)),
                   dot(p, vec3(113.0, 1.0, 57.0)))) *
          43758.5453);
    }

    vec3 voronoi_3d(const in vec3 x, float _res ) {
      vec3 p = floor(x);
      vec3 f = fract(x);

      float id = 0.0;
      vec2 res = vec2( _res );
      for (int k = -1; k <= 1; k++) {
        for (int j = -1; j <= 1; j++) {
          for (int i = -1; i <= 1; i++) {
            vec3 b = vec3(float(i), float(j), float(k));
            vec3 r = vec3(b) - f + voronoi_hash(p + b);
            float d = dot(r, r);

            float cond = max(sign(res.x - d), 0.0);
            float nCond = 1.0 - cond;

            float cond2 = nCond * max(sign(res.y - d), 0.0);
            float nCond2 = 1.0 - cond2;

            id = (dot(p + b, vec3(1.0, 57.0, 113.0)) * cond) + (id * nCond);
            res = vec2(d, res.x) * cond + res * nCond;

            res.y = cond2 * d + nCond2 * res.y;
          }
        }
      }

      return vec3(sqrt(res), abs(id));
    }

    vec3 voronoi( vec3 pos, float scale, float res, float time, float mode ) {
      vec3 v = voronoi_3d( pos * scale, res );
      vec3 fin;
      if( mode == 0. ) fin = vec3(v.x);
      if( mode == 1. ) fin = vec3(v.y);
      if( mode == 2. ) fin = vec3(v.y - v.x); 

      return fin;
    }
`,
    glsl2d:glsl(["#define GLSLIFY 1\n    \n    vec3 voronoi_hash(vec3 p) {\n      return fract(\n          sin(vec3(dot(p, vec3(1.0, 57.0, 113.0)), dot(p, vec3(57.0, 113.0, 1.0)),\n                   dot(p, vec3(113.0, 1.0, 57.0)))) * 43758.5453);\n    }\n\n    vec3 voronoi_3d(const in vec3 x, float _res ) {\n      vec3 p = floor(x);\n      vec3 f = fract(x);\n\n      float id = 0.0;\n      vec2 res = vec2( _res );\n      for (int k = -1; k <= 1; k++) {\n        for (int j = -1; j <= 1; j++) {\n          for (int i = -1; i <= 1; i++) {\n            vec3 b = vec3(float(i), float(j), float(k));\n            vec3 r = vec3(b) - f + voronoi_hash(p + b);\n            float d = dot(r, r);\n\n            float cond = max(sign(res.x - d), 0.0);\n            float nCond = 1.0 - cond;\n\n            float cond2 = nCond * max(sign(res.y - d), 0.0);\n            float nCond2 = 1.0 - cond2;\n\n            id = (dot(p + b, vec3(1.0, 57.0, 113.0)) * cond) + (id * nCond);\n            res = vec2(d, res.x) * cond + res * nCond;\n\n            res.y = cond2 * d + nCond2 * res.y;\n          }\n        }\n      }\n\n      return vec3(sqrt(res), abs(id));\n    }\n\n    vec3 voronoi2d( vec2 st, float scale, float res, float time, float mode ) {\n      vec3 v = voronoi_3d( vec3(st* scale, time), res );\n      vec3 fin;\n      if( mode == 0. ) fin = vec3(v.x);\n      if( mode == 1. ) fin = vec3(v.y);\n      if( mode == 2. ) fin = vec3(v.y - v.x); \n\n      return fin;\n    }\n\n",""]) ,
  },
  // adapted from https://thebookofshaders.com/edit.php#09/zigzag.frag
  zigzag: {
    name:'zigzag',
    glsl2d:`    
       vec2 mirrorTile(vec2 _st, float _zoom){
         _st *= _zoom;
         if (fract(_st.y * 0.5) > 0.5){
           _st.x = _st.x+0.5;
           _st.y = 1.0-_st.y;
         }
         return fract(_st);
       }

       float fillY(vec2 _st, float _pct,float _antia){
         return smoothstep( _pct-_antia, _pct, _st.y);
       }

       vec3 zigzag2d( vec2 st, float scale, float time ) {
         st = mirrorTile(st*vec2(1.,2.),scale);
         float x = st.x*2.;
         float a = floor(1.+sin(x*3.14));
         float b = floor(1.+sin((x+1.)*3.14));
         float f = fract(x);

         vec3 color = vec3( fillY(st,mix(a,b,f),0.01) ); 

         return vec3(color);
       }
` ,
    parameters: [
      { name:'scale', type:'float', default:5 },
      { name:'time', type:'float', default:1 }
    ],
  }
}

module.exports = textures

},{"glslify":120}],25:[function(require,module,exports){
module.exports = `
    // p = point on surface, p0 = object center
    vec2 getUVCubic(vec3 p ){
      vec3 absp = abs(p);
        
      // First conditional: If the point is in one of the sextants to the 
      // left or right of the x-axis, the uv cordinate will be (0.5*p.zy)/(p.x).
      // If you trace a line out to a zy plane that is 0.5 units from the zero origin,  
      // (0.5*p.xyz)/(p.x) will be the result, and
      // the yz components will be our uv coordinates, hence (0.5*p.zy)/(p.x).

      vec2 uv = ((absp.x>=absp.y)&&(absp.x>=absp.z)) 
        ? (0.5*p.zy)/(p.x) 
        : ((absp.y>=absp.z)&&(absp.y>=absp.x)) ? (0.5*p.xz)/(p.y) : (-0.5*p.xy)/(p.z);

      //We still need to determine which side our uv cordinates are on so
      //that the texture orients the right way. Note that there's some 
      // redundancy there, which I'll fix at some stage. For now, it works, so I'm not touching it. :)
      if( ((p.x<0.)&&(absp.x>=absp.y)&&(absp.x>=absp.z)) 
       || ((p.y<0.)&&(absp.y>=absp.z)&&(absp.y>=absp.x)) 
       || ((p.z>0.)&&(absp.z>=absp.x)&&(absp.z>=absp.y)) ) uv.y*=-1.;
             
      // Mapping the uv range from [-0.5, 0.5] to [0.0, 1.0].
      return (uv+0.5);
    }
    vec4 triplanar(vec3 n, vec4 texx, vec4 texy, vec4 texz, bool adjust3d, bool rescale) {
      //if (doflipz) n.z = -n.z;
      if (rescale) {
        texx = 2.0*texx - 1.0;
        texy = 2.0*texy - 1.0;
        texz = 2.0*texz - 1.0;
      }
      if (adjust3d) {
        texx.x *= sign(n.x);
        texy.y *= sign(n.y);
        texz.z *= sign(n.z);
      }
      //if (justtexy) return texy;
      vec3 weights = abs(n);
      //if (doweightcorrection) weights /= dot(weights,vec3(1)); // Keep spherical!
        return mat4(texx,texy,texz,vec4(0))*vec4(weights,0);
    } 
    `
/*
module.exports = `vec3 t3(sampler2D tex, vec3 p, vec3 n)
{
  mat3 R = mat3(vec3(cos(T),sin(T),0),vec3(-sin(T),cos(T),0),vec3(0,0,-1));
  p *= R/8.0;
  n *= R;
  #ifdef Smooth
  return  (texture(tex,p.xy).rgb*n.z*n.z
    +texture(tex,p.zy).rgb*n.x*n.x
    +texture(tex,p.xz).rgb*n.y*n.y);
  #else
    return (texture(tex,p.xy).rgb
      +texture(tex,p.zy).rgb
      +texture(tex,p.xz).rgb)/3.0;
    #endif
    }`
    */

},{}],26:[function(require,module,exports){
const { param_wrap, MaterialID } = require( './utils.js' )
const { Var, float_var_gen, vec2_var_gen, vec3_var_gen, vec4_var_gen, int_var_gen, VarAlloc }  = require( './var.js' )
const Matrix = require( './external/matrix.js' )
window.Matrix = Matrix
const MatrixWrap = function ( shouldInvert = false ) {
  const m = Object.create( MatrixWrap.prototype )
  m.dirty = true
  m.translation = {}
  m.scale = {}
  m.shouldInvert = shouldInvert
  m.rotation = {
    axis: {}
  }
  m.parent = null

  let tx = 0, ty = 0, tz = 0
  Object.defineProperties( m.translation, {
    x: {
      get() { return tx },
      set(v){
        tx = v
        //m.__data = m.__data.multiply( Matrix.translate( tx, ty, tz ) )
        m.dirty = true
      }
    },
    y: {
      get() { return ty },
      set(v){
        ty = v
        //m.__data = m.__data.multiply( Matrix.translate( tx, ty, tz ) )
        m.dirty = true
      }
    },
    z: {
      get() { return tz },
      set(v){
        tz = v
        //m.__data = m.__data.multiply( Matrix.translate( tx, ty, tz ) )
        m.dirty = true
      }
    },
  })

  // scaling must be sent as separate uniform to avoid sdf over estimation 
  let scale = 1
  Object.defineProperty( m,'scale', {
    get() { return scale },
    set(v){
      scale = v
      //m.__data = m.__data.multiply( Matrix.rotate( angle, rx, ry, rz ) )
      m.dirty = true
    } 
  })

  /* FOR NON-UNIFORM SCALING:
   *
   * 1. comment out scale property above
   * 2. uncomment scale property below
   * 3. change emit_decl to use a vec3 for scale
   * 4. change upload_data to upload a 3f
   * 5. In "primitives.js", replace line 155 (part of emit) to use compensated scaling
   */ 

  //let sx = 1, sy = 1, sz = 1
  //Object.defineProperties( m.scale, {
  //  x: {
  //    get() { return sx },
  //    set(v){
  //      sx = v
  //      //m.__data = m.__data.multiply( Matrix.scale( sx, sy, sz ) )
  //      m.dirty = true
  //    }
  //  },
  //  y: {
  //    get() { return sy },
  //    set(v){
  //      sy = v
  //      //m.__data = m.__data.multiply( Matrix.scale( sx, sy, sz ) )
  //      m.dirty = true
  //    }
  //  },
  //  z: {
  //    get() { return sz },
  //    set(v){
  //      sz = v
  //      //m.__data = m.__data.multiply( Matrix.scale( sx, sy, sz ) )
  //      m.dirty = true
  //    }
  //  },
  //})

  let angle = 0
  Object.defineProperty( m.rotation, 'angle', {
    get() { return angle },
    set(v){
      angle = v
      //m.__data = m.__data.multiply( Matrix.rotate( angle, rx, ry, rz ) )
      m.dirty = true
    } 
  })

  let rx = 0, ry = 0, rz = 0
  Object.defineProperties( m.rotation.axis, {
    x: {
      get() { return rx },
      set(v){
        rx = v
        //m.__data = m.__data = Matrix.rotate( angle, rx, ry, rz, m.__data )
        m.dirty = true
      }
    },
    y: {
      get() { return ry },
      set(v){
        ry = v
        //m.__data = m.__data = Matrix.rotate( angle, rx, ry, rz, m.__data )
        m.dirty = true
      }
    },
    z: {
      get() { return rz },
      set(v){
        rz = v
        //m.__data = m.__data = Matrix.rotate( angle, rx, ry, rz, m.__data )
        m.dirty = true
      }
    },
  })

  m.__rotations = []
  m.__id   = VarAlloc.alloc()  
  m.__dirty = function() {}
  m.__data = Matrix.identity()
  m.__Matrix = Matrix
  m.varName = 'transform' + m.__id

  return m
}

MatrixWrap.prototype = {
  type: 'matrix',

  emit() { return this.varName },

  emit_scale() { return this.varName + '_scale' },

  emit_decl() { 
    const decl =  `    uniform mat4 ${this.varName};
    uniform float ${this.varName}_scale;
    ` 

    return decl
  },

	update_location(gl, program) {
		this.loc = gl.getUniformLocation( program, this.varName )
		this.loc_scale = gl.getUniformLocation( program, this.varName+'_scale' )
	},	

	upload_data(gl) {
		if( !this.dirty ) return
		
    this.internal()

    if( this.shouldInvert === true ) {
      const inverse = Matrix.inverse( this.__data )
      gl.uniformMatrix4fv( this.loc, false, inverse.m )
    }else{
      gl.uniformMatrix4fv( this.loc, false, this.__data.m )
    }
    //gl.uniform3f(this.loc_scale, this.scale.x, this.scale.y, this.scale.z )
    
    // scaling must be sent as separate uniform to avoid sdf over-estimation 
    gl.uniform1f(this.loc_scale, this.scale )

		this.dirty = false
  },


  internal() {
    this.__data = Matrix.identity()
    if( this.parent != null ) this.__data = this.parent.__data

    this.__data = this.__data.multiply( Matrix.translate( this.translation.x, this.translation.y, this.translation.z ) ) 

    // handle cumulative rotations via .rotateBy() method
    this.__rotations.forEach( r => this.__data = this.__data.multiply( r ) )

    // handle absolute rotations via .rotate() method... should this be aliased to rotateTo() ?
    this.__data = this.__data.multiply( Matrix.rotate( this.rotation.angle, this.rotation.axis.x, this.rotation.axis.y, this.rotation.axis.z ) )

    this.__data = this.__data.multiply( Matrix.scale( this.scale, this.scale, this.scale ) )
  },

  invert( shouldInvert = true) {
    this.shouldInvert = shouldInvert
    this.dirty = true
  },

  apply( transform = null, shouldInvert = false ) {
    this.parent = transform
    this.dirty = true
  } 

}

module.exports = MatrixWrap

},{"./external/matrix.js":9,"./utils.js":27,"./var.js":28}],27:[function(require,module,exports){
const Var = require('./var.js').Var
const { Vec2, Vec3, Vec4 } = require( './vec.js' )

// Wrapper
function param_wrap( v, __default, name=null ) {
	if( v === undefined || v === null ) return __default()
	if( v.__isVar === true ) return v
	
	return Var( v, name )
}

const MaterialID = {
	current: 0,
	alloc() {
		return MaterialID.current++
  },
  clear() {
    MaterialID.current = 0
  }
}

const processVec2 = function( val ) {
  if( typeof val === 'number' ) 
    val = Vec2( color )
  else if( Array.isArray( val ) ) 
    val = Vec2( val[0], val[1] )

  return val
}

const processVec3 = function( val ) {
  if( typeof val === 'number' ) 
    val = Vec3( val )
  else if( Array.isArray( val ) ) 
    val = Vec3( val[0], val[1], val[2] )

  return val
}

module.exports = { param_wrap, MaterialID, processVec2, processVec3 }

},{"./var.js":28,"./vec.js":29}],28:[function(require,module,exports){
const { Vec2, Vec3, Vec4 } = require( './vec.js' )
const float = require( './float.js' )
const int   = require( './int.js' )

// Var
const VarAlloc = {
	current: 0,
  clear() {
    VarAlloc.current = 0
  },
	alloc() {
		return VarAlloc.current++
	}
}

const Var = function( value, fixedName = null, __type ) {
  const v = Object.create( Var.prototype )
	v.varName = fixedName !== null ? fixedName : 'var' + VarAlloc.alloc()
  v.value = value
  v.type = v.value.type
  if( v.type === undefined ) v.type = __type || 'float' 

  value.var = v

  if( v.type !== 'float' && v.type !== 'int' ) {
    Object.defineProperties( v, {
      x: {
        get() { return this.value.x },
        set(v){ this.value.x = v; this.dirty = true }
      },
      y: {
        get() { return this.value.y },
        set(v){ this.value.y = v; this.dirty = true }
      },
      z: {
        get() { return this.value.z },
        set(v){ this.value.z = v; this.dirty = true }
      },
      w: {
        get() { return this.value.w },
        set(v){ this.value.w = v; this.dirty = true }
      },
      r: {
        get() { return this.value.x },
        set(v){ this.value.x = v; this.dirty = true }
      },
      g: {
        get() { return this.value.y },
        set(v){ this.value.y = v; this.dirty = true }
      },
      b: {
        get() { return this.value.z },
        set(v){ this.value.z = v; this.dirty = true }
      },
    })
  }

  return v
}

Var.hardcode = false
const emit_float = function( a ) {
	if (a % 1 === 0)
		return a.toFixed( 1 )
	else
		return a
}

Var.prototype = {
	dirty: true,

	loc: -1,

  emit() { 
    let out
    if( this.value.isGen ) {
      const vecOut = this.value.emit() 
      out = vecOut.preface + vecOut.out
        
    }else{
      out = this.varName 
    } 

    return out
  },

  emit_decl() { 
    let out = ''
    if( this.value.isGen ) {
      out = this.value.emit_decl()
    }else{
      if( Var.hardcode === true ) {

        if( typeof this.value.emit !== 'function' ) {
          if( this.type === 'float' ) {
            out = `${this.type} ${this.varName} = ${emit_float(this.value)};\n`
          }else{
            out = `${this.type} ${this.varName} = ${this.value};\n`
          }
        }else{
          let val = this.value.emit()
          if( typeof val !== 'string' ) val = val.out
          out = val !== undefined ? `${this.type} ${this.varName} = ${val};\n` : ''
        }
      }else{
        out = `uniform ${this.type} ${this.varName};\n`
      }
    }
    return out
  },

	set(v) { this.value = v; this.dirty = true; },

	update_location(gl, program) {
    if( this.value.isGen ) {
      this.value.update_location( gl, program )
      return
    }
		this.loc = gl.getUniformLocation(program, this.varName)
	},	

	upload_data(gl) {
		if( !this.dirty ) return
		
    if( this.value.isGen ) {
      this.value.upload_data( gl  )
      this.dirty = false
      return
    }
		let v = this.value
		if (typeof v === 'number' ) {
			gl.uniform1f( this.loc, v )
		}else if ( v instanceof Vec2 ) {
			gl.uniform2f(this.loc, v.x, v.y )
		} else if( v instanceof Vec3 ) {
			gl.uniform3f(this.loc, v.x, v.y, v.z )
		} else if( v instanceof Vec4 ) {
			gl.uniform4f(this.loc, v.x, v.y, v.z, v.w )
    } else {
      // for color variables
      if( this.type === 'float' ) {
        gl.uniform1f( this.loc, v.x )
      }else{
        gl.uniform1i( this.loc, v.x )
      }
    }

		this.dirty = false
	}
}


function int_var_gen(x,name=null) { 
  let output = ()=> {
    let out = Var( int(x), name, 'int' ) 
    return out
  }

  return output
}
function float_var_gen(x,name=null) { return ()=> { return Var( float(x), name, 'float' ) } }

function vec2_var_gen(x, y,name=null) { 
  return ()=> Var( Vec2(x, y), name  ) 
}

function vec3_var_gen(x=0, y, z,name=null) { 
  return ()=> Var( Vec3(x, y, z), name ) 
}

function vec4_var_gen( x, y, z, w, name=null ) { 
  return Var( Vec4( x, y, z, w ), name ) 
}
//function float_var_gen(x,name=null) { return ()=> { return Var( float(x), name, 'float' ) } }

//function vec2_var_gen(x, y,name=null) { return ()=> Var( Vec2(x, y), name  ) }

//function vec3_var_gen(x, y, z,name=null) { return ()=> Var( Vec3(x, y, z), name ) }

//function vec4_var_gen( x, y, z, w, name=null ) { return Var( Vec4( x, y, z, w ), name ) }

module.exports = { Var, float_var_gen, vec2_var_gen, vec3_var_gen, vec4_var_gen, int_var_gen, VarAlloc }

/*function float_var_gen(x,name=null) { return ()=> { return Var( float(x), name, 'float' ) } }

function vec2_var_gen(x, y,name=null) { 
  if( y === undefined ) y = x
  return ()=> Var( Vec2(x, y), name  ) 
}

function vec3_var_gen(x, y, z,name=null) { 
  if( y === undefined ) y = x
  if( z === undefined ) z = x
  return ()=> Var( Vec3(x, y, z), name ) 
}

function vec4_var_gen( x, y, z, w, name=null ) { 
  if( y === undefined ) y = x
  if( z === undefined ) z = x
  if( w === undefined ) w = x
  return Var( Vec4( x, y, z, w ), name ) 
}
*/

},{"./float.js":10,"./int.js":13,"./vec.js":29}],29:[function(require,module,exports){
const Vec2 = function (x=0, y=0) {
  if( x.type === 'vec2' ) return x  
  const v = Object.create( Vec2.prototype )
  if( Array.isArray( x ) ) {
    v.x = x[0]; v.y = x[1]; 
  } else if( y === undefined ) {
    v.x = v.y = x
  }else{
    v.x = x; v.y = y; 
  }

  return v
}

Vec2.prototype = {
  type: 'vec2',
	emit() { return "vec2(" + this.x + "," + this.y + ")" },
  emit_decl() { return ""; },
  copy() {
    return Vec2( this.x, this.y )
  }
}

const Vec3 = function (x=0, y, z) {
  if( x.type === 'vec3' ) return x  
  const v = Object.create( Vec3.prototype )
  let vx =0,vy=0,vz=0
  Object.defineProperties( v, {
    x: {
      get()  { return vx },
      set(v) { vx = v; this.dirty = true; }
    },

    y: {
      get()  { return vy },
      set(v) { vy = v; this.dirty = true; }
    },

    z: {
      get()  { return vz },
      set(v) { vz = v; this.dirty = true; }
    },
    r: {
      get()  { return vx },
      set(v) { vx = v; this.dirty = true; }
    },

    g: {
      get()  { return vy },
      set(v) { vy = v; this.dirty = true; }
    },

    b: {
      get()  { return vz },
      set(v) { vz = v; this.dirty = true; }
    },

  })

  if( Array.isArray( x ) ) {
    v.x = x[0]; v.y = x[1]; v.z = x[2]; 
  } else if( y === undefined && z === undefined) {
    v.x = v.y = v.z = x
  }else{
    v.x = x; v.y = y; v.z = z;
  }
 
  v.isGen = v.x.type === 'string' || v.y.type === 'string' || v.z.type === 'string'
  return v
};

Vec3.prototype = {
  type: 'vec3',
  emit() { 
    let out = `vec3(`
    let preface = ''

    if( this.x.type === 'string' ) {
      const xout = this.x.emit()
      out += xout.out + ','
    }else{
      out += this.x + ','
    }

    if( this.y.type === 'string' ) {
      const yout = this.y.emit()
      out += yout.out + ',' 
    }else{
      out += this.y + ','
    }
    if( this.z.type === 'string' ) {
      const zout = this.z.emit()
      out += zout.out
    }else{
      out += this.z 
    }

    out += ')'

    return { out, preface }
  },
  emit_decl() { 
    let out = ''
    if( this.x.type === 'string' ) {
      out += this.x.emit_decl()
    } 
    if( this.y.type === 'string' && this.x !== this.y  ) {
      out += this.y.emit_decl()
    } 
    if( this.z.type === 'string' && this.z !== this.y && this.z !== this.x ) {
      out += this.z.emit_decl()
    } 
    return out
  },

	update_location(gl, program) {
    if( this.isGen ) {
      if( this.x.type === 'string' ) {
        this.x.update_location(gl,program)
      } 
      if( this.y.type === 'string' && this.x !== this.y  ) {
        this.y.update_location(gl,program)
      } 
      if( this.z.type === 'string' && this.z !== this.y && this.z !== this.x ) {
        this.z.update_location(gl,program)
      }      
    }
  },
  
  upload_data(gl) {
    if( this.isGen ) {
      if( this.x.type === 'string' ) {
        this.x.upload_data(gl)
      } 
      if( this.y.type === 'string' && this.x !== this.y  ) {
        this.y.upload_data(gl)
      } 
      if( this.z.type === 'string' && this.z !== this.y && this.z !== this.x ) {
        this.z.upload_data(gl)
      }      
    }
  },

  copy() {
    return Vec3( this.x, this.y, this.z )
  }

}

const Vec4 = function (x=0, y, z, w) {
  if( x.type === 'vec4' ) return x
  const v = Object.create( Vec4.prototype )

  if( Array.isArray( x ) ) {
    v.x = x[0]; v.y = x[1]; v.z = x[2]; v.w = x[3] 
  } else if( y === undefined && z === undefined) {
    v.x = v.y = v.z = v.w = x
  }else{
    v.x = x; v.y = y; v.z = z; v.w = w;;
  }

  v.isGen = v.x.type === 'string' || v.y.type === 'string' || v.z.type === 'string'

  return v
};

Vec4.prototype = {
  type: 'vec4',
  emit() { 
    let out = `vec4(`
    let preface = ''

    if( this.x.type === 'string' ) {
      const xout = this.x.emit()
      out += xout.out + ','
    }else{
      out += this.x + ','
    }

    if( this.y.type === 'string' ) {
      const yout = this.y.emit()
      out += yout.out + ',' 
    }else{
      out += this.y + ','
    }

    if( this.z.type === 'string' ) {
      const zout = this.z.emit()
      out += zout.out
    }else{
      out += this.z 
    }
    
    if( this.w.type === 'string' ) {
      const wout = this.w.emit()
      out += wout.out
    }else{
      out += this.w 
    }

    out += ')'

    return { out, preface }
  },
  emit_decl() { 
    let out = ''
    if( this.x.type === 'string' ) {
      out += this.x.emit_decl()
    } 
    if( this.y.type === 'string' && this.x !== this.y  ) {
      out += this.y.emit_decl()
    } 
    if( this.z.type === 'string' && this.z !== this.y && this.z !== this.x ) {
      out += this.z.emit_decl()
    } 
    if( this.w.type === 'string' && this.w !== this.y && this.w !== this.x && this.w !== this.z ) {
      out += this.w.emit_decl()
    }
    return out
  },

	update_location(gl, program) {
    if( this.isGen ) {
      if( this.x.type === 'string' ) {
        this.x.update_location(gl,program)
      } 
      if( this.y.type === 'string' && this.x !== this.y  ) {
        this.y.update_location(gl,program)
      } 
      if( this.z.type === 'string' && this.z !== this.y && this.z !== this.x ) {
        this.z.update_location(gl,program)
      }      
      if( this.w.type === 'string' && this.w !== this.y && this.w !== this.x && this.w !== this.z ) {
        this.w.update_location(gl,program)
      }  
    }
  },
  
  upload_data(gl) {
    if( this.isGen ) {
      if( this.x.type === 'string' ) {
        this.x.upload_data(gl)
      } 
      if( this.y.type === 'string' && this.x !== this.y  ) {
        this.y.upload_data(gl)
      } 
      if( this.z.type === 'string' && this.z !== this.y && this.z !== this.x ) {
        this.z.upload_data(gl)
      } 
      if( this.w.type === 'string' && this.w !== this.y && this.w !== this.x && this.w !== this.z ) {
        this.w.upload_data(gl)
      }      
    }
  },

  copy() {
    return Vec4( this.x, this.y, this.z, this.w )
  }
}
// Vec4

//let Vec4 = function (x, y, z, w) {
//  const v = Object.create( Vec4.prototype )
//  v.x = x; v.y = y; v.z = z; v.w = w

//  return v
//};

//Vec4.prototype = {
//  type: 'vec4',
//  emit() { return "vec4(" + this.x + "," + this.y + "," + this.z + "," + this.w + ")"; },
//  emit_decl() { return ""; }
//}





module.exports = { Vec2, Vec3, Vec4 } 

},{}],30:[function(require,module,exports){
const SceneNode = require( './sceneNode.js' ),
      { param_wrap, MaterialID } = require( './utils.js' ),
      { Var, float_var_gen, vec2_var_gen, vec3_var_gen, vec4_var_gen, int_var_gen, VarAlloc } = require( './var.js' )

const Vignette = function( Scene, SDF ) {

  const Vgn = function( radius=0.1, smoothness=.1 ) {
    const vgn = Object.create( Vgn.prototype )
    const __radius = param_wrap( radius, float_var_gen( radius ) )  
    
    Object.defineProperty( vgn, 'radius', {
      get() { return __radius },
      set( v ) {
        __radius.set( v )
      }
    })

    const __smoothness = param_wrap( smoothness, float_var_gen( smoothness ) )  
    
    Object.defineProperty( vgn, 'smoothness', {
      get() { return __smoothness },
      set( v ) {
        __smoothness.set( v )
      }
    })
    
    // this refers to the current scene via implicit binding in scene.js
    this.postprocessing.push( vgn )

    return this
  }

  Vgn.prototype = SceneNode()
 
  Object.assign( Vgn.prototype, {
    emit() {
      return `  color *= vignette( v_uv, ${this.radius.emit()}, ${this.smoothness.emit()} );`
    },
   
    emit_decl() {
      let str = this.radius.emit_decl() + this.smoothness.emit_decl()
      // taken from https://gist.github.com/r-lyeh-archived/170b53fcdc0e17afcf15
      // originally iq
      const preface = `  float vignette(vec2 uv, float radius, float smoothness) {
        return radius + 0.5*16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y); 
      }
  `
      if( SDF.memo.vgn === undefined ) {
        str = str + preface
        SDF.memo.vgn = true
      }else{
        str = ''
      }

      return str
    },

    update_location( gl, program ) {
      this.radius.update_location( gl, program )
      this.smoothness.update_location( gl, program )
    },

    upload_data( gl ) {
      this.radius.upload_data( gl )
      this.smoothness.upload_data( gl )
    }
  })

  return Vgn
}

module.exports = Vignette 

},{"./sceneNode.js":22,"./utils.js":27,"./var.js":28}],31:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],32:[function(require,module,exports){
/**
 * Bit twiddling hacks for JavaScript.
 *
 * Author: Mikola Lysenko
 *
 * Ported from Stanford bit twiddling hack library:
 *    http://graphics.stanford.edu/~seander/bithacks.html
 */

"use strict"; "use restrict";

//Number of bits in an integer
var INT_BITS = 32;

//Constants
exports.INT_BITS  = INT_BITS;
exports.INT_MAX   =  0x7fffffff;
exports.INT_MIN   = -1<<(INT_BITS-1);

//Returns -1, 0, +1 depending on sign of x
exports.sign = function(v) {
  return (v > 0) - (v < 0);
}

//Computes absolute value of integer
exports.abs = function(v) {
  var mask = v >> (INT_BITS-1);
  return (v ^ mask) - mask;
}

//Computes minimum of integers x and y
exports.min = function(x, y) {
  return y ^ ((x ^ y) & -(x < y));
}

//Computes maximum of integers x and y
exports.max = function(x, y) {
  return x ^ ((x ^ y) & -(x < y));
}

//Checks if a number is a power of two
exports.isPow2 = function(v) {
  return !(v & (v-1)) && (!!v);
}

//Computes log base 2 of v
exports.log2 = function(v) {
  var r, shift;
  r =     (v > 0xFFFF) << 4; v >>>= r;
  shift = (v > 0xFF  ) << 3; v >>>= shift; r |= shift;
  shift = (v > 0xF   ) << 2; v >>>= shift; r |= shift;
  shift = (v > 0x3   ) << 1; v >>>= shift; r |= shift;
  return r | (v >> 1);
}

//Computes log base 10 of v
exports.log10 = function(v) {
  return  (v >= 1000000000) ? 9 : (v >= 100000000) ? 8 : (v >= 10000000) ? 7 :
          (v >= 1000000) ? 6 : (v >= 100000) ? 5 : (v >= 10000) ? 4 :
          (v >= 1000) ? 3 : (v >= 100) ? 2 : (v >= 10) ? 1 : 0;
}

//Counts number of bits
exports.popCount = function(v) {
  v = v - ((v >>> 1) & 0x55555555);
  v = (v & 0x33333333) + ((v >>> 2) & 0x33333333);
  return ((v + (v >>> 4) & 0xF0F0F0F) * 0x1010101) >>> 24;
}

//Counts number of trailing zeros
function countTrailingZeros(v) {
  var c = 32;
  v &= -v;
  if (v) c--;
  if (v & 0x0000FFFF) c -= 16;
  if (v & 0x00FF00FF) c -= 8;
  if (v & 0x0F0F0F0F) c -= 4;
  if (v & 0x33333333) c -= 2;
  if (v & 0x55555555) c -= 1;
  return c;
}
exports.countTrailingZeros = countTrailingZeros;

//Rounds to next power of 2
exports.nextPow2 = function(v) {
  v += v === 0;
  --v;
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v + 1;
}

//Rounds down to previous power of 2
exports.prevPow2 = function(v) {
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v - (v>>>1);
}

//Computes parity of word
exports.parity = function(v) {
  v ^= v >>> 16;
  v ^= v >>> 8;
  v ^= v >>> 4;
  v &= 0xf;
  return (0x6996 >>> v) & 1;
}

var REVERSE_TABLE = new Array(256);

(function(tab) {
  for(var i=0; i<256; ++i) {
    var v = i, r = i, s = 7;
    for (v >>>= 1; v; v >>>= 1) {
      r <<= 1;
      r |= v & 1;
      --s;
    }
    tab[i] = (r << s) & 0xff;
  }
})(REVERSE_TABLE);

//Reverse bits in a 32 bit word
exports.reverse = function(v) {
  return  (REVERSE_TABLE[ v         & 0xff] << 24) |
          (REVERSE_TABLE[(v >>> 8)  & 0xff] << 16) |
          (REVERSE_TABLE[(v >>> 16) & 0xff] << 8)  |
           REVERSE_TABLE[(v >>> 24) & 0xff];
}

//Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes
exports.interleave2 = function(x, y) {
  x &= 0xFFFF;
  x = (x | (x << 8)) & 0x00FF00FF;
  x = (x | (x << 4)) & 0x0F0F0F0F;
  x = (x | (x << 2)) & 0x33333333;
  x = (x | (x << 1)) & 0x55555555;

  y &= 0xFFFF;
  y = (y | (y << 8)) & 0x00FF00FF;
  y = (y | (y << 4)) & 0x0F0F0F0F;
  y = (y | (y << 2)) & 0x33333333;
  y = (y | (y << 1)) & 0x55555555;

  return x | (y << 1);
}

//Extracts the nth interleaved component
exports.deinterleave2 = function(v, n) {
  v = (v >>> n) & 0x55555555;
  v = (v | (v >>> 1))  & 0x33333333;
  v = (v | (v >>> 2))  & 0x0F0F0F0F;
  v = (v | (v >>> 4))  & 0x00FF00FF;
  v = (v | (v >>> 16)) & 0x000FFFF;
  return (v << 16) >> 16;
}


//Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes
exports.interleave3 = function(x, y, z) {
  x &= 0x3FF;
  x  = (x | (x<<16)) & 4278190335;
  x  = (x | (x<<8))  & 251719695;
  x  = (x | (x<<4))  & 3272356035;
  x  = (x | (x<<2))  & 1227133513;

  y &= 0x3FF;
  y  = (y | (y<<16)) & 4278190335;
  y  = (y | (y<<8))  & 251719695;
  y  = (y | (y<<4))  & 3272356035;
  y  = (y | (y<<2))  & 1227133513;
  x |= (y << 1);
  
  z &= 0x3FF;
  z  = (z | (z<<16)) & 4278190335;
  z  = (z | (z<<8))  & 251719695;
  z  = (z | (z<<4))  & 3272356035;
  z  = (z | (z<<2))  & 1227133513;
  
  return x | (z << 2);
}

//Extracts nth interleaved component of a 3-tuple
exports.deinterleave3 = function(v, n) {
  v = (v >>> n)       & 1227133513;
  v = (v | (v>>>2))   & 3272356035;
  v = (v | (v>>>4))   & 251719695;
  v = (v | (v>>>8))   & 4278190335;
  v = (v | (v>>>16))  & 0x3FF;
  return (v<<22)>>22;
}

//Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)
exports.nextCombination = function(v) {
  var t = v | (v - 1);
  return (t + 1) | (((~t & -~t) - 1) >>> (countTrailingZeros(v) + 1));
}


},{}],33:[function(require,module,exports){

},{}],34:[function(require,module,exports){
(function (Buffer){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol.for === 'function')
    ? Symbol.for('nodejs.util.inspect.custom')
    : null

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    var proto = { foo: function () { return 42 } }
    Object.setPrototypeOf(proto, Uint8Array.prototype)
    Object.setPrototypeOf(arr, proto)
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof SharedArrayBuffer !== 'undefined' &&
      (isInstance(value, SharedArrayBuffer) ||
      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]]
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  } else if (typeof val === 'boolean') {
    val = Number(val)
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var hexSliceLookupTable = (function () {
  var alphabet = '0123456789abcdef'
  var table = new Array(256)
  for (var i = 0; i < 16; ++i) {
    var i16 = i * 16
    for (var j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
  }
  return table
})()

}).call(this,require("buffer").Buffer)

},{"base64-js":31,"buffer":34,"ieee754":121}],35:[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this,{"isBuffer":require("../../is-buffer/index.js")})

},{"../../is-buffer/index.js":124}],36:[function(require,module,exports){
"use strict"

var createThunk = require("./lib/thunk.js")

function Procedure() {
  this.argTypes = []
  this.shimArgs = []
  this.arrayArgs = []
  this.arrayBlockIndices = []
  this.scalarArgs = []
  this.offsetArgs = []
  this.offsetArgIndex = []
  this.indexArgs = []
  this.shapeArgs = []
  this.funcName = ""
  this.pre = null
  this.body = null
  this.post = null
  this.debug = false
}

function compileCwise(user_args) {
  //Create procedure
  var proc = new Procedure()
  
  //Parse blocks
  proc.pre    = user_args.pre
  proc.body   = user_args.body
  proc.post   = user_args.post

  //Parse arguments
  var proc_args = user_args.args.slice(0)
  proc.argTypes = proc_args
  for(var i=0; i<proc_args.length; ++i) {
    var arg_type = proc_args[i]
    if(arg_type === "array" || (typeof arg_type === "object" && arg_type.blockIndices)) {
      proc.argTypes[i] = "array"
      proc.arrayArgs.push(i)
      proc.arrayBlockIndices.push(arg_type.blockIndices ? arg_type.blockIndices : 0)
      proc.shimArgs.push("array" + i)
      if(i < proc.pre.args.length && proc.pre.args[i].count>0) {
        throw new Error("cwise: pre() block may not reference array args")
      }
      if(i < proc.post.args.length && proc.post.args[i].count>0) {
        throw new Error("cwise: post() block may not reference array args")
      }
    } else if(arg_type === "scalar") {
      proc.scalarArgs.push(i)
      proc.shimArgs.push("scalar" + i)
    } else if(arg_type === "index") {
      proc.indexArgs.push(i)
      if(i < proc.pre.args.length && proc.pre.args[i].count > 0) {
        throw new Error("cwise: pre() block may not reference array index")
      }
      if(i < proc.body.args.length && proc.body.args[i].lvalue) {
        throw new Error("cwise: body() block may not write to array index")
      }
      if(i < proc.post.args.length && proc.post.args[i].count > 0) {
        throw new Error("cwise: post() block may not reference array index")
      }
    } else if(arg_type === "shape") {
      proc.shapeArgs.push(i)
      if(i < proc.pre.args.length && proc.pre.args[i].lvalue) {
        throw new Error("cwise: pre() block may not write to array shape")
      }
      if(i < proc.body.args.length && proc.body.args[i].lvalue) {
        throw new Error("cwise: body() block may not write to array shape")
      }
      if(i < proc.post.args.length && proc.post.args[i].lvalue) {
        throw new Error("cwise: post() block may not write to array shape")
      }
    } else if(typeof arg_type === "object" && arg_type.offset) {
      proc.argTypes[i] = "offset"
      proc.offsetArgs.push({ array: arg_type.array, offset:arg_type.offset })
      proc.offsetArgIndex.push(i)
    } else {
      throw new Error("cwise: Unknown argument type " + proc_args[i])
    }
  }
  
  //Make sure at least one array argument was specified
  if(proc.arrayArgs.length <= 0) {
    throw new Error("cwise: No array arguments specified")
  }
  
  //Make sure arguments are correct
  if(proc.pre.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in pre() block")
  }
  if(proc.body.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in body() block")
  }
  if(proc.post.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in post() block")
  }

  //Check debug flag
  proc.debug = !!user_args.printCode || !!user_args.debug
  
  //Retrieve name
  proc.funcName = user_args.funcName || "cwise"
  
  //Read in block size
  proc.blockSize = user_args.blockSize || 64

  return createThunk(proc)
}

module.exports = compileCwise

},{"./lib/thunk.js":38}],37:[function(require,module,exports){
"use strict"

var uniq = require("uniq")

// This function generates very simple loops analogous to how you typically traverse arrays (the outermost loop corresponds to the slowest changing index, the innermost loop to the fastest changing index)
// TODO: If two arrays have the same strides (and offsets) there is potential for decreasing the number of "pointers" and related variables. The drawback is that the type signature would become more specific and that there would thus be less potential for caching, but it might still be worth it, especially when dealing with large numbers of arguments.
function innerFill(order, proc, body) {
  var dimension = order.length
    , nargs = proc.arrayArgs.length
    , has_index = proc.indexArgs.length>0
    , code = []
    , vars = []
    , idx=0, pidx=0, i, j
  for(i=0; i<dimension; ++i) { // Iteration variables
    vars.push(["i",i,"=0"].join(""))
  }
  //Compute scan deltas
  for(j=0; j<nargs; ++j) {
    for(i=0; i<dimension; ++i) {
      pidx = idx
      idx = order[i]
      if(i === 0) { // The innermost/fastest dimension's delta is simply its stride
        vars.push(["d",j,"s",i,"=t",j,"p",idx].join(""))
      } else { // For other dimensions the delta is basically the stride minus something which essentially "rewinds" the previous (more inner) dimension
        vars.push(["d",j,"s",i,"=(t",j,"p",idx,"-s",pidx,"*t",j,"p",pidx,")"].join(""))
      }
    }
  }
  if (vars.length > 0) {
    code.push("var " + vars.join(","))
  }  
  //Scan loop
  for(i=dimension-1; i>=0; --i) { // Start at largest stride and work your way inwards
    idx = order[i]
    code.push(["for(i",i,"=0;i",i,"<s",idx,";++i",i,"){"].join(""))
  }
  //Push body of inner loop
  code.push(body)
  //Advance scan pointers
  for(i=0; i<dimension; ++i) {
    pidx = idx
    idx = order[i]
    for(j=0; j<nargs; ++j) {
      code.push(["p",j,"+=d",j,"s",i].join(""))
    }
    if(has_index) {
      if(i > 0) {
        code.push(["index[",pidx,"]-=s",pidx].join(""))
      }
      code.push(["++index[",idx,"]"].join(""))
    }
    code.push("}")
  }
  return code.join("\n")
}

// Generate "outer" loops that loop over blocks of data, applying "inner" loops to the blocks by manipulating the local variables in such a way that the inner loop only "sees" the current block.
// TODO: If this is used, then the previous declaration (done by generateCwiseOp) of s* is essentially unnecessary.
//       I believe the s* are not used elsewhere (in particular, I don't think they're used in the pre/post parts and "shape" is defined independently), so it would be possible to make defining the s* dependent on what loop method is being used.
function outerFill(matched, order, proc, body) {
  var dimension = order.length
    , nargs = proc.arrayArgs.length
    , blockSize = proc.blockSize
    , has_index = proc.indexArgs.length > 0
    , code = []
  for(var i=0; i<nargs; ++i) {
    code.push(["var offset",i,"=p",i].join(""))
  }
  //Generate loops for unmatched dimensions
  // The order in which these dimensions are traversed is fairly arbitrary (from small stride to large stride, for the first argument)
  // TODO: It would be nice if the order in which these loops are placed would also be somehow "optimal" (at the very least we should check that it really doesn't hurt us if they're not).
  for(var i=matched; i<dimension; ++i) {
    code.push(["for(var j"+i+"=SS[", order[i], "]|0;j", i, ">0;){"].join("")) // Iterate back to front
    code.push(["if(j",i,"<",blockSize,"){"].join("")) // Either decrease j by blockSize (s = blockSize), or set it to zero (after setting s = j).
    code.push(["s",order[i],"=j",i].join(""))
    code.push(["j",i,"=0"].join(""))
    code.push(["}else{s",order[i],"=",blockSize].join(""))
    code.push(["j",i,"-=",blockSize,"}"].join(""))
    if(has_index) {
      code.push(["index[",order[i],"]=j",i].join(""))
    }
  }
  for(var i=0; i<nargs; ++i) {
    var indexStr = ["offset"+i]
    for(var j=matched; j<dimension; ++j) {
      indexStr.push(["j",j,"*t",i,"p",order[j]].join(""))
    }
    code.push(["p",i,"=(",indexStr.join("+"),")"].join(""))
  }
  code.push(innerFill(order, proc, body))
  for(var i=matched; i<dimension; ++i) {
    code.push("}")
  }
  return code.join("\n")
}

//Count the number of compatible inner orders
// This is the length of the longest common prefix of the arrays in orders.
// Each array in orders lists the dimensions of the correspond ndarray in order of increasing stride.
// This is thus the maximum number of dimensions that can be efficiently traversed by simple nested loops for all arrays.
function countMatches(orders) {
  var matched = 0, dimension = orders[0].length
  while(matched < dimension) {
    for(var j=1; j<orders.length; ++j) {
      if(orders[j][matched] !== orders[0][matched]) {
        return matched
      }
    }
    ++matched
  }
  return matched
}

//Processes a block according to the given data types
// Replaces variable names by different ones, either "local" ones (that are then ferried in and out of the given array) or ones matching the arguments that the function performing the ultimate loop will accept.
function processBlock(block, proc, dtypes) {
  var code = block.body
  var pre = []
  var post = []
  for(var i=0; i<block.args.length; ++i) {
    var carg = block.args[i]
    if(carg.count <= 0) {
      continue
    }
    var re = new RegExp(carg.name, "g")
    var ptrStr = ""
    var arrNum = proc.arrayArgs.indexOf(i)
    switch(proc.argTypes[i]) {
      case "offset":
        var offArgIndex = proc.offsetArgIndex.indexOf(i)
        var offArg = proc.offsetArgs[offArgIndex]
        arrNum = offArg.array
        ptrStr = "+q" + offArgIndex // Adds offset to the "pointer" in the array
      case "array":
        ptrStr = "p" + arrNum + ptrStr
        var localStr = "l" + i
        var arrStr = "a" + arrNum
        if (proc.arrayBlockIndices[arrNum] === 0) { // Argument to body is just a single value from this array
          if(carg.count === 1) { // Argument/array used only once(?)
            if(dtypes[arrNum] === "generic") {
              if(carg.lvalue) {
                pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)
                code = code.replace(re, localStr)
                post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
              } else {
                code = code.replace(re, [arrStr, ".get(", ptrStr, ")"].join(""))
              }
            } else {
              code = code.replace(re, [arrStr, "[", ptrStr, "]"].join(""))
            }
          } else if(dtypes[arrNum] === "generic") {
            pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")) // TODO: Could we optimize by checking for carg.rvalue?
            code = code.replace(re, localStr)
            if(carg.lvalue) {
              post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
            }
          } else {
            pre.push(["var ", localStr, "=", arrStr, "[", ptrStr, "]"].join("")) // TODO: Could we optimize by checking for carg.rvalue?
            code = code.replace(re, localStr)
            if(carg.lvalue) {
              post.push([arrStr, "[", ptrStr, "]=", localStr].join(""))
            }
          }
        } else { // Argument to body is a "block"
          var reStrArr = [carg.name], ptrStrArr = [ptrStr]
          for(var j=0; j<Math.abs(proc.arrayBlockIndices[arrNum]); j++) {
            reStrArr.push("\\s*\\[([^\\]]+)\\]")
            ptrStrArr.push("$" + (j+1) + "*t" + arrNum + "b" + j) // Matched index times stride
          }
          re = new RegExp(reStrArr.join(""), "g")
          ptrStr = ptrStrArr.join("+")
          if(dtypes[arrNum] === "generic") {
            /*if(carg.lvalue) {
              pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)
              code = code.replace(re, localStr)
              post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
            } else {
              code = code.replace(re, [arrStr, ".get(", ptrStr, ")"].join(""))
            }*/
            throw new Error("cwise: Generic arrays not supported in combination with blocks!")
          } else {
            // This does not produce any local variables, even if variables are used multiple times. It would be possible to do so, but it would complicate things quite a bit.
            code = code.replace(re, [arrStr, "[", ptrStr, "]"].join(""))
          }
        }
      break
      case "scalar":
        code = code.replace(re, "Y" + proc.scalarArgs.indexOf(i))
      break
      case "index":
        code = code.replace(re, "index")
      break
      case "shape":
        code = code.replace(re, "shape")
      break
    }
  }
  return [pre.join("\n"), code, post.join("\n")].join("\n").trim()
}

function typeSummary(dtypes) {
  var summary = new Array(dtypes.length)
  var allEqual = true
  for(var i=0; i<dtypes.length; ++i) {
    var t = dtypes[i]
    var digits = t.match(/\d+/)
    if(!digits) {
      digits = ""
    } else {
      digits = digits[0]
    }
    if(t.charAt(0) === 0) {
      summary[i] = "u" + t.charAt(1) + digits
    } else {
      summary[i] = t.charAt(0) + digits
    }
    if(i > 0) {
      allEqual = allEqual && summary[i] === summary[i-1]
    }
  }
  if(allEqual) {
    return summary[0]
  }
  return summary.join("")
}

//Generates a cwise operator
function generateCWiseOp(proc, typesig) {

  //Compute dimension
  // Arrays get put first in typesig, and there are two entries per array (dtype and order), so this gets the number of dimensions in the first array arg.
  var dimension = (typesig[1].length - Math.abs(proc.arrayBlockIndices[0]))|0
  var orders = new Array(proc.arrayArgs.length)
  var dtypes = new Array(proc.arrayArgs.length)
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    dtypes[i] = typesig[2*i]
    orders[i] = typesig[2*i+1]
  }
  
  //Determine where block and loop indices start and end
  var blockBegin = [], blockEnd = [] // These indices are exposed as blocks
  var loopBegin = [], loopEnd = [] // These indices are iterated over
  var loopOrders = [] // orders restricted to the loop indices
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    if (proc.arrayBlockIndices[i]<0) {
      loopBegin.push(0)
      loopEnd.push(dimension)
      blockBegin.push(dimension)
      blockEnd.push(dimension+proc.arrayBlockIndices[i])
    } else {
      loopBegin.push(proc.arrayBlockIndices[i]) // Non-negative
      loopEnd.push(proc.arrayBlockIndices[i]+dimension)
      blockBegin.push(0)
      blockEnd.push(proc.arrayBlockIndices[i])
    }
    var newOrder = []
    for(var j=0; j<orders[i].length; j++) {
      if (loopBegin[i]<=orders[i][j] && orders[i][j]<loopEnd[i]) {
        newOrder.push(orders[i][j]-loopBegin[i]) // If this is a loop index, put it in newOrder, subtracting loopBegin, to make sure that all loopOrders are using a common set of indices.
      }
    }
    loopOrders.push(newOrder)
  }

  //First create arguments for procedure
  var arglist = ["SS"] // SS is the overall shape over which we iterate
  var code = ["'use strict'"]
  var vars = []
  
  for(var j=0; j<dimension; ++j) {
    vars.push(["s", j, "=SS[", j, "]"].join("")) // The limits for each dimension.
  }
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    arglist.push("a"+i) // Actual data array
    arglist.push("t"+i) // Strides
    arglist.push("p"+i) // Offset in the array at which the data starts (also used for iterating over the data)
    
    for(var j=0; j<dimension; ++j) { // Unpack the strides into vars for looping
      vars.push(["t",i,"p",j,"=t",i,"[",loopBegin[i]+j,"]"].join(""))
    }
    
    for(var j=0; j<Math.abs(proc.arrayBlockIndices[i]); ++j) { // Unpack the strides into vars for block iteration
      vars.push(["t",i,"b",j,"=t",i,"[",blockBegin[i]+j,"]"].join(""))
    }
  }
  for(var i=0; i<proc.scalarArgs.length; ++i) {
    arglist.push("Y" + i)
  }
  if(proc.shapeArgs.length > 0) {
    vars.push("shape=SS.slice(0)") // Makes the shape over which we iterate available to the user defined functions (so you can use width/height for example)
  }
  if(proc.indexArgs.length > 0) {
    // Prepare an array to keep track of the (logical) indices, initialized to dimension zeroes.
    var zeros = new Array(dimension)
    for(var i=0; i<dimension; ++i) {
      zeros[i] = "0"
    }
    vars.push(["index=[", zeros.join(","), "]"].join(""))
  }
  for(var i=0; i<proc.offsetArgs.length; ++i) { // Offset arguments used for stencil operations
    var off_arg = proc.offsetArgs[i]
    var init_string = []
    for(var j=0; j<off_arg.offset.length; ++j) {
      if(off_arg.offset[j] === 0) {
        continue
      } else if(off_arg.offset[j] === 1) {
        init_string.push(["t", off_arg.array, "p", j].join(""))      
      } else {
        init_string.push([off_arg.offset[j], "*t", off_arg.array, "p", j].join(""))
      }
    }
    if(init_string.length === 0) {
      vars.push("q" + i + "=0")
    } else {
      vars.push(["q", i, "=", init_string.join("+")].join(""))
    }
  }

  //Prepare this variables
  var thisVars = uniq([].concat(proc.pre.thisVars)
                      .concat(proc.body.thisVars)
                      .concat(proc.post.thisVars))
  vars = vars.concat(thisVars)
  if (vars.length > 0) {
    code.push("var " + vars.join(","))
  }
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    code.push("p"+i+"|=0")
  }
  
  //Inline prelude
  if(proc.pre.body.length > 3) {
    code.push(processBlock(proc.pre, proc, dtypes))
  }

  //Process body
  var body = processBlock(proc.body, proc, dtypes)
  var matched = countMatches(loopOrders)
  if(matched < dimension) {
    code.push(outerFill(matched, loopOrders[0], proc, body)) // TODO: Rather than passing loopOrders[0], it might be interesting to look at passing an order that represents the majority of the arguments for example.
  } else {
    code.push(innerFill(loopOrders[0], proc, body))
  }

  //Inline epilog
  if(proc.post.body.length > 3) {
    code.push(processBlock(proc.post, proc, dtypes))
  }
  
  if(proc.debug) {
    console.log("-----Generated cwise routine for ", typesig, ":\n" + code.join("\n") + "\n----------")
  }
  
  var loopName = [(proc.funcName||"unnamed"), "_cwise_loop_", orders[0].join("s"),"m",matched,typeSummary(dtypes)].join("")
  var f = new Function(["function ",loopName,"(", arglist.join(","),"){", code.join("\n"),"} return ", loopName].join(""))
  return f()
}
module.exports = generateCWiseOp

},{"uniq":190}],38:[function(require,module,exports){
"use strict"

// The function below is called when constructing a cwise function object, and does the following:
// A function object is constructed which accepts as argument a compilation function and returns another function.
// It is this other function that is eventually returned by createThunk, and this function is the one that actually
// checks whether a certain pattern of arguments has already been used before and compiles new loops as needed.
// The compilation passed to the first function object is used for compiling new functions.
// Once this function object is created, it is called with compile as argument, where the first argument of compile
// is bound to "proc" (essentially containing a preprocessed version of the user arguments to cwise).
// So createThunk roughly works like this:
// function createThunk(proc) {
//   var thunk = function(compileBound) {
//     var CACHED = {}
//     return function(arrays and scalars) {
//       if (dtype and order of arrays in CACHED) {
//         var func = CACHED[dtype and order of arrays]
//       } else {
//         var func = CACHED[dtype and order of arrays] = compileBound(dtype and order of arrays)
//       }
//       return func(arrays and scalars)
//     }
//   }
//   return thunk(compile.bind1(proc))
// }

var compile = require("./compile.js")

function createThunk(proc) {
  var code = ["'use strict'", "var CACHED={}"]
  var vars = []
  var thunkName = proc.funcName + "_cwise_thunk"
  
  //Build thunk
  code.push(["return function ", thunkName, "(", proc.shimArgs.join(","), "){"].join(""))
  var typesig = []
  var string_typesig = []
  var proc_args = [["array",proc.arrayArgs[0],".shape.slice(", // Slice shape so that we only retain the shape over which we iterate (which gets passed to the cwise operator as SS).
                    Math.max(0,proc.arrayBlockIndices[0]),proc.arrayBlockIndices[0]<0?(","+proc.arrayBlockIndices[0]+")"):")"].join("")]
  var shapeLengthConditions = [], shapeConditions = []
  // Process array arguments
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    var j = proc.arrayArgs[i]
    vars.push(["t", j, "=array", j, ".dtype,",
               "r", j, "=array", j, ".order"].join(""))
    typesig.push("t" + j)
    typesig.push("r" + j)
    string_typesig.push("t"+j)
    string_typesig.push("r"+j+".join()")
    proc_args.push("array" + j + ".data")
    proc_args.push("array" + j + ".stride")
    proc_args.push("array" + j + ".offset|0")
    if (i>0) { // Gather conditions to check for shape equality (ignoring block indices)
      shapeLengthConditions.push("array" + proc.arrayArgs[0] + ".shape.length===array" + j + ".shape.length+" + (Math.abs(proc.arrayBlockIndices[0])-Math.abs(proc.arrayBlockIndices[i])))
      shapeConditions.push("array" + proc.arrayArgs[0] + ".shape[shapeIndex+" + Math.max(0,proc.arrayBlockIndices[0]) + "]===array" + j + ".shape[shapeIndex+" + Math.max(0,proc.arrayBlockIndices[i]) + "]")
    }
  }
  // Check for shape equality
  if (proc.arrayArgs.length > 1) {
    code.push("if (!(" + shapeLengthConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same dimensionality!')")
    code.push("for(var shapeIndex=array" + proc.arrayArgs[0] + ".shape.length-" + Math.abs(proc.arrayBlockIndices[0]) + "; shapeIndex-->0;) {")
    code.push("if (!(" + shapeConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same shape!')")
    code.push("}")
  }
  // Process scalar arguments
  for(var i=0; i<proc.scalarArgs.length; ++i) {
    proc_args.push("scalar" + proc.scalarArgs[i])
  }
  // Check for cached function (and if not present, generate it)
  vars.push(["type=[", string_typesig.join(","), "].join()"].join(""))
  vars.push("proc=CACHED[type]")
  code.push("var " + vars.join(","))
  
  code.push(["if(!proc){",
             "CACHED[type]=proc=compile([", typesig.join(","), "])}",
             "return proc(", proc_args.join(","), ")}"].join(""))

  if(proc.debug) {
    console.log("-----Generated thunk:\n" + code.join("\n") + "\n----------")
  }
  
  //Compile thunk
  var thunk = new Function("compile", code.join("\n"))
  return thunk(compile.bind(undefined, proc))
}

module.exports = createThunk

},{"./compile.js":37}],39:[function(require,module,exports){
(function (Buffer){

/**
 * Module exports.
 */

module.exports = dataUriToBuffer;

/**
 * Returns a `Buffer` instance from the given data URI `uri`.
 *
 * @param {String} uri Data URI to turn into a Buffer instance
 * @return {Buffer} Buffer instance from Data URI
 * @api public
 */

function dataUriToBuffer (uri) {
  if (!/^data\:/i.test(uri)) {
    throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
  }

  // strip newlines
  uri = uri.replace(/\r?\n/g, '');

  // split the URI up into the "metadata" and the "data" portions
  var firstComma = uri.indexOf(',');
  if (-1 === firstComma || firstComma <= 4) throw new TypeError('malformed data: URI');

  // remove the "data:" scheme and parse the metadata
  var meta = uri.substring(5, firstComma).split(';');

  var base64 = false;
  var charset = 'US-ASCII';
  for (var i = 0; i < meta.length; i++) {
    if ('base64' == meta[i]) {
      base64 = true;
    } else if (0 == meta[i].indexOf('charset=')) {
      charset = meta[i].substring(8);
    }
  }

  // get the encoded data portion and decode URI-encoded chars
  var data = unescape(uri.substring(firstComma + 1));

  var encoding = base64 ? 'base64' : 'ascii';
  var buffer = new Buffer(data, encoding);

  // set `.type` property to MIME type
  buffer.type = meta[0] || 'text/plain';

  // set the `.charset` property
  buffer.charset = charset;

  return buffer;
}

}).call(this,require("buffer").Buffer)

},{"buffer":34}],40:[function(require,module,exports){
"use strict"

function dupe_array(count, value, i) {
  var c = count[i]|0
  if(c <= 0) {
    return []
  }
  var result = new Array(c), j
  if(i === count.length-1) {
    for(j=0; j<c; ++j) {
      result[j] = value
    }
  } else {
    for(j=0; j<c; ++j) {
      result[j] = dupe_array(count, value, i+1)
    }
  }
  return result
}

function dupe_number(count, value) {
  var result, i
  result = new Array(count)
  for(i=0; i<count; ++i) {
    result[i] = value
  }
  return result
}

function dupe(count, value) {
  if(typeof value === "undefined") {
    value = 0
  }
  switch(typeof count) {
    case "number":
      if(count > 0) {
        return dupe_number(count|0, value)
      }
    break
    case "object":
      if(typeof (count.length) === "number") {
        return dupe_array(count, value, 0)
      }
    break
  }
  return []
}

module.exports = dupe
},{}],41:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],42:[function(require,module,exports){
(function (Buffer,process){
'use strict'

var path          = require('path')
var ndarray       = require('ndarray')
var GifReader     = require('omggif').GifReader
var pack          = require('ndarray-pack')
var through       = require('through')
var parseDataURI  = require('data-uri-to-buffer')

function defaultImage(url, cb) {
  var img = new Image()
  img.crossOrigin = "Anonymous"
  img.onload = function() {
    var canvas = document.createElement('canvas')
    canvas.width = img.width
    canvas.height = img.height
    var context = canvas.getContext('2d')
    context.drawImage(img, 0, 0)
    var pixels = context.getImageData(0, 0, img.width, img.height)
    cb(null, ndarray(new Uint8Array(pixels.data), [img.width, img.height, 4], [4, 4*img.width, 1], 0))
  }
  img.onerror = function(err) {
    cb(err)
  }
  img.src = url
}

//Animated gif loading
function handleGif(data, cb) {
  var reader
  try {
    reader = new GifReader(data)
  } catch(err) {
    cb(err)
    return
  }
  if(reader.numFrames() > 0) {
    var nshape = [reader.numFrames(), reader.height, reader.width, 4]
    var ndata = new Uint8Array(nshape[0] * nshape[1] * nshape[2] * nshape[3])
    var result = ndarray(ndata, nshape)
    try {
      for(var i=0; i<reader.numFrames(); ++i) {
        reader.decodeAndBlitFrameRGBA(i, ndata.subarray(
          result.index(i, 0, 0, 0),
          result.index(i+1, 0, 0, 0)))
      }
    } catch(err) {
      cb(err)
      return
    }
    cb(null, result.transpose(0,2,1))
  } else {
    var nshape = [reader.height, reader.width, 4]
    var ndata = new Uint8Array(nshape[0] * nshape[1] * nshape[2])
    var result = ndarray(ndata, nshape)
    try {
      reader.decodeAndBlitFrameRGBA(0, ndata)
    } catch(err) {
      cb(err)
      return
    }
    cb(null, result.transpose(1,0))
  }
}

function httpGif(url, cb) {
  var xhr          = new XMLHttpRequest()
  xhr.open('GET', url, true)
  xhr.responseType = 'arraybuffer'
  if(xhr.overrideMimeType){
    xhr.overrideMimeType('application/binary')
  }
  xhr.onerror = function(err) {
    cb(err)
  }
  xhr.onload = function() {
    if(xhr.readyState !== 4) {
      return
    }
    var data = new Uint8Array(xhr.response)
    handleGif(data, cb)
    return
  }
  xhr.send()
}

function copyBuffer(buffer) {
  if(buffer[0] === undefined) {
    var n = buffer.length
    var result = new Uint8Array(n)
    for(var i=0; i<n; ++i) {
      result[i] = buffer.get(i)
    }
    return result
  } else {
    return new Uint8Array(buffer)
  }
}

function dataGif(url, cb) {
  process.nextTick(function() {
    try {
      var buffer = parseDataURI(url)
      if(buffer) {
        handleGif(copyBuffer(buffer), cb)
      } else {
        cb(new Error('Error parsing data URI'))
      }
    } catch(err) {
      cb(err)
    }
  })
}

module.exports = function getPixels(url, type, cb) {
  if(!cb) {
    cb = type
    type = ''
  }
  var ext = path.extname(url)
  switch(type || ext.toUpperCase()) {
    case '.GIF':
      httpGif(url, cb)
    break
    default:
      if(Buffer.isBuffer(url)) {
        url = 'data:' + type + ';base64,' + url.toString('base64')
      }
      if(url.indexOf('data:image/gif;') === 0) {
        dataGif(url, cb)
      } else {
        defaultImage(url, cb)
      }
  }
}
}).call(this,{"isBuffer":require("../is-buffer/index.js")},require('_process'))

},{"../is-buffer/index.js":124,"_process":169,"data-uri-to-buffer":39,"ndarray":165,"ndarray-pack":163,"omggif":166,"path":167,"through":187}],43:[function(require,module,exports){
module.exports = adjoint;

/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function adjoint(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
    out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
    out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
    out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
    out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
    out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
    return out;
};
},{}],44:[function(require,module,exports){
module.exports = clone;

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
function clone(a) {
    var out = new Float32Array(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};
},{}],45:[function(require,module,exports){
module.exports = copy;

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};
},{}],46:[function(require,module,exports){
module.exports = create;

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
function create() {
    var out = new Float32Array(16);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};
},{}],47:[function(require,module,exports){
module.exports = determinant;

/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32;

    // Calculate the determinant
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
};
},{}],48:[function(require,module,exports){
module.exports = fromQuat;

/**
 * Creates a matrix from a quaternion rotation.
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @returns {mat4} out
 */
function fromQuat(out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;

    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;

    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;

    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;

    return out;
};
},{}],49:[function(require,module,exports){
module.exports = fromRotation

/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.rotate(dest, dest, rad, axis)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
function fromRotation(out, rad, axis) {
  var s, c, t
  var x = axis[0]
  var y = axis[1]
  var z = axis[2]
  var len = Math.sqrt(x * x + y * y + z * z)

  if (Math.abs(len) < 0.000001) {
    return null
  }

  len = 1 / len
  x *= len
  y *= len
  z *= len

  s = Math.sin(rad)
  c = Math.cos(rad)
  t = 1 - c

  // Perform rotation-specific matrix multiplication
  out[0] = x * x * t + c
  out[1] = y * x * t + z * s
  out[2] = z * x * t - y * s
  out[3] = 0
  out[4] = x * y * t - z * s
  out[5] = y * y * t + c
  out[6] = z * y * t + x * s
  out[7] = 0
  out[8] = x * z * t + y * s
  out[9] = y * z * t - x * s
  out[10] = z * z * t + c
  out[11] = 0
  out[12] = 0
  out[13] = 0
  out[14] = 0
  out[15] = 1
  return out
}

},{}],50:[function(require,module,exports){
module.exports = fromRotationTranslation;

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
function fromRotationTranslation(out, q, v) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    
    return out;
};
},{}],51:[function(require,module,exports){
module.exports = fromScaling

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.scale(dest, dest, vec)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */
function fromScaling(out, v) {
  out[0] = v[0]
  out[1] = 0
  out[2] = 0
  out[3] = 0
  out[4] = 0
  out[5] = v[1]
  out[6] = 0
  out[7] = 0
  out[8] = 0
  out[9] = 0
  out[10] = v[2]
  out[11] = 0
  out[12] = 0
  out[13] = 0
  out[14] = 0
  out[15] = 1
  return out
}

},{}],52:[function(require,module,exports){
module.exports = fromTranslation

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.translate(dest, dest, vec)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
function fromTranslation(out, v) {
  out[0] = 1
  out[1] = 0
  out[2] = 0
  out[3] = 0
  out[4] = 0
  out[5] = 1
  out[6] = 0
  out[7] = 0
  out[8] = 0
  out[9] = 0
  out[10] = 1
  out[11] = 0
  out[12] = v[0]
  out[13] = v[1]
  out[14] = v[2]
  out[15] = 1
  return out
}

},{}],53:[function(require,module,exports){
module.exports = fromXRotation

/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.rotateX(dest, dest, rad)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromXRotation(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad)

    // Perform axis-specific matrix multiplication
    out[0] = 1
    out[1] = 0
    out[2] = 0
    out[3] = 0
    out[4] = 0
    out[5] = c
    out[6] = s
    out[7] = 0
    out[8] = 0
    out[9] = -s
    out[10] = c
    out[11] = 0
    out[12] = 0
    out[13] = 0
    out[14] = 0
    out[15] = 1
    return out
}
},{}],54:[function(require,module,exports){
module.exports = fromYRotation

/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.rotateY(dest, dest, rad)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromYRotation(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad)

    // Perform axis-specific matrix multiplication
    out[0] = c
    out[1] = 0
    out[2] = -s
    out[3] = 0
    out[4] = 0
    out[5] = 1
    out[6] = 0
    out[7] = 0
    out[8] = s
    out[9] = 0
    out[10] = c
    out[11] = 0
    out[12] = 0
    out[13] = 0
    out[14] = 0
    out[15] = 1
    return out
}
},{}],55:[function(require,module,exports){
module.exports = fromZRotation

/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.rotateZ(dest, dest, rad)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromZRotation(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad)

    // Perform axis-specific matrix multiplication
    out[0] = c
    out[1] = s
    out[2] = 0
    out[3] = 0
    out[4] = -s
    out[5] = c
    out[6] = 0
    out[7] = 0
    out[8] = 0
    out[9] = 0
    out[10] = 1
    out[11] = 0
    out[12] = 0
    out[13] = 0
    out[14] = 0
    out[15] = 1
    return out
}
},{}],56:[function(require,module,exports){
module.exports = frustum;

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
function frustum(out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left),
        tb = 1 / (top - bottom),
        nf = 1 / (near - far);
    out[0] = (near * 2) * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = (near * 2) * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (far * near * 2) * nf;
    out[15] = 0;
    return out;
};
},{}],57:[function(require,module,exports){
module.exports = identity;

/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};
},{}],58:[function(require,module,exports){
module.exports = {
  create: require('./create')
  , clone: require('./clone')
  , copy: require('./copy')
  , identity: require('./identity')
  , transpose: require('./transpose')
  , invert: require('./invert')
  , adjoint: require('./adjoint')
  , determinant: require('./determinant')
  , multiply: require('./multiply')
  , translate: require('./translate')
  , scale: require('./scale')
  , rotate: require('./rotate')
  , rotateX: require('./rotateX')
  , rotateY: require('./rotateY')
  , rotateZ: require('./rotateZ')
  , fromRotation: require('./fromRotation')
  , fromRotationTranslation: require('./fromRotationTranslation')
  , fromScaling: require('./fromScaling')
  , fromTranslation: require('./fromTranslation')
  , fromXRotation: require('./fromXRotation')
  , fromYRotation: require('./fromYRotation')
  , fromZRotation: require('./fromZRotation')
  , fromQuat: require('./fromQuat')
  , frustum: require('./frustum')
  , perspective: require('./perspective')
  , perspectiveFromFieldOfView: require('./perspectiveFromFieldOfView')
  , ortho: require('./ortho')
  , lookAt: require('./lookAt')
  , str: require('./str')
}

},{"./adjoint":43,"./clone":44,"./copy":45,"./create":46,"./determinant":47,"./fromQuat":48,"./fromRotation":49,"./fromRotationTranslation":50,"./fromScaling":51,"./fromTranslation":52,"./fromXRotation":53,"./fromYRotation":54,"./fromZRotation":55,"./frustum":56,"./identity":57,"./invert":59,"./lookAt":60,"./multiply":61,"./ortho":62,"./perspective":63,"./perspectiveFromFieldOfView":64,"./rotate":65,"./rotateX":66,"./rotateY":67,"./rotateZ":68,"./scale":69,"./str":70,"./translate":71,"./transpose":72}],59:[function(require,module,exports){
module.exports = invert;

/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function invert(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
};
},{}],60:[function(require,module,exports){
var identity = require('./identity');

module.exports = lookAt;

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
function lookAt(out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
        eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2],
        centerx = center[0],
        centery = center[1],
        centerz = center[2];

    if (Math.abs(eyex - centerx) < 0.000001 &&
        Math.abs(eyey - centery) < 0.000001 &&
        Math.abs(eyez - centerz) < 0.000001) {
        return identity(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;

    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;

    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;

    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;

    return out;
};
},{"./identity":57}],61:[function(require,module,exports){
module.exports = multiply;

/**
 * Multiplies two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function multiply(out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    // Cache only the current line of the second matrix
    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];  
    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
    return out;
};
},{}],62:[function(require,module,exports){
module.exports = ortho;

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function ortho(out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right),
        bt = 1 / (bottom - top),
        nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
};
},{}],63:[function(require,module,exports){
module.exports = perspective;

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function perspective(out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf = 1 / (near - far);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) * nf;
    out[15] = 0;
    return out;
};
},{}],64:[function(require,module,exports){
module.exports = perspectiveFromFieldOfView;

/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function perspectiveFromFieldOfView(out, fov, near, far) {
    var upTan = Math.tan(fov.upDegrees * Math.PI/180.0),
        downTan = Math.tan(fov.downDegrees * Math.PI/180.0),
        leftTan = Math.tan(fov.leftDegrees * Math.PI/180.0),
        rightTan = Math.tan(fov.rightDegrees * Math.PI/180.0),
        xScale = 2.0 / (leftTan + rightTan),
        yScale = 2.0 / (upTan + downTan);

    out[0] = xScale;
    out[1] = 0.0;
    out[2] = 0.0;
    out[3] = 0.0;
    out[4] = 0.0;
    out[5] = yScale;
    out[6] = 0.0;
    out[7] = 0.0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = ((upTan - downTan) * yScale * 0.5);
    out[10] = far / (near - far);
    out[11] = -1.0;
    out[12] = 0.0;
    out[13] = 0.0;
    out[14] = (far * near) / (near - far);
    out[15] = 0.0;
    return out;
}


},{}],65:[function(require,module,exports){
module.exports = rotate;

/**
 * Rotates a mat4 by the given angle
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
function rotate(out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t,
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23,
        b00, b01, b02,
        b10, b11, b12,
        b20, b21, b22;

    if (Math.abs(len) < 0.000001) { return null; }
    
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

    // Construct the elements of the rotation matrix
    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

    // Perform rotation-specific matrix multiplication
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    return out;
};
},{}],66:[function(require,module,exports){
module.exports = rotateX;

/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateX(out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[0]  = a[0];
        out[1]  = a[1];
        out[2]  = a[2];
        out[3]  = a[3];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
};
},{}],67:[function(require,module,exports){
module.exports = rotateY;

/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateY(out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[4]  = a[4];
        out[5]  = a[5];
        out[6]  = a[6];
        out[7]  = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
};
},{}],68:[function(require,module,exports){
module.exports = rotateZ;

/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateZ(out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[8]  = a[8];
        out[9]  = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
};
},{}],69:[function(require,module,exports){
module.exports = scale;

/**
 * Scales the mat4 by the dimensions in the given vec3
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
function scale(out, a, v) {
    var x = v[0], y = v[1], z = v[2];

    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};
},{}],70:[function(require,module,exports){
module.exports = str;

/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
                    a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
                    a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + 
                    a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
};
},{}],71:[function(require,module,exports){
module.exports = translate;

/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
function translate(out, a, v) {
    var x = v[0], y = v[1], z = v[2],
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23;

    if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
};
},{}],72:[function(require,module,exports){
module.exports = transpose;

/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function transpose(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a03 = a[3],
            a12 = a[6], a13 = a[7],
            a23 = a[11];

        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a01;
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a02;
        out[9] = a12;
        out[11] = a[14];
        out[12] = a03;
        out[13] = a13;
        out[14] = a23;
    } else {
        out[0] = a[0];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a[1];
        out[5] = a[5];
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a[2];
        out[9] = a[6];
        out[10] = a[10];
        out[11] = a[14];
        out[12] = a[3];
        out[13] = a[7];
        out[14] = a[11];
        out[15] = a[15];
    }
    
    return out;
};
},{}],73:[function(require,module,exports){
'use strict'

var ndarray = require('ndarray')
var ops     = require('ndarray-ops')
var pool    = require('typedarray-pool')

module.exports = createTexture2D

var linearTypes = null
var filterTypes = null
var wrapTypes   = null

function lazyInitLinearTypes(gl) {
  linearTypes = [
    gl.LINEAR,
    gl.NEAREST_MIPMAP_LINEAR,
    gl.LINEAR_MIPMAP_NEAREST,
    gl.LINEAR_MIPMAP_NEAREST
  ]
  filterTypes = [
    gl.NEAREST,
    gl.LINEAR,
    gl.NEAREST_MIPMAP_NEAREST,
    gl.NEAREST_MIPMAP_LINEAR,
    gl.LINEAR_MIPMAP_NEAREST,
    gl.LINEAR_MIPMAP_LINEAR
  ]
  wrapTypes = [
    gl.REPEAT,
    gl.CLAMP_TO_EDGE,
    gl.MIRRORED_REPEAT
  ]
}

function acceptTextureDOM (obj) {
  return (
    ('undefined' != typeof HTMLCanvasElement && obj instanceof HTMLCanvasElement) ||
    ('undefined' != typeof HTMLImageElement && obj instanceof HTMLImageElement) ||
    ('undefined' != typeof HTMLVideoElement && obj instanceof HTMLVideoElement) ||
    ('undefined' != typeof ImageData && obj instanceof ImageData))
}

var convertFloatToUint8 = function(out, inp) {
  ops.muls(out, inp, 255.0)
}

function reshapeTexture(tex, w, h) {
  var gl = tex.gl
  var maxSize = gl.getParameter(gl.MAX_TEXTURE_SIZE)
  if(w < 0 || w > maxSize || h < 0 || h > maxSize) {
    throw new Error('gl-texture2d: Invalid texture size')
  }
  tex._shape = [w, h]
  tex.bind()
  gl.texImage2D(gl.TEXTURE_2D, 0, tex.format, w, h, 0, tex.format, tex.type, null)
  tex._mipLevels = [0]
  return tex
}

function Texture2D(gl, handle, width, height, format, type) {
  this.gl = gl
  this.handle = handle
  this.format = format
  this.type = type
  this._shape = [width, height]
  this._mipLevels = [0]
  this._magFilter = gl.NEAREST
  this._minFilter = gl.NEAREST
  this._wrapS = gl.CLAMP_TO_EDGE
  this._wrapT = gl.CLAMP_TO_EDGE
  this._anisoSamples = 1

  var parent = this
  var wrapVector = [this._wrapS, this._wrapT]
  Object.defineProperties(wrapVector, [
    {
      get: function() {
        return parent._wrapS
      },
      set: function(v) {
        return parent.wrapS = v
      }
    },
    {
      get: function() {
        return parent._wrapT
      },
      set: function(v) {
        return parent.wrapT = v
      }
    }
  ])
  this._wrapVector = wrapVector

  var shapeVector = [this._shape[0], this._shape[1]]
  Object.defineProperties(shapeVector, [
    {
      get: function() {
        return parent._shape[0]
      },
      set: function(v) {
        return parent.width = v
      }
    },
    {
      get: function() {
        return parent._shape[1]
      },
      set: function(v) {
        return parent.height = v
      }
    }
  ])
  this._shapeVector = shapeVector
}

var proto = Texture2D.prototype

Object.defineProperties(proto, {
  minFilter: {
    get: function() {
      return this._minFilter
    },
    set: function(v) {
      this.bind()
      var gl = this.gl
      if(this.type === gl.FLOAT && linearTypes.indexOf(v) >= 0) {
        if(!gl.getExtension('OES_texture_float_linear')) {
          v = gl.NEAREST
        }
      }
      if(filterTypes.indexOf(v) < 0) {
        throw new Error('gl-texture2d: Unknown filter mode ' + v)
      }
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, v)
      return this._minFilter = v
    }
  },
  magFilter: {
    get: function() {
      return this._magFilter
    },
    set: function(v) {
      this.bind()
      var gl = this.gl
      if(this.type === gl.FLOAT && linearTypes.indexOf(v) >= 0) {
        if(!gl.getExtension('OES_texture_float_linear')) {
          v = gl.NEAREST
        }
      }
      if(filterTypes.indexOf(v) < 0) {
        throw new Error('gl-texture2d: Unknown filter mode ' + v)
      }
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, v)
      return this._magFilter = v
    }
  },
  mipSamples: {
    get: function() {
      return this._anisoSamples
    },
    set: function(i) {
      var psamples = this._anisoSamples
      this._anisoSamples = Math.max(i, 1)|0
      if(psamples !== this._anisoSamples) {
        var ext = this.gl.getExtension('EXT_texture_filter_anisotropic')
        if(ext) {
          this.gl.texParameterf(this.gl.TEXTURE_2D, ext.TEXTURE_MAX_ANISOTROPY_EXT, this._anisoSamples)
        }
      }
      return this._anisoSamples
    }
  },
  wrapS: {
    get: function() {
      return this._wrapS
    },
    set: function(v) {
      this.bind()
      if(wrapTypes.indexOf(v) < 0) {
        throw new Error('gl-texture2d: Unknown wrap mode ' + v)
      }
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, v)
      return this._wrapS = v
    }
  },
  wrapT: {
    get: function() {
      return this._wrapT
    },
    set: function(v) {
      this.bind()
      if(wrapTypes.indexOf(v) < 0) {
        throw new Error('gl-texture2d: Unknown wrap mode ' + v)
      }
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, v)
      return this._wrapT = v
    }
  },
  wrap: {
    get: function() {
      return this._wrapVector
    },
    set: function(v) {
      if(!Array.isArray(v)) {
        v = [v,v]
      }
      if(v.length !== 2) {
        throw new Error('gl-texture2d: Must specify wrap mode for rows and columns')
      }
      for(var i=0; i<2; ++i) {
        if(wrapTypes.indexOf(v[i]) < 0) {
          throw new Error('gl-texture2d: Unknown wrap mode ' + v)
        }
      }
      this._wrapS = v[0]
      this._wrapT = v[1]

      var gl = this.gl
      this.bind()
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this._wrapS)
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this._wrapT)

      return v
    }
  },
  shape: {
    get: function() {
      return this._shapeVector
    },
    set: function(x) {
      if(!Array.isArray(x)) {
        x = [x|0,x|0]
      } else {
        if(x.length !== 2) {
          throw new Error('gl-texture2d: Invalid texture shape')
        }
      }
      reshapeTexture(this, x[0]|0, x[1]|0)
      return [x[0]|0, x[1]|0]
    }
  },
  width: {
    get: function() {
      return this._shape[0]
    },
    set: function(w) {
      w = w|0
      reshapeTexture(this, w, this._shape[1])
      return w
    }
  },
  height: {
    get: function() {
      return this._shape[1]
    },
    set: function(h) {
      h = h|0
      reshapeTexture(this, this._shape[0], h)
      return h
    }
  }
})

proto.bind = function(unit) {
  var gl = this.gl
  if(unit !== undefined) {
    gl.activeTexture(gl.TEXTURE0 + (unit|0))
  }
  gl.bindTexture(gl.TEXTURE_2D, this.handle)
  if(unit !== undefined) {
    return (unit|0)
  }
  return gl.getParameter(gl.ACTIVE_TEXTURE) - gl.TEXTURE0
}

proto.dispose = function() {
  this.gl.deleteTexture(this.handle)
}

proto.generateMipmap = function() {
  this.bind()
  this.gl.generateMipmap(this.gl.TEXTURE_2D)

  //Update mip levels
  var l = Math.min(this._shape[0], this._shape[1])
  for(var i=0; l>0; ++i, l>>>=1) {
    if(this._mipLevels.indexOf(i) < 0) {
      this._mipLevels.push(i)
    }
  }
}

proto.setPixels = function(data, x_off, y_off, mip_level) {
  var gl = this.gl
  this.bind()
  if(Array.isArray(x_off)) {
    mip_level = y_off
    y_off = x_off[1]|0
    x_off = x_off[0]|0
  } else {
    x_off = x_off || 0
    y_off = y_off || 0
  }
  mip_level = mip_level || 0
  var directData = acceptTextureDOM(data) ? data : data.raw
  if(directData) {
    var needsMip = this._mipLevels.indexOf(mip_level) < 0
    if(needsMip) {
      gl.texImage2D(gl.TEXTURE_2D, 0, this.format, this.format, this.type, directData)
      this._mipLevels.push(mip_level)
    } else {
      gl.texSubImage2D(gl.TEXTURE_2D, mip_level, x_off, y_off, this.format, this.type, directData)
    }
  } else if(data.shape && data.stride && data.data) {
    if(data.shape.length < 2 ||
       x_off + data.shape[1] > this._shape[1]>>>mip_level ||
       y_off + data.shape[0] > this._shape[0]>>>mip_level ||
       x_off < 0 ||
       y_off < 0) {
      throw new Error('gl-texture2d: Texture dimensions are out of bounds')
    }
    texSubImageArray(gl, x_off, y_off, mip_level, this.format, this.type, this._mipLevels, data)
  } else {
    throw new Error('gl-texture2d: Unsupported data type')
  }
}


function isPacked(shape, stride) {
  if(shape.length === 3) {
    return  (stride[2] === 1) &&
            (stride[1] === shape[0]*shape[2]) &&
            (stride[0] === shape[2])
  }
  return  (stride[0] === 1) &&
          (stride[1] === shape[0])
}

function texSubImageArray(gl, x_off, y_off, mip_level, cformat, ctype, mipLevels, array) {
  var dtype = array.dtype
  var shape = array.shape.slice()
  if(shape.length < 2 || shape.length > 3) {
    throw new Error('gl-texture2d: Invalid ndarray, must be 2d or 3d')
  }
  var type = 0, format = 0
  var packed = isPacked(shape, array.stride.slice())
  if(dtype === 'float32') {
    type = gl.FLOAT
  } else if(dtype === 'float64') {
    type = gl.FLOAT
    packed = false
    dtype = 'float32'
  } else if(dtype === 'uint8') {
    type = gl.UNSIGNED_BYTE
  } else {
    type = gl.UNSIGNED_BYTE
    packed = false
    dtype = 'uint8'
  }
  var channels = 1
  if(shape.length === 2) {
    format = gl.LUMINANCE
    shape = [shape[0], shape[1], 1]
    array = ndarray(array.data, shape, [array.stride[0], array.stride[1], 1], array.offset)
  } else if(shape.length === 3) {
    if(shape[2] === 1) {
      format = gl.ALPHA
    } else if(shape[2] === 2) {
      format = gl.LUMINANCE_ALPHA
    } else if(shape[2] === 3) {
      format = gl.RGB
    } else if(shape[2] === 4) {
      format = gl.RGBA
    } else {
      throw new Error('gl-texture2d: Invalid shape for pixel coords')
    }
    channels = shape[2]
  } else {
    throw new Error('gl-texture2d: Invalid shape for texture')
  }
  //For 1-channel textures allow conversion between formats
  if((format  === gl.LUMINANCE || format  === gl.ALPHA) &&
     (cformat === gl.LUMINANCE || cformat === gl.ALPHA)) {
    format = cformat
  }
  if(format !== cformat) {
    throw new Error('gl-texture2d: Incompatible texture format for setPixels')
  }
  var size = array.size
  var needsMip = mipLevels.indexOf(mip_level) < 0
  if(needsMip) {
    mipLevels.push(mip_level)
  }
  if(type === ctype && packed) {
    //Array data types are compatible, can directly copy into texture
    if(array.offset === 0 && array.data.length === size) {
      if(needsMip) {
        gl.texImage2D(gl.TEXTURE_2D, mip_level, cformat, shape[0], shape[1], 0, cformat, ctype, array.data)
      } else {
        gl.texSubImage2D(gl.TEXTURE_2D, mip_level, x_off, y_off, shape[0], shape[1], cformat, ctype, array.data)
      }
    } else {
      if(needsMip) {
        gl.texImage2D(gl.TEXTURE_2D, mip_level, cformat, shape[0], shape[1], 0, cformat, ctype, array.data.subarray(array.offset, array.offset+size))
      } else {
        gl.texSubImage2D(gl.TEXTURE_2D, mip_level, x_off, y_off, shape[0], shape[1], cformat, ctype, array.data.subarray(array.offset, array.offset+size))
      }
    }
  } else {
    //Need to do type conversion to pack data into buffer
    var pack_buffer
    if(ctype === gl.FLOAT) {
      pack_buffer = pool.mallocFloat32(size)
    } else {
      pack_buffer = pool.mallocUint8(size)
    }
    var pack_view = ndarray(pack_buffer, shape, [shape[2], shape[2]*shape[0], 1])
    if(type === gl.FLOAT && ctype === gl.UNSIGNED_BYTE) {
      convertFloatToUint8(pack_view, array)
    } else {
      ops.assign(pack_view, array)
    }
    if(needsMip) {
      gl.texImage2D(gl.TEXTURE_2D, mip_level, cformat, shape[0], shape[1], 0, cformat, ctype, pack_buffer.subarray(0, size))
    } else {
      gl.texSubImage2D(gl.TEXTURE_2D, mip_level, x_off, y_off, shape[0], shape[1], cformat, ctype, pack_buffer.subarray(0, size))
    }
    if(ctype === gl.FLOAT) {
      pool.freeFloat32(pack_buffer)
    } else {
      pool.freeUint8(pack_buffer)
    }
  }
}

function initTexture(gl) {
  var tex = gl.createTexture()
  gl.bindTexture(gl.TEXTURE_2D, tex)
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
  return tex
}

function createTextureShape(gl, width, height, format, type) {
  var maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE)
  if(width < 0 || width > maxTextureSize || height < 0 || height  > maxTextureSize) {
    throw new Error('gl-texture2d: Invalid texture shape')
  }
  if(type === gl.FLOAT && !gl.getExtension('OES_texture_float')) {
    throw new Error('gl-texture2d: Floating point textures not supported on this platform')
  }
  var tex = initTexture(gl)
  gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, 0, format, type, null)
  return new Texture2D(gl, tex, width, height, format, type)
}

function createTextureDOM(gl, directData, width, height, format, type) {
  var tex = initTexture(gl)
  gl.texImage2D(gl.TEXTURE_2D, 0, format, format, type, directData)
  return new Texture2D(gl, tex, width, height, format, type)
}

//Creates a texture from an ndarray
function createTextureArray(gl, array) {
  var dtype = array.dtype
  var shape = array.shape.slice()
  var maxSize = gl.getParameter(gl.MAX_TEXTURE_SIZE)
  if(shape[0] < 0 || shape[0] > maxSize || shape[1] < 0 || shape[1] > maxSize) {
    throw new Error('gl-texture2d: Invalid texture size')
  }
  var packed = isPacked(shape, array.stride.slice())
  var type = 0
  if(dtype === 'float32') {
    type = gl.FLOAT
  } else if(dtype === 'float64') {
    type = gl.FLOAT
    packed = false
    dtype = 'float32'
  } else if(dtype === 'uint8') {
    type = gl.UNSIGNED_BYTE
  } else {
    type = gl.UNSIGNED_BYTE
    packed = false
    dtype = 'uint8'
  }
  var format = 0
  if(shape.length === 2) {
    format = gl.LUMINANCE
    shape = [shape[0], shape[1], 1]
    array = ndarray(array.data, shape, [array.stride[0], array.stride[1], 1], array.offset)
  } else if(shape.length === 3) {
    if(shape[2] === 1) {
      format = gl.ALPHA
    } else if(shape[2] === 2) {
      format = gl.LUMINANCE_ALPHA
    } else if(shape[2] === 3) {
      format = gl.RGB
    } else if(shape[2] === 4) {
      format = gl.RGBA
    } else {
      throw new Error('gl-texture2d: Invalid shape for pixel coords')
    }
  } else {
    throw new Error('gl-texture2d: Invalid shape for texture')
  }
  if(type === gl.FLOAT && !gl.getExtension('OES_texture_float')) {
    type = gl.UNSIGNED_BYTE
    packed = false
  }
  var buffer, buf_store
  var size = array.size
  if(!packed) {
    var stride = [shape[2], shape[2]*shape[0], 1]
    buf_store = pool.malloc(size, dtype)
    var buf_array = ndarray(buf_store, shape, stride, 0)
    if((dtype === 'float32' || dtype === 'float64') && type === gl.UNSIGNED_BYTE) {
      convertFloatToUint8(buf_array, array)
    } else {
      ops.assign(buf_array, array)
    }
    buffer = buf_store.subarray(0, size)
  } else if (array.offset === 0 && array.data.length === size) {
    buffer = array.data
  } else {
    buffer = array.data.subarray(array.offset, array.offset + size)
  }
  var tex = initTexture(gl)
  gl.texImage2D(gl.TEXTURE_2D, 0, format, shape[0], shape[1], 0, format, type, buffer)
  if(!packed) {
    pool.free(buf_store)
  }
  return new Texture2D(gl, tex, shape[0], shape[1], format, type)
}

function createTexture2D(gl) {
  if(arguments.length <= 1) {
    throw new Error('gl-texture2d: Missing arguments for texture2d constructor')
  }
  if(!linearTypes) {
    lazyInitLinearTypes(gl)
  }
  if(typeof arguments[1] === 'number') {
    return createTextureShape(gl, arguments[1], arguments[2], arguments[3]||gl.RGBA, arguments[4]||gl.UNSIGNED_BYTE)
  }
  if(Array.isArray(arguments[1])) {
    return createTextureShape(gl, arguments[1][0]|0, arguments[1][1]|0, arguments[2]||gl.RGBA, arguments[3]||gl.UNSIGNED_BYTE)
  }
  if(typeof arguments[1] === 'object') {
    var obj = arguments[1]
    var directData = acceptTextureDOM(obj) ? obj : obj.raw
    if (directData) {
      return createTextureDOM(gl, directData, obj.width|0, obj.height|0, arguments[2]||gl.RGBA, arguments[3]||gl.UNSIGNED_BYTE)
    } else if(obj.shape && obj.data && obj.stride) {
      return createTextureArray(gl, obj)
    }
  }
  throw new Error('gl-texture2d: Invalid arguments for texture2d constructor')
}

},{"ndarray":165,"ndarray-ops":162,"typedarray-pool":189}],74:[function(require,module,exports){
module.exports = add;

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function add(out, a, b) {
    out[0] = a[0] + b[0]
    out[1] = a[1] + b[1]
    out[2] = a[2] + b[2]
    return out
}
},{}],75:[function(require,module,exports){
module.exports = angle

var fromValues = require('./fromValues')
var normalize = require('./normalize')
var dot = require('./dot')

/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */
function angle(a, b) {
    var tempA = fromValues(a[0], a[1], a[2])
    var tempB = fromValues(b[0], b[1], b[2])
 
    normalize(tempA, tempA)
    normalize(tempB, tempB)
 
    var cosine = dot(tempA, tempB)

    if(cosine > 1.0){
        return 0
    } else {
        return Math.acos(cosine)
    }     
}

},{"./dot":85,"./fromValues":91,"./normalize":102}],76:[function(require,module,exports){
module.exports = ceil

/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */
function ceil(out, a) {
  out[0] = Math.ceil(a[0])
  out[1] = Math.ceil(a[1])
  out[2] = Math.ceil(a[2])
  return out
}

},{}],77:[function(require,module,exports){
module.exports = clone;

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
function clone(a) {
    var out = new Float32Array(3)
    out[0] = a[0]
    out[1] = a[1]
    out[2] = a[2]
    return out
}
},{}],78:[function(require,module,exports){
module.exports = copy;

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */
function copy(out, a) {
    out[0] = a[0]
    out[1] = a[1]
    out[2] = a[2]
    return out
}
},{}],79:[function(require,module,exports){
module.exports = create;

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
function create() {
    var out = new Float32Array(3)
    out[0] = 0
    out[1] = 0
    out[2] = 0
    return out
}
},{}],80:[function(require,module,exports){
module.exports = cross;

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function cross(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2],
        bx = b[0], by = b[1], bz = b[2]

    out[0] = ay * bz - az * by
    out[1] = az * bx - ax * bz
    out[2] = ax * by - ay * bx
    return out
}
},{}],81:[function(require,module,exports){
module.exports = require('./distance')

},{"./distance":82}],82:[function(require,module,exports){
module.exports = distance;

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */
function distance(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2]
    return Math.sqrt(x*x + y*y + z*z)
}
},{}],83:[function(require,module,exports){
module.exports = require('./divide')

},{"./divide":84}],84:[function(require,module,exports){
module.exports = divide;

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function divide(out, a, b) {
    out[0] = a[0] / b[0]
    out[1] = a[1] / b[1]
    out[2] = a[2] / b[2]
    return out
}
},{}],85:[function(require,module,exports){
module.exports = dot;

/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]
}
},{}],86:[function(require,module,exports){
module.exports = 0.000001

},{}],87:[function(require,module,exports){
module.exports = equals

var EPSILON = require('./epsilon')

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function equals(a, b) {
  var a0 = a[0]
  var a1 = a[1]
  var a2 = a[2]
  var b0 = b[0]
  var b1 = b[1]
  var b2 = b[2]
  return (Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)))
}

},{"./epsilon":86}],88:[function(require,module,exports){
module.exports = exactEquals

/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2]
}

},{}],89:[function(require,module,exports){
module.exports = floor

/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */
function floor(out, a) {
  out[0] = Math.floor(a[0])
  out[1] = Math.floor(a[1])
  out[2] = Math.floor(a[2])
  return out
}

},{}],90:[function(require,module,exports){
module.exports = forEach;

var vec = require('./create')()

/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
function forEach(a, stride, offset, count, fn, arg) {
        var i, l
        if(!stride) {
            stride = 3
        }

        if(!offset) {
            offset = 0
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length)
        } else {
            l = a.length
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i] 
            vec[1] = a[i+1] 
            vec[2] = a[i+2]
            fn(vec, vec, arg)
            a[i] = vec[0] 
            a[i+1] = vec[1] 
            a[i+2] = vec[2]
        }
        
        return a
}
},{"./create":79}],91:[function(require,module,exports){
module.exports = fromValues;

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
function fromValues(x, y, z) {
    var out = new Float32Array(3)
    out[0] = x
    out[1] = y
    out[2] = z
    return out
}
},{}],92:[function(require,module,exports){
module.exports = {
  EPSILON: require('./epsilon')
  , create: require('./create')
  , clone: require('./clone')
  , angle: require('./angle')
  , fromValues: require('./fromValues')
  , copy: require('./copy')
  , set: require('./set')
  , equals: require('./equals')
  , exactEquals: require('./exactEquals')
  , add: require('./add')
  , subtract: require('./subtract')
  , sub: require('./sub')
  , multiply: require('./multiply')
  , mul: require('./mul')
  , divide: require('./divide')
  , div: require('./div')
  , min: require('./min')
  , max: require('./max')
  , floor: require('./floor')
  , ceil: require('./ceil')
  , round: require('./round')
  , scale: require('./scale')
  , scaleAndAdd: require('./scaleAndAdd')
  , distance: require('./distance')
  , dist: require('./dist')
  , squaredDistance: require('./squaredDistance')
  , sqrDist: require('./sqrDist')
  , length: require('./length')
  , len: require('./len')
  , squaredLength: require('./squaredLength')
  , sqrLen: require('./sqrLen')
  , negate: require('./negate')
  , inverse: require('./inverse')
  , normalize: require('./normalize')
  , dot: require('./dot')
  , cross: require('./cross')
  , lerp: require('./lerp')
  , random: require('./random')
  , transformMat4: require('./transformMat4')
  , transformMat3: require('./transformMat3')
  , transformQuat: require('./transformQuat')
  , rotateX: require('./rotateX')
  , rotateY: require('./rotateY')
  , rotateZ: require('./rotateZ')
  , forEach: require('./forEach')
}

},{"./add":74,"./angle":75,"./ceil":76,"./clone":77,"./copy":78,"./create":79,"./cross":80,"./dist":81,"./distance":82,"./div":83,"./divide":84,"./dot":85,"./epsilon":86,"./equals":87,"./exactEquals":88,"./floor":89,"./forEach":90,"./fromValues":91,"./inverse":93,"./len":94,"./length":95,"./lerp":96,"./max":97,"./min":98,"./mul":99,"./multiply":100,"./negate":101,"./normalize":102,"./random":103,"./rotateX":104,"./rotateY":105,"./rotateZ":106,"./round":107,"./scale":108,"./scaleAndAdd":109,"./set":110,"./sqrDist":111,"./sqrLen":112,"./squaredDistance":113,"./squaredLength":114,"./sub":115,"./subtract":116,"./transformMat3":117,"./transformMat4":118,"./transformQuat":119}],93:[function(require,module,exports){
module.exports = inverse;

/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */
function inverse(out, a) {
  out[0] = 1.0 / a[0]
  out[1] = 1.0 / a[1]
  out[2] = 1.0 / a[2]
  return out
}
},{}],94:[function(require,module,exports){
module.exports = require('./length')

},{"./length":95}],95:[function(require,module,exports){
module.exports = length;

/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
function length(a) {
    var x = a[0],
        y = a[1],
        z = a[2]
    return Math.sqrt(x*x + y*y + z*z)
}
},{}],96:[function(require,module,exports){
module.exports = lerp;

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
function lerp(out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2]
    out[0] = ax + t * (b[0] - ax)
    out[1] = ay + t * (b[1] - ay)
    out[2] = az + t * (b[2] - az)
    return out
}
},{}],97:[function(require,module,exports){
module.exports = max;

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function max(out, a, b) {
    out[0] = Math.max(a[0], b[0])
    out[1] = Math.max(a[1], b[1])
    out[2] = Math.max(a[2], b[2])
    return out
}
},{}],98:[function(require,module,exports){
module.exports = min;

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function min(out, a, b) {
    out[0] = Math.min(a[0], b[0])
    out[1] = Math.min(a[1], b[1])
    out[2] = Math.min(a[2], b[2])
    return out
}
},{}],99:[function(require,module,exports){
module.exports = require('./multiply')

},{"./multiply":100}],100:[function(require,module,exports){
module.exports = multiply;

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function multiply(out, a, b) {
    out[0] = a[0] * b[0]
    out[1] = a[1] * b[1]
    out[2] = a[2] * b[2]
    return out
}
},{}],101:[function(require,module,exports){
module.exports = negate;

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */
function negate(out, a) {
    out[0] = -a[0]
    out[1] = -a[1]
    out[2] = -a[2]
    return out
}
},{}],102:[function(require,module,exports){
module.exports = normalize;

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
function normalize(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2]
    var len = x*x + y*y + z*z
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len)
        out[0] = a[0] * len
        out[1] = a[1] * len
        out[2] = a[2] * len
    }
    return out
}
},{}],103:[function(require,module,exports){
module.exports = random;

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */
function random(out, scale) {
    scale = scale || 1.0

    var r = Math.random() * 2.0 * Math.PI
    var z = (Math.random() * 2.0) - 1.0
    var zScale = Math.sqrt(1.0-z*z) * scale

    out[0] = Math.cos(r) * zScale
    out[1] = Math.sin(r) * zScale
    out[2] = z * scale
    return out
}
},{}],104:[function(require,module,exports){
module.exports = rotateX;

/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateX(out, a, b, c){
    var by = b[1]
    var bz = b[2]

    // Translate point to the origin
    var py = a[1] - by
    var pz = a[2] - bz

    var sc = Math.sin(c)
    var cc = Math.cos(c)

    // perform rotation and translate to correct position
    out[0] = a[0]
    out[1] = by + py * cc - pz * sc
    out[2] = bz + py * sc + pz * cc

    return out
}

},{}],105:[function(require,module,exports){
module.exports = rotateY;

/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateY(out, a, b, c){
    var bx = b[0]
    var bz = b[2]

    // translate point to the origin
    var px = a[0] - bx
    var pz = a[2] - bz
    
    var sc = Math.sin(c)
    var cc = Math.cos(c)
  
    // perform rotation and translate to correct position
    out[0] = bx + pz * sc + px * cc
    out[1] = a[1]
    out[2] = bz + pz * cc - px * sc
  
    return out
}

},{}],106:[function(require,module,exports){
module.exports = rotateZ;

/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateZ(out, a, b, c){
    var bx = b[0]
    var by = b[1]

    //Translate point to the origin
    var px = a[0] - bx
    var py = a[1] - by
  
    var sc = Math.sin(c)
    var cc = Math.cos(c)

    // perform rotation and translate to correct position
    out[0] = bx + px * cc - py * sc
    out[1] = by + px * sc + py * cc
    out[2] = a[2]
  
    return out
}

},{}],107:[function(require,module,exports){
module.exports = round

/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */
function round(out, a) {
  out[0] = Math.round(a[0])
  out[1] = Math.round(a[1])
  out[2] = Math.round(a[2])
  return out
}

},{}],108:[function(require,module,exports){
module.exports = scale;

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
function scale(out, a, b) {
    out[0] = a[0] * b
    out[1] = a[1] * b
    out[2] = a[2] * b
    return out
}
},{}],109:[function(require,module,exports){
module.exports = scaleAndAdd;

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
function scaleAndAdd(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale)
    out[1] = a[1] + (b[1] * scale)
    out[2] = a[2] + (b[2] * scale)
    return out
}
},{}],110:[function(require,module,exports){
module.exports = set;

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
function set(out, x, y, z) {
    out[0] = x
    out[1] = y
    out[2] = z
    return out
}
},{}],111:[function(require,module,exports){
module.exports = require('./squaredDistance')

},{"./squaredDistance":113}],112:[function(require,module,exports){
module.exports = require('./squaredLength')

},{"./squaredLength":114}],113:[function(require,module,exports){
module.exports = squaredDistance;

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2]
    return x*x + y*y + z*z
}
},{}],114:[function(require,module,exports){
module.exports = squaredLength;

/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength(a) {
    var x = a[0],
        y = a[1],
        z = a[2]
    return x*x + y*y + z*z
}
},{}],115:[function(require,module,exports){
module.exports = require('./subtract')

},{"./subtract":116}],116:[function(require,module,exports){
module.exports = subtract;

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function subtract(out, a, b) {
    out[0] = a[0] - b[0]
    out[1] = a[1] - b[1]
    out[2] = a[2] - b[2]
    return out
}
},{}],117:[function(require,module,exports){
module.exports = transformMat3;

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
function transformMat3(out, a, m) {
    var x = a[0], y = a[1], z = a[2]
    out[0] = x * m[0] + y * m[3] + z * m[6]
    out[1] = x * m[1] + y * m[4] + z * m[7]
    out[2] = x * m[2] + y * m[5] + z * m[8]
    return out
}
},{}],118:[function(require,module,exports){
module.exports = transformMat4;

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
function transformMat4(out, a, m) {
    var x = a[0], y = a[1], z = a[2],
        w = m[3] * x + m[7] * y + m[11] * z + m[15]
    w = w || 1.0
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w
    return out
}
},{}],119:[function(require,module,exports){
module.exports = transformQuat;

/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */
function transformQuat(out, a, q) {
    // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx
    return out
}
},{}],120:[function(require,module,exports){
module.exports = function(strings) {
  if (typeof strings === 'string') strings = [strings]
  var exprs = [].slice.call(arguments,1)
  var parts = []
  for (var i = 0; i < strings.length-1; i++) {
    parts.push(strings[i], exprs[i] || '')
  }
  parts.push(strings[i])
  return parts.join('')
}

},{}],121:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],122:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],123:[function(require,module,exports){
"use strict"

function iota(n) {
  var result = new Array(n)
  for(var i=0; i<n; ++i) {
    result[i] = i
  }
  return result
}

module.exports = iota
},{}],124:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],125:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],126:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CodeBuilder = exports.bufferSamplerName = void 0;
const expr_1 = require("./expressions/expr");
const webglprogramloop_1 = require("./webglprogramloop");
const FRAG_SET = `  gl_FragColor = texture2D(uSampler, gl_FragCoord.xy / uResolution);\n`;
const SCENE_SET = `uniform sampler2D uSceneSampler;\n`;
const TIME_SET = `uniform mediump float uTime;\n`;
const BOILERPLATE = `#ifdef GL_ES
precision mediump float;
#endif

uniform sampler2D uSampler;
uniform mediump vec2 uResolution;\n`;
function bufferSamplerName(buf) {
    // texture 2 sampler has number 0 (0 and 1 are used for back buffer and scene)
    return `uBufferSampler${buf}`;
}
exports.bufferSamplerName = bufferSamplerName;
function bufferSamplerDeclaration(buf) {
    return `uniform sampler2D ${bufferSamplerName(buf)};`;
}
class CodeBuilder {
    constructor(effectLoop) {
        this.calls = [];
        this.externalFuncs = new Set();
        this.uniformDeclarations = new Set();
        this.counter = 0;
        this.baseLoop = effectLoop;
        const buildInfo = {
            uniformTypes: {},
            externalFuncs: new Set(),
            exprs: [],
            needs: {
                centerSample: false,
                neighborSample: false,
                sceneBuffer: false,
                timeUniform: false,
                extraBuffers: new Set(),
            },
        };
        this.addEffectLoop(effectLoop, 1, buildInfo);
        // add all the types to uniform declarations from the `BuildInfo` instance
        for (const name in buildInfo.uniformTypes) {
            const typeName = buildInfo.uniformTypes[name];
            this.uniformDeclarations.add(`uniform mediump ${typeName} ${name};`);
        }
        //this.uniformNames = Object.keys(buildInfo.uniformTypes);
        // add all external functions from the `BuildInfo` instance
        buildInfo.externalFuncs.forEach((func) => this.externalFuncs.add(func));
        this.totalNeeds = buildInfo.needs;
        this.exprs = buildInfo.exprs;
    }
    addEffectLoop(effectLoop, indentLevel, buildInfo, topLevel = true) {
        const needsLoop = !topLevel && effectLoop.repeat.num > 1;
        if (needsLoop) {
            const iName = "i" + this.counter;
            indentLevel++;
            const forStart = "  ".repeat(indentLevel - 1) +
                `for (int ${iName} = 0; ${iName} < ${effectLoop.repeat.num}; ${iName}++) {`;
            this.calls.push(forStart);
        }
        for (const e of effectLoop.effects) {
            if (e instanceof expr_1.Expr) {
                e.parse(buildInfo);
                this.calls.push("  ".repeat(indentLevel) + "gl_FragColor = " + e.sourceCode + ";");
                this.counter++;
            }
            else {
                this.addEffectLoop(e, indentLevel, buildInfo, false);
            }
        }
        if (needsLoop) {
            this.calls.push("  ".repeat(indentLevel - 1) + "}");
        }
    }
    compileProgram(gl, vShader, uniformLocs) {
        // set up the fragment shader
        const fShader = gl.createShader(gl.FRAGMENT_SHADER);
        if (fShader === null) {
            throw new Error("problem creating fragment shader");
        }
        const fullCode = BOILERPLATE +
            (this.totalNeeds.sceneBuffer ? SCENE_SET : "") +
            (this.totalNeeds.timeUniform ? TIME_SET : "") +
            Array.from(this.totalNeeds.extraBuffers)
                .map((n) => bufferSamplerDeclaration(n))
                .join("\n") +
            "\n" +
            [...this.uniformDeclarations].join("\n") +
            "\n" +
            [...this.externalFuncs].join("\n") +
            "\n" +
            "void main() {\n" +
            (this.totalNeeds.centerSample ? FRAG_SET : "") +
            this.calls.join("\n") +
            "\n}";
        gl.shaderSource(fShader, fullCode);
        gl.compileShader(fShader);
        // set up the program
        const program = gl.createProgram();
        if (program === null) {
            throw new Error("problem creating program");
        }
        gl.attachShader(program, vShader);
        gl.attachShader(program, fShader);
        const shaderLog = (name, shader) => {
            const output = gl.getShaderInfoLog(shader);
            if (output)
                console.log(`${name} shader info log\n${output}`);
        };
        shaderLog("vertex", vShader);
        shaderLog("fragment", fShader);
        gl.linkProgram(program);
        // we need to use the program here so we can get uniform locations
        gl.useProgram(program);
        console.log(fullCode);
        // find all uniform locations and add them to the dictionary
        for (const expr of this.exprs) {
            for (const name in expr.uniformValChangeMap) {
                const location = gl.getUniformLocation(program, name);
                if (location === null) {
                    throw new Error("couldn't find uniform " + name);
                }
                // TODO enforce unique names in the same program
                if (uniformLocs[name] === undefined) {
                    uniformLocs[name] = { locs: [], counter: 0 };
                }
                // assign the name to the location
                uniformLocs[name].locs.push(location);
            }
        }
        // set the uniform resolution (every program has this uniform)
        const uResolution = gl.getUniformLocation(program, "uResolution");
        gl.uniform2f(uResolution, gl.drawingBufferWidth, gl.drawingBufferHeight);
        if (this.totalNeeds.sceneBuffer) {
            // TODO allow for texture options for scene texture
            const location = gl.getUniformLocation(program, "uSceneSampler");
            // put the scene buffer in texture 1 (0 is used for the backbuffer)
            gl.uniform1i(location, 1);
        }
        // set all sampler uniforms
        for (const b of this.totalNeeds.extraBuffers) {
            const location = gl.getUniformLocation(program, bufferSamplerName(b));
            // offset the texture location by 2 (0 and 1 are used for scene and original)
            gl.uniform1i(location, b + 2);
        }
        // get attribute
        const position = gl.getAttribLocation(program, "aPosition");
        // enable the attribute
        gl.enableVertexAttribArray(position);
        // points to the vertices in the last bound array buffer
        gl.vertexAttribPointer(position, 2, gl.FLOAT, false, 0, 0);
        return new webglprogramloop_1.WebGLProgramLoop(program, this.baseLoop.repeat, gl, this.totalNeeds, this.exprs);
    }
}
exports.CodeBuilder = CodeBuilder;

},{"./expressions/expr":137,"./webglprogramloop":161}],127:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.a1 = exports.Arity1HomogenousExpr = void 0;
const expr_1 = require("./expr");
function genArity1SourceList(name, val) {
    return {
        sections: [name + "(", ")"],
        values: [val],
    };
}
class Arity1HomogenousExpr extends expr_1.Operator {
    constructor(val, operation) {
        super(val, genArity1SourceList(operation, val), ["uVal"]);
        this.val = val;
    }
    setVal(right) {
        this.setUniform("uVal" + this.id, right);
    }
}
exports.Arity1HomogenousExpr = Arity1HomogenousExpr;
function a1(name, val) {
    return new Arity1HomogenousExpr(expr_1.wrapInValue(val), name);
}
exports.a1 = a1;

},{"./expr":137}],128:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.a2 = exports.Arity2HomogenousExpr = void 0;
const expr_1 = require("./expr");
function genArity1SourceList(name, val1, val2) {
    return {
        sections: [name + "(", ",", ")"],
        values: [val1, val2],
    };
}
class Arity2HomogenousExpr extends expr_1.Operator {
    constructor(name, val1, val2) {
        super(val1, genArity1SourceList(name, val1, val2), ["uBase", "uExponent"]);
    }
    setFirstVal(left) {
        this.setUniform("uBase" + this.id, left);
    }
    setSecondVal(right) {
        this.setUniform("uExponent" + this.id, right);
    }
}
exports.Arity2HomogenousExpr = Arity2HomogenousExpr;
// implementation
function a2(name, val1, val2) {
    return new Arity2HomogenousExpr(name, expr_1.wrapInValue(val1), expr_1.wrapInValue(val2));
}
exports.a2 = a2;

},{"./expr":137}],129:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.blur2d = exports.Blur2dLoop = void 0;
const mergepass_1 = require("../mergepass");
const blurexpr_1 = require("./blurexpr");
const expr_1 = require("./expr");
const vecexprs_1 = require("./vecexprs");
class Blur2dLoop extends mergepass_1.EffectLoop {
    constructor(horizontalExpr, verticalExpr, reps = 2, taps) {
        const side = blurexpr_1.gauss(vecexprs_1.vec2(horizontalExpr, 0), taps);
        const up = blurexpr_1.gauss(vecexprs_1.vec2(0, verticalExpr), taps);
        super([side, up], { num: reps });
    }
}
exports.Blur2dLoop = Blur2dLoop;
function blur2d(horizontalExpr, verticalExpr, reps, taps) {
    return new Blur2dLoop(expr_1.n2e(horizontalExpr), expr_1.n2e(verticalExpr), reps, taps);
}
exports.blur2d = blur2d;

},{"../mergepass":160,"./blurexpr":130,"./expr":137,"./vecexprs":156}],130:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.gauss = exports.BlurExpr = void 0;
const glslfunctions_1 = require("../glslfunctions");
const expr_1 = require("./expr");
function genBlurSource(direction, taps, buffer) {
    return {
        sections: [`gauss${taps}${buffer === undefined ? "" : "_" + buffer}(`, ")"],
        values: [direction],
    };
}
function tapsToFuncSource(taps) {
    switch (taps) {
        case 5:
            return glslfunctions_1.glslFuncs.gauss5;
        case 9:
            return glslfunctions_1.glslFuncs.gauss9;
        case 13:
            return glslfunctions_1.glslFuncs.gauss13;
    }
}
class BlurExpr extends expr_1.ExprVec4 {
    constructor(direction, taps = 5, samplerNum) {
        // this is already guaranteed by typescript
        if (![5, 9, 13].includes(taps)) {
            throw new Error("taps for gauss blur can only be 5, 9 or 13");
        }
        super(genBlurSource(direction, taps, samplerNum), ["uDirection"]);
        if (samplerNum === undefined) {
            this.needs.neighborSample = true;
            this.externalFuncs = [tapsToFuncSource(taps)];
        }
        else {
            this.needs.extraBuffers = new Set([samplerNum]);
            console.log("taps", taps);
            console.log("samplerNum", samplerNum);
            this.externalFuncs = [
                glslfunctions_1.replaceSampler(tapsToFuncSource(taps), /vec4\sgauss[0-9]+/g, samplerNum),
            ];
        }
    }
    setDirection(direction) {
        this.setUniform("uDirection" + this.id, direction);
    }
}
exports.BlurExpr = BlurExpr;
function gauss(direction, taps = 5, samplerNum) {
    return new BlurExpr(direction, taps, samplerNum);
}
exports.gauss = gauss;

},{"../glslfunctions":158,"./expr":137}],131:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.brightness = exports.Brightness = void 0;
const glslfunctions_1 = require("../glslfunctions");
const expr_1 = require("./expr");
const fragcolorexpr_1 = require("./fragcolorexpr");
class Brightness extends expr_1.ExprVec4 {
    constructor(val, col = fragcolorexpr_1.fcolor()) {
        super(expr_1.tag `(brightness(${val}, ${col}))`, ["uBrightness", "uColor"]);
        this.externalFuncs = [glslfunctions_1.glslFuncs.brightness];
    }
    setBrightness(brightness) {
        this.setUniform("uBrightness" + this.id, brightness);
    }
}
exports.Brightness = Brightness;
function brightness(val, col) {
    return new Brightness(expr_1.n2e(val), col);
}
exports.brightness = brightness;

},{"../glslfunctions":158,"./expr":137,"./fragcolorexpr":138}],132:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.channel = exports.BufferSampleExpr = void 0;
const codebuilder_1 = require("../codebuilder");
const expr_1 = require("./expr");
const normfragcoordexpr_1 = require("./normfragcoordexpr");
function genBufferSamplerSource(buf, coord) {
    return {
        sections: [`texture2D(${codebuilder_1.bufferSamplerName(buf)}, `, `)`],
        values: [coord],
    };
}
class BufferSampleExpr extends expr_1.ExprVec4 {
    constructor(buf, coord = normfragcoordexpr_1.nfcoord()) {
        super(genBufferSamplerSource(buf, coord), ["uVec"]);
        this.needs.extraBuffers = new Set([buf]);
    }
}
exports.BufferSampleExpr = BufferSampleExpr;
function channel(channel, vec) {
    return new BufferSampleExpr(channel, vec);
}
exports.channel = channel;

},{"../codebuilder":126,"./expr":137,"./normfragcoordexpr":147}],133:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.changecomp = exports.ChangeCompExpr = void 0;
const expr_1 = require("./expr");
const getcompexpr_1 = require("./getcompexpr");
function getChangeFunc(typ, id, setter, comps, op = "") {
    return `${typ} changecomp_${id}(${typ} col, ${setter.typeString()} setter) {
  col.${comps} ${op}= setter;
  return col;
}`;
}
function checkGetComponents(comps, setter, vec) {
    // setter has different length than components
    if (comps.length !== getcompexpr_1.typeStringToLength(setter.typeString())) {
        throw new Error("components length must be equal to the target float/vec");
    }
    // duplicate components
    if (duplicateComponents(comps)) {
        throw new Error("duplicate components not allowed on left side");
    }
    // legal components
    getcompexpr_1.checkLegalComponents(comps, vec);
}
function duplicateComponents(comps) {
    return new Set(comps.split("")).size !== comps.length;
}
class ChangeCompExpr extends expr_1.Operator {
    constructor(vec, setter, comps, op) {
        checkGetComponents(comps, setter, vec);
        // part of name of custom function
        const suffix = `${vec.typeString()}_${setter.typeString()}_${comps}`;
        super(vec, { sections: [`changecomp_${suffix}(`, ", ", ")"], values: [vec, setter] }, ["uOriginal", "uNew"]);
        this.externalFuncs = [
            getChangeFunc(vec.typeString(), suffix, setter, comps, op),
        ];
    }
    setOriginal(vec) {
        this.setUniform("uOriginal" + this.id, vec);
    }
    setNew(setter) {
        this.setUniform("uNew" + this.id, setter);
    }
}
exports.ChangeCompExpr = ChangeCompExpr;
function changecomp(vec, setter, comps, op) {
    return new ChangeCompExpr(vec, expr_1.wrapInValue(setter), comps, op);
}
exports.changecomp = changecomp;

},{"./expr":137,"./getcompexpr":141}],134:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.contrast = exports.Contrast = void 0;
const glslfunctions_1 = require("../glslfunctions");
const expr_1 = require("./expr");
const fragcolorexpr_1 = require("./fragcolorexpr");
class Contrast extends expr_1.ExprVec4 {
    constructor(val, col = fragcolorexpr_1.fcolor()) {
        super(expr_1.tag `contrast(${val}, ${col})`, ["uVal", "uCol"]);
        this.externalFuncs = [glslfunctions_1.glslFuncs.contrast];
    }
    setContrast(contrast) {
        this.setUniform("uContrast" + this.id, contrast);
    }
}
exports.Contrast = Contrast;
function contrast(val, col) {
    return new Contrast(expr_1.n2e(val), col);
}
exports.contrast = contrast;

},{"../glslfunctions":158,"./expr":137,"./fragcolorexpr":138}],135:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.depth2occlusion = exports.DepthToOcclusionExpr = void 0;
const expr_1 = require("./expr");
const vecexprs_1 = require("./vecexprs");
const buffersampleexpr_1 = require("./buffersampleexpr");
// TODO reconsider whether we need this
class DepthToOcclusionExpr extends expr_1.ExprVec4 {
    constructor(depthCol = buffersampleexpr_1.channel(0), newCol = vecexprs_1.vec4(1, 1, 1, 1), threshold = expr_1.float(0.01)) {
        super(expr_1.tag `depth2occlusion(${depthCol}, ${newCol}, ${threshold})`, [
            "uDepth",
            "uNewCol",
            "uThreshold",
        ]);
    }
}
exports.DepthToOcclusionExpr = DepthToOcclusionExpr;
function depth2occlusion(depthCol, newCol, threshold) {
    return new DepthToOcclusionExpr(depthCol, newCol, expr_1.n2e(threshold));
}
exports.depth2occlusion = depth2occlusion;

},{"./buffersampleexpr":132,"./expr":137,"./vecexprs":156}],136:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.dof = exports.DoFLoop = void 0;
const mergepass_1 = require("../mergepass");
const blurexpr_1 = require("./blurexpr");
const buffersampleexpr_1 = require("./buffersampleexpr");
const expr_1 = require("./expr");
const gaussianexpr_1 = require("./gaussianexpr");
const getcompexpr_1 = require("./getcompexpr");
const opexpr_1 = require("./opexpr");
const arity2_1 = require("./arity2");
const vecexprs_1 = require("./vecexprs");
class DoFLoop extends mergepass_1.EffectLoop {
    constructor(focus = expr_1.mut(expr_1.pfloat(0.3)), rad = expr_1.mut(expr_1.pfloat(0.01)), depth = getcompexpr_1.getcomp(buffersampleexpr_1.channel(0), "r"), reps = 2) {
        let guassianExpr = gaussianexpr_1.gaussian(depth, focus, rad);
        // TODO optional taps number
        const side = blurexpr_1.gauss(vecexprs_1.vec2(arity2_1.a2("pow", opexpr_1.op(1, "-", guassianExpr), 4), 0), 13);
        const up = blurexpr_1.gauss(vecexprs_1.vec2(0, arity2_1.a2("pow", opexpr_1.op(1, "-", guassianExpr), 4)), 13);
        super([side, up], { num: reps });
        this.gaussian = guassianExpr;
    }
    setDepth(depth) {
        // this translates the gaussian curve to the side
        this.gaussian.setA(depth);
    }
    setRadius(radius) {
        // this scales the gaussian curve to focus on a larger band of depth
        this.gaussian.setB(radius);
    }
}
exports.DoFLoop = DoFLoop;
function dof(focus, rad, depth, reps) {
    return new DoFLoop(expr_1.n2e(focus), expr_1.n2e(rad), expr_1.n2e(depth), reps);
}
exports.dof = dof;

},{"../mergepass":160,"./arity2":128,"./blurexpr":130,"./buffersampleexpr":132,"./expr":137,"./gaussianexpr":140,"./getcompexpr":141,"./opexpr":148,"./vecexprs":156}],137:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tag = exports.wrapInValue = exports.pfloat = exports.n2p = exports.n2e = exports.Operator = exports.ExprVec4 = exports.ExprVec3 = exports.ExprVec2 = exports.float = exports.ExprFloat = exports.BasicFloat = exports.ExprVec = exports.BasicVec4 = exports.BasicVec3 = exports.BasicVec2 = exports.BasicVec = exports.PrimitiveVec4 = exports.PrimitiveVec3 = exports.PrimitiveVec2 = exports.PrimitiveVec = exports.PrimitiveFloat = exports.Primitive = exports.mut = exports.Mutable = exports.Expr = void 0;
const mergepass_1 = require("../mergepass");
const webglprogramloop_1 = require("../webglprogramloop");
function toGLSLFloatString(num) {
    let str = "" + num;
    if (!str.includes("."))
        str += ".";
    return str;
}
class Expr {
    constructor(sourceLists, defaultNames) {
        this.needs = {
            neighborSample: false,
            centerSample: false,
            sceneBuffer: false,
            timeUniform: false,
            extraBuffers: new Set(),
        };
        this.uniformValChangeMap = {};
        this.defaultNameMap = {};
        this.externalFuncs = [];
        this.sourceCode = "";
        this.id = "_id_" + Expr.count;
        Expr.count++;
        if (sourceLists.sections.length - sourceLists.values.length !== 1) {
            // this cannot happen if you use `tag` to destructure a template string
            throw new Error("wrong lengths for source and values");
        }
        if (sourceLists.values.length !== defaultNames.length) {
            throw new Error("default names list length doesn't match values list length");
        }
        this.sourceLists = sourceLists;
        this.defaultNames = defaultNames;
    }
    applyUniforms(gl, uniformLocs) {
        for (const name in this.uniformValChangeMap) {
            const loc = uniformLocs[name];
            if (this.uniformValChangeMap[name].changed) {
                //this.uniformValChangeMap[name].changed = false;
                this.uniformValChangeMap[name].val.applyUniform(gl, loc.locs[loc.counter]);
            }
            // increment and reset the counter to wrap back around to first location
            loc.counter++;
            loc.counter %= loc.locs.length;
            // once we have wrapped then we know all uniforms have been changed
            if (loc.counter === 0) {
                this.uniformValChangeMap[name].changed = false;
            }
        }
    }
    getSampleNum(mult = 1) {
        return this.needs.neighborSample ? mult : 0;
    }
    setUniform(name, newVal) {
        var _a, _b;
        newVal = wrapInValue(newVal);
        const originalName = name;
        if (typeof newVal === "number") {
            newVal = n2p(newVal);
        }
        if (!(newVal instanceof Primitive)) {
            throw new Error("cannot set a non-primitive");
        }
        // if name does not exist, try mapping default name to new name
        if (((_a = this.uniformValChangeMap[name]) === null || _a === void 0 ? void 0 : _a.val) === undefined) {
            name = this.defaultNameMap[name];
        }
        const oldVal = (_b = this.uniformValChangeMap[name]) === null || _b === void 0 ? void 0 : _b.val;
        if (oldVal === undefined) {
            throw new Error("tried to set uniform " +
                name +
                " which doesn't exist. original name: " +
                originalName);
        }
        if (oldVal.typeString() !== newVal.typeString()) {
            throw new Error("tried to set uniform " + name + " to a new type");
        }
        this.uniformValChangeMap[name].val = newVal;
        this.uniformValChangeMap[name].changed = true;
    }
    /** parses this expression into a string, adding info as it recurses */
    parse(buildInfo) {
        this.sourceCode = "";
        buildInfo.exprs.push(this);
        buildInfo.needs = webglprogramloop_1.updateNeeds(buildInfo.needs, this.needs);
        // add each of the external funcs to the builder
        this.externalFuncs.forEach((func) => buildInfo.externalFuncs.add(func));
        // put all of the values between all of the source sections
        for (let i = 0; i < this.sourceLists.values.length; i++) {
            this.sourceCode +=
                this.sourceLists.sections[i] +
                    this.sourceLists.values[i].parse(buildInfo, this.defaultNames[i], this);
        }
        // TODO does sourceCode have to be a member?
        this.sourceCode += this.sourceLists.sections[this.sourceLists.sections.length - 1];
        return this.sourceCode;
    }
}
exports.Expr = Expr;
Expr.count = 0;
class Mutable {
    constructor(primitive, name) {
        this.primitive = primitive;
        this.name = name;
    }
    parse(buildInfo, defaultName, enc) {
        if (enc === undefined) {
            throw new Error("tried to put a mutable expression at the top level");
        }
        // accept the default name if given no name
        if (this.name === undefined)
            this.name = defaultName + enc.id;
        // set to true so they are set to their default values on first draw
        buildInfo.uniformTypes[this.name] = this.primitive.typeString();
        // add the name mapping
        enc.uniformValChangeMap[this.name] = {
            val: this.primitive,
            changed: true,
        };
        // add the new type to the map
        enc.defaultNameMap[defaultName + enc.id] = this.name;
        return this.name;
    }
    applyUniform(gl, loc) {
        this.primitive.applyUniform(gl, loc);
    }
    typeString() {
        return this.primitive.typeString();
    }
}
exports.Mutable = Mutable;
function mut(val, name) {
    const primitive = typeof val === "number" ? n2p(val) : val;
    return new Mutable(primitive, name);
}
exports.mut = mut;
class Primitive {
    parse(buildInfo, defaultName, enc) {
        return this.toString();
    }
}
exports.Primitive = Primitive;
class PrimitiveFloat extends Primitive {
    constructor(num) {
        if (!isFinite(num))
            throw new Error("number not finite");
        super();
        this.value = num;
    }
    toString() {
        let str = "" + this.value;
        if (!str.includes("."))
            str += ".";
        return str;
    }
    typeString() {
        return "float";
    }
    applyUniform(gl, loc) {
        gl.uniform1f(loc, this.value);
    }
}
exports.PrimitiveFloat = PrimitiveFloat;
class PrimitiveVec extends Primitive {
    constructor(comps) {
        super();
        this.values = comps;
    }
    typeString() {
        return ("vec" + this.values.length);
    }
    toString() {
        return `${this.typeString}(${this.values
            .map((n) => toGLSLFloatString(n))
            .join(", ")})`;
    }
}
exports.PrimitiveVec = PrimitiveVec;
class PrimitiveVec2 extends PrimitiveVec {
    applyUniform(gl, loc) {
        gl.uniform2f(loc, this.values[0], this.values[1]);
    }
}
exports.PrimitiveVec2 = PrimitiveVec2;
class PrimitiveVec3 extends PrimitiveVec {
    applyUniform(gl, loc) {
        gl.uniform3f(loc, this.values[0], this.values[1], this.values[2]);
    }
}
exports.PrimitiveVec3 = PrimitiveVec3;
class PrimitiveVec4 extends PrimitiveVec {
    applyUniform(gl, loc) {
        gl.uniform4f(loc, this.values[0], this.values[1], this.values[2], this.values[3]);
    }
}
exports.PrimitiveVec4 = PrimitiveVec4;
class BasicVec extends Expr {
    constructor(sourceLists, defaultNames) {
        super(sourceLists, defaultNames);
        // this cast is fine as long as you only instantiate these with the
        // shorthand version
        const values = sourceLists.values;
        this.values = values;
        this.defaultNames = defaultNames;
    }
    typeString() {
        return ("vec" + this.values.length);
    }
    setComp(index, primitive) {
        if (index < 0 || index >= this.values.length) {
            throw new Error("out of bounds of setting component");
        }
        this.setUniform(this.defaultNames[index] + this.id, n2p(primitive));
    }
}
exports.BasicVec = BasicVec;
class BasicVec2 extends BasicVec {
    constructor() {
        super(...arguments);
        this.bvec2 = undefined; // brand for nominal typing
    }
}
exports.BasicVec2 = BasicVec2;
class BasicVec3 extends BasicVec {
    constructor() {
        super(...arguments);
        this.bvec3 = undefined; // brand for nominal typing
    }
}
exports.BasicVec3 = BasicVec3;
class BasicVec4 extends BasicVec {
    constructor() {
        super(...arguments);
        this.bvec4 = undefined; // brand for nominal typing
    }
}
exports.BasicVec4 = BasicVec4;
class ExprVec extends Expr {
    constructor(sourceLists, defaultNames) {
        super(sourceLists, defaultNames);
        const values = sourceLists.values;
        this.values = values;
        this.defaultNames = defaultNames;
    }
}
exports.ExprVec = ExprVec;
class BasicFloat extends Expr {
    constructor(sourceLists, defaultNames) {
        super(sourceLists, defaultNames);
        this.float = undefined; // brand for nominal typing
    }
    setVal(primitive) {
        this.setUniform("uFloat" + this.id, n2p(primitive));
    }
    typeString() {
        return "float";
    }
}
exports.BasicFloat = BasicFloat;
class ExprFloat extends Expr {
    constructor(sourceLists, defaultNames) {
        super(sourceLists, defaultNames);
        this.float = undefined; // brand for nominal typing
    }
    setVal(primitive) {
        this.setUniform("uFloat" + this.id, n2p(primitive));
    }
    typeString() {
        return "float";
    }
}
exports.ExprFloat = ExprFloat;
function float(value) {
    if (typeof value === "number")
        value = n2p(value);
    return new BasicFloat({ sections: ["", ""], values: [value] }, ["uFloat"]);
}
exports.float = float;
class ExprVec2 extends ExprVec {
    constructor() {
        super(...arguments);
        this.vec2 = undefined; // brand for nominal typing
    }
    typeString() {
        return "vec2";
    }
}
exports.ExprVec2 = ExprVec2;
class ExprVec3 extends ExprVec {
    constructor() {
        super(...arguments);
        this.vec3 = undefined; // brand for nominal typing
    }
    typeString() {
        return "vec3";
    }
}
exports.ExprVec3 = ExprVec3;
class ExprVec4 extends ExprVec {
    constructor() {
        super(...arguments);
        this.vec4 = undefined; // brand for nominal typing
    }
    repeat(num) {
        return new mergepass_1.EffectLoop([this], { num: num });
    }
    genPrograms(gl, vShader, uniformLocs) {
        return new mergepass_1.EffectLoop([this], { num: 1 }).genPrograms(gl, vShader, uniformLocs);
    }
    typeString() {
        return "vec4";
    }
}
exports.ExprVec4 = ExprVec4;
class Operator extends Expr {
    constructor(ret, sourceLists, defaultNames) {
        super(sourceLists, defaultNames);
        this.ret = ret;
    }
    typeString() {
        return this.ret.typeString();
    }
}
exports.Operator = Operator;
function n2e(num) {
    if (num === undefined)
        return undefined;
    if (num instanceof PrimitiveFloat ||
        num instanceof ExprFloat ||
        num instanceof Operator ||
        num instanceof Mutable ||
        num instanceof BasicFloat)
        return num;
    return new PrimitiveFloat(num);
}
exports.n2e = n2e;
/** number to primitive float */
function n2p(num) {
    if (num instanceof PrimitiveFloat)
        return num;
    return new PrimitiveFloat(num);
}
exports.n2p = n2p;
function pfloat(num) {
    return new PrimitiveFloat(num);
}
exports.pfloat = pfloat;
function wrapInValue(num) {
    if (typeof num === "number")
        return pfloat(num);
    return num;
}
exports.wrapInValue = wrapInValue;
function tag(strings, ...values) {
    return { sections: strings.concat([]), values: values };
}
exports.tag = tag;

},{"../mergepass":160,"../webglprogramloop":161}],138:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fcolor = exports.FragColorExpr = void 0;
const expr_1 = require("./expr");
class FragColorExpr extends expr_1.ExprVec4 {
    constructor() {
        super(expr_1.tag `gl_FragColor`, []);
        this.needs.centerSample = true;
    }
}
exports.FragColorExpr = FragColorExpr;
function fcolor() {
    return new FragColorExpr();
}
exports.fcolor = fcolor;

},{"./expr":137}],139:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fxaa = void 0;
const expr_1 = require("./expr");
const glslfunctions_1 = require("../glslfunctions");
class FXAAExpr extends expr_1.ExprVec4 {
    constructor() {
        super(expr_1.tag `fxaa()`, []);
        this.externalFuncs = [glslfunctions_1.glslFuncs.fxaa];
        this.needs.neighborSample = true;
    }
}
function fxaa() {
    return new FXAAExpr();
}
exports.fxaa = fxaa;

},{"../glslfunctions":158,"./expr":137}],140:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.gaussian = exports.GaussianExpr = void 0;
const expr_1 = require("./expr");
const glslfunctions_1 = require("../glslfunctions");
class GaussianExpr extends expr_1.ExprFloat {
    constructor(x, a, b) {
        super(expr_1.tag `gaussian(${x}, ${a}, ${b})`, ["uFloatX", "uFloatA", "uFloatB"]);
        this.externalFuncs = [glslfunctions_1.glslFuncs.gaussian];
    }
    setX(x) {
        this.setUniform("uFloatX" + this.id, x);
    }
    setA(a) {
        this.setUniform("uFloatA" + this.id, a);
    }
    setB(b) {
        this.setUniform("uFloatB" + this.id, b);
    }
}
exports.GaussianExpr = GaussianExpr;
function gaussian(x, a = 0, b = 1) {
    return new GaussianExpr(expr_1.n2e(x), expr_1.n2e(a), expr_1.n2e(b));
}
exports.gaussian = gaussian;

},{"../glslfunctions":158,"./expr":137}],141:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.get4comp = exports.get3comp = exports.get2comp = exports.getcomp = exports.Get4CompExpr = exports.Get3CompExpr = exports.Get2CompExpr = exports.GetCompExpr = exports.checkLegalComponents = exports.typeStringToLength = void 0;
const expr_1 = require("./expr");
// TODO this should probably be somewhere else
function typeStringToLength(str) {
    switch (str) {
        case "float":
            return 1;
        case "vec2":
            return 2;
        case "vec3":
            return 3;
        case "vec4":
            return 4;
    }
}
exports.typeStringToLength = typeStringToLength;
function genCompSource(vec, components) {
    return {
        sections: ["", "." + components],
        values: [vec],
    };
}
function checkLegalComponents(comps, vec) {
    const check = (range, domain) => {
        let inside = 0;
        let outside = 0;
        for (const c of range) {
            domain.includes(c) ? inside++ : outside++;
        }
        return inside === inside && !outside;
    };
    const inLen = typeStringToLength(vec.typeString());
    const rgbaCheck = check(comps, "rgba".substr(0, inLen));
    const xyzwCheck = check(comps, "xyzw".substr(0, inLen));
    const stpqCheck = check(comps, "stpq".substr(0, inLen));
    if (!(rgbaCheck || xyzwCheck || stpqCheck)) {
        throw new Error("component sets are mixed or incorrect entirely");
    }
}
exports.checkLegalComponents = checkLegalComponents;
function checkGetComponents(comps, outLen, vec) {
    if (comps.length > outLen)
        throw new Error("too many components");
    checkLegalComponents(comps, vec);
}
class GetCompExpr extends expr_1.ExprFloat {
    constructor(vec, comps) {
        checkGetComponents(comps, 1, vec);
        super(genCompSource(vec, comps), ["uVec"]);
    }
}
exports.GetCompExpr = GetCompExpr;
class Get2CompExpr extends expr_1.ExprVec2 {
    constructor(vec, comps) {
        checkGetComponents(comps, 2, vec);
        super(genCompSource(vec, comps), ["uVec"]);
    }
}
exports.Get2CompExpr = Get2CompExpr;
class Get3CompExpr extends expr_1.ExprVec3 {
    constructor(vec, comps) {
        checkGetComponents(comps, 3, vec);
        super(genCompSource(vec, comps), ["uVec"]);
    }
}
exports.Get3CompExpr = Get3CompExpr;
class Get4CompExpr extends expr_1.ExprVec4 {
    constructor(vec, comps) {
        checkGetComponents(comps, 4, vec);
        super(genCompSource(vec, comps), ["uVec"]);
    }
}
exports.Get4CompExpr = Get4CompExpr;
function getcomp(vec, comps) {
    return new GetCompExpr(vec, comps);
}
exports.getcomp = getcomp;
function get2comp(vec, comps) {
    return new Get2CompExpr(vec, comps);
}
exports.get2comp = get2comp;
function get3comp(vec, comps) {
    return new Get3CompExpr(vec, comps);
}
exports.get3comp = get3comp;
function get4comp(vec, comps) {
    return new Get4CompExpr(vec, comps);
}
exports.get4comp = get4comp;

},{"./expr":137}],142:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.godrays = exports.GodRaysExpr = void 0;
const expr_1 = require("./expr");
const fragcolorexpr_1 = require("./fragcolorexpr");
const glslfunctions_1 = require("../glslfunctions");
const vecexprs_1 = require("./vecexprs");
class GodRaysExpr extends expr_1.ExprVec4 {
    constructor(col, exposure, decay, density, weight, lightPos, samplerNum, convertDepth) {
        // TODO the metaprogramming here is not so good!
        // leaving off the function call section for now
        const sourceLists = expr_1.tag `${col}, ${exposure}, ${decay}, ${density}, ${weight}, ${lightPos}, ${convertDepth !== undefined ? convertDepth.threshold : expr_1.float(0)}, ${convertDepth !== undefined ? convertDepth.newColor : vecexprs_1.vec4(0, 0, 0, 0)})`;
        // append the _<num> onto the function name
        // also add _depth if this is a version of the function that uses depth buffer
        sourceLists.sections[0] += `godrays_${samplerNum}${convertDepth !== undefined ? "_depth" : ""}(`;
        super(sourceLists, [
            "uCol",
            "uExposure",
            "uDecay",
            "uDensity",
            "uWeight",
            "uLightPos",
            "uThreshold",
            "uNewColor",
        ]);
        let customGodRayFunc = glslfunctions_1.replaceSampler(glslfunctions_1.glslFuncs.godrays, /vec4\sgodrays/g, samplerNum, convertDepth === undefined ? undefined : "_depth");
        if (convertDepth !== undefined) {
            // uncomment the line that does the conversion
            customGodRayFunc = customGodRayFunc.replace(/\/\/uncomment\s/g, "");
            this.externalFuncs.push(glslfunctions_1.glslFuncs.depth2occlusion);
        }
        this.externalFuncs.push(customGodRayFunc);
        this.needs.extraBuffers = new Set([0]);
    }
    setColor(color) {
        this.setUniform("uCol" + this.id, color);
    }
    setExposure(exposure) {
        this.setUniform("uExposure" + this.id, exposure);
    }
    setDecay(decay) {
        this.setUniform("uDecay" + this.id, decay);
    }
    setDensity(density) {
        this.setUniform("uDensity" + this.id, density);
    }
    setWeight(weight) {
        this.setUniform("uWeight" + this.id, weight);
    }
    setLightPos(lightPos) {
        this.setUniform("uLightPos" + this.id, lightPos);
    }
    // these only matter when you're using a depth buffer and not an occlusion
    // buffer (although right now, you'll still be able to set them)
    setThreshold(threshold) {
        this.setUniform("uThreshold" + this.id, threshold);
    }
    setNewcolor(newColor) {
        this.setUniform("uNewColor" + this.id, newColor);
    }
}
exports.GodRaysExpr = GodRaysExpr;
// sane godray defaults from https://github.com/Erkaman/glsl-godrays/blob/master/example/index.js
function godrays(col = fragcolorexpr_1.fcolor(), exposure = 1.0, decay = 1.0, density = 1.0, weight = 0.01, lightPos = vecexprs_1.vec2(0.5, 0.5), samplerNum = 0, convertDepth) {
    return new GodRaysExpr(col, expr_1.n2e(exposure), expr_1.n2e(decay), expr_1.n2e(density), expr_1.n2e(weight), lightPos, samplerNum, convertDepth === undefined
        ? undefined
        : {
            threshold: expr_1.n2e(convertDepth.threshold),
            newColor: convertDepth.newColor,
        });
}
exports.godrays = godrays;

},{"../glslfunctions":158,"./expr":137,"./fragcolorexpr":138,"./vecexprs":156}],143:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.grain = exports.GrainExpr = void 0;
const glslfunctions_1 = require("../glslfunctions");
const expr_1 = require("./expr");
class GrainExpr extends expr_1.ExprVec4 {
    constructor(val) {
        // TODO compose with other expressions rather than write full glsl?
        super(expr_1.tag `vec4((1.0 - ${val} * random(gl_FragCoord.xy)) * gl_FragColor.rgb, gl_FragColor.a);`, ["uGrain"]);
        this.externalFuncs = [glslfunctions_1.glslFuncs.random];
        // TODO get rid of this if we choose to use fcolor instead later
        this.needs.centerSample = true;
    }
    setGrain(grain) {
        this.setUniform("uGrain" + this.id, grain);
    }
}
exports.GrainExpr = GrainExpr;
function grain(val) {
    return new GrainExpr(expr_1.n2e(val));
}
exports.grain = grain;

},{"../glslfunctions":158,"./expr":137}],144:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hsv2rgb = exports.HSVToRGBExpr = void 0;
const expr_1 = require("./expr");
const glslfunctions_1 = require("../glslfunctions");
class HSVToRGBExpr extends expr_1.ExprVec4 {
    constructor(col) {
        super(expr_1.tag `hsv2rgb(${col})`, ["uHSVCol"]);
        this.externalFuncs = [glslfunctions_1.glslFuncs.hsv2rgb];
    }
    setColor(col) {
        this.setUniform("uHSVCol", col);
    }
}
exports.HSVToRGBExpr = HSVToRGBExpr;
function hsv2rgb(col) {
    return new HSVToRGBExpr(col);
}
exports.hsv2rgb = hsv2rgb;

},{"../glslfunctions":158,"./expr":137}],145:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.len = exports.LenExpr = void 0;
const expr_1 = require("./expr");
class LenExpr extends expr_1.ExprFloat {
    constructor(vec) {
        super(expr_1.tag `(length(${vec}))`, ["uVec"]);
        this.vec = vec;
    }
    setVec(vec) {
        this.setUniform("uVec" + this.id, vec);
    }
}
exports.LenExpr = LenExpr;
function len(vec) {
    return new LenExpr(vec);
}
exports.len = len;

},{"./expr":137}],146:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ncfcoord = exports.NormCenterFragCoordExpr = void 0;
const expr_1 = require("./expr");
class NormCenterFragCoordExpr extends expr_1.ExprVec2 {
    constructor() {
        super(expr_1.tag `(gl_FragCoord.xy / uResolution - 0.5)`, []);
    }
}
exports.NormCenterFragCoordExpr = NormCenterFragCoordExpr;
function ncfcoord() {
    return new NormCenterFragCoordExpr();
}
exports.ncfcoord = ncfcoord;

},{"./expr":137}],147:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.nfcoord = exports.NormFragCoordExpr = void 0;
const expr_1 = require("./expr");
class NormFragCoordExpr extends expr_1.ExprVec2 {
    constructor() {
        super(expr_1.tag `(gl_FragCoord.xy / uResolution)`, []);
    }
}
exports.NormFragCoordExpr = NormFragCoordExpr;
function nfcoord() {
    return new NormFragCoordExpr();
}
exports.nfcoord = nfcoord;

},{"./expr":137}],148:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.op = exports.OpExpr = void 0;
const expr_1 = require("./expr");
function genOpSourceList(left, op, right) {
    return {
        sections: ["(", ` ${op} `, ")"],
        values: [left, right],
    };
}
class OpExpr extends expr_1.Operator {
    constructor(left, op, right) {
        super(left, genOpSourceList(left, op, right), ["uLeft", "uRight"]);
        this.left = left;
        this.right = right;
    }
    setLeft(left) {
        this.setUniform("uLeft" + this.id, left);
    }
    setRight(right) {
        this.setUniform("uRight" + this.id, right);
    }
}
exports.OpExpr = OpExpr;
// implementation
function op(left, op, right) {
    return new OpExpr(expr_1.wrapInValue(left), op, expr_1.wrapInValue(right));
}
exports.op = op;

},{"./expr":137}],149:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pblur = exports.PowerBlurLoop = void 0;
const mergepass_1 = require("../mergepass");
const blurexpr_1 = require("./blurexpr");
const vecexprs_1 = require("./vecexprs");
const expr_1 = require("./expr");
const baseLog = (x, y) => Math.log(y) / Math.log(x);
class PowerBlurLoop extends mergepass_1.EffectLoop {
    constructor(size) {
        const side = blurexpr_1.gauss(expr_1.mut(vecexprs_1.pvec2(size, 0)));
        const up = blurexpr_1.gauss(expr_1.mut(vecexprs_1.pvec2(0, size)));
        const reps = Math.ceil(baseLog(2, size));
        super([side, up], {
            num: reps + 1,
        });
        this.size = size;
        this.repeat.func = (i) => {
            const distance = this.size / Math.pow(2, i);
            up.setDirection(vecexprs_1.pvec2(0, distance));
            side.setDirection(vecexprs_1.pvec2(distance, 0));
        };
    }
    setSize(size) {
        this.size = size;
        this.repeat.num = Math.ceil(baseLog(2, size));
    }
}
exports.PowerBlurLoop = PowerBlurLoop;
/**
 * fast approximate blur for large blur radius that might look good in some cases
 */
function pblur(size) {
    return new PowerBlurLoop(size);
}
exports.pblur = pblur;

},{"../mergepass":160,"./blurexpr":130,"./expr":137,"./vecexprs":156}],150:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RandomExpr = void 0;
const glslfunctions_1 = require("../glslfunctions");
const expr_1 = require("./expr");
class RandomExpr extends expr_1.ExprVec4 {
    constructor() {
        super(expr_1.tag `(random(gl_FragCoord.xy))`, []);
        this.externalFuncs = [glslfunctions_1.glslFuncs.random];
    }
}
exports.RandomExpr = RandomExpr;

},{"../glslfunctions":158,"./expr":137}],151:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.rgb2hsv = exports.RGBToHSVExpr = void 0;
const expr_1 = require("./expr");
const glslfunctions_1 = require("../glslfunctions");
class RGBToHSVExpr extends expr_1.ExprVec4 {
    constructor(col) {
        super(expr_1.tag `rgb2hsv(${col})`, ["uRGBCol"]);
        this.externalFuncs = [glslfunctions_1.glslFuncs.rgb2hsv];
    }
    setColor(col) {
        this.setUniform("uRGBCol", col);
    }
}
exports.RGBToHSVExpr = RGBToHSVExpr;
function rgb2hsv(col) {
    return new RGBToHSVExpr(col);
}
exports.rgb2hsv = rgb2hsv;

},{"../glslfunctions":158,"./expr":137}],152:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.input = exports.SceneSampleExpr = void 0;
const expr_1 = require("./expr");
const normfragcoordexpr_1 = require("./normfragcoordexpr");
class SceneSampleExpr extends expr_1.ExprVec4 {
    constructor(coord = normfragcoordexpr_1.nfcoord()) {
        super(expr_1.tag `texture2D(uSceneSampler, ${coord})`, ["uCoord"]);
        this.needs.sceneBuffer = true;
    }
    setCoord(coord) {
        this.setUniform("uCoord", coord);
    }
}
exports.SceneSampleExpr = SceneSampleExpr;
function input(vec) {
    return new SceneSampleExpr(vec);
}
exports.input = input;

},{"./expr":137,"./normfragcoordexpr":147}],153:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setcolor = exports.SetColorExpr = void 0;
const expr_1 = require("./expr");
class SetColorExpr extends expr_1.ExprVec4 {
    constructor(val) {
        super(expr_1.tag `(${val})`, ["uVal"]);
    }
    setVal(val) {
        this.setUniform("uVal", val);
    }
}
exports.SetColorExpr = SetColorExpr;
function setcolor(val) {
    return new SetColorExpr(val);
}
exports.setcolor = setcolor;

},{"./expr":137}],154:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.time = exports.TimeExpr = void 0;
const expr_1 = require("./expr");
class TimeExpr extends expr_1.ExprFloat {
    constructor() {
        super(expr_1.tag `uTime`, []);
        this.needs.timeUniform = true;
    }
}
exports.TimeExpr = TimeExpr;
function time() {
    return new TimeExpr();
}
exports.time = time;

},{"./expr":137}],155:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.truedepth = exports.TrueDepthExpr = void 0;
const expr_1 = require("./expr");
const glslfunctions_1 = require("../glslfunctions");
class TrueDepthExpr extends expr_1.ExprFloat {
    constructor(dist) {
        super(expr_1.tag `truedepth(${dist})`, ["uDist"]);
        this.externalFuncs = [glslfunctions_1.glslFuncs.truedepth];
    }
    setDist(dist) {
        this.setUniform("uDist", dist);
    }
}
exports.TrueDepthExpr = TrueDepthExpr;
function truedepth(dist) {
    return new TrueDepthExpr(expr_1.n2e(dist));
}
exports.truedepth = truedepth;

},{"../glslfunctions":158,"./expr":137}],156:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pvec4 = exports.pvec3 = exports.pvec2 = exports.vec4 = exports.vec3 = exports.vec2 = void 0;
const expr_1 = require("./expr");
function vecSourceList(...components) {
    const sections = ["vec" + components.length + "("];
    for (let i = 0; i < components.length - 1; i++) {
        sections.push(", ");
    }
    const defaultNames = [];
    for (let i = 0; i < components.length; i++) {
        defaultNames.push("uComp" + i);
    }
    sections.push(")");
    return [{ sections: sections, values: components }, defaultNames];
}
// expression vector shorthands
function vec2(comp1, comp2) {
    return new expr_1.BasicVec2(...vecSourceList(...[comp1, comp2].map((c) => expr_1.n2e(c))));
}
exports.vec2 = vec2;
function vec3(comp1, comp2, comp3) {
    return new expr_1.BasicVec3(...vecSourceList(...[comp1, comp2, comp3].map((c) => expr_1.n2e(c))));
}
exports.vec3 = vec3;
function vec4(comp1, comp2, comp3, comp4) {
    return new expr_1.BasicVec4(...vecSourceList(...[comp1, comp2, comp3, comp4].map((c) => expr_1.n2e(c))));
}
exports.vec4 = vec4;
// primitive vector shorthands
function pvec2(comp1, comp2) {
    return new expr_1.PrimitiveVec2([comp1, comp2]);
}
exports.pvec2 = pvec2;
function pvec3(comp1, comp2, comp3) {
    return new expr_1.PrimitiveVec2([comp1, comp2, comp3]);
}
exports.pvec3 = pvec3;
function pvec4(comp1, comp2, comp3, comp4) {
    return new expr_1.PrimitiveVec2([comp1, comp2, comp3, comp4]);
}
exports.pvec4 = pvec4;

},{"./expr":137}],157:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

},{}],158:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.replaceSampler = exports.captureAndAppend = exports.glslFuncs = void 0;
// adapted from The Book of Shaders
exports.glslFuncs = {
    // TODO replace with a better one
    random: `float random(vec2 st) {
  return fract(sin(dot(st.xy / 99., vec2(12.9898, 78.233))) * 43758.5453123);
}`,
    //  rotate2d: `mat2 rotate2d(float angle) {
    //  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));
    //}`,
    //  scale: `mat2 scale(vec2 scale) {
    //  return mat2(scale.x, 0.0, 0.0, scale.y);
    //}`,
    hsv2rgb: `vec4 hsv2rgb(vec4 co){
  vec3 c = co.xyz;
  vec3 rgb = clamp(abs(mod(
    c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);
  rgb = rgb * rgb * (3.0 - 2.0 * rgb);
  vec3 hsv = c.z * mix(vec3(1.0), rgb, c.y);
  return vec4(hsv.x, hsv.y, hsv.z, co.a);
}`,
    rgb2hsv: `vec4 rgb2hsv(vec4 co){
  vec3 c = co.rgb;
  vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
  vec4 p = mix(vec4(c.bg, K.wz),
               vec4(c.gb, K.xy),
               step(c.b, c.g));
  vec4 q = mix(vec4(p.xyw, c.r),
               vec4(c.r, p.yzx),
               step(p.x, c.r));
  float d = q.x - min(q.w, q.y);
  float e = 1.0e-10;
  return vec4(abs(q.z + (q.w - q.y) / (6.0 * d + e)),
              d / (q.x + e),
              q.x, co.a);
}`,
    // TODO code-gen gaussian blur of arbitrary taps by calculating the curve?
    // adapted from https://github.com/Jam3/glsl-fast-gaussian-blur/blob/master/5.glsl
    gauss5: `vec4 gauss5(vec2 dir) {
  vec2 uv = gl_FragCoord.xy / uResolution;
  vec4 col = vec4(0.0);
  vec2 off1 = vec2(1.3333333333333333) * dir;
  col += texture2D(uSampler, uv) * 0.29411764705882354;
  col += texture2D(uSampler, uv + (off1 / uResolution)) * 0.35294117647058826;
  col += texture2D(uSampler, uv - (off1 / uResolution)) * 0.35294117647058826;
  return col;
}`,
    gauss9: `vec4 gauss9(vec2 dir) {
  vec2 uv = gl_FragCoord.xy / uResolution;
  vec4 col = vec4(0.0);
  vec2 off1 = vec2(1.3846153846) * dir;
  vec2 off2 = vec2(3.2307692308) * dir;
  col += texture2D(uSampler, uv) * 0.2270270270;
  col += texture2D(uSampler, uv + (off1 / uResolution)) * 0.3162162162;
  col += texture2D(uSampler, uv - (off1 / uResolution)) * 0.3162162162;
  col += texture2D(uSampler, uv + (off2 / uResolution)) * 0.0702702703;
  col += texture2D(uSampler, uv - (off2 / uResolution)) * 0.0702702703;
  return col;
}`,
    gauss13: `vec4 gauss13(vec2 dir) {
  vec2 uv = gl_FragCoord.xy / uResolution;
  vec4 col = vec4(0.0);
  vec2 off1 = vec2(1.411764705882353) * dir;
  vec2 off2 = vec2(3.2941176470588234) * dir;
  vec2 off3 = vec2(5.176470588235294) * dir;
  col += texture2D(uSampler, uv) * 0.1964825501511404;
  col += texture2D(uSampler, uv + (off1 / uResolution)) * 0.2969069646728344;
  col += texture2D(uSampler, uv - (off1 / uResolution)) * 0.2969069646728344;
  col += texture2D(uSampler, uv + (off2 / uResolution)) * 0.09447039785044732;
  col += texture2D(uSampler, uv - (off2 / uResolution)) * 0.09447039785044732;
  col += texture2D(uSampler, uv + (off3 / uResolution)) * 0.010381362401148057;
  col += texture2D(uSampler, uv - (off3 / uResolution)) * 0.010381362401148057;
  return col;
}`,
    contrast: `vec4 contrast(float val, vec4 col) {
  col.rgb /= col.a;
  col.rgb = ((col.rgb - 0.5) * val) + 0.5;
  col.rgb *= col.a;
  return col;
}`,
    brightness: `vec4 brightness(float val, vec4 col) {
  col.rgb /= col.a;
  col.rgb += val;
  col.rgb *= col.a;
  return col;
}`,
    // adapted from https://www.shadertoy.com/view/ls3GWS which was adapted from
    // http://www.geeks3d.com/20110405/fxaa-fast-approximate-anti-aliasing-demo-glsl-opengl-test-radeon-geforce/3/
    // pass in normalized coordinates to rcpFrame
    fxaa: `vec4 fxaa() {
  float FXAA_SPAN_MAX = 8.0;
  float FXAA_REDUCE_MUL = 1.0 / FXAA_SPAN_MAX;
  float FXAA_REDUCE_MIN = 1.0 / 128.0;
  float FXAA_SUBPIX_SHIFT = 1.0 / 4.0;

  vec2 rcpFrame = 1. / uResolution.xy;
  vec2 t_uv = gl_FragCoord.xy / uResolution.xy; 
  vec4 uv = vec4(t_uv, t_uv - (rcpFrame * (0.5 + FXAA_SUBPIX_SHIFT)));

  vec3 rgbNW = texture2D(uSampler, uv.zw).xyz;
  vec3 rgbNE = texture2D(uSampler, uv.zw + vec2(1,0) * rcpFrame.xy).xyz;
  vec3 rgbSW = texture2D(uSampler, uv.zw + vec2(0,1) * rcpFrame.xy).xyz;
  vec3 rgbSE = texture2D(uSampler, uv.zw + vec2(1,1) * rcpFrame.xy).xyz;
  vec4 rgbMfull = texture2D(uSampler, uv.xy);
  vec3 rgbM = rgbMfull.xyz;
  float alpha = rgbMfull.a;

  vec3 luma = vec3(0.299, 0.587, 0.114);
  float lumaNW = dot(rgbNW, luma);
  float lumaNE = dot(rgbNE, luma);
  float lumaSW = dot(rgbSW, luma);
  float lumaSE = dot(rgbSE, luma);
  float lumaM = dot(rgbM,  luma);

  float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
  float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

  vec2 dir;
  dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
  dir.y = ((lumaNW + lumaSW) - (lumaNE + lumaSE));

  float dirReduce = max(
    (lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);
  float rcpDirMin = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);

  dir = min(vec2(FXAA_SPAN_MAX,  FXAA_SPAN_MAX),
    max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
    dir * rcpDirMin)) * rcpFrame.xy;

  vec3 rgbA = (1.0 / 2.0) * (
    texture2D(uSampler, uv.xy + dir * (1.0 / 3.0 - 0.5)).xyz +
    texture2D(uSampler, uv.xy + dir * (2.0 / 3.0 - 0.5)).xyz);
  vec3 rgbB = rgbA * (1.0 / 2.0) + (1.0 / 4.0) * (
    texture2D(uSampler, uv.xy + dir * (0.0 / 3.0 - 0.5)).xyz +
    texture2D(uSampler, uv.xy + dir * (3.0 / 3.0 - 0.5)).xyz);

  float lumaB = dot(rgbB, luma);

  if(lumaB < lumaMin || lumaB > lumaMax) {
    return vec4(rgbA.r, rgbA.g, rgbA.b, alpha);
  }

  return vec4(rgbB.r, rgbB.g, rgbB.b, alpha);
}`,
    // normal curve is a = 0 and b = 1
    gaussian: `float gaussian(float x, float a, float b) {
  float e = 2.71828;
  return pow(e, -pow(x - a, 2.) / b);
}`,
    // for calculating the true distance from 0 to 1 depth buffer
    truedepth: `float truedepth(float i) {
  i = max(i, 0.00000001);
  return (1. - i) / i;
}`,
    // based off of https://fabiensanglard.net/lightScattering/index.php
    godrays: `vec4 godrays(
  vec4 col,
  float exposure,
  float decay,
  float density,
  float weight,
  vec2 lightPos,
  float threshold,
  vec4 newColor
) {
  vec2 texCoord = gl_FragCoord.xy / uResolution;
  vec2 deltaTexCoord = texCoord - lightPos;

  const int NUM_SAMPLES = 100;
  deltaTexCoord *= 1. / float(NUM_SAMPLES) * density;
  float illuminationDecay = 1.0;

  for (int i=0; i < NUM_SAMPLES; i++) {
    texCoord -= deltaTexCoord;
    vec4 sample = texture2D(uSampler, texCoord);
    //uncomment sample = depth2occlusion(sample, newColor, threshold);
    sample *= illuminationDecay * weight;
    col += sample;
    illuminationDecay *= decay;
  }
  return col * exposure;
}`,
    depth2occlusion: `vec4 depth2occlusion(vec4 depthCol, vec4 newCol, float threshold) {
  float red = 1. - ceil(depthCol.r - threshold);
  return vec4(newCol.rgb * red, 1.0);
}`,
};
function captureAndAppend(str, reg, suffix) {
    const matches = str.match(reg);
    if (matches === null)
        throw new Error("no match in the given string");
    return str.replace(reg, matches[0] + suffix);
}
exports.captureAndAppend = captureAndAppend;
function replaceSampler(fullString, funcRegExp, samplerNum, extra) {
    return captureAndAppend(fullString.replace(/uSampler/g, "uBufferSampler" + samplerNum), funcRegExp, "_" + samplerNum + (extra === undefined ? "" : extra));
}
exports.replaceSampler = replaceSampler;

},{}],159:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./mergepass"), exports);
__exportStar(require("./exprtypes"), exports);
__exportStar(require("./glslfunctions"), exports);
__exportStar(require("./expressions/blurexpr"), exports);
__exportStar(require("./expressions/randomexpr"), exports);
__exportStar(require("./expressions/fragcolorexpr"), exports);
__exportStar(require("./expressions/vecexprs"), exports);
__exportStar(require("./expressions/opexpr"), exports);
__exportStar(require("./expressions/powerblur"), exports);
__exportStar(require("./expressions/blur2dloop"), exports);
__exportStar(require("./expressions/lenexpr"), exports);
__exportStar(require("./expressions/normfragcoordexpr"), exports);
__exportStar(require("./expressions/normcenterfragcoordexpr"), exports);
__exportStar(require("./expressions/scenesampleexpr"), exports);
__exportStar(require("./expressions/brightnessexpr"), exports);
__exportStar(require("./expressions/setcolorexpr"), exports);
__exportStar(require("./expressions/contrastexpr"), exports);
__exportStar(require("./expressions/grainexpr"), exports);
__exportStar(require("./expressions/getcompexpr"), exports);
__exportStar(require("./expressions/changecompexpr"), exports);
__exportStar(require("./expressions/rgbtohsvexpr"), exports);
__exportStar(require("./expressions/hsvtorgbexpr"), exports);
__exportStar(require("./expressions/timeexpr"), exports);
__exportStar(require("./expressions/arity1"), exports);
__exportStar(require("./expressions/arity2"), exports);
__exportStar(require("./expressions/fxaaexpr"), exports);
__exportStar(require("./expressions/buffersampleexpr"), exports);
__exportStar(require("./expressions/dofloop"), exports);
__exportStar(require("./expressions/truedepthexpr"), exports);
__exportStar(require("./expressions/godraysexpr"), exports);
__exportStar(require("./expressions/depthtoocclusionexpr"), exports);
__exportStar(require("./expressions/expr"), exports);

},{"./expressions/arity1":127,"./expressions/arity2":128,"./expressions/blur2dloop":129,"./expressions/blurexpr":130,"./expressions/brightnessexpr":131,"./expressions/buffersampleexpr":132,"./expressions/changecompexpr":133,"./expressions/contrastexpr":134,"./expressions/depthtoocclusionexpr":135,"./expressions/dofloop":136,"./expressions/expr":137,"./expressions/fragcolorexpr":138,"./expressions/fxaaexpr":139,"./expressions/getcompexpr":141,"./expressions/godraysexpr":142,"./expressions/grainexpr":143,"./expressions/hsvtorgbexpr":144,"./expressions/lenexpr":145,"./expressions/normcenterfragcoordexpr":146,"./expressions/normfragcoordexpr":147,"./expressions/opexpr":148,"./expressions/powerblur":149,"./expressions/randomexpr":150,"./expressions/rgbtohsvexpr":151,"./expressions/scenesampleexpr":152,"./expressions/setcolorexpr":153,"./expressions/timeexpr":154,"./expressions/truedepthexpr":155,"./expressions/vecexprs":156,"./exprtypes":157,"./glslfunctions":158,"./mergepass":160}],160:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sendTexture = exports.makeTexture = exports.Merger = exports.loop = exports.EffectLoop = void 0;
const codebuilder_1 = require("./codebuilder");
const webglprogramloop_1 = require("./webglprogramloop");
class EffectLoop {
    constructor(effects, repeat) {
        this.effects = effects;
        this.repeat = repeat;
    }
    getSampleNum(mult = 1, sliceStart = 0, sliceEnd = this.effects.length) {
        mult *= this.repeat.num;
        let acc = 0;
        const sliced = this.effects.slice(sliceStart, sliceEnd);
        for (const e of sliced) {
            acc += e.getSampleNum(mult);
        }
        return acc;
    }
    /** places effects into loops broken up by sampling effects */
    regroup() {
        let sampleCount = 0;
        /** number of samples in all previous */
        let prevSampleCount = 0;
        let prevEffects = [];
        const regroupedEffects = [];
        const breakOff = () => {
            if (prevEffects.length > 0) {
                // break off all previous effects into their own loop
                if (prevEffects.length === 1) {
                    // this is to prevent wrapping in another effect loop
                    regroupedEffects.push(prevEffects[0]);
                }
                else {
                    regroupedEffects.push(new EffectLoop(prevEffects, { num: 1 }));
                }
                sampleCount -= prevSampleCount;
                prevEffects = [];
            }
        };
        for (const e of this.effects) {
            const sampleNum = e.getSampleNum();
            prevSampleCount = sampleCount;
            sampleCount += sampleNum;
            if (sampleCount > 0)
                breakOff();
            prevEffects.push(e);
        }
        // push on all the straggling effects after the grouping is done
        breakOff();
        return regroupedEffects;
    }
    /** recursive descent parser for turning effects into programs */
    genPrograms(gl, vShader, uniformLocs) {
        // validate
        const fullSampleNum = this.getSampleNum() / this.repeat.num;
        const firstSampleNum = this.getSampleNum(undefined, 0, 1) / this.repeat.num;
        const restSampleNum = this.getSampleNum(undefined, 1) / this.repeat.num;
        if (fullSampleNum === 0 || (firstSampleNum === 1 && restSampleNum === 0)) {
            const codeBuilder = new codebuilder_1.CodeBuilder(this);
            const program = codeBuilder.compileProgram(gl, vShader, uniformLocs);
            return program;
        }
        // otherwise, regroup and try again on regrouped loops
        this.effects = this.regroup();
        // okay to have undefined needs here
        return new webglprogramloop_1.WebGLProgramLoop(this.effects.map((e) => e.genPrograms(gl, vShader, uniformLocs)), this.repeat, gl);
    }
}
exports.EffectLoop = EffectLoop;
function loop(effects, rep) {
    return new EffectLoop(effects, { num: rep });
}
exports.loop = loop;
const V_SOURCE = `attribute vec2 aPosition;
void main() {
  gl_Position = vec4(aPosition, 0.0, 1.0);
}\n`;
class Merger {
    constructor(effects, source, gl, options) {
        var _a;
        this.uniformLocs = {};
        /** additional channels */
        this.channels = [];
        // set channels if provided with channels
        if ((options === null || options === void 0 ? void 0 : options.channels) !== undefined)
            this.channels = options === null || options === void 0 ? void 0 : options.channels;
        // wrap the given list of effects as a loop if need be
        if (!(effects instanceof EffectLoop)) {
            this.effectLoop = new EffectLoop(effects, { num: 1 });
        }
        else {
            this.effectLoop = effects;
        }
        if (this.effectLoop.effects.length === 0) {
            throw new Error("list of effects was empty");
        }
        this.source = source;
        this.gl = gl;
        this.options = options;
        // set the viewport
        this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);
        // set up the vertex buffer
        const vertexBuffer = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, vertexBuffer);
        const vertexArray = [-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1];
        const triangles = new Float32Array(vertexArray);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, triangles, this.gl.STATIC_DRAW);
        // compile the simple vertex shader (2 big triangles)
        const vShader = this.gl.createShader(this.gl.VERTEX_SHADER);
        if (vShader === null) {
            throw new Error("problem creating the vertex shader");
        }
        this.gl.shaderSource(vShader, V_SOURCE);
        this.gl.compileShader(vShader);
        // make textures
        this.tex = {
            // make the front texture the source if we're given a texture instead of
            // an image
            back: source instanceof WebGLTexture
                ? source
                : makeTexture(this.gl, this.options),
            front: makeTexture(this.gl, this.options),
            scene: undefined,
            bufTextures: [],
        };
        // create the framebuffer
        const framebuffer = gl.createFramebuffer();
        if (framebuffer === null) {
            throw new Error("problem creating the framebuffer");
        }
        this.framebuffer = framebuffer;
        // generate the fragment shaders and programs
        this.programLoop = this.effectLoop.genPrograms(this.gl, vShader, this.uniformLocs);
        // find the final program
        let atBottom = false;
        let currProgramLoop = this.programLoop;
        while (!atBottom) {
            if (currProgramLoop.programElement instanceof WebGLProgram) {
                // we traveled right and hit a program, so it must be the last
                currProgramLoop.last = true;
                atBottom = true;
            }
            else {
                // set the current program loop to the last in the list
                currProgramLoop =
                    currProgramLoop.programElement[currProgramLoop.programElement.length - 1];
            }
        }
        if (this.programLoop.getTotalNeeds().sceneBuffer) {
            this.tex.scene = makeTexture(this.gl, this.options);
        }
        console.log(this.programLoop);
        // create x amount of empty textures based on buffers needed
        let channelsNeeded = 0;
        if (((_a = this.programLoop.totalNeeds) === null || _a === void 0 ? void 0 : _a.extraBuffers) !== undefined) {
            channelsNeeded =
                Math.max(...this.programLoop.totalNeeds.extraBuffers) + 1;
        }
        let channelsSupplied = this.channels.length;
        if (channelsNeeded > channelsSupplied) {
            throw new Error("not enough channels supplied for this effect");
        }
        for (let i = 0; i < this.channels.length; i++) {
            const texOrImage = this.channels[i];
            if (!(texOrImage instanceof WebGLTexture)) {
                // create a new texture; we will update this with the image source every draw
                const texture = makeTexture(this.gl, this.options);
                this.tex.bufTextures.push(texture);
            }
            else {
                // this is already a texture; the user will handle updating this
                this.tex.bufTextures.push(texOrImage);
            }
        }
    }
    draw(time = 0) {
        // TODO double check if this is neccessary
        const originalFront = this.tex.front;
        const originalBack = this.tex.back;
        this.gl.activeTexture(this.gl.TEXTURE0);
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.tex.back);
        sendTexture(this.gl, this.source);
        // bind the scene buffer
        if (this.programLoop.getTotalNeeds().sceneBuffer &&
            this.tex.scene !== undefined) {
            this.gl.activeTexture(this.gl.TEXTURE1);
            this.gl.bindTexture(this.gl.TEXTURE_2D, this.tex.scene);
            sendTexture(this.gl, this.source);
        }
        // bind the additional buffers
        let counter = 0;
        for (const b of this.channels) {
            // TODO what's the limit on amount of textures?
            this.gl.activeTexture(this.gl.TEXTURE2 + counter);
            this.gl.bindTexture(this.gl.TEXTURE_2D, this.tex.bufTextures[counter]);
            sendTexture(this.gl, b);
            counter++;
        }
        // swap textures before beginning draw
        this.programLoop.draw(this.gl, this.tex, this.framebuffer, this.uniformLocs, this.programLoop.last, time);
        // make sure front and back are in same order
        this.tex.front = originalFront;
        this.tex.back = originalBack;
    }
}
exports.Merger = Merger;
function makeTexture(gl, options) {
    const texture = gl.createTexture();
    if (texture === null) {
        throw new Error("problem creating texture");
    }
    // flip the order of the pixels, or else it displays upside down
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    // bind the texture after creating it
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.drawingBufferWidth, gl.drawingBufferHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    const filterMode = (f) => f === undefined || f === "linear" ? gl.LINEAR : gl.NEAREST;
    // how to map texture element
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filterMode(options === null || options === void 0 ? void 0 : options.minFilterMode));
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filterMode(options === null || options === void 0 ? void 0 : options.maxFilterMode));
    if ((options === null || options === void 0 ? void 0 : options.edgeMode) !== "wrap") {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    }
    return texture;
}
exports.makeTexture = makeTexture;
function sendTexture(gl, src) {
    // if you are using textures instead of images, the user is responsible for
    // doing `texImage2D` and updating it with new info, so just return
    if (src instanceof WebGLTexture)
        return;
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, src);
}
exports.sendTexture = sendTexture;

},{"./codebuilder":126,"./webglprogramloop":161}],161:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebGLProgramLoop = exports.updateNeeds = void 0;
// update me on change to needs
exports.updateNeeds = (acc, curr) => {
    return {
        neighborSample: acc.neighborSample || curr.neighborSample,
        centerSample: acc.centerSample || curr.centerSample,
        sceneBuffer: acc.sceneBuffer || curr.sceneBuffer,
        timeUniform: acc.timeUniform || curr.timeUniform,
        extraBuffers: new Set([...acc.extraBuffers, ...curr.extraBuffers]),
    };
};
class WebGLProgramLoop {
    constructor(programElement, repeat, gl, totalNeeds, // only defined when leaf
    effects = [] // only populated when leaf
    ) {
        var _a;
        this.last = false;
        this.programElement = programElement;
        this.repeat = repeat;
        this.totalNeeds = totalNeeds;
        this.effects = effects;
        if (programElement instanceof WebGLProgram) {
            if (gl === undefined) {
                throw new Error("program element is a program but context is undefined");
            }
            if ((_a = this.totalNeeds) === null || _a === void 0 ? void 0 : _a.timeUniform) {
                gl.useProgram(programElement);
                const timeLoc = gl.getUniformLocation(programElement, "uTime");
                if (timeLoc === null) {
                    throw new Error("could not get the time uniform location");
                }
                this.timeLoc = timeLoc;
            }
        }
    }
    getTotalNeeds() {
        // go through needs of program loop
        if (!(this.programElement instanceof WebGLProgram)) {
            const allNeeds = [];
            for (const p of this.programElement) {
                allNeeds.push(p.getTotalNeeds());
            }
            // update me on change to needs
            return allNeeds.reduce(exports.updateNeeds);
        }
        if (this.totalNeeds === undefined) {
            throw new Error("total needs of webgl program was somehow undefined");
        }
        return this.totalNeeds;
    }
    draw(gl, tex, framebuffer, uniformLocs, last, time) {
        var _a, _b;
        for (let i = 0; i < this.repeat.num; i++) {
            const newLast = i === this.repeat.num - 1;
            if (this.programElement instanceof WebGLProgram) {
                // effects list is populated
                if (i === 0) {
                    gl.useProgram(this.programElement);
                    if ((_a = this.totalNeeds) === null || _a === void 0 ? void 0 : _a.sceneBuffer) {
                        if (tex.scene === undefined) {
                            throw new Error("needs scene buffer, but scene texture is somehow undefined");
                        }
                        gl.activeTexture(gl.TEXTURE1);
                        gl.bindTexture(gl.TEXTURE_2D, tex.scene);
                    }
                    for (const effect of this.effects) {
                        effect.applyUniforms(gl, uniformLocs);
                    }
                    if ((_b = this.totalNeeds) === null || _b === void 0 ? void 0 : _b.timeUniform) {
                        if (this.timeLoc === undefined || time === undefined) {
                            throw new Error("time or location is undefined");
                        }
                        gl.uniform1f(this.timeLoc, time);
                    }
                }
                if (newLast && last && this.last) {
                    // we are on the final pass of the final loop, so draw screen by
                    // setting to the default framebuffer
                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                }
                else {
                    // we have to bounce between two textures
                    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
                    // use the framebuffer to write to front texture
                    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex.front, 0);
                }
                // allows us to read from `texBack`
                // default sampler is 0, so `uSampler` uniform will always sample from texture 0
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, tex.back);
                [tex.back, tex.front] = [tex.front, tex.back];
                // go back to the default framebuffer object
                // use our last program as the draw program
                gl.drawArrays(gl.TRIANGLES, 0, 6);
            }
            else {
                if (this.repeat.func !== undefined) {
                    this.repeat.func(i);
                }
                for (const p of this.programElement) {
                    p.draw(gl, tex, framebuffer, uniformLocs, newLast, time);
                }
            }
        }
    }
}
exports.WebGLProgramLoop = WebGLProgramLoop;

},{}],162:[function(require,module,exports){
"use strict"

var compile = require("cwise-compiler")

var EmptyProc = {
  body: "",
  args: [],
  thisVars: [],
  localVars: []
}

function fixup(x) {
  if(!x) {
    return EmptyProc
  }
  for(var i=0; i<x.args.length; ++i) {
    var a = x.args[i]
    if(i === 0) {
      x.args[i] = {name: a, lvalue:true, rvalue: !!x.rvalue, count:x.count||1 }
    } else {
      x.args[i] = {name: a, lvalue:false, rvalue:true, count: 1}
    }
  }
  if(!x.thisVars) {
    x.thisVars = []
  }
  if(!x.localVars) {
    x.localVars = []
  }
  return x
}

function pcompile(user_args) {
  return compile({
    args:     user_args.args,
    pre:      fixup(user_args.pre),
    body:     fixup(user_args.body),
    post:     fixup(user_args.proc),
    funcName: user_args.funcName
  })
}

function makeOp(user_args) {
  var args = []
  for(var i=0; i<user_args.args.length; ++i) {
    args.push("a"+i)
  }
  var wrapper = new Function("P", [
    "return function ", user_args.funcName, "_ndarrayops(", args.join(","), ") {P(", args.join(","), ");return a0}"
  ].join(""))
  return wrapper(pcompile(user_args))
}

var assign_ops = {
  add:  "+",
  sub:  "-",
  mul:  "*",
  div:  "/",
  mod:  "%",
  band: "&",
  bor:  "|",
  bxor: "^",
  lshift: "<<",
  rshift: ">>",
  rrshift: ">>>"
}
;(function(){
  for(var id in assign_ops) {
    var op = assign_ops[id]
    exports[id] = makeOp({
      args: ["array","array","array"],
      body: {args:["a","b","c"],
             body: "a=b"+op+"c"},
      funcName: id
    })
    exports[id+"eq"] = makeOp({
      args: ["array","array"],
      body: {args:["a","b"],
             body:"a"+op+"=b"},
      rvalue: true,
      funcName: id+"eq"
    })
    exports[id+"s"] = makeOp({
      args: ["array", "array", "scalar"],
      body: {args:["a","b","s"],
             body:"a=b"+op+"s"},
      funcName: id+"s"
    })
    exports[id+"seq"] = makeOp({
      args: ["array","scalar"],
      body: {args:["a","s"],
             body:"a"+op+"=s"},
      rvalue: true,
      funcName: id+"seq"
    })
  }
})();

var unary_ops = {
  not: "!",
  bnot: "~",
  neg: "-",
  recip: "1.0/"
}
;(function(){
  for(var id in unary_ops) {
    var op = unary_ops[id]
    exports[id] = makeOp({
      args: ["array", "array"],
      body: {args:["a","b"],
             body:"a="+op+"b"},
      funcName: id
    })
    exports[id+"eq"] = makeOp({
      args: ["array"],
      body: {args:["a"],
             body:"a="+op+"a"},
      rvalue: true,
      count: 2,
      funcName: id+"eq"
    })
  }
})();

var binary_ops = {
  and: "&&",
  or: "||",
  eq: "===",
  neq: "!==",
  lt: "<",
  gt: ">",
  leq: "<=",
  geq: ">="
}
;(function() {
  for(var id in binary_ops) {
    var op = binary_ops[id]
    exports[id] = makeOp({
      args: ["array","array","array"],
      body: {args:["a", "b", "c"],
             body:"a=b"+op+"c"},
      funcName: id
    })
    exports[id+"s"] = makeOp({
      args: ["array","array","scalar"],
      body: {args:["a", "b", "s"],
             body:"a=b"+op+"s"},
      funcName: id+"s"
    })
    exports[id+"eq"] = makeOp({
      args: ["array", "array"],
      body: {args:["a", "b"],
             body:"a=a"+op+"b"},
      rvalue:true,
      count:2,
      funcName: id+"eq"
    })
    exports[id+"seq"] = makeOp({
      args: ["array", "scalar"],
      body: {args:["a","s"],
             body:"a=a"+op+"s"},
      rvalue:true,
      count:2,
      funcName: id+"seq"
    })
  }
})();

var math_unary = [
  "abs",
  "acos",
  "asin",
  "atan",
  "ceil",
  "cos",
  "exp",
  "floor",
  "log",
  "round",
  "sin",
  "sqrt",
  "tan"
]
;(function() {
  for(var i=0; i<math_unary.length; ++i) {
    var f = math_unary[i]
    exports[f] = makeOp({
                    args: ["array", "array"],
                    pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                    body: {args:["a","b"], body:"a=this_f(b)", thisVars:["this_f"]},
                    funcName: f
                  })
    exports[f+"eq"] = makeOp({
                      args: ["array"],
                      pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                      body: {args: ["a"], body:"a=this_f(a)", thisVars:["this_f"]},
                      rvalue: true,
                      count: 2,
                      funcName: f+"eq"
                    })
  }
})();

var math_comm = [
  "max",
  "min",
  "atan2",
  "pow"
]
;(function(){
  for(var i=0; i<math_comm.length; ++i) {
    var f= math_comm[i]
    exports[f] = makeOp({
                  args:["array", "array", "array"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b","c"], body:"a=this_f(b,c)", thisVars:["this_f"]},
                  funcName: f
                })
    exports[f+"s"] = makeOp({
                  args:["array", "array", "scalar"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b","c"], body:"a=this_f(b,c)", thisVars:["this_f"]},
                  funcName: f+"s"
                  })
    exports[f+"eq"] = makeOp({ args:["array", "array"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b"], body:"a=this_f(a,b)", thisVars:["this_f"]},
                  rvalue: true,
                  count: 2,
                  funcName: f+"eq"
                  })
    exports[f+"seq"] = makeOp({ args:["array", "scalar"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b"], body:"a=this_f(a,b)", thisVars:["this_f"]},
                  rvalue:true,
                  count:2,
                  funcName: f+"seq"
                  })
  }
})();

var math_noncomm = [
  "atan2",
  "pow"
]
;(function(){
  for(var i=0; i<math_noncomm.length; ++i) {
    var f= math_noncomm[i]
    exports[f+"op"] = makeOp({
                  args:["array", "array", "array"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b","c"], body:"a=this_f(c,b)", thisVars:["this_f"]},
                  funcName: f+"op"
                })
    exports[f+"ops"] = makeOp({
                  args:["array", "array", "scalar"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b","c"], body:"a=this_f(c,b)", thisVars:["this_f"]},
                  funcName: f+"ops"
                  })
    exports[f+"opeq"] = makeOp({ args:["array", "array"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b"], body:"a=this_f(b,a)", thisVars:["this_f"]},
                  rvalue: true,
                  count: 2,
                  funcName: f+"opeq"
                  })
    exports[f+"opseq"] = makeOp({ args:["array", "scalar"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b"], body:"a=this_f(b,a)", thisVars:["this_f"]},
                  rvalue:true,
                  count:2,
                  funcName: f+"opseq"
                  })
  }
})();

exports.any = compile({
  args:["array"],
  pre: EmptyProc,
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:1}], body: "if(a){return true}", localVars: [], thisVars: []},
  post: {args:[], localVars:[], thisVars:[], body:"return false"},
  funcName: "any"
})

exports.all = compile({
  args:["array"],
  pre: EmptyProc,
  body: {args:[{name:"x", lvalue:false, rvalue:true, count:1}], body: "if(!x){return false}", localVars: [], thisVars: []},
  post: {args:[], localVars:[], thisVars:[], body:"return true"},
  funcName: "all"
})

exports.sum = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:1}], body: "this_s+=a", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
  funcName: "sum"
})

exports.prod = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=1"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:1}], body: "this_s*=a", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
  funcName: "prod"
})

exports.norm2squared = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:2}], body: "this_s+=a*a", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
  funcName: "norm2squared"
})
  
exports.norm2 = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:2}], body: "this_s+=a*a", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return Math.sqrt(this_s)"},
  funcName: "norm2"
})
  

exports.norminf = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:4}], body:"if(-a>this_s){this_s=-a}else if(a>this_s){this_s=a}", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
  funcName: "norminf"
})

exports.norm1 = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:3}], body: "this_s+=a<0?-a:a", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
  funcName: "norm1"
})

exports.sup = compile({
  args: [ "array" ],
  pre:
   { body: "this_h=-Infinity",
     args: [],
     thisVars: [ "this_h" ],
     localVars: [] },
  body:
   { body: "if(_inline_1_arg0_>this_h)this_h=_inline_1_arg0_",
     args: [{"name":"_inline_1_arg0_","lvalue":false,"rvalue":true,"count":2} ],
     thisVars: [ "this_h" ],
     localVars: [] },
  post:
   { body: "return this_h",
     args: [],
     thisVars: [ "this_h" ],
     localVars: [] }
 })

exports.inf = compile({
  args: [ "array" ],
  pre:
   { body: "this_h=Infinity",
     args: [],
     thisVars: [ "this_h" ],
     localVars: [] },
  body:
   { body: "if(_inline_1_arg0_<this_h)this_h=_inline_1_arg0_",
     args: [{"name":"_inline_1_arg0_","lvalue":false,"rvalue":true,"count":2} ],
     thisVars: [ "this_h" ],
     localVars: [] },
  post:
   { body: "return this_h",
     args: [],
     thisVars: [ "this_h" ],
     localVars: [] }
 })

exports.argmin = compile({
  args:["index","array","shape"],
  pre:{
    body:"{this_v=Infinity;this_i=_inline_0_arg2_.slice(0)}",
    args:[
      {name:"_inline_0_arg0_",lvalue:false,rvalue:false,count:0},
      {name:"_inline_0_arg1_",lvalue:false,rvalue:false,count:0},
      {name:"_inline_0_arg2_",lvalue:false,rvalue:true,count:1}
      ],
    thisVars:["this_i","this_v"],
    localVars:[]},
  body:{
    body:"{if(_inline_1_arg1_<this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
    args:[
      {name:"_inline_1_arg0_",lvalue:false,rvalue:true,count:2},
      {name:"_inline_1_arg1_",lvalue:false,rvalue:true,count:2}],
    thisVars:["this_i","this_v"],
    localVars:["_inline_1_k"]},
  post:{
    body:"{return this_i}",
    args:[],
    thisVars:["this_i"],
    localVars:[]}
})

exports.argmax = compile({
  args:["index","array","shape"],
  pre:{
    body:"{this_v=-Infinity;this_i=_inline_0_arg2_.slice(0)}",
    args:[
      {name:"_inline_0_arg0_",lvalue:false,rvalue:false,count:0},
      {name:"_inline_0_arg1_",lvalue:false,rvalue:false,count:0},
      {name:"_inline_0_arg2_",lvalue:false,rvalue:true,count:1}
      ],
    thisVars:["this_i","this_v"],
    localVars:[]},
  body:{
    body:"{if(_inline_1_arg1_>this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
    args:[
      {name:"_inline_1_arg0_",lvalue:false,rvalue:true,count:2},
      {name:"_inline_1_arg1_",lvalue:false,rvalue:true,count:2}],
    thisVars:["this_i","this_v"],
    localVars:["_inline_1_k"]},
  post:{
    body:"{return this_i}",
    args:[],
    thisVars:["this_i"],
    localVars:[]}
})  

exports.random = makeOp({
  args: ["array"],
  pre: {args:[], body:"this_f=Math.random", thisVars:["this_f"]},
  body: {args: ["a"], body:"a=this_f()", thisVars:["this_f"]},
  funcName: "random"
})

exports.assign = makeOp({
  args:["array", "array"],
  body: {args:["a", "b"], body:"a=b"},
  funcName: "assign" })

exports.assigns = makeOp({
  args:["array", "scalar"],
  body: {args:["a", "b"], body:"a=b"},
  funcName: "assigns" })


exports.equals = compile({
  args:["array", "array"],
  pre: EmptyProc,
  body: {args:[{name:"x", lvalue:false, rvalue:true, count:1},
               {name:"y", lvalue:false, rvalue:true, count:1}], 
        body: "if(x!==y){return false}", 
        localVars: [], 
        thisVars: []},
  post: {args:[], localVars:[], thisVars:[], body:"return true"},
  funcName: "equals"
})



},{"cwise-compiler":36}],163:[function(require,module,exports){
"use strict"

var ndarray = require("ndarray")
var do_convert = require("./doConvert.js")

module.exports = function convert(arr, result) {
  var shape = [], c = arr, sz = 1
  while(Array.isArray(c)) {
    shape.push(c.length)
    sz *= c.length
    c = c[0]
  }
  if(shape.length === 0) {
    return ndarray()
  }
  if(!result) {
    result = ndarray(new Float64Array(sz), shape)
  }
  do_convert(result, arr)
  return result
}

},{"./doConvert.js":164,"ndarray":165}],164:[function(require,module,exports){
module.exports=require('cwise-compiler')({"args":["array","scalar","index"],"pre":{"body":"{}","args":[],"thisVars":[],"localVars":[]},"body":{"body":"{\nvar _inline_1_v=_inline_1_arg1_,_inline_1_i\nfor(_inline_1_i=0;_inline_1_i<_inline_1_arg2_.length-1;++_inline_1_i) {\n_inline_1_v=_inline_1_v[_inline_1_arg2_[_inline_1_i]]\n}\n_inline_1_arg0_=_inline_1_v[_inline_1_arg2_[_inline_1_arg2_.length-1]]\n}","args":[{"name":"_inline_1_arg0_","lvalue":true,"rvalue":false,"count":1},{"name":"_inline_1_arg1_","lvalue":false,"rvalue":true,"count":1},{"name":"_inline_1_arg2_","lvalue":false,"rvalue":true,"count":4}],"thisVars":[],"localVars":["_inline_1_i","_inline_1_v"]},"post":{"body":"{}","args":[],"thisVars":[],"localVars":[]},"funcName":"convert","blockSize":64})

},{"cwise-compiler":36}],165:[function(require,module,exports){
var iota = require("iota-array")
var isBuffer = require("is-buffer")

var hasTypedArrays  = ((typeof Float64Array) !== "undefined")

function compare1st(a, b) {
  return a[0] - b[0]
}

function order() {
  var stride = this.stride
  var terms = new Array(stride.length)
  var i
  for(i=0; i<terms.length; ++i) {
    terms[i] = [Math.abs(stride[i]), i]
  }
  terms.sort(compare1st)
  var result = new Array(terms.length)
  for(i=0; i<result.length; ++i) {
    result[i] = terms[i][1]
  }
  return result
}

function compileConstructor(dtype, dimension) {
  var className = ["View", dimension, "d", dtype].join("")
  if(dimension < 0) {
    className = "View_Nil" + dtype
  }
  var useGetters = (dtype === "generic")

  if(dimension === -1) {
    //Special case for trivial arrays
    var code =
      "function "+className+"(a){this.data=a;};\
var proto="+className+".prototype;\
proto.dtype='"+dtype+"';\
proto.index=function(){return -1};\
proto.size=0;\
proto.dimension=-1;\
proto.shape=proto.stride=proto.order=[];\
proto.lo=proto.hi=proto.transpose=proto.step=\
function(){return new "+className+"(this.data);};\
proto.get=proto.set=function(){};\
proto.pick=function(){return null};\
return function construct_"+className+"(a){return new "+className+"(a);}"
    var procedure = new Function(code)
    return procedure()
  } else if(dimension === 0) {
    //Special case for 0d arrays
    var code =
      "function "+className+"(a,d) {\
this.data = a;\
this.offset = d\
};\
var proto="+className+".prototype;\
proto.dtype='"+dtype+"';\
proto.index=function(){return this.offset};\
proto.dimension=0;\
proto.size=1;\
proto.shape=\
proto.stride=\
proto.order=[];\
proto.lo=\
proto.hi=\
proto.transpose=\
proto.step=function "+className+"_copy() {\
return new "+className+"(this.data,this.offset)\
};\
proto.pick=function "+className+"_pick(){\
return TrivialArray(this.data);\
};\
proto.valueOf=proto.get=function "+className+"_get(){\
return "+(useGetters ? "this.data.get(this.offset)" : "this.data[this.offset]")+
"};\
proto.set=function "+className+"_set(v){\
return "+(useGetters ? "this.data.set(this.offset,v)" : "this.data[this.offset]=v")+"\
};\
return function construct_"+className+"(a,b,c,d){return new "+className+"(a,d)}"
    var procedure = new Function("TrivialArray", code)
    return procedure(CACHED_CONSTRUCTORS[dtype][0])
  }

  var code = ["'use strict'"]

  //Create constructor for view
  var indices = iota(dimension)
  var args = indices.map(function(i) { return "i"+i })
  var index_str = "this.offset+" + indices.map(function(i) {
        return "this.stride[" + i + "]*i" + i
      }).join("+")
  var shapeArg = indices.map(function(i) {
      return "b"+i
    }).join(",")
  var strideArg = indices.map(function(i) {
      return "c"+i
    }).join(",")
  code.push(
    "function "+className+"(a," + shapeArg + "," + strideArg + ",d){this.data=a",
      "this.shape=[" + shapeArg + "]",
      "this.stride=[" + strideArg + "]",
      "this.offset=d|0}",
    "var proto="+className+".prototype",
    "proto.dtype='"+dtype+"'",
    "proto.dimension="+dimension)

  //view.size:
  code.push("Object.defineProperty(proto,'size',{get:function "+className+"_size(){\
return "+indices.map(function(i) { return "this.shape["+i+"]" }).join("*"),
"}})")

  //view.order:
  if(dimension === 1) {
    code.push("proto.order=[0]")
  } else {
    code.push("Object.defineProperty(proto,'order',{get:")
    if(dimension < 4) {
      code.push("function "+className+"_order(){")
      if(dimension === 2) {
        code.push("return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})")
      } else if(dimension === 3) {
        code.push(
"var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\
if(s0>s1){\
if(s1>s2){\
return [2,1,0];\
}else if(s0>s2){\
return [1,2,0];\
}else{\
return [1,0,2];\
}\
}else if(s0>s2){\
return [2,0,1];\
}else if(s2>s1){\
return [0,1,2];\
}else{\
return [0,2,1];\
}}})")
      }
    } else {
      code.push("ORDER})")
    }
  }

  //view.set(i0, ..., v):
  code.push(
"proto.set=function "+className+"_set("+args.join(",")+",v){")
  if(useGetters) {
    code.push("return this.data.set("+index_str+",v)}")
  } else {
    code.push("return this.data["+index_str+"]=v}")
  }

  //view.get(i0, ...):
  code.push("proto.get=function "+className+"_get("+args.join(",")+"){")
  if(useGetters) {
    code.push("return this.data.get("+index_str+")}")
  } else {
    code.push("return this.data["+index_str+"]}")
  }

  //view.index:
  code.push(
    "proto.index=function "+className+"_index(", args.join(), "){return "+index_str+"}")

  //view.hi():
  code.push("proto.hi=function "+className+"_hi("+args.join(",")+"){return new "+className+"(this.data,"+
    indices.map(function(i) {
      return ["(typeof i",i,"!=='number'||i",i,"<0)?this.shape[", i, "]:i", i,"|0"].join("")
    }).join(",")+","+
    indices.map(function(i) {
      return "this.stride["+i + "]"
    }).join(",")+",this.offset)}")

  //view.lo():
  var a_vars = indices.map(function(i) { return "a"+i+"=this.shape["+i+"]" })
  var c_vars = indices.map(function(i) { return "c"+i+"=this.stride["+i+"]" })
  code.push("proto.lo=function "+className+"_lo("+args.join(",")+"){var b=this.offset,d=0,"+a_vars.join(",")+","+c_vars.join(","))
  for(var i=0; i<dimension; ++i) {
    code.push(
"if(typeof i"+i+"==='number'&&i"+i+">=0){\
d=i"+i+"|0;\
b+=c"+i+"*d;\
a"+i+"-=d}")
  }
  code.push("return new "+className+"(this.data,"+
    indices.map(function(i) {
      return "a"+i
    }).join(",")+","+
    indices.map(function(i) {
      return "c"+i
    }).join(",")+",b)}")

  //view.step():
  code.push("proto.step=function "+className+"_step("+args.join(",")+"){var "+
    indices.map(function(i) {
      return "a"+i+"=this.shape["+i+"]"
    }).join(",")+","+
    indices.map(function(i) {
      return "b"+i+"=this.stride["+i+"]"
    }).join(",")+",c=this.offset,d=0,ceil=Math.ceil")
  for(var i=0; i<dimension; ++i) {
    code.push(
"if(typeof i"+i+"==='number'){\
d=i"+i+"|0;\
if(d<0){\
c+=b"+i+"*(a"+i+"-1);\
a"+i+"=ceil(-a"+i+"/d)\
}else{\
a"+i+"=ceil(a"+i+"/d)\
}\
b"+i+"*=d\
}")
  }
  code.push("return new "+className+"(this.data,"+
    indices.map(function(i) {
      return "a" + i
    }).join(",")+","+
    indices.map(function(i) {
      return "b" + i
    }).join(",")+",c)}")

  //view.transpose():
  var tShape = new Array(dimension)
  var tStride = new Array(dimension)
  for(var i=0; i<dimension; ++i) {
    tShape[i] = "a[i"+i+"]"
    tStride[i] = "b[i"+i+"]"
  }
  code.push("proto.transpose=function "+className+"_transpose("+args+"){"+
    args.map(function(n,idx) { return n + "=(" + n + "===undefined?" + idx + ":" + n + "|0)"}).join(";"),
    "var a=this.shape,b=this.stride;return new "+className+"(this.data,"+tShape.join(",")+","+tStride.join(",")+",this.offset)}")

  //view.pick():
  code.push("proto.pick=function "+className+"_pick("+args+"){var a=[],b=[],c=this.offset")
  for(var i=0; i<dimension; ++i) {
    code.push("if(typeof i"+i+"==='number'&&i"+i+">=0){c=(c+this.stride["+i+"]*i"+i+")|0}else{a.push(this.shape["+i+"]);b.push(this.stride["+i+"])}")
  }
  code.push("var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}")

  //Add return statement
  code.push("return function construct_"+className+"(data,shape,stride,offset){return new "+className+"(data,"+
    indices.map(function(i) {
      return "shape["+i+"]"
    }).join(",")+","+
    indices.map(function(i) {
      return "stride["+i+"]"
    }).join(",")+",offset)}")

  //Compile procedure
  var procedure = new Function("CTOR_LIST", "ORDER", code.join("\n"))
  return procedure(CACHED_CONSTRUCTORS[dtype], order)
}

function arrayDType(data) {
  if(isBuffer(data)) {
    return "buffer"
  }
  if(hasTypedArrays) {
    switch(Object.prototype.toString.call(data)) {
      case "[object Float64Array]":
        return "float64"
      case "[object Float32Array]":
        return "float32"
      case "[object Int8Array]":
        return "int8"
      case "[object Int16Array]":
        return "int16"
      case "[object Int32Array]":
        return "int32"
      case "[object Uint8Array]":
        return "uint8"
      case "[object Uint16Array]":
        return "uint16"
      case "[object Uint32Array]":
        return "uint32"
      case "[object Uint8ClampedArray]":
        return "uint8_clamped"
      case "[object BigInt64Array]":
        return "bigint64"
      case "[object BigUint64Array]":
        return "biguint64"
    }
  }
  if(Array.isArray(data)) {
    return "array"
  }
  return "generic"
}

var CACHED_CONSTRUCTORS = {
  "float32":[],
  "float64":[],
  "int8":[],
  "int16":[],
  "int32":[],
  "uint8":[],
  "uint16":[],
  "uint32":[],
  "array":[],
  "uint8_clamped":[],
  "bigint64": [],
  "biguint64": [],
  "buffer":[],
  "generic":[]
}

;(function() {
  for(var id in CACHED_CONSTRUCTORS) {
    CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1))
  }
});

function wrappedNDArrayCtor(data, shape, stride, offset) {
  if(data === undefined) {
    var ctor = CACHED_CONSTRUCTORS.array[0]
    return ctor([])
  } else if(typeof data === "number") {
    data = [data]
  }
  if(shape === undefined) {
    shape = [ data.length ]
  }
  var d = shape.length
  if(stride === undefined) {
    stride = new Array(d)
    for(var i=d-1, sz=1; i>=0; --i) {
      stride[i] = sz
      sz *= shape[i]
    }
  }
  if(offset === undefined) {
    offset = 0
    for(var i=0; i<d; ++i) {
      if(stride[i] < 0) {
        offset -= (shape[i]-1)*stride[i]
      }
    }
  }
  var dtype = arrayDType(data)
  var ctor_list = CACHED_CONSTRUCTORS[dtype]
  while(ctor_list.length <= d+1) {
    ctor_list.push(compileConstructor(dtype, ctor_list.length-1))
  }
  var ctor = ctor_list[d+1]
  return ctor(data, shape, stride, offset)
}

module.exports = wrappedNDArrayCtor

},{"iota-array":123,"is-buffer":124}],166:[function(require,module,exports){
// (c) Dean McNamee <dean@gmail.com>, 2013.
//
// https://github.com/deanm/omggif
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
//
// omggif is a JavaScript implementation of a GIF 89a encoder and decoder,
// including animation and compression.  It does not rely on any specific
// underlying system, so should run in the browser, Node, or Plask.

"use strict";

function GifWriter(buf, width, height, gopts) {
  var p = 0;

  var gopts = gopts === undefined ? { } : gopts;
  var loop_count = gopts.loop === undefined ? null : gopts.loop;
  var global_palette = gopts.palette === undefined ? null : gopts.palette;

  if (width <= 0 || height <= 0 || width > 65535 || height > 65535)
    throw new Error("Width/Height invalid.");

  function check_palette_and_num_colors(palette) {
    var num_colors = palette.length;
    if (num_colors < 2 || num_colors > 256 ||  num_colors & (num_colors-1)) {
      throw new Error(
          "Invalid code/color length, must be power of 2 and 2 .. 256.");
    }
    return num_colors;
  }

  // - Header.
  buf[p++] = 0x47; buf[p++] = 0x49; buf[p++] = 0x46;  // GIF
  buf[p++] = 0x38; buf[p++] = 0x39; buf[p++] = 0x61;  // 89a

  // Handling of Global Color Table (palette) and background index.
  var gp_num_colors_pow2 = 0;
  var background = 0;
  if (global_palette !== null) {
    var gp_num_colors = check_palette_and_num_colors(global_palette);
    while (gp_num_colors >>= 1) ++gp_num_colors_pow2;
    gp_num_colors = 1 << gp_num_colors_pow2;
    --gp_num_colors_pow2;
    if (gopts.background !== undefined) {
      background = gopts.background;
      if (background >= gp_num_colors)
        throw new Error("Background index out of range.");
      // The GIF spec states that a background index of 0 should be ignored, so
      // this is probably a mistake and you really want to set it to another
      // slot in the palette.  But actually in the end most browsers, etc end
      // up ignoring this almost completely (including for dispose background).
      if (background === 0)
        throw new Error("Background index explicitly passed as 0.");
    }
  }

  // - Logical Screen Descriptor.
  // NOTE(deanm): w/h apparently ignored by implementations, but set anyway.
  buf[p++] = width & 0xff; buf[p++] = width >> 8 & 0xff;
  buf[p++] = height & 0xff; buf[p++] = height >> 8 & 0xff;
  // NOTE: Indicates 0-bpp original color resolution (unused?).
  buf[p++] = (global_palette !== null ? 0x80 : 0) |  // Global Color Table Flag.
             gp_num_colors_pow2;  // NOTE: No sort flag (unused?).
  buf[p++] = background;  // Background Color Index.
  buf[p++] = 0;  // Pixel aspect ratio (unused?).

  // - Global Color Table
  if (global_palette !== null) {
    for (var i = 0, il = global_palette.length; i < il; ++i) {
      var rgb = global_palette[i];
      buf[p++] = rgb >> 16 & 0xff;
      buf[p++] = rgb >> 8 & 0xff;
      buf[p++] = rgb & 0xff;
    }
  }

  if (loop_count !== null) {  // Netscape block for looping.
    if (loop_count < 0 || loop_count > 65535)
      throw new Error("Loop count invalid.")
    // Extension code, label, and length.
    buf[p++] = 0x21; buf[p++] = 0xff; buf[p++] = 0x0b;
    // NETSCAPE2.0
    buf[p++] = 0x4e; buf[p++] = 0x45; buf[p++] = 0x54; buf[p++] = 0x53;
    buf[p++] = 0x43; buf[p++] = 0x41; buf[p++] = 0x50; buf[p++] = 0x45;
    buf[p++] = 0x32; buf[p++] = 0x2e; buf[p++] = 0x30;
    // Sub-block
    buf[p++] = 0x03; buf[p++] = 0x01;
    buf[p++] = loop_count & 0xff; buf[p++] = loop_count >> 8 & 0xff;
    buf[p++] = 0x00;  // Terminator.
  }


  var ended = false;

  this.addFrame = function(x, y, w, h, indexed_pixels, opts) {
    if (ended === true) { --p; ended = false; }  // Un-end.

    opts = opts === undefined ? { } : opts;

    // TODO(deanm): Bounds check x, y.  Do they need to be within the virtual
    // canvas width/height, I imagine?
    if (x < 0 || y < 0 || x > 65535 || y > 65535)
      throw new Error("x/y invalid.")

    if (w <= 0 || h <= 0 || w > 65535 || h > 65535)
      throw new Error("Width/Height invalid.")

    if (indexed_pixels.length < w * h)
      throw new Error("Not enough pixels for the frame size.");

    var using_local_palette = true;
    var palette = opts.palette;
    if (palette === undefined || palette === null) {
      using_local_palette = false;
      palette = global_palette;
    }

    if (palette === undefined || palette === null)
      throw new Error("Must supply either a local or global palette.");

    var num_colors = check_palette_and_num_colors(palette);

    // Compute the min_code_size (power of 2), destroying num_colors.
    var min_code_size = 0;
    while (num_colors >>= 1) ++min_code_size;
    num_colors = 1 << min_code_size;  // Now we can easily get it back.

    var delay = opts.delay === undefined ? 0 : opts.delay;

    // From the spec:
    //     0 -   No disposal specified. The decoder is
    //           not required to take any action.
    //     1 -   Do not dispose. The graphic is to be left
    //           in place.
    //     2 -   Restore to background color. The area used by the
    //           graphic must be restored to the background color.
    //     3 -   Restore to previous. The decoder is required to
    //           restore the area overwritten by the graphic with
    //           what was there prior to rendering the graphic.
    //  4-7 -    To be defined.
    // NOTE(deanm): Dispose background doesn't really work, apparently most
    // browsers ignore the background palette index and clear to transparency.
    var disposal = opts.disposal === undefined ? 0 : opts.disposal;
    if (disposal < 0 || disposal > 3)  // 4-7 is reserved.
      throw new Error("Disposal out of range.");

    var use_transparency = false;
    var transparent_index = 0;
    if (opts.transparent !== undefined && opts.transparent !== null) {
      use_transparency = true;
      transparent_index = opts.transparent;
      if (transparent_index < 0 || transparent_index >= num_colors)
        throw new Error("Transparent color index.");
    }

    if (disposal !== 0 || use_transparency || delay !== 0) {
      // - Graphics Control Extension
      buf[p++] = 0x21; buf[p++] = 0xf9;  // Extension / Label.
      buf[p++] = 4;  // Byte size.

      buf[p++] = disposal << 2 | (use_transparency === true ? 1 : 0);
      buf[p++] = delay & 0xff; buf[p++] = delay >> 8 & 0xff;
      buf[p++] = transparent_index;  // Transparent color index.
      buf[p++] = 0;  // Block Terminator.
    }

    // - Image Descriptor
    buf[p++] = 0x2c;  // Image Seperator.
    buf[p++] = x & 0xff; buf[p++] = x >> 8 & 0xff;  // Left.
    buf[p++] = y & 0xff; buf[p++] = y >> 8 & 0xff;  // Top.
    buf[p++] = w & 0xff; buf[p++] = w >> 8 & 0xff;
    buf[p++] = h & 0xff; buf[p++] = h >> 8 & 0xff;
    // NOTE: No sort flag (unused?).
    // TODO(deanm): Support interlace.
    buf[p++] = using_local_palette === true ? (0x80 | (min_code_size-1)) : 0;

    // - Local Color Table
    if (using_local_palette === true) {
      for (var i = 0, il = palette.length; i < il; ++i) {
        var rgb = palette[i];
        buf[p++] = rgb >> 16 & 0xff;
        buf[p++] = rgb >> 8 & 0xff;
        buf[p++] = rgb & 0xff;
      }
    }

    p = GifWriterOutputLZWCodeStream(
            buf, p, min_code_size < 2 ? 2 : min_code_size, indexed_pixels);

    return p;
  };

  this.end = function() {
    if (ended === false) {
      buf[p++] = 0x3b;  // Trailer.
      ended = true;
    }
    return p;
  };

  this.getOutputBuffer = function() { return buf; };
  this.setOutputBuffer = function(v) { buf = v; };
  this.getOutputBufferPosition = function() { return p; };
  this.setOutputBufferPosition = function(v) { p = v; };
}

// Main compression routine, palette indexes -> LZW code stream.
// |index_stream| must have at least one entry.
function GifWriterOutputLZWCodeStream(buf, p, min_code_size, index_stream) {
  buf[p++] = min_code_size;
  var cur_subblock = p++;  // Pointing at the length field.

  var clear_code = 1 << min_code_size;
  var code_mask = clear_code - 1;
  var eoi_code = clear_code + 1;
  var next_code = eoi_code + 1;

  var cur_code_size = min_code_size + 1;  // Number of bits per code.
  var cur_shift = 0;
  // We have at most 12-bit codes, so we should have to hold a max of 19
  // bits here (and then we would write out).
  var cur = 0;

  function emit_bytes_to_buffer(bit_block_size) {
    while (cur_shift >= bit_block_size) {
      buf[p++] = cur & 0xff;
      cur >>= 8; cur_shift -= 8;
      if (p === cur_subblock + 256) {  // Finished a subblock.
        buf[cur_subblock] = 255;
        cur_subblock = p++;
      }
    }
  }

  function emit_code(c) {
    cur |= c << cur_shift;
    cur_shift += cur_code_size;
    emit_bytes_to_buffer(8);
  }

  // I am not an expert on the topic, and I don't want to write a thesis.
  // However, it is good to outline here the basic algorithm and the few data
  // structures and optimizations here that make this implementation fast.
  // The basic idea behind LZW is to build a table of previously seen runs
  // addressed by a short id (herein called output code).  All data is
  // referenced by a code, which represents one or more values from the
  // original input stream.  All input bytes can be referenced as the same
  // value as an output code.  So if you didn't want any compression, you
  // could more or less just output the original bytes as codes (there are
  // some details to this, but it is the idea).  In order to achieve
  // compression, values greater then the input range (codes can be up to
  // 12-bit while input only 8-bit) represent a sequence of previously seen
  // inputs.  The decompressor is able to build the same mapping while
  // decoding, so there is always a shared common knowledge between the
  // encoding and decoder, which is also important for "timing" aspects like
  // how to handle variable bit width code encoding.
  //
  // One obvious but very important consequence of the table system is there
  // is always a unique id (at most 12-bits) to map the runs.  'A' might be
  // 4, then 'AA' might be 10, 'AAA' 11, 'AAAA' 12, etc.  This relationship
  // can be used for an effecient lookup strategy for the code mapping.  We
  // need to know if a run has been seen before, and be able to map that run
  // to the output code.  Since we start with known unique ids (input bytes),
  // and then from those build more unique ids (table entries), we can
  // continue this chain (almost like a linked list) to always have small
  // integer values that represent the current byte chains in the encoder.
  // This means instead of tracking the input bytes (AAAABCD) to know our
  // current state, we can track the table entry for AAAABC (it is guaranteed
  // to exist by the nature of the algorithm) and the next character D.
  // Therefor the tuple of (table_entry, byte) is guaranteed to also be
  // unique.  This allows us to create a simple lookup key for mapping input
  // sequences to codes (table indices) without having to store or search
  // any of the code sequences.  So if 'AAAA' has a table entry of 12, the
  // tuple of ('AAAA', K) for any input byte K will be unique, and can be our
  // key.  This leads to a integer value at most 20-bits, which can always
  // fit in an SMI value and be used as a fast sparse array / object key.

  // Output code for the current contents of the index buffer.
  var ib_code = index_stream[0] & code_mask;  // Load first input index.
  var code_table = { };  // Key'd on our 20-bit "tuple".

  emit_code(clear_code);  // Spec says first code should be a clear code.

  // First index already loaded, process the rest of the stream.
  for (var i = 1, il = index_stream.length; i < il; ++i) {
    var k = index_stream[i] & code_mask;
    var cur_key = ib_code << 8 | k;  // (prev, k) unique tuple.
    var cur_code = code_table[cur_key];  // buffer + k.

    // Check if we have to create a new code table entry.
    if (cur_code === undefined) {  // We don't have buffer + k.
      // Emit index buffer (without k).
      // This is an inline version of emit_code, because this is the core
      // writing routine of the compressor (and V8 cannot inline emit_code
      // because it is a closure here in a different context).  Additionally
      // we can call emit_byte_to_buffer less often, because we can have
      // 30-bits (from our 31-bit signed SMI), and we know our codes will only
      // be 12-bits, so can safely have 18-bits there without overflow.
      // emit_code(ib_code);
      cur |= ib_code << cur_shift;
      cur_shift += cur_code_size;
      while (cur_shift >= 8) {
        buf[p++] = cur & 0xff;
        cur >>= 8; cur_shift -= 8;
        if (p === cur_subblock + 256) {  // Finished a subblock.
          buf[cur_subblock] = 255;
          cur_subblock = p++;
        }
      }

      if (next_code === 4096) {  // Table full, need a clear.
        emit_code(clear_code);
        next_code = eoi_code + 1;
        cur_code_size = min_code_size + 1;
        code_table = { };
      } else {  // Table not full, insert a new entry.
        // Increase our variable bit code sizes if necessary.  This is a bit
        // tricky as it is based on "timing" between the encoding and
        // decoder.  From the encoders perspective this should happen after
        // we've already emitted the index buffer and are about to create the
        // first table entry that would overflow our current code bit size.
        if (next_code >= (1 << cur_code_size)) ++cur_code_size;
        code_table[cur_key] = next_code++;  // Insert into code table.
      }

      ib_code = k;  // Index buffer to single input k.
    } else {
      ib_code = cur_code;  // Index buffer to sequence in code table.
    }
  }

  emit_code(ib_code);  // There will still be something in the index buffer.
  emit_code(eoi_code);  // End Of Information.

  // Flush / finalize the sub-blocks stream to the buffer.
  emit_bytes_to_buffer(1);

  // Finish the sub-blocks, writing out any unfinished lengths and
  // terminating with a sub-block of length 0.  If we have already started
  // but not yet used a sub-block it can just become the terminator.
  if (cur_subblock + 1 === p) {  // Started but unused.
    buf[cur_subblock] = 0;
  } else {  // Started and used, write length and additional terminator block.
    buf[cur_subblock] = p - cur_subblock - 1;
    buf[p++] = 0;
  }
  return p;
}

function GifReader(buf) {
  var p = 0;

  // - Header (GIF87a or GIF89a).
  if (buf[p++] !== 0x47 ||            buf[p++] !== 0x49 || buf[p++] !== 0x46 ||
      buf[p++] !== 0x38 || (buf[p++]+1 & 0xfd) !== 0x38 || buf[p++] !== 0x61) {
    throw new Error("Invalid GIF 87a/89a header.");
  }

  // - Logical Screen Descriptor.
  var width = buf[p++] | buf[p++] << 8;
  var height = buf[p++] | buf[p++] << 8;
  var pf0 = buf[p++];  // <Packed Fields>.
  var global_palette_flag = pf0 >> 7;
  var num_global_colors_pow2 = pf0 & 0x7;
  var num_global_colors = 1 << (num_global_colors_pow2 + 1);
  var background = buf[p++];
  buf[p++];  // Pixel aspect ratio (unused?).

  var global_palette_offset = null;
  var global_palette_size   = null;

  if (global_palette_flag) {
    global_palette_offset = p;
    global_palette_size = num_global_colors;
    p += num_global_colors * 3;  // Seek past palette.
  }

  var no_eof = true;

  var frames = [ ];

  var delay = 0;
  var transparent_index = null;
  var disposal = 0;  // 0 - No disposal specified.
  var loop_count = null;

  this.width = width;
  this.height = height;

  while (no_eof && p < buf.length) {
    switch (buf[p++]) {
      case 0x21:  // Graphics Control Extension Block
        switch (buf[p++]) {
          case 0xff:  // Application specific block
            // Try if it's a Netscape block (with animation loop counter).
            if (buf[p   ] !== 0x0b ||  // 21 FF already read, check block size.
                // NETSCAPE2.0
                buf[p+1 ] == 0x4e && buf[p+2 ] == 0x45 && buf[p+3 ] == 0x54 &&
                buf[p+4 ] == 0x53 && buf[p+5 ] == 0x43 && buf[p+6 ] == 0x41 &&
                buf[p+7 ] == 0x50 && buf[p+8 ] == 0x45 && buf[p+9 ] == 0x32 &&
                buf[p+10] == 0x2e && buf[p+11] == 0x30 &&
                // Sub-block
                buf[p+12] == 0x03 && buf[p+13] == 0x01 && buf[p+16] == 0) {
              p += 14;
              loop_count = buf[p++] | buf[p++] << 8;
              p++;  // Skip terminator.
            } else {  // We don't know what it is, just try to get past it.
              p += 12;
              while (true) {  // Seek through subblocks.
                var block_size = buf[p++];
                // Bad block size (ex: undefined from an out of bounds read).
                if (!(block_size >= 0)) throw Error("Invalid block size");
                if (block_size === 0) break;  // 0 size is terminator
                p += block_size;
              }
            }
            break;

          case 0xf9:  // Graphics Control Extension
            if (buf[p++] !== 0x4 || buf[p+4] !== 0)
              throw new Error("Invalid graphics extension block.");
            var pf1 = buf[p++];
            delay = buf[p++] | buf[p++] << 8;
            transparent_index = buf[p++];
            if ((pf1 & 1) === 0) transparent_index = null;
            disposal = pf1 >> 2 & 0x7;
            p++;  // Skip terminator.
            break;

          case 0xfe:  // Comment Extension.
            while (true) {  // Seek through subblocks.
              var block_size = buf[p++];
              // Bad block size (ex: undefined from an out of bounds read).
              if (!(block_size >= 0)) throw Error("Invalid block size");
              if (block_size === 0) break;  // 0 size is terminator
              // console.log(buf.slice(p, p+block_size).toString('ascii'));
              p += block_size;
            }
            break;

          default:
            throw new Error(
                "Unknown graphic control label: 0x" + buf[p-1].toString(16));
        }
        break;

      case 0x2c:  // Image Descriptor.
        var x = buf[p++] | buf[p++] << 8;
        var y = buf[p++] | buf[p++] << 8;
        var w = buf[p++] | buf[p++] << 8;
        var h = buf[p++] | buf[p++] << 8;
        var pf2 = buf[p++];
        var local_palette_flag = pf2 >> 7;
        var interlace_flag = pf2 >> 6 & 1;
        var num_local_colors_pow2 = pf2 & 0x7;
        var num_local_colors = 1 << (num_local_colors_pow2 + 1);
        var palette_offset = global_palette_offset;
        var palette_size = global_palette_size;
        var has_local_palette = false;
        if (local_palette_flag) {
          var has_local_palette = true;
          palette_offset = p;  // Override with local palette.
          palette_size = num_local_colors;
          p += num_local_colors * 3;  // Seek past palette.
        }

        var data_offset = p;

        p++;  // codesize
        while (true) {
          var block_size = buf[p++];
          // Bad block size (ex: undefined from an out of bounds read).
          if (!(block_size >= 0)) throw Error("Invalid block size");
          if (block_size === 0) break;  // 0 size is terminator
          p += block_size;
        }

        frames.push({x: x, y: y, width: w, height: h,
                     has_local_palette: has_local_palette,
                     palette_offset: palette_offset,
                     palette_size: palette_size,
                     data_offset: data_offset,
                     data_length: p - data_offset,
                     transparent_index: transparent_index,
                     interlaced: !!interlace_flag,
                     delay: delay,
                     disposal: disposal});
        break;

      case 0x3b:  // Trailer Marker (end of file).
        no_eof = false;
        break;

      default:
        throw new Error("Unknown gif block: 0x" + buf[p-1].toString(16));
        break;
    }
  }

  this.numFrames = function() {
    return frames.length;
  };

  this.loopCount = function() {
    return loop_count;
  };

  this.frameInfo = function(frame_num) {
    if (frame_num < 0 || frame_num >= frames.length)
      throw new Error("Frame index out of range.");
    return frames[frame_num];
  }

  this.decodeAndBlitFrameBGRA = function(frame_num, pixels) {
    var frame = this.frameInfo(frame_num);
    var num_pixels = frame.width * frame.height;
    var index_stream = new Uint8Array(num_pixels);  // At most 8-bit indices.
    GifReaderLZWOutputIndexStream(
        buf, frame.data_offset, index_stream, num_pixels);
    var palette_offset = frame.palette_offset;

    // NOTE(deanm): It seems to be much faster to compare index to 256 than
    // to === null.  Not sure why, but CompareStub_EQ_STRICT shows up high in
    // the profile, not sure if it's related to using a Uint8Array.
    var trans = frame.transparent_index;
    if (trans === null) trans = 256;

    // We are possibly just blitting to a portion of the entire frame.
    // That is a subrect within the framerect, so the additional pixels
    // must be skipped over after we finished a scanline.
    var framewidth  = frame.width;
    var framestride = width - framewidth;
    var xleft       = framewidth;  // Number of subrect pixels left in scanline.

    // Output indicies of the top left and bottom right corners of the subrect.
    var opbeg = ((frame.y * width) + frame.x) * 4;
    var opend = ((frame.y + frame.height) * width + frame.x) * 4;
    var op    = opbeg;

    var scanstride = framestride * 4;

    // Use scanstride to skip past the rows when interlacing.  This is skipping
    // 7 rows for the first two passes, then 3 then 1.
    if (frame.interlaced === true) {
      scanstride += width * 4 * 7;  // Pass 1.
    }

    var interlaceskip = 8;  // Tracking the row interval in the current pass.

    for (var i = 0, il = index_stream.length; i < il; ++i) {
      var index = index_stream[i];

      if (xleft === 0) {  // Beginning of new scan line
        op += scanstride;
        xleft = framewidth;
        if (op >= opend) { // Catch the wrap to switch passes when interlacing.
          scanstride = framestride * 4 + width * 4 * (interlaceskip-1);
          // interlaceskip / 2 * 4 is interlaceskip << 1.
          op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
          interlaceskip >>= 1;
        }
      }

      if (index === trans) {
        op += 4;
      } else {
        var r = buf[palette_offset + index * 3];
        var g = buf[palette_offset + index * 3 + 1];
        var b = buf[palette_offset + index * 3 + 2];
        pixels[op++] = b;
        pixels[op++] = g;
        pixels[op++] = r;
        pixels[op++] = 255;
      }
      --xleft;
    }
  };

  // I will go to copy and paste hell one day...
  this.decodeAndBlitFrameRGBA = function(frame_num, pixels) {
    var frame = this.frameInfo(frame_num);
    var num_pixels = frame.width * frame.height;
    var index_stream = new Uint8Array(num_pixels);  // At most 8-bit indices.
    GifReaderLZWOutputIndexStream(
        buf, frame.data_offset, index_stream, num_pixels);
    var palette_offset = frame.palette_offset;

    // NOTE(deanm): It seems to be much faster to compare index to 256 than
    // to === null.  Not sure why, but CompareStub_EQ_STRICT shows up high in
    // the profile, not sure if it's related to using a Uint8Array.
    var trans = frame.transparent_index;
    if (trans === null) trans = 256;

    // We are possibly just blitting to a portion of the entire frame.
    // That is a subrect within the framerect, so the additional pixels
    // must be skipped over after we finished a scanline.
    var framewidth  = frame.width;
    var framestride = width - framewidth;
    var xleft       = framewidth;  // Number of subrect pixels left in scanline.

    // Output indicies of the top left and bottom right corners of the subrect.
    var opbeg = ((frame.y * width) + frame.x) * 4;
    var opend = ((frame.y + frame.height) * width + frame.x) * 4;
    var op    = opbeg;

    var scanstride = framestride * 4;

    // Use scanstride to skip past the rows when interlacing.  This is skipping
    // 7 rows for the first two passes, then 3 then 1.
    if (frame.interlaced === true) {
      scanstride += width * 4 * 7;  // Pass 1.
    }

    var interlaceskip = 8;  // Tracking the row interval in the current pass.

    for (var i = 0, il = index_stream.length; i < il; ++i) {
      var index = index_stream[i];

      if (xleft === 0) {  // Beginning of new scan line
        op += scanstride;
        xleft = framewidth;
        if (op >= opend) { // Catch the wrap to switch passes when interlacing.
          scanstride = framestride * 4 + width * 4 * (interlaceskip-1);
          // interlaceskip / 2 * 4 is interlaceskip << 1.
          op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
          interlaceskip >>= 1;
        }
      }

      if (index === trans) {
        op += 4;
      } else {
        var r = buf[palette_offset + index * 3];
        var g = buf[palette_offset + index * 3 + 1];
        var b = buf[palette_offset + index * 3 + 2];
        pixels[op++] = r;
        pixels[op++] = g;
        pixels[op++] = b;
        pixels[op++] = 255;
      }
      --xleft;
    }
  };
}

function GifReaderLZWOutputIndexStream(code_stream, p, output, output_length) {
  var min_code_size = code_stream[p++];

  var clear_code = 1 << min_code_size;
  var eoi_code = clear_code + 1;
  var next_code = eoi_code + 1;

  var cur_code_size = min_code_size + 1;  // Number of bits per code.
  // NOTE: This shares the same name as the encoder, but has a different
  // meaning here.  Here this masks each code coming from the code stream.
  var code_mask = (1 << cur_code_size) - 1;
  var cur_shift = 0;
  var cur = 0;

  var op = 0;  // Output pointer.

  var subblock_size = code_stream[p++];

  // TODO(deanm): Would using a TypedArray be any faster?  At least it would
  // solve the fast mode / backing store uncertainty.
  // var code_table = Array(4096);
  var code_table = new Int32Array(4096);  // Can be signed, we only use 20 bits.

  var prev_code = null;  // Track code-1.

  while (true) {
    // Read up to two bytes, making sure we always 12-bits for max sized code.
    while (cur_shift < 16) {
      if (subblock_size === 0) break;  // No more data to be read.

      cur |= code_stream[p++] << cur_shift;
      cur_shift += 8;

      if (subblock_size === 1) {  // Never let it get to 0 to hold logic above.
        subblock_size = code_stream[p++];  // Next subblock.
      } else {
        --subblock_size;
      }
    }

    // TODO(deanm): We should never really get here, we should have received
    // and EOI.
    if (cur_shift < cur_code_size)
      break;

    var code = cur & code_mask;
    cur >>= cur_code_size;
    cur_shift -= cur_code_size;

    // TODO(deanm): Maybe should check that the first code was a clear code,
    // at least this is what you're supposed to do.  But actually our encoder
    // now doesn't emit a clear code first anyway.
    if (code === clear_code) {
      // We don't actually have to clear the table.  This could be a good idea
      // for greater error checking, but we don't really do any anyway.  We
      // will just track it with next_code and overwrite old entries.

      next_code = eoi_code + 1;
      cur_code_size = min_code_size + 1;
      code_mask = (1 << cur_code_size) - 1;

      // Don't update prev_code ?
      prev_code = null;
      continue;
    } else if (code === eoi_code) {
      break;
    }

    // We have a similar situation as the decoder, where we want to store
    // variable length entries (code table entries), but we want to do in a
    // faster manner than an array of arrays.  The code below stores sort of a
    // linked list within the code table, and then "chases" through it to
    // construct the dictionary entries.  When a new entry is created, just the
    // last byte is stored, and the rest (prefix) of the entry is only
    // referenced by its table entry.  Then the code chases through the
    // prefixes until it reaches a single byte code.  We have to chase twice,
    // first to compute the length, and then to actually copy the data to the
    // output (backwards, since we know the length).  The alternative would be
    // storing something in an intermediate stack, but that doesn't make any
    // more sense.  I implemented an approach where it also stored the length
    // in the code table, although it's a bit tricky because you run out of
    // bits (12 + 12 + 8), but I didn't measure much improvements (the table
    // entries are generally not the long).  Even when I created benchmarks for
    // very long table entries the complexity did not seem worth it.
    // The code table stores the prefix entry in 12 bits and then the suffix
    // byte in 8 bits, so each entry is 20 bits.

    var chase_code = code < next_code ? code : prev_code;

    // Chase what we will output, either {CODE} or {CODE-1}.
    var chase_length = 0;
    var chase = chase_code;
    while (chase > clear_code) {
      chase = code_table[chase] >> 8;
      ++chase_length;
    }

    var k = chase;

    var op_end = op + chase_length + (chase_code !== code ? 1 : 0);
    if (op_end > output_length) {
      console.log("Warning, gif stream longer than expected.");
      return;
    }

    // Already have the first byte from the chase, might as well write it fast.
    output[op++] = k;

    op += chase_length;
    var b = op;  // Track pointer, writing backwards.

    if (chase_code !== code)  // The case of emitting {CODE-1} + k.
      output[op++] = k;

    chase = chase_code;
    while (chase_length--) {
      chase = code_table[chase];
      output[--b] = chase & 0xff;  // Write backwards.
      chase >>= 8;  // Pull down to the prefix code.
    }

    if (prev_code !== null && next_code < 4096) {
      code_table[next_code++] = prev_code << 8 | k;
      // TODO(deanm): Figure out this clearing vs code growth logic better.  I
      // have an feeling that it should just happen somewhere else, for now it
      // is awkward between when we grow past the max and then hit a clear code.
      // For now just check if we hit the max 12-bits (then a clear code should
      // follow, also of course encoded in 12-bits).
      if (next_code >= code_mask+1 && cur_code_size < 12) {
        ++cur_code_size;
        code_mask = code_mask << 1 | 1;
      }
    }

    prev_code = code;
  }

  if (op !== output_length) {
    console.log("Warning, gif stream shorter than expected.");
  }

  return output;
}

// CommonJS.
try { exports.GifWriter = GifWriter; exports.GifReader = GifReader } catch(e) {}

},{}],167:[function(require,module,exports){
(function (process){
// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47 /*/*/;
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';
  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }
  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';

  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
}

// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
exports.basename = function (path, ext) {
  var f = basename(path);
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var preDotState = 0;
  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }
    if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
    } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 ||
      // We saw a non-dot character immediately before the dot
      preDotState === 0 ||
      // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }
  return path.slice(startDot, end);
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":169}],168:[function(require,module,exports){
(function (process){
'use strict';

if (typeof process === 'undefined' ||
    !process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


}).call(this,require('_process'))

},{"_process":169}],169:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],170:[function(require,module,exports){
module.exports = require('./lib/_stream_duplex.js');

},{"./lib/_stream_duplex.js":171}],171:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};
},{"./_stream_readable":173,"./_stream_writable":175,"core-util-is":35,"inherits":122,"process-nextick-args":168}],172:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":174,"core-util-is":35,"inherits":122}],173:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var destroyImpl = require('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./_stream_duplex":171,"./internal/streams/BufferList":176,"./internal/streams/destroy":177,"./internal/streams/stream":178,"_process":169,"core-util-is":35,"events":41,"inherits":122,"isarray":125,"process-nextick-args":168,"safe-buffer":179,"string_decoder/":185,"util":33}],174:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":171,"core-util-is":35,"inherits":122}],175:[function(require,module,exports){
(function (process,global,setImmediate){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = require('./internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("timers").setImmediate)

},{"./_stream_duplex":171,"./internal/streams/destroy":177,"./internal/streams/stream":178,"_process":169,"core-util-is":35,"inherits":122,"process-nextick-args":168,"safe-buffer":179,"timers":188,"util-deprecate":191}],176:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = require('safe-buffer').Buffer;
var util = require('util');

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}
},{"safe-buffer":179,"util":33}],177:[function(require,module,exports){
'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
},{"process-nextick-args":168}],178:[function(require,module,exports){
module.exports = require('events').EventEmitter;

},{"events":41}],179:[function(require,module,exports){
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":34}],180:[function(require,module,exports){
module.exports = require('./readable').PassThrough

},{"./readable":181}],181:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":171,"./lib/_stream_passthrough.js":172,"./lib/_stream_readable.js":173,"./lib/_stream_transform.js":174,"./lib/_stream_writable.js":175}],182:[function(require,module,exports){
module.exports = require('./readable').Transform

},{"./readable":181}],183:[function(require,module,exports){
module.exports = require('./lib/_stream_writable.js');

},{"./lib/_stream_writable.js":175}],184:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":41,"inherits":122,"readable-stream/duplex.js":170,"readable-stream/passthrough.js":180,"readable-stream/readable.js":181,"readable-stream/transform.js":182,"readable-stream/writable.js":183}],185:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":186}],186:[function(require,module,exports){
arguments[4][179][0].apply(exports,arguments)
},{"buffer":34,"dup":179}],187:[function(require,module,exports){
(function (process){
var Stream = require('stream')

// through
//
// a stream that does nothing but re-emit the input.
// useful for aggregating a series of changing but not ending streams into one stream)

exports = module.exports = through
through.through = through

//create a readable writable stream.

function through (write, end, opts) {
  write = write || function (data) { this.queue(data) }
  end = end || function () { this.queue(null) }

  var ended = false, destroyed = false, buffer = [], _ended = false
  var stream = new Stream()
  stream.readable = stream.writable = true
  stream.paused = false

//  stream.autoPause   = !(opts && opts.autoPause   === false)
  stream.autoDestroy = !(opts && opts.autoDestroy === false)

  stream.write = function (data) {
    write.call(this, data)
    return !stream.paused
  }

  function drain() {
    while(buffer.length && !stream.paused) {
      var data = buffer.shift()
      if(null === data)
        return stream.emit('end')
      else
        stream.emit('data', data)
    }
  }

  stream.queue = stream.push = function (data) {
//    console.error(ended)
    if(_ended) return stream
    if(data === null) _ended = true
    buffer.push(data)
    drain()
    return stream
  }

  //this will be registered as the first 'end' listener
  //must call destroy next tick, to make sure we're after any
  //stream piped from here.
  //this is only a problem if end is not emitted synchronously.
  //a nicer way to do this is to make sure this is the last listener for 'end'

  stream.on('end', function () {
    stream.readable = false
    if(!stream.writable && stream.autoDestroy)
      process.nextTick(function () {
        stream.destroy()
      })
  })

  function _end () {
    stream.writable = false
    end.call(stream)
    if(!stream.readable && stream.autoDestroy)
      stream.destroy()
  }

  stream.end = function (data) {
    if(ended) return
    ended = true
    if(arguments.length) stream.write(data)
    _end() // will emit or queue
    return stream
  }

  stream.destroy = function () {
    if(destroyed) return
    destroyed = true
    ended = true
    buffer.length = 0
    stream.writable = stream.readable = false
    stream.emit('close')
    return stream
  }

  stream.pause = function () {
    if(stream.paused) return
    stream.paused = true
    return stream
  }

  stream.resume = function () {
    if(stream.paused) {
      stream.paused = false
      stream.emit('resume')
    }
    drain()
    //may have become paused again,
    //as drain emits 'data'.
    if(!stream.paused)
      stream.emit('drain')
    return stream
  }
  return stream
}


}).call(this,require('_process'))

},{"_process":169,"stream":184}],188:[function(require,module,exports){
(function (setImmediate,clearImmediate){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this,require("timers").setImmediate,require("timers").clearImmediate)

},{"process/browser.js":169,"timers":188}],189:[function(require,module,exports){
(function (global){
'use strict'

var bits = require('bit-twiddle')
var dup = require('dup')
var Buffer = require('buffer').Buffer

//Legacy pool support
if(!global.__TYPEDARRAY_POOL) {
  global.__TYPEDARRAY_POOL = {
      UINT8     : dup([32, 0])
    , UINT16    : dup([32, 0])
    , UINT32    : dup([32, 0])
    , BIGUINT64 : dup([32, 0])
    , INT8      : dup([32, 0])
    , INT16     : dup([32, 0])
    , INT32     : dup([32, 0])
    , BIGINT64  : dup([32, 0])
    , FLOAT     : dup([32, 0])
    , DOUBLE    : dup([32, 0])
    , DATA      : dup([32, 0])
    , UINT8C    : dup([32, 0])
    , BUFFER    : dup([32, 0])
  }
}

var hasUint8C = (typeof Uint8ClampedArray) !== 'undefined'
var hasBigUint64 = (typeof BigUint64Array) !== 'undefined'
var hasBigInt64 = (typeof BigInt64Array) !== 'undefined'
var POOL = global.__TYPEDARRAY_POOL

//Upgrade pool
if(!POOL.UINT8C) {
  POOL.UINT8C = dup([32, 0])
}
if(!POOL.BIGUINT64) {
  POOL.BIGUINT64 = dup([32, 0])
}
if(!POOL.BIGINT64) {
  POOL.BIGINT64 = dup([32, 0])
}
if(!POOL.BUFFER) {
  POOL.BUFFER = dup([32, 0])
}

//New technique: Only allocate from ArrayBufferView and Buffer
var DATA    = POOL.DATA
  , BUFFER  = POOL.BUFFER

exports.free = function free(array) {
  if(Buffer.isBuffer(array)) {
    BUFFER[bits.log2(array.length)].push(array)
  } else {
    if(Object.prototype.toString.call(array) !== '[object ArrayBuffer]') {
      array = array.buffer
    }
    if(!array) {
      return
    }
    var n = array.length || array.byteLength
    var log_n = bits.log2(n)|0
    DATA[log_n].push(array)
  }
}

function freeArrayBuffer(buffer) {
  if(!buffer) {
    return
  }
  var n = buffer.length || buffer.byteLength
  var log_n = bits.log2(n)
  DATA[log_n].push(buffer)
}

function freeTypedArray(array) {
  freeArrayBuffer(array.buffer)
}

exports.freeUint8 =
exports.freeUint16 =
exports.freeUint32 =
exports.freeBigUint64 =
exports.freeInt8 =
exports.freeInt16 =
exports.freeInt32 =
exports.freeBigInt64 =
exports.freeFloat32 = 
exports.freeFloat =
exports.freeFloat64 = 
exports.freeDouble = 
exports.freeUint8Clamped = 
exports.freeDataView = freeTypedArray

exports.freeArrayBuffer = freeArrayBuffer

exports.freeBuffer = function freeBuffer(array) {
  BUFFER[bits.log2(array.length)].push(array)
}

exports.malloc = function malloc(n, dtype) {
  if(dtype === undefined || dtype === 'arraybuffer') {
    return mallocArrayBuffer(n)
  } else {
    switch(dtype) {
      case 'uint8':
        return mallocUint8(n)
      case 'uint16':
        return mallocUint16(n)
      case 'uint32':
        return mallocUint32(n)
      case 'int8':
        return mallocInt8(n)
      case 'int16':
        return mallocInt16(n)
      case 'int32':
        return mallocInt32(n)
      case 'float':
      case 'float32':
        return mallocFloat(n)
      case 'double':
      case 'float64':
        return mallocDouble(n)
      case 'uint8_clamped':
        return mallocUint8Clamped(n)
      case 'bigint64':
        return mallocBigInt64(n)
      case 'biguint64':
        return mallocBigUint64(n)
      case 'buffer':
        return mallocBuffer(n)
      case 'data':
      case 'dataview':
        return mallocDataView(n)

      default:
        return null
    }
  }
  return null
}

function mallocArrayBuffer(n) {
  var n = bits.nextPow2(n)
  var log_n = bits.log2(n)
  var d = DATA[log_n]
  if(d.length > 0) {
    return d.pop()
  }
  return new ArrayBuffer(n)
}
exports.mallocArrayBuffer = mallocArrayBuffer

function mallocUint8(n) {
  return new Uint8Array(mallocArrayBuffer(n), 0, n)
}
exports.mallocUint8 = mallocUint8

function mallocUint16(n) {
  return new Uint16Array(mallocArrayBuffer(2*n), 0, n)
}
exports.mallocUint16 = mallocUint16

function mallocUint32(n) {
  return new Uint32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocUint32 = mallocUint32

function mallocInt8(n) {
  return new Int8Array(mallocArrayBuffer(n), 0, n)
}
exports.mallocInt8 = mallocInt8

function mallocInt16(n) {
  return new Int16Array(mallocArrayBuffer(2*n), 0, n)
}
exports.mallocInt16 = mallocInt16

function mallocInt32(n) {
  return new Int32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocInt32 = mallocInt32

function mallocFloat(n) {
  return new Float32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocFloat32 = exports.mallocFloat = mallocFloat

function mallocDouble(n) {
  return new Float64Array(mallocArrayBuffer(8*n), 0, n)
}
exports.mallocFloat64 = exports.mallocDouble = mallocDouble

function mallocUint8Clamped(n) {
  if(hasUint8C) {
    return new Uint8ClampedArray(mallocArrayBuffer(n), 0, n)
  } else {
    return mallocUint8(n)
  }
}
exports.mallocUint8Clamped = mallocUint8Clamped

function mallocBigUint64(n) {
  if(hasBigUint64) {
    return new BigUint64Array(mallocArrayBuffer(8*n), 0, n)
  } else {
    return null;
  }
}
exports.mallocBigUint64 = mallocBigUint64

function mallocBigInt64(n) {
  if (hasBigInt64) {
    return new BigInt64Array(mallocArrayBuffer(8*n), 0, n)
  } else {
    return null;
  }
}
exports.mallocBigInt64 = mallocBigInt64

function mallocDataView(n) {
  return new DataView(mallocArrayBuffer(n), 0, n)
}
exports.mallocDataView = mallocDataView

function mallocBuffer(n) {
  n = bits.nextPow2(n)
  var log_n = bits.log2(n)
  var cache = BUFFER[log_n]
  if(cache.length > 0) {
    return cache.pop()
  }
  return new Buffer(n)
}
exports.mallocBuffer = mallocBuffer

exports.clearCache = function clearCache() {
  for(var i=0; i<32; ++i) {
    POOL.UINT8[i].length = 0
    POOL.UINT16[i].length = 0
    POOL.UINT32[i].length = 0
    POOL.INT8[i].length = 0
    POOL.INT16[i].length = 0
    POOL.INT32[i].length = 0
    POOL.FLOAT[i].length = 0
    POOL.DOUBLE[i].length = 0
    POOL.BIGUINT64[i].length = 0
    POOL.BIGINT64[i].length = 0
    POOL.UINT8C[i].length = 0
    DATA[i].length = 0
    BUFFER[i].length = 0
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"bit-twiddle":32,"buffer":34,"dup":40}],190:[function(require,module,exports){
"use strict"

function unique_pred(list, compare) {
  var ptr = 1
    , len = list.length
    , a=list[0], b=list[0]
  for(var i=1; i<len; ++i) {
    b = a
    a = list[i]
    if(compare(a, b)) {
      if(i === ptr) {
        ptr++
        continue
      }
      list[ptr++] = a
    }
  }
  list.length = ptr
  return list
}

function unique_eq(list) {
  var ptr = 1
    , len = list.length
    , a=list[0], b = list[0]
  for(var i=1; i<len; ++i, b=a) {
    b = a
    a = list[i]
    if(a !== b) {
      if(i === ptr) {
        ptr++
        continue
      }
      list[ptr++] = a
    }
  }
  list.length = ptr
  return list
}

function unique(list, compare, sorted) {
  if(list.length === 0) {
    return list
  }
  if(compare) {
    if(!sorted) {
      list.sort(compare)
    }
    return unique_pred(list, compare)
  }
  if(!sorted) {
    list.sort()
  }
  return unique_eq(list)
}

module.exports = unique

},{}],191:[function(require,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}]},{},[12])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJqcy9hbHRlcmF0aW9ucy5qcyIsImpzL2F1ZGlvLmpzIiwianMvYmFja2dyb3VuZC5qcyIsImpzL2NhbWVyYS5qcyIsImpzL2Rpc3RhbmNlRGVmb3JtYXRpb25zLmpzIiwianMvZGlzdGFuY2VPcGVyYXRpb25zLmpzIiwianMvZGlzdGFuY2VPcGVyYXRpb25zR0xTTC5qcyIsImpzL2RvbWFpbk9wZXJhdGlvbnMuanMiLCJqcy9leHRlcm5hbC9tYXRyaXguanMiLCJqcy9mbG9hdC5qcyIsImpzL2ZvZy5qcyIsImpzL2luZGV4LmpzIiwianMvaW50LmpzIiwianMvbGlnaHRpbmcuanMiLCJqcy9tYWluLmpzIiwianMvbWF0ZXJpYWwuanMiLCJqcy9ub2lzZS5qcyIsImpzL3ByaW1pdGl2ZURlc2NyaXB0aW9ucy5qcyIsImpzL3ByaW1pdGl2ZXMuanMiLCJqcy9yZW5kZXJGcmFnbWVudFNoYWRlci5qcyIsImpzL3NjZW5lLmpzIiwianMvc2NlbmVOb2RlLmpzIiwianMvdGV4dHVyZS5qcyIsImpzL3RleHR1cmVEZXNjcmlwdGlvbnMuanMiLCJqcy90ZXh0dXJlV3JhcC5qcyIsImpzL3RyYW5zZm9ybS5qcyIsImpzL3V0aWxzLmpzIiwianMvdmFyLmpzIiwianMvdmVjLmpzIiwianMvdmlnbmV0dGUuanMiLCJub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JpdC10d2lkZGxlL3R3aWRkbGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLXV0aWwtaXMvbGliL3V0aWwuanMiLCJub2RlX21vZHVsZXMvY3dpc2UtY29tcGlsZXIvY29tcGlsZXIuanMiLCJub2RlX21vZHVsZXMvY3dpc2UtY29tcGlsZXIvbGliL2NvbXBpbGUuanMiLCJub2RlX21vZHVsZXMvY3dpc2UtY29tcGlsZXIvbGliL3RodW5rLmpzIiwibm9kZV9tb2R1bGVzL2RhdGEtdXJpLXRvLWJ1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9kdXAvZHVwLmpzIiwibm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJub2RlX21vZHVsZXMvZ2V0LXBpeGVscy9kb20tcGl4ZWxzLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvYWRqb2ludC5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L2Nsb25lLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvY29weS5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L2NyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L2RldGVybWluYW50LmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvZnJvbVF1YXQuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9mcm9tUm90YXRpb24uanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9mcm9tUm90YXRpb25UcmFuc2xhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L2Zyb21TY2FsaW5nLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvZnJvbVRyYW5zbGF0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvZnJvbVhSb3RhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L2Zyb21ZUm90YXRpb24uanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9mcm9tWlJvdGF0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvZnJ1c3R1bS5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L2lkZW50aXR5LmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9pbnZlcnQuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9sb29rQXQuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9tdWx0aXBseS5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L29ydGhvLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvcGVyc3BlY3RpdmUuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9wZXJzcGVjdGl2ZUZyb21GaWVsZE9mVmlldy5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L3JvdGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L3JvdGF0ZVguanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9yb3RhdGVZLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvcm90YXRlWi5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L3NjYWxlLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvc3RyLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvdHJhbnNsYXRlLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvdHJhbnNwb3NlLmpzIiwibm9kZV9tb2R1bGVzL2dsLXRleHR1cmUyZC90ZXh0dXJlLmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvYWRkLmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvYW5nbGUuanMiLCJub2RlX21vZHVsZXMvZ2wtdmVjMy9jZWlsLmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvY2xvbmUuanMiLCJub2RlX21vZHVsZXMvZ2wtdmVjMy9jb3B5LmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvY3Jvc3MuanMiLCJub2RlX21vZHVsZXMvZ2wtdmVjMy9kaXN0LmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvZGlzdGFuY2UuanMiLCJub2RlX21vZHVsZXMvZ2wtdmVjMy9kaXYuanMiLCJub2RlX21vZHVsZXMvZ2wtdmVjMy9kaXZpZGUuanMiLCJub2RlX21vZHVsZXMvZ2wtdmVjMy9kb3QuanMiLCJub2RlX21vZHVsZXMvZ2wtdmVjMy9lcHNpbG9uLmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvZXF1YWxzLmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvZXhhY3RFcXVhbHMuanMiLCJub2RlX21vZHVsZXMvZ2wtdmVjMy9mbG9vci5qcyIsIm5vZGVfbW9kdWxlcy9nbC12ZWMzL2ZvckVhY2guanMiLCJub2RlX21vZHVsZXMvZ2wtdmVjMy9mcm9tVmFsdWVzLmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ2wtdmVjMy9pbnZlcnNlLmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvbGVuLmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvbGVuZ3RoLmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvbGVycC5qcyIsIm5vZGVfbW9kdWxlcy9nbC12ZWMzL21heC5qcyIsIm5vZGVfbW9kdWxlcy9nbC12ZWMzL21pbi5qcyIsIm5vZGVfbW9kdWxlcy9nbC12ZWMzL211bC5qcyIsIm5vZGVfbW9kdWxlcy9nbC12ZWMzL211bHRpcGx5LmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvbmVnYXRlLmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvbm9ybWFsaXplLmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvcmFuZG9tLmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvcm90YXRlWC5qcyIsIm5vZGVfbW9kdWxlcy9nbC12ZWMzL3JvdGF0ZVkuanMiLCJub2RlX21vZHVsZXMvZ2wtdmVjMy9yb3RhdGVaLmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvcm91bmQuanMiLCJub2RlX21vZHVsZXMvZ2wtdmVjMy9zY2FsZS5qcyIsIm5vZGVfbW9kdWxlcy9nbC12ZWMzL3NjYWxlQW5kQWRkLmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvc2V0LmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvc3FyRGlzdC5qcyIsIm5vZGVfbW9kdWxlcy9nbC12ZWMzL3Nxckxlbi5qcyIsIm5vZGVfbW9kdWxlcy9nbC12ZWMzL3NxdWFyZWREaXN0YW5jZS5qcyIsIm5vZGVfbW9kdWxlcy9nbC12ZWMzL3NxdWFyZWRMZW5ndGguanMiLCJub2RlX21vZHVsZXMvZ2wtdmVjMy9zdWIuanMiLCJub2RlX21vZHVsZXMvZ2wtdmVjMy9zdWJ0cmFjdC5qcyIsIm5vZGVfbW9kdWxlcy9nbC12ZWMzL3RyYW5zZm9ybU1hdDMuanMiLCJub2RlX21vZHVsZXMvZ2wtdmVjMy90cmFuc2Zvcm1NYXQ0LmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvdHJhbnNmb3JtUXVhdC5qcyIsIm5vZGVfbW9kdWxlcy9nbHNsaWZ5L2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2lvdGEtYXJyYXkvaW90YS5qcyIsIm5vZGVfbW9kdWxlcy9pcy1idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tZXJnZS1wYXNzL2Rpc3QvY29kZWJ1aWxkZXIuanMiLCJub2RlX21vZHVsZXMvbWVyZ2UtcGFzcy9kaXN0L2V4cHJlc3Npb25zL2FyaXR5MS5qcyIsIm5vZGVfbW9kdWxlcy9tZXJnZS1wYXNzL2Rpc3QvZXhwcmVzc2lvbnMvYXJpdHkyLmpzIiwibm9kZV9tb2R1bGVzL21lcmdlLXBhc3MvZGlzdC9leHByZXNzaW9ucy9ibHVyMmRsb29wLmpzIiwibm9kZV9tb2R1bGVzL21lcmdlLXBhc3MvZGlzdC9leHByZXNzaW9ucy9ibHVyZXhwci5qcyIsIm5vZGVfbW9kdWxlcy9tZXJnZS1wYXNzL2Rpc3QvZXhwcmVzc2lvbnMvYnJpZ2h0bmVzc2V4cHIuanMiLCJub2RlX21vZHVsZXMvbWVyZ2UtcGFzcy9kaXN0L2V4cHJlc3Npb25zL2J1ZmZlcnNhbXBsZWV4cHIuanMiLCJub2RlX21vZHVsZXMvbWVyZ2UtcGFzcy9kaXN0L2V4cHJlc3Npb25zL2NoYW5nZWNvbXBleHByLmpzIiwibm9kZV9tb2R1bGVzL21lcmdlLXBhc3MvZGlzdC9leHByZXNzaW9ucy9jb250cmFzdGV4cHIuanMiLCJub2RlX21vZHVsZXMvbWVyZ2UtcGFzcy9kaXN0L2V4cHJlc3Npb25zL2RlcHRodG9vY2NsdXNpb25leHByLmpzIiwibm9kZV9tb2R1bGVzL21lcmdlLXBhc3MvZGlzdC9leHByZXNzaW9ucy9kb2Zsb29wLmpzIiwibm9kZV9tb2R1bGVzL21lcmdlLXBhc3MvZGlzdC9leHByZXNzaW9ucy9leHByLmpzIiwibm9kZV9tb2R1bGVzL21lcmdlLXBhc3MvZGlzdC9leHByZXNzaW9ucy9mcmFnY29sb3JleHByLmpzIiwibm9kZV9tb2R1bGVzL21lcmdlLXBhc3MvZGlzdC9leHByZXNzaW9ucy9meGFhZXhwci5qcyIsIm5vZGVfbW9kdWxlcy9tZXJnZS1wYXNzL2Rpc3QvZXhwcmVzc2lvbnMvZ2F1c3NpYW5leHByLmpzIiwibm9kZV9tb2R1bGVzL21lcmdlLXBhc3MvZGlzdC9leHByZXNzaW9ucy9nZXRjb21wZXhwci5qcyIsIm5vZGVfbW9kdWxlcy9tZXJnZS1wYXNzL2Rpc3QvZXhwcmVzc2lvbnMvZ29kcmF5c2V4cHIuanMiLCJub2RlX21vZHVsZXMvbWVyZ2UtcGFzcy9kaXN0L2V4cHJlc3Npb25zL2dyYWluZXhwci5qcyIsIm5vZGVfbW9kdWxlcy9tZXJnZS1wYXNzL2Rpc3QvZXhwcmVzc2lvbnMvaHN2dG9yZ2JleHByLmpzIiwibm9kZV9tb2R1bGVzL21lcmdlLXBhc3MvZGlzdC9leHByZXNzaW9ucy9sZW5leHByLmpzIiwibm9kZV9tb2R1bGVzL21lcmdlLXBhc3MvZGlzdC9leHByZXNzaW9ucy9ub3JtY2VudGVyZnJhZ2Nvb3JkZXhwci5qcyIsIm5vZGVfbW9kdWxlcy9tZXJnZS1wYXNzL2Rpc3QvZXhwcmVzc2lvbnMvbm9ybWZyYWdjb29yZGV4cHIuanMiLCJub2RlX21vZHVsZXMvbWVyZ2UtcGFzcy9kaXN0L2V4cHJlc3Npb25zL29wZXhwci5qcyIsIm5vZGVfbW9kdWxlcy9tZXJnZS1wYXNzL2Rpc3QvZXhwcmVzc2lvbnMvcG93ZXJibHVyLmpzIiwibm9kZV9tb2R1bGVzL21lcmdlLXBhc3MvZGlzdC9leHByZXNzaW9ucy9yYW5kb21leHByLmpzIiwibm9kZV9tb2R1bGVzL21lcmdlLXBhc3MvZGlzdC9leHByZXNzaW9ucy9yZ2J0b2hzdmV4cHIuanMiLCJub2RlX21vZHVsZXMvbWVyZ2UtcGFzcy9kaXN0L2V4cHJlc3Npb25zL3NjZW5lc2FtcGxlZXhwci5qcyIsIm5vZGVfbW9kdWxlcy9tZXJnZS1wYXNzL2Rpc3QvZXhwcmVzc2lvbnMvc2V0Y29sb3JleHByLmpzIiwibm9kZV9tb2R1bGVzL21lcmdlLXBhc3MvZGlzdC9leHByZXNzaW9ucy90aW1lZXhwci5qcyIsIm5vZGVfbW9kdWxlcy9tZXJnZS1wYXNzL2Rpc3QvZXhwcmVzc2lvbnMvdHJ1ZWRlcHRoZXhwci5qcyIsIm5vZGVfbW9kdWxlcy9tZXJnZS1wYXNzL2Rpc3QvZXhwcmVzc2lvbnMvdmVjZXhwcnMuanMiLCJub2RlX21vZHVsZXMvbWVyZ2UtcGFzcy9kaXN0L2V4cHJ0eXBlcy5qcyIsIm5vZGVfbW9kdWxlcy9tZXJnZS1wYXNzL2Rpc3QvZ2xzbGZ1bmN0aW9ucy5qcyIsIm5vZGVfbW9kdWxlcy9tZXJnZS1wYXNzL2Rpc3QvaW5kZXguanMiLCJub2RlX21vZHVsZXMvbWVyZ2UtcGFzcy9kaXN0L21lcmdlcGFzcy5qcyIsIm5vZGVfbW9kdWxlcy9tZXJnZS1wYXNzL2Rpc3Qvd2ViZ2xwcm9ncmFtbG9vcC5qcyIsIm5vZGVfbW9kdWxlcy9uZGFycmF5LW9wcy9uZGFycmF5LW9wcy5qcyIsIm5vZGVfbW9kdWxlcy9uZGFycmF5LXBhY2svY29udmVydC5qcyIsIm5vZGVfbW9kdWxlcy9uZGFycmF5LXBhY2svZG9Db252ZXJ0LmpzIiwibm9kZV9tb2R1bGVzL25kYXJyYXkvbmRhcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9vbWdnaWYvb21nZ2lmLmpzIiwibm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzLW5leHRpY2stYXJncy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2R1cGxleC1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL25vZGVfbW9kdWxlcy9zYWZlLWJ1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zdHJpbmdfZGVjb2Rlci9saWIvc3RyaW5nX2RlY29kZXIuanMiLCJub2RlX21vZHVsZXMvdGhyb3VnaC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwibm9kZV9tb2R1bGVzL3R5cGVkYXJyYXktcG9vbC9wb29sLmpzIiwibm9kZV9tb2R1bGVzL3VuaXEvdW5pcS5qcyIsIm5vZGVfbW9kdWxlcy91dGlsLWRlcHJlY2F0ZS9icm93c2VyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDblZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM1lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdGFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3VEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9NQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1TUE7OztBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2x3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN0SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdldBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdnlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDOVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeExBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMxL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDOXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOURBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUN2U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQzNFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiY29uc3QgU2NlbmVOb2RlID0gcmVxdWlyZSggJy4vc2NlbmVOb2RlLmpzJyApXG5jb25zdCB7IHBhcmFtX3dyYXAsIE1hdGVyaWFsSUQgfSA9IHJlcXVpcmUoICcuL3V0aWxzLmpzJyApXG5jb25zdCB7IFZhciwgZmxvYXRfdmFyX2dlbiwgdmVjMl92YXJfZ2VuLCB2ZWMzX3Zhcl9nZW4sIHZlYzRfdmFyX2dlbiwgaW50X3Zhcl9nZW4gfSA9IHJlcXVpcmUoICcuL3Zhci5qcycgKVxuXG5jb25zdCBvcHMgPSB7IFxuICBPbmlvbjoge1xuICAgIGZ1bmMoIHNkZix0aGlja25lc3MgKSB7IHJldHVybiBgdmVjMiggb3BPbmlvbiggJHtzZGZ9LngsICR7dGhpY2tuZXNzfSApLCAke3NkZn0ueSApYCB9LFxuICAgIHZhcmlhYmxlczpbWyd0aGlja25lc3MnLCAnZmxvYXQnLCAuMDNdXVxuICB9LFxuICBIYWx2ZToge1xuICAgIGZ1bmMoIHNkZiwgZGlyZWN0aW9uICkgeyByZXR1cm4gYHZlYzIoIG9wSGFsdmUoICR7c2RmfS54LCBwLCAke2RpcmVjdGlvbn0gKSwgJHtzZGZ9LnkgKWAgfSxcbiAgICB2YXJpYWJsZXM6W1snZGlyZWN0aW9uJywnaW50JywwXV1cbiAgfSxcbiAgUm91bmQ6IHtcbiAgICBmdW5jKCBzZGYsIGFtb3VudCApIHsgcmV0dXJuIGB2ZWMyKCAke3NkZn0ueCAtICR7YW1vdW50fSwgJHtzZGZ9LnkgKWAgfSxcbiAgICB2YXJpYWJsZXM6W1snYW1vdW50JywnZmxvYXQnLC4xXV1cbiAgfVxufVxuXG5cbmNvbnN0IEFsdGVyYXRpb25zPSB7fVxuXG5mb3IoIGxldCBuYW1lIGluIG9wcyApIHtcblxuICAvLyBnZXQgY29kZWdlbiBmdW5jdGlvblxuICBsZXQgb3AgPSBvcHNbIG5hbWUgXVxuXG4gIC8vIGNyZWF0ZSBjb25zdHJ1Y3RvclxuICBBbHRlcmF0aW9uc1sgbmFtZSBdID0gZnVuY3Rpb24oIHNkZiwgLi4uYXJncyApIHtcbiAgICBjb25zdCBfX29wID0gT2JqZWN0LmNyZWF0ZSggQWx0ZXJhdGlvbnNbIG5hbWUgXS5wcm90b3R5cGUgKVxuICAgIF9fb3Auc2RmID0gc2RmXG4gICAgX19vcC52YXJpYWJsZXMgPSBbXVxuICAgIF9fb3AuX19kZXNjID0geyBwYXJhbWV0ZXJzOltdIH1cblxuICAgIGZvciggbGV0IGkgPSAwOyBpIDwgb3AudmFyaWFibGVzLmxlbmd0aDsgaSsrICkge1xuICAgICAgY29uc3QgcHJvcEFycmF5ID0gb3AudmFyaWFibGVzWyBpIF1cbiAgICAgIGNvbnN0IHByb3BOYW1lID0gcHJvcEFycmF5WyAwIF1cbiAgICAgIGNvbnN0IHByb3BUeXBlID0gcHJvcEFycmF5WyAxIF1cbiAgICAgIGNvbnN0IHByb3BWYWx1ZSA9IGFyZ3NbIGkgXSA9PT0gdW5kZWZpbmVkID8gcHJvcEFycmF5WyAyIF0gOiBhcmdzWyBpIF1cblxuICAgICAgX19vcC5fX2Rlc2MucGFyYW1ldGVycy5wdXNoKHsgbmFtZTpwcm9wTmFtZSwgdmFsdWU6cHJvcFZhbHVlIH0pXG4gICAgICBsZXQgcGFyYW1cblxuICAgICAgc3dpdGNoKCBwcm9wVHlwZSApIHtcbiAgICAgICAgY2FzZSAnaW50JzpcbiAgICAgICAgICBwYXJhbSA9IGludF92YXJfZ2VuKCBwcm9wVmFsdWUgKSgpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcGFyYW0gPSBmbG9hdF92YXJfZ2VuKCBwcm9wVmFsdWUgKSgpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggX19vcCwgcHJvcE5hbWUsIHtcbiAgICAgICAgZ2V0KCkgeyByZXR1cm4gcGFyYW0gfSxcbiAgICAgICAgc2V0KHYpIHsgcGFyYW0uc2V0KCB2ICkgfVxuICAgICAgfSlcblxuICAgICAgX19vcC52YXJpYWJsZXMucHVzaCggcGFyYW0gKVxuICAgIH1cbiAgICAgIFxuICAgIF9fb3AubWF0SWQgPSBNYXRlcmlhbElELmFsbG9jKClcblxuICAgIHJldHVybiBfX29wXG4gIH0gXG5cbiAgQWx0ZXJhdGlvbnNbIG5hbWUgXS5wcm90b3R5cGUgPSBTY2VuZU5vZGUoKVxuXG4gIEFsdGVyYXRpb25zWyBuYW1lIF0ucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAoIF9fbmFtZSApIHtcbiAgICBjb25zdCBlbWl0dGVyQSA9IHRoaXMuc2RmLmVtaXQoIF9fbmFtZSApXG4gICAgLy9jb25zdCBlbWl0dGVyQiA9IHRoaXMuYi5lbWl0KClcblxuICAgIGNvbnN0IG91dHB1dCA9IHtcbiAgICAgIG91dDogb3AuZnVuYyggZW1pdHRlckEub3V0LCAuLi50aGlzLnZhcmlhYmxlcy5tYXAoIHYgPT4gdi5lbWl0KCkgKSApLCBcbiAgICAgIHByZWZhY2U6IChlbWl0dGVyQS5wcmVmYWNlIHx8ICcnKSBcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0XG4gIH1cblxuICBBbHRlcmF0aW9uc1tuYW1lXS5wcm90b3R5cGUuZW1pdF9kZWNsID0gZnVuY3Rpb24gKCkge1xuICAgIGxldCBzdHIgPSAgdGhpcy5zZGYuZW1pdF9kZWNsKCkgXG4gICAgZm9yKCBsZXQgdiBvZiB0aGlzLnZhcmlhYmxlcyApIHtcbiAgICAgIHN0ciArPSB2LmVtaXRfZGVjbCgpXG4gICAgfVxuXG4gICAgcmV0dXJuIHN0clxuICB9O1xuXG4gIEFsdGVyYXRpb25zW25hbWVdLnByb3RvdHlwZS51cGRhdGVfbG9jYXRpb24gPSBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgIHRoaXMuc2RmLnVwZGF0ZV9sb2NhdGlvbiggZ2wsIHByb2dyYW0gKVxuICAgIGZvciggbGV0IHYgb2YgdGhpcy52YXJpYWJsZXMgKSB2LnVwZGF0ZV9sb2NhdGlvbiggZ2wsIHByb2dyYW0gKVxuICB9XG5cbiAgQWx0ZXJhdGlvbnNbbmFtZV0ucHJvdG90eXBlLnVwbG9hZF9kYXRhID0gZnVuY3Rpb24oZ2wpIHtcbiAgICB0aGlzLnNkZi51cGxvYWRfZGF0YSggZ2wgKVxuICAgIGZvciggbGV0IHYgb2YgdGhpcy52YXJpYWJsZXMgKSB2LnVwbG9hZF9kYXRhKCBnbCApXG4gICAgXG4gIH1cbn1cblxuQWx0ZXJhdGlvbnMuSGFsdmUuVVAgPSAwXG5BbHRlcmF0aW9ucy5IYWx2ZS5ET1dOID0gMVxuQWx0ZXJhdGlvbnMuSGFsdmUuTEVGVCA9IDNcbkFsdGVyYXRpb25zLkhhbHZlLlJJR0hUID0gMlxuXG5tb2R1bGUuZXhwb3J0cyA9IEFsdGVyYXRpb25zXG4iLCJjb25zdCBBdWRpbyA9IHtcbiAgX19oYXNJbnB1dDogZmFsc2UsXG4gIGN0eDogbnVsbCxcblxuICBzdGFydCgpIHtcbiAgICBpZiggQXVkaW8uX19oYXNJbnB1dCA9PT0gZmFsc2UgKSB7XG4gICAgICBBdWRpby5jdHggPSBuZXcgQXVkaW9Db250ZXh0KClcbiAgICAgIEF1ZGlvLmNyZWF0ZUlucHV0KCkudGhlbiggaW5wdXQgPT4ge1xuICAgICAgICBBdWRpby5jcmVhdGVGRlQoKVxuICAgICAgICBpbnB1dC5jb25uZWN0KCBBdWRpby5GRlQgKVxuXG4gICAgICAgIEF1ZGlvLmludGVydmFsID0gc2V0SW50ZXJ2YWwoIEF1ZGlvLmZmdENhbGxiYWNrLCAxMDAwLzYwIClcbiAgICAgICAgLy93aW5kb3cuRkZUID0gQXVkaW8uRkZUXG4gICAgICB9KVxuICAgIH1cbiAgICBBdWRpby5fX2hhc0lucHV0ID0gdHJ1ZVxuICB9LFxuXG4gIGNyZWF0ZUlucHV0KCkge1xuICAgIGNvbnNvbGUubG9nKCAnY29ubmVjdGluZyBhdWRpbyBpbnB1dC4uLicgKVxuICAgIFxuICAgIGNvbnN0IHAgPSBuZXcgUHJvbWlzZSggcmVzb2x2ZSA9PiB7XG4gICAgICBjb25zb2xlLmxvZyggJ3N0YXJ0PycgKVxuICAgICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoeyBhdWRpbzp0cnVlLCB2aWRlbzpmYWxzZSB9KVxuICAgICAgICAudGhlbiggc3RyZWFtID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZyggJ2F1ZGlvIGlucHV0IGNvbm5lY3RlZCcgKVxuICAgICAgICAgIEF1ZGlvLmlucHV0ID0gQXVkaW8uY3R4LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKCBzdHJlYW0gKVxuICAgICAgICAgIC8vQXVkaW8ubWVkaWFTdHJlYW1Tb3VyY2UuY29ubmVjdCggR2liYmVyaXNoLm5vZGUgKVxuICAgICAgICAgIEF1ZGlvLl9faGFzSW5wdXQgPSB0cnVlXG4gICAgICAgICAgcmVzb2x2ZSggQXVkaW8uaW5wdXQgKVxuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goIGVyciA9PiB7IFxuICAgICAgICAgIGNvbnNvbGUubG9nKCAnZXJyb3Igb3BlbmluZyBhdWRpbyBpbnB1dDonLCBlcnIgKVxuICAgICAgICB9KVxuICAgIH0pXG4gICAgcmV0dXJuIHBcbiAgfSxcblxuICBjcmVhdGVGRlQoKSB7XG4gICAgQXVkaW8uRkZUID0gQXVkaW8uY3R4LmNyZWF0ZUFuYWx5c2VyKClcblxuICAgIGxldCBfX3dpbmRvd1NpemUgPSA1MTJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIEF1ZGlvLCAnd2luZG93U2l6ZScsIHtcbiAgICAgIGdldCgpIHsgcmV0dXJuIF9fd2luZG93U2l6ZSB9LFxuICAgICAgc2V0KHYpe1xuICAgICAgICBfX3dpbmRvd1NpemUgPSB2XG4gICAgICAgIEF1ZGlvLkZGVC5mZnRTaXplID0gdiBcbiAgICAgICAgQXVkaW8uRkZULnZhbHVlcyA9IG5ldyBVaW50OEFycmF5KCBBdWRpby5GRlQuZnJlcXVlbmN5QmluQ291bnQgKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBBdWRpby53aW5kb3dTaXplID0gNTEyXG4gIH0sXG5cbiAgZmZ0Q2FsbGJhY2soKSB7XG4gICAgQXVkaW8uRkZULmdldEJ5dGVGcmVxdWVuY3lEYXRhKCBBdWRpby5GRlQudmFsdWVzIClcbiAgICBcbiAgICBsZXQgbG93U3VtLCBtaWRTdW0sIGhpZ2hTdW0sIGxvd0NvdW50LCBtaWRDb3VudCwgaGlnaENvdW50XG4gICAgbG93U3VtID0gbWlkU3VtID0gaGlnaFN1bSA9IGxvd0NvdW50ID0gbWlkQ291bnQgPSBoaWdoQ291bnQgPSAwXG5cbiAgICBsZXQgZnJlcXVlbmN5Q291bnRlciA9IDBcblxuICAgIC8vIGRvZXMgdGhpcyBzdGFydCBhdCAwSHo/IGFjay4uLiBjYW4ndCByZW1lbWJlci4uLiBkb2VzIGl0IGluY2x1ZGUgREMgb2Zmc2V0P1xuICAgIGNvbnN0IGh6UGVyQmluID0gKEF1ZGlvLmN0eC5zYW1wbGVSYXRlIC8gMikgLyBBdWRpby5GRlQuZnJlcXVlbmN5QmluQ291bnRcbiAgICBjb25zdCBsb3dSYW5nZSA9IDE1MCwgbWlkUmFuZ2UgPSAxNDAwLCBoaWdoUmFuZ2UgPSBBdWRpby5jdHguc2FtcGxlUmF0ZSAvIDJcblxuICAgIGZvciggbGV0IGkgPSAxOyBpIDwgQXVkaW8uRkZULmZyZXF1ZW5jeUJpbkNvdW50OyBpKysgKSB7XG4gICAgICBpZiggZnJlcXVlbmN5Q291bnRlciA8IGxvd1JhbmdlICkge1xuICAgICAgICBsb3dTdW0gKz0gQXVkaW8uRkZULnZhbHVlc1sgaSBdXG4gICAgICAgIGxvd0NvdW50KytcbiAgICAgIH1lbHNlIGlmKCBmcmVxdWVuY3lDb3VudGVyIDwgbWlkUmFuZ2UgKSB7XG4gICAgICAgIG1pZFN1bSArPSBBdWRpby5GRlQudmFsdWVzWyBpIF1cbiAgICAgICAgbWlkQ291bnQrK1xuICAgICAgfWVsc2V7XG4gICAgICAgIGhpZ2hTdW0gKz0gQXVkaW8uRkZULnZhbHVlc1sgaSBdXG4gICAgICAgIGhpZ2hDb3VudCsrXG4gICAgICB9XG5cbiAgICAgIGZyZXF1ZW5jeUNvdW50ZXIgKz0gaHpQZXJCaW5cbiAgICB9XG5cbiAgICBBdWRpby5sb3cgPSAobG93U3VtIC8gbG93Q291bnQpIC8gMjU1XG4gICAgQXVkaW8ubWlkID0gKG1pZFN1bSAvIG1pZENvdW50KSAvIDI1NSB8fCAwXG4gICAgQXVkaW8uaGlnaCA9IChoaWdoU3VtIC8gaGlnaENvdW50KSAvIDI1NVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQXVkaW9cbiIsImNvbnN0IFNjZW5lTm9kZSA9IHJlcXVpcmUoICcuL3NjZW5lTm9kZS5qcycgKSxcbiAgICAgIHsgcGFyYW1fd3JhcCwgTWF0ZXJpYWxJRCB9ID0gcmVxdWlyZSggJy4vdXRpbHMuanMnICksXG4gICAgICB7IFZhciwgZmxvYXRfdmFyX2dlbiwgdmVjMl92YXJfZ2VuLCB2ZWMzX3Zhcl9nZW4sIHZlYzRfdmFyX2dlbiB9ID0gcmVxdWlyZSggJy4vdmFyLmpzJyApXG5cbmNvbnN0IHsgVmVjMiwgVmVjMywgVmVjNCB9ID0gcmVxdWlyZSggJy4vdmVjLmpzJyApXG5cbmNvbnN0IEJHID0gZnVuY3Rpb24oIFNjZW5lLCBTREYgKSB7XG5cbiAgY29uc3QgQmFja2dyb3VuZCA9IGZ1bmN0aW9uKCBjb2xvciApIHtcbiAgICBpZiggU0RGLm1lbW8uYmFja2dyb3VuZCA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgY29uc3QgYmcgPSBPYmplY3QuY3JlYXRlKCBCYWNrZ3JvdW5kLnByb3RvdHlwZSApXG5cbiAgICAgIGNvbnN0IF9fY29sb3IgPSBwYXJhbV93cmFwKCBWZWMzKGNvbG9yKSwgdmVjM192YXJfZ2VuKCAwLDAsMCwgJ2JnJyApLCAnYmcnICkgIFxuICAgICAgXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIGJnLCAnY29sb3InLCB7XG4gICAgICAgIGdldCgpIHsgcmV0dXJuIF9fY29sb3IgfSxcbiAgICAgICAgc2V0KCB2ICkge1xuICAgICAgICAgIF9fY29sb3IudmFyLnNldCggdiApXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBcbiAgICAgIC8vIHRoaXMgcmVmZXJzIHRvIHRoZSBjdXJyZW50IHNjZW5lIHZpYSBpbXBsaWNpdCBiaW5kaW5nIGluIHNjZW5lLmpzXG4gICAgICB0aGlzLnBvc3Rwcm9jZXNzaW5nLnB1c2goIGJnIClcblxuICAgICAgU0RGLm1lbW8uYmFja2dyb3VuZCA9IHRydWVcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIEJhY2tncm91bmQucHJvdG90eXBlID0gU2NlbmVOb2RlKClcbiBcbiAgT2JqZWN0LmFzc2lnbiggQmFja2dyb3VuZC5wcm90b3R5cGUsIHtcbiAgICBlbWl0KCkge1xuICAgICAgcmV0dXJuICcnLy90aGlzLmNvbG9yLmVtaXQoKVxuICAgIH0sXG4gICBcbiAgICBlbWl0X2RlY2woKSB7XG4gICAgICBsZXQgc3RyID0gdGhpcy5jb2xvci5lbWl0X2RlY2woKVxuICAgICAgU0RGLm1lbW8uYmFja2dyb3VuZCA9IHRydWVcblxuICAgICAgcmV0dXJuIHN0clxuICAgIH0sXG5cbiAgICB1cGRhdGVfbG9jYXRpb24oIGdsLCBwcm9ncmFtICkge1xuICAgICAgdGhpcy5jb2xvci51cGRhdGVfbG9jYXRpb24oIGdsLCBwcm9ncmFtIClcbiAgICB9LFxuXG4gICAgdXBsb2FkX2RhdGEoIGdsICkge1xuICAgICAgdGhpcy5jb2xvci51cGxvYWRfZGF0YSggZ2wgKVxuICAgIH1cbiAgfSlcblxuICByZXR1cm4gQmFja2dyb3VuZFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJHIFxuIiwiY29uc3QgdmVjMyA9IHJlcXVpcmUoJ2dsLXZlYzMnKVxuY29uc3QgbWF0NCA9IHJlcXVpcmUoJ2dsLW1hdDQnKVxuXG4vLyBjYW1lcmEgYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9zaGFtYS9maXJzdC1wZXJzb24tY2FtZXJhXG5mdW5jdGlvbiBGaXJzdFBlcnNvbkNhbWVyYShvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBGaXJzdFBlcnNvbkNhbWVyYSkpIHJldHVybiBuZXcgRmlyc3RQZXJzb25DYW1lcmEob3B0cylcbiAgb3B0cyA9IG9wdHMgfHwge31cbiAgdGhpcy5wb3NpdGlvbiA9IG9wdHMucG9zaXRpb24gfHwgdmVjMy5jcmVhdGUoKVxuICB0aGlzLnJvdGF0aW9uID0gb3B0cy5yb3RhdGlvbiB8fCB2ZWMzLmNyZWF0ZSgpXG4gIHRoaXMucG9zaXRpb25TcGVlZCA9IG9wdHMucG9zaXRpb25TcGVlZCB8fCAtLjVcbiAgdGhpcy5yb3RhdGlvblNwZWVkID0gb3B0cy5yb3RhdGlvblNwZWVkIHx8IC4wMVxufVxubW9kdWxlLmV4cG9ydHMgPSBGaXJzdFBlcnNvbkNhbWVyYVxuXG5GaXJzdFBlcnNvbkNhbWVyYS5wcm90b3R5cGUudmlldyA9IGZ1bmN0aW9uKG91dCkge1xuICBpZiAoIW91dCkgb3V0ID0gbWF0NC5jcmVhdGUoKVxuICAvLyBhbHRlcmVkIHgveSBvcmRlcmluZyBmcm9tIG9yaWdpbmFsXG4gIG1hdDQucm90YXRlWShvdXQsIG91dCwgdGhpcy5yb3RhdGlvblsxXSlcbiAgbWF0NC5yb3RhdGVYKG91dCwgb3V0LCB0aGlzLnJvdGF0aW9uWzBdKVxuICBtYXQ0LnJvdGF0ZVoob3V0LCBvdXQsIHRoaXMucm90YXRpb25bMl0gLSBNYXRoLlBJKVxuICBtYXQ0LnRyYW5zbGF0ZShvdXQsIG91dCwgWy10aGlzLnBvc2l0aW9uWzBdLCAtdGhpcy5wb3NpdGlvblsxXSwgLXRoaXMucG9zaXRpb25bMl1dKVxuXG4gIHJldHVybiBvdXRcbn1cblxuRmlyc3RQZXJzb25DYW1lcmEucHJvdG90eXBlLmNvbnRyb2wgPSBmdW5jdGlvbihkdCwgbW92ZSwgbW91c2UsIHByZXZNb3VzZSkge1xuICB2YXIgc3BlZWQgPSAodGhpcy5wb3NpdGlvblNwZWVkIC8gMTAwMCkgKiBkdFxuICB2YXIgZGlyID0gWzAsMCwwXVxuICBpZiAobW92ZVswXSkgZGlyWzJdIC09IHNwZWVkICogKE1hcmNoaW5nLmtleXMuQWx0ID8gNCA6IDEgKVxuICBlbHNlIGlmIChtb3ZlWzFdKSBkaXJbMl0gKz0gc3BlZWQgKiAoTWFyY2hpbmcua2V5cy5BbHQgPyA0IDogMSApXG4gIGlmIChtb3ZlWzJdKSBkaXJbMF0gKz0gc3BlZWQgKiAoTWFyY2hpbmcua2V5cy5BbHQgPyA0IDogMSApXG4gIGVsc2UgaWYgKG1vdmVbM10pIGRpclswXSAtPSBzcGVlZCAqIChNYXJjaGluZy5rZXlzLkFsdCA/IDQgOiAxIClcbiAgaWYgKG1vdmVbNF0pIGRpclsxXSAtPSBzcGVlZCAqIChNYXJjaGluZy5rZXlzLkFsdCA/IDQgOiAxIClcbiAgZWxzZSBpZiAobW92ZVs1XSkgZGlyWzFdICs9IHNwZWVkICogKE1hcmNoaW5nLmtleXMuQWx0ID8gNCA6IDEgKVxuICB0aGlzLm1vdmUoZGlyKVxuICAvLyBqdXN0IHVzZSBhcnJvdyBrZXlzIGluc3RlYWQgb2YgbW91c2VcbiAgLy8gdGhpcy5wb2ludGVyKG1vdXNlLCBwcmV2TW91c2UpXG59XG5cbkZpcnN0UGVyc29uQ2FtZXJhLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24oZGlyKSB7XG4gIGlmIChkaXJbMF0gIT09IDAgfHwgZGlyWzFdICE9PSAwIHx8IGRpclsyXSAhPT0gMCkge1xuICAgIHZhciBjYW0gPSBtYXQ0LmNyZWF0ZSgpXG4gICAgbWF0NC5yb3RhdGVZKGNhbSwgY2FtLCB0aGlzLnJvdGF0aW9uWzFdKVxuICAgIG1hdDQucm90YXRlWChjYW0sIGNhbSwgdGhpcy5yb3RhdGlvblswXSlcbiAgICB2ZWMzLnRyYW5zZm9ybU1hdDQoZGlyLCBkaXIsIGNhbSlcbiAgICB2ZWMzLmFkZCh0aGlzLnBvc2l0aW9uLCB0aGlzLnBvc2l0aW9uLCBkaXIpXG4gICAgdGhpcy5wYXJlbnQucG9zLmRpcnR5ID0gdHJ1ZVxuXG4gIH1cbn1cblxuLy9GaXJzdFBlcnNvbkNhbWVyYS5wcm90b3R5cGUucG9pbnRlciA9IGZ1bmN0aW9uKGRhLCBkYikge1xuLy8gIHZhciBkdCA9IFtkYVswXSAtIGRiWzBdLCBkYVsxXS0gZGJbMV1dXG4vLyAgdmFyIHJvdCA9IHRoaXMucm90YXRpb25cbi8vICByb3RbMV0gLT0gZHRbMF0gKiB0aGlzLnJvdGF0aW9uU3BlZWRcbi8vICBpZiAocm90WzFdIDwgMCkgcm90WzFdICs9IE1hdGguUEkgKiAyXG4vLyAgaWYgKHJvdFsxXSA+PSBNYXRoLlBJICogMikgcm90WzFdIC09IE1hdGguUEkgKiAyXG4vLyAgcm90WzBdIC09IGR0WzFdICogdGhpcy5yb3RhdGlvblNwZWVkXG4vLyAgaWYgKHJvdFswXSA8IC1NYXRoLlBJICogLjUpIHJvdFswXSA9IC1NYXRoLlBJKjAuNVxuLy8gIGlmIChyb3RbMF0gPiBNYXRoLlBJICogLjUpIHJvdFswXSA9IE1hdGguUEkqMC41XG4vL31cblxuY29uc3QgQ2FtZXJhID0ge1xuICBpbml0KCBnbCwgcHJvZ3JhbSwgaGFuZGxlciApIHtcblxuICAgIGNvbnN0IGNhbWVyYSA9IEZpcnN0UGVyc29uQ2FtZXJhKHtcbiAgICAgIGZvdjogMTkwLFxuICAgICAgbmVhcjouMDEsXG4gICAgICBmYXI6MTAsXG4gICAgICBkaXJlY3Rpb246WzAsMCwxXSxcbiAgICAgIHZpZXdwb3J0OlsxLDEsMSwtMV1cbiAgICB9KVxuICAgIGNhbWVyYS5yb3RhdGlvbiA9IFswLE1hdGguUEksTWF0aC5QSV0gXG4gICAgQ2FtZXJhLl9fY2FtZXJhID0gY2FtZXJhXG4gICAgY2FtZXJhLnBhcmVudCA9IHRoaXNcblxuICAgIGNvbnN0IGNhbWVyYV9wb3MgICAgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdjYW1lcmFfcG9zJyApXG4gICAgY29uc3QgY2FtZXJhX25vcm1hbCA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2NhbWVyYV9ub3JtYWwnIClcbiAgICBjb25zdCBjYW1lcmFfcm90ICAgID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnY2FtZXJhX3JvdCcgKVxuICAgIGNvbnN0IHVjYW1lcmEgICAgICAgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdjYW1lcmEnIClcblxuICAgIHRoaXMucG9zID0geyBkaXJ0eTpmYWxzZSB9XG4gICAgdGhpcy5kaXIgPSB7IGRpcnR5OnRydWUgfVxuICAgIHRoaXMuX19yb3QgPSB7IGRpcnR5OnRydWUsIHZhbHVlOjAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAncm90YXRpb24nLCB7XG4gICAgICBjb25maWd1cmFibGU6dHJ1ZSxcbiAgICAgIGdldCgpIHsgcmV0dXJuIHRoaXMuX19yb3QudmFsdWUgfSxcbiAgICAgIHNldCh2KSB7IFxuICAgICAgICB0aGlzLl9fcm90LnZhbHVlID0gdiBcbiAgICAgICAgdGhpcy5fX3JvdC5kaXJ0eSA9IHRydWVcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgbGV0IHB4ID0gMCwgcHkgPTAsIHB6ID0gNSwgbnggPSAwLCBueSA9IDAsIG56ID0gMFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCB0aGlzLnBvcywge1xuICAgICAgeDoge1xuICAgICAgICBnZXQoKSAgeyByZXR1cm4gcHggfSxcbiAgICAgICAgc2V0KHYpIHsgcHggPSBjYW1lcmEucG9zaXRpb25bMF0gPSB2O3RoaXMuZGlydHkgPSB0cnVlOyB9XG4gICAgICB9LFxuXG4gICAgICB5OiB7XG4gICAgICAgIGdldCgpICB7IHJldHVybiBweSB9LFxuICAgICAgICBzZXQodikgeyBweSA9IGNhbWVyYS5wb3NpdGlvblsxXSA9IHY7IHRoaXMuZGlydHkgPSB0cnVlOyB9XG4gICAgICB9LFxuXG4gICAgICB6OiB7XG4gICAgICAgIGdldCgpICB7IHJldHVybiBweiB9LFxuICAgICAgICBzZXQodikgeyBweiA9IGNhbWVyYS5wb3NpdGlvblsyXSA9IHY7IHRoaXMuZGlydHkgPSB0cnVlOyB9XG4gICAgICB9LFxuICAgIH0pXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggdGhpcy5kaXIsIHtcbiAgICAgIHg6IHtcbiAgICAgICAgZ2V0KCkgIHsgcmV0dXJuIG54IH0sXG4gICAgICAgIHNldCh2KSB7IG54ID0gY2FtZXJhLnJvdGF0aW9uWzBdID0gdjsgdGhpcy5kaXJ0eSA9IHRydWU7IH1cbiAgICAgIH0sXG5cbiAgICAgIHk6IHtcbiAgICAgICAgZ2V0KCkgIHsgcmV0dXJuIG55IH0sXG4gICAgICAgIHNldCh2KSB7IG55ID0gY2FtZXJhLnJvdGF0aW9uWzFdID0gdjsgdGhpcy5kaXJ0eSA9IHRydWU7IH1cbiAgICAgIH0sXG5cbiAgICAgIHo6IHtcbiAgICAgICAgZ2V0KCkgIHsgcmV0dXJuIG56IH0sXG4gICAgICAgIHNldCh2KSB7IG56ID0gY2FtZXJhLnJvdGF0aW9uWzJdID0gdjsgdGhpcy5kaXJ0eSA9IHRydWU7IH1cbiAgICAgIH0sXG4gICAgfSlcblxuICAgIGxldCBpbml0ID0gZmFsc2VcbiAgICBnbC51bmlmb3JtM2YoIGNhbWVyYV9ub3JtYWwsIHRoaXMuZGlyLngsIHRoaXMuZGlyLnksIHRoaXMuZGlyLnogKVxuICAgIGNhbWVyYS5wb3NpdGlvbiA9IFt0aGlzLnBvcy54LCB0aGlzLnBvcy55LCB0aGlzLnBvcy56IF0gXG4gICAgLy9jYW1lcmEudXBkYXRlKClcbiAgICBnbC51bmlmb3JtM2YoIGNhbWVyYV9wb3MsIHRoaXMucG9zLngsIHRoaXMucG9zLnksIHRoaXMucG9zLnogKVxuICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYoIHVjYW1lcmEsIGZhbHNlLCBjYW1lcmEudmlldygpIClcbiAgICBnbC51bmlmb3JtMWYoIGNhbWVyYV9yb3QsIHRoaXMucm90ICkgXG5cbiAgICBDYW1lcmEubW92ZSA9ICh4LHkseikgPT4ge1xuICAgICAgLy8gWFhYIGRvZXMgdGhpcyBuZWVkIHRvIHVwZGF0ZSBwcm9wZXJ0eSB2YWx1ZXM/XG4gICAgICBjYW1lcmEubW92ZShbeCx5LHpdKVxuICAgICAgQ2FtZXJhLnVwZGF0ZSgpXG4gICAgfVxuICAgIENhbWVyYS5tb3ZlVG8gPSAoeCx5LHopID0+IHtcbiAgICAgIENhbWVyYS5wb3MueCA9IHhcbiAgICAgIENhbWVyYS5wb3MueSA9IHlcbiAgICAgIENhbWVyYS5wb3MueiA9IHpcbiAgICB9XG4gICAgQ2FtZXJhLnVwZGF0ZSA9ICgpPT4ge1xuICAgICAgY29uc3QgcG9zID0gY2FtZXJhLnBvc2l0aW9uXG4gICAgICBnbC51bmlmb3JtM2YoIGNhbWVyYV9wb3MsIHBvc1swXSwgcG9zWzFdLCBwb3NbMl0gIClcbiAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYoIHVjYW1lcmEsIGZhbHNlLCBjYW1lcmEudmlldygpIClcbiAgICB9XG5cbiAgICAvLyBkZXRlcm1pbmUgYW4gb2Zmc2V0IGZyb20gdGhlIGN1cnJlbnQgY2FtZXJhIHBvc2l0aW9uIGJhc2VkXG4gICAgLy8gb24gdGhlIGN1cnJlbnQgY2FtZXJhIHJvdGF0aW9uIGUuZy4gdG8gYWx3YXlzIHBvc2l0aW9uIGEgbGlnaHRcbiAgICAvLyBiZWhpbmQgdGhlIGNhbWVyYS5cbiAgICBDYW1lcmEub2Zmc2V0ID0gKGFtdD1bMCwwLDNdKSA9PiB7XG4gICAgICBjb25zdCBjYW0gPSBtYXQ0LmNyZWF0ZSgpXG4gICAgICBtYXQ0LnJvdGF0ZVkoY2FtLCBjYW0sIGNhbWVyYS5yb3RhdGlvblsxXSlcbiAgICAgIG1hdDQucm90YXRlWChjYW0sIGNhbSwgY2FtZXJhLnJvdGF0aW9uWzBdKVxuICAgICAgdmVjMy50cmFuc2Zvcm1NYXQ0KGFtdCwgYW10LCBjYW0pXG4gICAgICByZXR1cm4gYW10XG4gICAgfVxuXG4gICAgbGV0IHBydnggPSAwLCBwcnZ5ID0gMCwgeCA9IDAsIHkgPSAwXG4gICAgQ2FtZXJhLl9fbW91c2Vtb3ZlZm5jID0gZSA9PiB7XG4gICAgICBwcnZ4ID0geFxuICAgICAgcHJ2eSA9IHlcbiAgICAgIHggPSBlLnBhZ2VYXG4gICAgICB5ID0gZS5wYWdlWVxuICAgIH1cblxuICAgIGxldCBwcmV2VGltZSA9IDBcbiAgICBsZXQgayAgPSBNYXJjaGluZy5rZXlzXG4gICAgQ2FtZXJhLl9fZnJhbWVmbmMgPSB0ID0+IHtcbiAgICAgIGlmKCBrLkFycm93TGVmdCApIGNhbWVyYS5yb3RhdGlvblsxXSArPSBjYW1lcmEucm90YXRpb25TcGVlZFxuICAgICAgaWYoIGsuQXJyb3dSaWdodCApIGNhbWVyYS5yb3RhdGlvblsxXSAtPSBjYW1lcmEucm90YXRpb25TcGVlZFxuICAgICAgaWYoIGsuQXJyb3dVcCAmJiAhay5TaGlmdCApIGNhbWVyYS5yb3RhdGlvblswXSAtPSBjYW1lcmEucm90YXRpb25TcGVlZFxuICAgICAgaWYoIGsuQXJyb3dEb3duICYmICFrLlNoaWZ0KSBjYW1lcmEucm90YXRpb25bMF0gKz0gY2FtZXJhLnJvdGF0aW9uU3BlZWRcbiAgICAgIFxuICAgICAgaWYoIE1hcmNoaW5nLmNhbWVyYUVuYWJsZWQgKSB7IFxuICAgICAgICBjYW1lcmEuY29udHJvbCggXG4gICAgICAgICAgdCoxMDAwIC0gcHJldlRpbWUsXG4gICAgICAgICAgW2sudyxrLnMsay5kLGsuYSxrLkFycm93VXAgJiYgay5TaGlmdCwgay5BcnJvd0Rvd24gJiYgay5TaGlmdF0sIFxuICAgICAgICAgIFt4LHldLCBbcHJ2eCxwcnZ5XSBcbiAgICAgICAgKVxuICAgICAgICBDYW1lcmEudXBkYXRlKClcbiAgICAgICAgcHJ2eCA9IHhcbiAgICAgICAgcHJ2eSA9IHlcbiAgICAgICAgcHJldlRpbWUgPSB0KjEwMDBcbiAgICAgIH1cbiAgICB9XG5cbiAgICBDYW1lcmEuX19tb3VzZW1vdmUgPSBudWxsXG4gICAgQ2FtZXJhLm9uID0gKCk9PiB7XG4gICAgICBpZiggQ2FtZXJhLl9fbW91c2Vtb3ZlID09PSBudWxsICkge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNlbW92ZScsIENhbWVyYS5fX21vdXNlbW92ZWZuYyApXG4gICAgICAgIENhbWVyYS5fX21vdXNlbW92ZSA9IHRydWVcbiAgICAgIH1cbiAgICAgIGlmKCBNYXJjaGluZy5jYWxsYmFja3MuaW5kZXhPZiggQ2FtZXJhLl9fZnJhbWVmbmMgKSA9PT0gLTEgKSB7XG4gICAgICAgIE1hcmNoaW5nLmNhbGxiYWNrcy5wdXNoKCBDYW1lcmEuX19mcmFtZWZuYyApXG4gICAgICB9XG4gICAgfVxuXG4gICAgaGFuZGxlciggKCk9PiB7XG4gICAgICBpZiggdGhpcy5wb3MuZGlydHkgPT09IHRydWUgKSB7XG5cbiAgICAgICAgLy9jYW1lcmEucG9zaXRpb24gPSBbdGhpcy5wb3MueCwgdGhpcy5wb3MueSwgdGhpcy5wb3MueiBdXG4gXG4gICAgICAgIC8vY2FtZXJhLnBvc2l0aW9uID0gW3RoaXMucG9zLngsIHRoaXMucG9zLnksIHRoaXMucG9zLnogXVxuICAgICAgICAvL2NhbWVyYS51cGRhdGUoKVxuICAgICAgICBjb25zdCBwb3MgPSBjYW1lcmEucG9zaXRpb25cbiAgICAgICAgZ2wudW5pZm9ybTNmKCBjYW1lcmFfcG9zLCBwb3NbMF0sIHBvc1sxXSwgcG9zWzJdIClcbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdiggdWNhbWVyYSwgZmFsc2UsIGNhbWVyYS52aWV3KCkgKVxuICAgICAgICB0aGlzLnBvcy5kaXJ0eSA9IGZhbHNlXG5cblxuICAgICAgfVxuXG4gICAgICAvLyBYWFggdGhpcyBpcyBicm9rZW4gYW5kIG5lZWRzIHRvIGJlIGZpeGVkXG4gICAgICBpZiggdGhpcy5kaXIuZGlydHkgPT09IHRydWUgKSB7XG4gICAgICAgIGdsLnVuaWZvcm0zZiggY2FtZXJhX25vcm1hbCwgdGhpcy5kaXIueCwgdGhpcy5kaXIueSwgdGhpcy5kaXIueiApXG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYoIHVjYW1lcmEsIGZhbHNlLCBjYW1lcmEudmlldygpIClcbiAgICAgICAgdGhpcy5kaXIuZGlydHkgPSBmYWxzZVxuICAgICAgfVxuICAgICAgaWYoIHRoaXMuX19yb3QuZGlydHkgPT09IHRydWUgKSB7XG4gICAgICAgIGdsLnVuaWZvcm0xZiggY2FtZXJhX3JvdCwgdGhpcy5fX3JvdC52YWx1ZSApXG4gICAgICAgIHRoaXMuX19yb3QuZGlydHkgPSBmYWxzZVxuICAgICAgfVxuICAgICAgaWYoIHR5cGVvZiB0aGlzLm9ubW92ZSA9PT0gJ2Z1bmN0aW9uJyApIHtcbiAgICAgICAgdGhpcy5vbm1vdmUoIHRoaXMgKVxuICAgICAgfVxuICAgIH0pXG5cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENhbWVyYVxuIiwiY29uc3QgU2NlbmVOb2RlID0gcmVxdWlyZSggJy4vc2NlbmVOb2RlLmpzJyApXG5jb25zdCB7IHBhcmFtX3dyYXAsIE1hdGVyaWFsSUQgfSA9IHJlcXVpcmUoICcuL3V0aWxzLmpzJyApXG5jb25zdCB7IFZhciwgZmxvYXRfdmFyX2dlbiwgdmVjMl92YXJfZ2VuLCB2ZWMzX3Zhcl9nZW4sIHZlYzRfdmFyX2dlbiwgaW50X3Zhcl9nZW4sIFZhckFsbG9jIH0gPSByZXF1aXJlKCAnLi92YXIuanMnIClcbmNvbnN0IFRyYW5zZm9ybSA9IHJlcXVpcmUoICcuL3RyYW5zZm9ybS5qcycgKVxuXG5jb25zdCBvcHMgPSB7IFxuICAvLyB0aGlzIG5lZWRzIHRvIGNyZWF0ZSBhbiBvcE91dCwgbm90IHJldHVybiBhIHZlYzJcbiAgRGlzcGxhY2UoIF9fbmFtZSApIHtcbiAgICBsZXQgbmFtZSA9IF9fbmFtZSA9PT0gdW5kZWZpbmVkID8gJ3AnIDogX19uYW1lXG4gICAgY29uc3Qgc2RmID0gdGhpcy5zZGYuZW1pdCggbmFtZSApO1xuXG4gICAgY29uc3Qgc2RmU3RyID0gYGZsb2F0IGQxJHt0aGlzLmlkfSA9ICR7c2RmLm91dH0ueDtcXG5gXG5cbiAgICBsZXQgZGlzcGxhY2VTdHJpbmcgPSBgZmxvYXQgZDIke3RoaXMuaWR9ID0gc2luKCAke3RoaXMuYW1vdW50LmVtaXQoKX0ueCAqICR7bmFtZX0ueCApICogYCAgXG4gICAgZGlzcGxhY2VTdHJpbmcgKz0gYHNpbiggJHt0aGlzLmFtb3VudC5lbWl0KCl9LnkgKiAke25hbWV9LnkgKSAqIGBcbiAgICBkaXNwbGFjZVN0cmluZyArPSBgc2luKCAke3RoaXMuYW1vdW50LmVtaXQoKX0ueiAqICR7bmFtZX0ueiApO1xcbmBcbiAgICBkaXNwbGFjZVN0cmluZyArPSBgJHtzZGYub3V0fS54ID0gKGQxJHt0aGlzLmlkfSArIGQyJHt0aGlzLmlkfSoke3RoaXMuc2l6ZS5lbWl0KCl9KSouNTtcXG5gXG5cbiAgICBjb25zdCBvdXRwdXQgPSB7XG4gICAgICBvdXQ6IGAke3NkZi5vdXR9YCwgXG4gICAgICBwcmVmYWNlOiBzZGYucHJlZmFjZSArIHNkZlN0ciArIGRpc3BsYWNlU3RyaW5nIFxuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXRcbiAgfSxcblxuICBCZW5kKCBfX25hbWUgKSB7XG4gICAgbGV0IG5hbWUgPSBfX25hbWUgPT09IHVuZGVmaW5lZCA/ICdwJyA6IF9fbmFtZVxuICAgIGNvbnN0IHNkZiA9IHRoaXMuc2RmLmVtaXQoICdxJyt0aGlzLmlkICk7XG5cbiAgICBsZXQgcHJlZmFjZT1gICAgICAgICBmbG9hdCBjJHt0aGlzLmlkfSA9IGNvcyggJHt0aGlzLmFtb3VudC5lbWl0KCl9LnggKiAke25hbWV9LnggKTtcbiAgICAgICAgZmxvYXQgcyR7dGhpcy5pZH0gPSBzaW4oICR7dGhpcy5hbW91bnQuZW1pdCgpfS54ICogJHtuYW1lfS54ICk7XG4gICAgICAgIG1hdDIgIG0ke3RoaXMuaWR9ID0gbWF0MiggYyR7dGhpcy5pZH0sLXMke3RoaXMuaWR9LHMke3RoaXMuaWR9LGMke3RoaXMuaWR9ICk7XG4gICAgICAgIHZlYzQgIHEke3RoaXMuaWR9ID0gdmVjNCggbSR7dGhpcy5pZH0gKiAke25hbWV9Lnh5LCAke25hbWV9LnosIDEuICk7XFxuYFxuXG4gICAgaWYoIHR5cGVvZiBzZGYucHJlZmFjZSA9PT0gJ3N0cmluZycgKSB7XG4gICAgICBwcmVmYWNlICs9IHNkZi5wcmVmYWNlXG4gICAgfVxuXG4gICAgcmV0dXJuIHsgcHJlZmFjZSwgb3V0OnNkZi5vdXQgfVxuICB9LFxuXG4gIFR3aXN0KCBfX25hbWUgKSB7XG4gICAgbGV0IG5hbWUgPSBfX25hbWUgPT09IHVuZGVmaW5lZCA/ICdwJyA6IF9fbmFtZVxuICAgIGNvbnN0IHNkZiA9IHRoaXMuc2RmLmVtaXQoICdxJyt0aGlzLmlkICk7XG5cbiAgICBsZXQgcHJlZmFjZT1gICAgICAgICBmbG9hdCBjJHt0aGlzLmlkfSA9IGNvcyggJHt0aGlzLmFtb3VudC5lbWl0KCl9LnggKiAke25hbWV9LnkgKTtcbiAgICAgICAgZmxvYXQgcyR7dGhpcy5pZH0gPSBzaW4oICR7dGhpcy5hbW91bnQuZW1pdCgpfS54ICogJHtuYW1lfS55ICk7XG4gICAgICAgIG1hdDIgIG0ke3RoaXMuaWR9ID0gbWF0MiggYyR7dGhpcy5pZH0sLXMke3RoaXMuaWR9LHMke3RoaXMuaWR9LGMke3RoaXMuaWR9ICk7XG4gICAgICAgIHZlYzQgIHEke3RoaXMuaWR9ID0gdmVjNCggbSR7dGhpcy5pZH0gKiAke25hbWV9Lnh6LCAke25hbWV9LnksIDEuICk7XFxuYFxuXG4gICAgaWYoIHR5cGVvZiBzZGYucHJlZmFjZSA9PT0gJ3N0cmluZycgKSB7XG4gICAgICBwcmVmYWNlICs9IHNkZi5wcmVmYWNlXG4gICAgfVxuXG4gICAgcmV0dXJuIHsgcHJlZmFjZSwgb3V0OnNkZi5vdXQgfVxuICB9LFxuICBfX0J1bXAoIF9fbmFtZSApIHtcbiAgICBsZXQgbmFtZSA9IF9fbmFtZSA9PT0gdW5kZWZpbmVkID8gJ3AnIDogX19uYW1lXG5cbiAgICBjb25zdCBidW1wU3RyaW5nID0gIGAgICAgICAgIHZlYzQgdHJhbnNmb3JtQnVtcCR7dGhpcy5pZH0gPSAke25hbWV9ICogJHt0aGlzLnRyYW5zZm9ybS5lbWl0KCl9O1xcbmBcbiAgICBjb25zdCB0ZXggPSB0aGlzLmFtb3VudC5lbWl0KCBuYW1lIClcblxuICAgIGNvbnN0IHBvaW50U3RyaW5nID0gYCh0cmFuc2Zvcm1CdW1wJHt0aGlzLmlkfSAqICR7dGhpcy5zZGYudHJhbnNmb3JtLmVtaXQoKX0pYFxuXG4gICAgY29uc3Qgc2RmID0gdGhpcy5zZGYuZW1pdCggcG9pbnRTdHJpbmcsIHRoaXMudHJhbnNmb3JtLCBgdGV4JHt0aGlzLmlkfWAgKSBcblxuICAgIE1hcmNoaW5nLnRleHR1cmVzLmFkZFRleHR1cmUoIHRoaXMuYW1vdW50LnZhbHVlIClcblxuICAgIGxldCBwcmVmYWNlPWAgIHZlYzMgdGV4JHt0aGlzLmlkfSA9IGdldFRleHR1cmUoICR7dGhpcy5hbW91bnQudmFsdWUuaWR9LCAke3BvaW50U3RyaW5nfS54eXogKSAqICR7dGhpcy5zaXplLmVtaXQoKX07XFxuXG4gICAgICAgIC8vdmVjNCBkaXNwbGFjZUJ1bXAke3RoaXMuaWR9ID0gdmVjNCgoJHtwb2ludFN0cmluZ30gLSB0ZXgke3RoaXMuaWR9KSwgMS4pO1xuICAgIGBcbiAgICAgICAgLy8ke3NkZi5vdXR9LnggPSAodGV4JHt0aGlzLmlkfS54ICsgdGV4JHt0aGlzLmlkfS55ICsgdGV4JHt0aGlzLmlkfS56ICkgLyAzLiAqIC41ICsgJHtzZGYub3V0fS54O1xcbmBcbiAgICAgICAgLy92ZWM0ICR7J3AnK3RoaXMuaWR9ID0gdmVjNCgke3BvaW50U3RyaW5nfSArIHRleCR7dGhpcy5pZH0sIDEuKTtcXG5gXG5cbiAgICAvL3NkZi5wcmVmYWNlICs9IGBcXG4gICAgICAgIFxuICAgIC8vICAgICR7c2RmLm91dH0ueCAtPSBtaW4odGV4JHt0aGlzLmlkfS54LCBtaW4odGV4JHt0aGlzLmlkfS55LCB0ZXgke3RoaXMuaWR9LnopKTtcXG5gIFxuXG4gICAgaWYoIHR5cGVvZiBzZGYucHJlZmFjZSA9PT0gJ3N0cmluZycgKSB7XG4gICAgICBwcmVmYWNlID0gcHJlZmFjZSArIHNkZi5wcmVmYWNlXG4gICAgfVxuXG4gICAgcHJlZmFjZSA9ICBidW1wU3RyaW5nICsgcHJlZmFjZVxuXG4gICAgcmV0dXJuIHsgcHJlZmFjZSwgb3V0OnNkZi5vdXQgfVxuICB9LFxuICAvLyBYWFggdG9kbzogc29tZXRoaW5nIGxpa2UgaHR0cHM6Ly93d3cuc2hhZGVydG95LmNvbS92aWV3L2xkU0d6UlxuICAvLyBodHRwczovL3d3dy5kcm9wYm94LmNvbS9zL2wxeWwxNjRqYjNyaG9tcS9tbV9zZmdyYWRfYnVtcC5wZGY/ZGw9MFxuICBCdW1wKCBfX25hbWUgKSB7XG4gICAgbGV0IG5hbWUgPSBfX25hbWUgPT09IHVuZGVmaW5lZCA/ICdwJyA6IF9fbmFtZVxuXG4gICAgY29uc3QgYnVtcFN0cmluZyA9ICBgICAgICAgICB2ZWM0IHRyYW5zZm9ybUJ1bXAke3RoaXMuaWR9ID0gJHtuYW1lfSAqICR7dGhpcy50cmFuc2Zvcm0uZW1pdCgpfTtcXG5gXG4gICAgY29uc3QgdGV4ID0gdGhpcy5hbW91bnQuZW1pdCggbmFtZSApXG5cbiAgICBjb25zdCBwb2ludFN0cmluZyA9IGAodHJhbnNmb3JtQnVtcCR7dGhpcy5pZH0gKiAke3RoaXMuc2RmLnRyYW5zZm9ybS5lbWl0KCl9KS54eXpgXG5cbiAgICBjb25zdCBzZGYgPSB0aGlzLnNkZi5lbWl0KCBgdHJhbnNmb3JtQnVtcCR7dGhpcy5pZH1gLCB0aGlzLnRyYW5zZm9ybSApIFxuXG4gICAgTWFyY2hpbmcudGV4dHVyZXMuYWRkVGV4dHVyZSggdGhpcy5hbW91bnQudmFsdWUgKVxuXG4gICAgbGV0IHByZWZhY2U9YCAgdmVjMyB0ZXgke3RoaXMuaWR9ID0gZ2V0VGV4dHVyZSggJHt0aGlzLmFtb3VudC52YWx1ZS5pZH0sICR7cG9pbnRTdHJpbmd9KSAqICR7dGhpcy5zaXplLmVtaXQoKX07XG4gICAgICAgICR7c2RmLm91dH0ueCA9ICh0ZXgke3RoaXMuaWR9LnggKyB0ZXgke3RoaXMuaWR9LnkgKyB0ZXgke3RoaXMuaWR9LnopLzMuICsgJHtzZGYub3V0fS54O1xcbmBcblxuICAgIGlmKCB0eXBlb2Ygc2RmLnByZWZhY2UgPT09ICdzdHJpbmcnICkge1xuICAgICAgcHJlZmFjZSA9IHNkZi5wcmVmYWNlICsgcHJlZmFjZVxuICAgIH1cblxuICAgIHByZWZhY2UgPSBidW1wU3RyaW5nICsgcHJlZmFjZVxuXG4gICAgcmV0dXJuIHsgcHJlZmFjZSwgb3V0OnNkZi5vdXQgfVxuICB9LFxufVxuXG5jb25zdCBEaXN0YW5jZU9wcyA9IHt9XG5cbmZvciggbGV0IG5hbWUgaW4gb3BzICkge1xuXG4gIC8vIGdldCBjb2RlZ2VuIGZ1bmN0aW9uXG4gIGxldCBfX29wID0gb3BzWyBuYW1lIF1cblxuICAvLyBjcmVhdGUgY29uc3RydWN0b3JcbiAgRGlzdGFuY2VPcHNbIG5hbWUgXSA9IGZ1bmN0aW9uKCBhLGIsYyApIHtcbiAgICBjb25zdCBvcCA9IE9iamVjdC5jcmVhdGUoIERpc3RhbmNlT3BzWyBuYW1lIF0ucHJvdG90eXBlIClcbiAgICBvcC5zZGYgPSBhXG4gICAgb3AuYW1vdW50ID0gYlxuICAgIG9wLmVtaXQgPSBfX29wXG4gICAgb3AubmFtZSA9IG5hbWVcbiAgICBvcC50cmFuc2Zvcm0gPSBUcmFuc2Zvcm0oKVxuXG4gICAgY29uc3QgZGVmYXVsdFZhbHVlcyA9IFsuNSwuNSwuNV1cblxuICAgIG9wLmlkID0gVmFyQWxsb2MuYWxsb2MoKVxuICAgIGNvbnN0IGlzQXJyYXkgPSB0cnVlIFxuICAgIFxuICAgIGlmKCB0eXBlb2YgYiA9PT0gJ251bWJlcicgKSB7XG4gICAgICBiID0gW2IsYixiXVxuICAgICAgYi50eXBlID0gJ3ZlYzMnXG4gICAgfVxuICAgIFxuICAgIGlmKCBuYW1lICE9PSAnQnVtcHonICkge1xuICAgICAgbGV0IF9fdmFyID0gIHBhcmFtX3dyYXAoIFxuICAgICAgICBiLCBcbiAgICAgICAgdmVjM192YXJfZ2VuKCAuLi5kZWZhdWx0VmFsdWVzICkgXG4gICAgICApXG5cbiAgICAgIC8vIGZvciBhc3NpZ25pbmcgZW50aXJlIG5ldyB2ZWN0b3JzIHRvIHByb3BlcnR5XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIG9wLCAnYW1vdW50Jywge1xuICAgICAgICBnZXQoKSB7IHJldHVybiBfX3ZhciB9LFxuICAgICAgICBzZXQodikge1xuICAgICAgICAgIGlmKCB0eXBlb2YgdiA9PT0gJ29iamVjdCcgKSB7XG4gICAgICAgICAgICBfX3Zhci5zZXQoIHYgKVxuICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgX192YXIudmFsdWUueCA9IHZcbiAgICAgICAgICAgIF9fdmFyLnZhbHVlLnkgPSB2XG4gICAgICAgICAgICBfX3Zhci52YWx1ZS56ID0gdlxuICAgICAgICAgICAgX192YXIudmFsdWUudyA9IHZcbiAgICAgICAgICAgIF9fdmFyLmRpcnR5ID0gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgb3AucGFyYW1zID0gW3sgbmFtZTonYW1vdW50JyB9XVxuICAgIH1lbHNle1xuICAgICAgb3AucGFyYW1zID0gW11cbiAgICAgIG9wLmVtaXRfZGVjbCA9IGZ1bmN0aW9uKCkge31cbiAgICAgIG9wLmVtaXQgPSBmdW5jdGlvbigpIHt9XG4gICAgICBvcC51cGRhdGVfZGF0YT0gZnVuY3Rpb24oKSB7fVxuICAgICAgb3AudXBsb2FkX2xvY2F0aW9uID0gZnVuY3Rpb24oKSB7fVxuICAgIH1cbiAgICBvcC5fX3NldE1hdGVyaWFsID0gZnVuY3Rpb24obWF0KSB7XG4gICAgICBpZiggdHlwZW9mIG1hdCA9PT0gJ3N0cmluZycgKSBtYXQgPSBNYXJjaGluZy5NYXRlcmlhbFsgbWF0IF1cbiAgICAgIHRoaXMuX19tYXRlcmlhbCA9IHRoaXMubWF0ID0gTWFyY2hpbmcubWF0ZXJpYWxzLmFkZE1hdGVyaWFsKCBtYXQgKVxuICAgICAgb3Auc2RmLm1hdGVyaWFsKCB0aGlzLl9fbWF0ZXJpYWwgKVxuICAgIH1cbiAgICBpZiggbmFtZSA9PT0gJ0Rpc3BsYWNlJyB8fCBuYW1lID09PSAnQnVtcCcgKSB7XG4gICAgICBsZXQgX192YXIyID0gIHBhcmFtX3dyYXAoIFxuICAgICAgICBjLCBcbiAgICAgICAgZmxvYXRfdmFyX2dlbiggLjAzICkgXG4gICAgICApXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIG9wLCAnc2l6ZScsIHtcbiAgICAgICAgZ2V0KCkgeyByZXR1cm4gX192YXIyIH0sXG4gICAgICAgIHNldCh2KSB7XG4gICAgICAgICAgX192YXIyLnNldCggdiApXG4gICAgICAgICAgX192YXIyLmRpcnR5ID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICBvcC5wYXJhbXMucHVzaCh7IG5hbWU6J3NpemUnIH0pXG4gICAgfVxuICAgIG9wLl9fZGVzYyA9IHsgcGFyYW1ldGVyczpvcC5wYXJhbXMgfVxuICAgIHJldHVybiBvcFxuICB9IFxuXG4gIERpc3RhbmNlT3BzWyBuYW1lIF0ucHJvdG90eXBlID0gU2NlbmVOb2RlKClcblxuICBEaXN0YW5jZU9wc1tuYW1lXS5wcm90b3R5cGUuZW1pdF9kZWNsID0gZnVuY3Rpb24gKCkge1xuICAgIGxldCBzdHIgPSAgdGhpcy5zZGYuZW1pdF9kZWNsKCkgKyAodGhpcy5uYW1lICE9PSAnQnVtcCcgPyB0aGlzLmFtb3VudC5lbWl0X2RlY2woKSA6ICcnKVxuICAgIHN0ciArPSB0aGlzLnRyYW5zZm9ybS5lbWl0X2RlY2woKVxuICAgIGlmKCB0aGlzLm5hbWUgPT09ICdEaXNwbGFjZScgfHwgdGhpcy5uYW1lID09PSAnQnVtcCcgKSBzdHIgKz0gdGhpcy5zaXplLmVtaXRfZGVjbCgpICBcblxuICAgIHJldHVybiBzdHJcbiAgfTtcblxuICBEaXN0YW5jZU9wc1tuYW1lXS5wcm90b3R5cGUudXBkYXRlX2xvY2F0aW9uID0gZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICB0aGlzLnNkZi51cGRhdGVfbG9jYXRpb24oIGdsLCBwcm9ncmFtIClcbiAgICBpZiggdGhpcy5uYW1lICE9PSAnQnVtcCcgKSB0aGlzLmFtb3VudC51cGRhdGVfbG9jYXRpb24oIGdsLCBwcm9ncmFtIClcbiAgICBpZiggdGhpcy5uYW1lID09PSAnRGlzcGxhY2UnIHx8IHRoaXMubmFtZSA9PT0gJ0J1bXAnKSB0aGlzLnNpemUudXBkYXRlX2xvY2F0aW9uKCBnbCwgcHJvZ3JhbSApIFxuICAgIHRoaXMudHJhbnNmb3JtLnVwZGF0ZV9sb2NhdGlvbiggZ2wsIHByb2dyYW0gKVxuICB9XG5cbiAgRGlzdGFuY2VPcHNbbmFtZV0ucHJvdG90eXBlLnVwbG9hZF9kYXRhID0gZnVuY3Rpb24oZ2wpIHtcbiAgICB0aGlzLnNkZi51cGxvYWRfZGF0YSggZ2wgKVxuICAgIGlmKCB0aGlzLm5hbWUgIT09ICdCdW1wJyApIHRoaXMuYW1vdW50LnVwbG9hZF9kYXRhKCBnbCApXG4gICAgaWYoIHRoaXMubmFtZSA9PT0gJ0Rpc3BsYWNlJyB8fCB0aGlzLm5hbWUgPT09ICdCdW1wJykgdGhpcy5zaXplLnVwbG9hZF9kYXRhKCBnbCApXG4gICAgdGhpcy50cmFuc2Zvcm0udXBsb2FkX2RhdGEoIGdsIClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERpc3RhbmNlT3BzXG5cbiIsImNvbnN0IFNjZW5lTm9kZSA9IHJlcXVpcmUoICcuL3NjZW5lTm9kZS5qcycgKVxuY29uc3QgeyBwYXJhbV93cmFwLCBNYXRlcmlhbElEIH0gPSByZXF1aXJlKCAnLi91dGlscy5qcycgKVxuY29uc3QgeyBWYXIsIGZsb2F0X3Zhcl9nZW4sIHZlYzJfdmFyX2dlbiwgdmVjM192YXJfZ2VuLCB2ZWM0X3Zhcl9nZW4sIGludF92YXJfZ2VuLCBWYXJBbGxvYyB9ID0gcmVxdWlyZSggJy4vdmFyLmpzJyApXG5jb25zdCBUcmFuc2Zvcm0gPSByZXF1aXJlKCAnLi90cmFuc2Zvcm0uanMnIClcbmNvbnN0IGdsc2xvcHMgPSByZXF1aXJlKCAnLi9kaXN0YW5jZU9wZXJhdGlvbnNHTFNMLmpzJyApXG5cbmNvbnN0IG9wc2xlbiA9IHsgXG4gIFVuaW9uOjIsXG4gIEludGVyc2VjdGlvbjoyLFxuICBEaWZmZXJlbmNlOjIsXG4gIFN0YWlyc1VuaW9uOjQsXG4gIFN0YWlyc0ludGVyc2VjdGlvbjo0LFxuICBTdGFpcnNEaWZmZXJlbmNlOjQsXG4gIFJvdW5kVW5pb246MyxcbiAgUm91bmREaWZmZXJlbmNlOjMsXG4gIFJvdW5kSW50ZXJzZWN0aW9uOjMsXG4gIENoYW1mZXJVbmlvbjozLFxuICBDaGFtZmVyRGlmZmVyZW5jZTozLFxuICBDaGFtZmVySW50ZXJzZWN0aW9uOjMsXG4gIFBpcGU6MyxcbiAgRW5ncmF2ZTozLFxuICBHcm9vdmU6NCxcbiAgVG9uZ3VlOjQsXG4gIFxuICAvLyB0aGVzZSB0d28gZG8gbm90IGN1cnJlbnRseSBoYXZlIHN1cHBvcnQgZm9yIHRyYW5zZm9ybXMgb3IgcmVwZWF0cy4uLlxuICBPbmlvbjoyLFxuICBTd2l0Y2g6MlxufVxuXG5jb25zdCBvcHMgPSB7IFxuICBVbmlvbiggLi4uYXJncyApIHsgcmV0dXJuIGBvcFUoICR7YXJncy5qb2luKCcsJyl9IClgIH0sXG4gIFNtb290aFVuaW9uKCAuLi5hcmdzICApIHsgcmV0dXJuIGBvcFNtb290aFVuaW9uKCAke2FyZ3Muam9pbignLCcpfSApYCB9LFxuICBJbnRlcnNlY3Rpb24oIC4uLmFyZ3MgKSB7IHJldHVybiBgb3BJKCAke2FyZ3Muam9pbignLCcpfSApYCB9LFxuICBTbW9vdGhJbnRlcnNlY3Rpb24oIC4uLmFyZ3MgKSB7IHJldHVybiBgb3BTbW9vdGhJbnRlcnNlY3Rpb24oICR7YXJncy5qb2luKCcsJyl9IClgIH0sICBcbiAgRGlmZmVyZW5jZSggLi4uYXJncyApIHsgcmV0dXJuIGBvcFMoICR7YXJncy5qb2luKCcsJyl9IClgIH0sICBcbiAgU21vb3RoRGlmZmVyZW5jZSggLi4uYXJncyApIHsgcmV0dXJuIGBvcFNtb290aFN1YnRyYWN0aW9uKCAke2FyZ3Muam9pbignLCcpfSApYCB9LCAgXG4gIFN0YWlyc1VuaW9uKCAgLi4uYXJncyApIHsgcmV0dXJuIGBmT3BVbmlvblN0YWlycyggJHthcmdzLmpvaW4oJywnKX0gKWAgIH0sXG4gIFN0YWlyc0ludGVyc2VjdGlvbiggLi4uYXJncyApIHsgcmV0dXJuIGBmT3BJbnRlcnNlY3Rpb25TdGFpcnMoICR7YXJncy5qb2luKCcsJyl9IClgIH0sXG4gIFN0YWlyc0RpZmZlcmVuY2UoIC4uLmFyZ3MgKSB7IHJldHVybiBgZk9wU3Vic3RyYWN0aW9uU3RhaXJzKCAke2FyZ3Muam9pbignLCcpfSApYCB9LFxuICBSb3VuZFVuaW9uKCAuLi5hcmdzICkgeyByZXR1cm4gYGZPcFVuaW9uUm91bmQoICR7YXJncy5qb2luKCcsJyl9IClgIH0sXG4gIFJvdW5kRGlmZmVyZW5jZSggLi4uYXJncyApIHsgcmV0dXJuIGBmT3BEaWZmZXJlbmNlUm91bmQoICR7YXJncy5qb2luKCcsJyl9IClgIH0sXG4gIFJvdW5kSW50ZXJzZWN0aW9uKCAuLi5hcmdzICkgeyByZXR1cm4gYGZPcEludGVyc2VjdGlvblJvdW5kKCAke2FyZ3Muam9pbignLCcpfSApYCB9LFxuICBDaGFtZmVyVW5pb24oIC4uLmFyZ3MgKSB7IHJldHVybiBgZk9wVW5pb25DaGFtZmVyKCAke2FyZ3Muam9pbignLCcpfSApYCB9LFxuICBDaGFtZmVyRGlmZmVyZW5jZSggLi4uYXJncyApIHsgcmV0dXJuIGBmT3BEaWZmZXJlbmNlQ2hhbWZlciggJHthcmdzLmpvaW4oJywnKX0gKWAgfSxcbiAgQ2hhbWZlckludGVyc2VjdGlvbiggLi4uYXJncyApIHsgcmV0dXJuIGBmT3BJbnRlcnNlY3Rpb25DaGFtZmVyKCAke2FyZ3Muam9pbignLCcpfSApYCB9LFxuICBQaXBlKCAuLi5hcmdzICkgeyByZXR1cm4gYGZPcFBpcGUoICR7YXJncy5qb2luKCcsJyl9IClgIH0sXG4gIEVuZ3JhdmUoIC4uLmFyZ3MgKSB7IHJldHVybiBgZk9wRW5ncmF2ZSggJHthcmdzLmpvaW4oJywnKX0gKWAgfSxcbiAgR3Jvb3ZlKCAuLi5hcmdzICkgeyByZXR1cm4gYGZPcEdyb292ZSggJHthcmdzLmpvaW4oJywnKX0gKWAgfSxcbiAgVG9uZ3VlKCAuLi5hcmdzICkgeyByZXR1cm4gYGZPcFRvbmd1ZSggJHthcmdzLmpvaW4oJywnKX0gKWAgfSxcbiAgXG4gIC8vIHRoZXNlIHR3byBkbyBub3QgY3VycmVudGx5IGhhdmUgc3VwcG9ydCBmb3IgdHJhbnNmb3JtcyBvciByZXBlYXRzLi4uXG4gIE9uaW9uKCBhLGIgKSB7IHJldHVybiBgb3BPbmlvbiggJHthfSwgJHtifSApYCB9LFxuICBTd2l0Y2goIGEsYixjLGQsZSxmICkgeyByZXR1cm4gYG9wU3dpdGNoKCAke2F9LCAke2J9LCAke2N9IClgIH1cbn1cblxuY29uc3QgZW1pdF9mbG9hdCA9IGZ1bmN0aW9uKCBhICkge1xuXHRpZiAoYSAlIDEgPT09IDApXG5cdFx0cmV0dXJuIGEudG9GaXhlZCggMSApXG5cdGVsc2Vcblx0XHRyZXR1cm4gYVxufVxuXG5jb25zdCBEaXN0YW5jZU9wcyA9IHtcbiAgX19nbHNsOltdLFxuICBfX2dldEdMU0woKSB7XG4gICAgcmV0dXJuIHRoaXMuX19nbHNsLmpvaW4oJ1xcbicpXG4gIH0sXG4gIF9fY2xlYXIoKSB7IHRoaXMuX19nbHNsLmxlbmd0aCA9IDAgfVxufVxuXG5cbmZvciggbGV0IG5hbWUgaW4gb3BzICkge1xuXG4gIC8vIGdldCBjb2RlZ2VuIGZ1bmN0aW9uXG4gIGxldCBvcCA9IG9wc1sgbmFtZSBdXG4gIGNvbnN0IG5hbWUyID0gbmFtZSArICcyJ1xuXG4gIC8vIGNyZWF0ZSBjb25zdHJ1Y3RvclxuICBEaXN0YW5jZU9wc1sgbmFtZSBdID0gZnVuY3Rpb24oIGEsYixjLGQgKSB7XG4gICAgY29uc3Qgb3AgPSBPYmplY3QuY3JlYXRlKCBEaXN0YW5jZU9wc1sgbmFtZSBdLnByb3RvdHlwZSApXG4gICAgb3AuYSA9IGFcbiAgICBvcC5iID0gYlxuICAgIG9wLnRyYW5zZm9ybSA9IFRyYW5zZm9ybSggZmFsc2UgKVxuICAgIG9wLmlkID0gVmFyQWxsb2MuYWxsb2MoKVxuICAgIG9wLnR5cGUgPSAnZGlzdGFuY2Vfb3AnXG4gICAgb3AubmFtZSA9IG5hbWVcblxuICAgIGxldCBfX2MgPSBwYXJhbV93cmFwKCBjLCBmbG9hdF92YXJfZ2VuKC4zKSApXG5cbiAgICBvcC5fX2xlbiA9IG9wc2xlblsgbmFtZSBdXG4gICAgaWYoIG9wLl9fbGVuID4gMiApIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb3AsICdjJywge1xuICAgICAgICBnZXQoKSB7IHJldHVybiBfX2MgfSxcbiAgICAgICAgc2V0KHYpIHtcbiAgICAgICAgICBfX2Muc2V0KCB2IClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIFxuICAgICAgaWYoIG9wLl9fbGVuID4gMyApIHtcbiAgICAgICAgbGV0IF9fZCA9IHBhcmFtX3dyYXAoIGQsIGZsb2F0X3Zhcl9nZW4oNCkgKVxuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb3AsICdkJywge1xuICAgICAgICAgIGdldCgpIHsgcmV0dXJuIF9fZCB9LFxuICAgICAgICAgIHNldCh2KSB7XG4gICAgICAgICAgICBfX2Quc2V0KCB2IClcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgb3AuX19zZXRUZXh0dXJlID0gZnVuY3Rpb24odGV4LHByb3BzKSB7XG4gICAgICBpZiggdHlwZW9mIHRleCA9PT0gJ3N0cmluZycgKSB7XG4gICAgICAgIHRoaXMudGV4dHVyZSA9IG9wLnRleHR1cmUuYmluZCggdGhpcyApXG4gICAgICAgIHRoaXMuX190ZXh0dXJlT2JqID0gdGhpcy50ZXggPSBNYXJjaGluZy5UZXh0dXJlKCB0ZXgscHJvcHMsdGhpcy50ZXh0dXJlIClcbiAgICAgICAgdGhpcy5fX3RleHR1cmVJRCA9IHRoaXMuX190ZXh0dXJlT2JqLmlkXG4gICAgICB9ZWxzZXtcbiAgICAgICAgdGhpcy5fX3RleHR1cmVPYmogPSB0aGlzLnRleCA9IE9iamVjdC5hc3NpZ24oIHRleCwgcHJvcHMgKVxuICAgICAgICB0aGlzLl9fdGV4dHVyZUlEID0gdGhpcy5fX3RleHR1cmVPYmouaWRcbiAgICAgIH1cbiAgICB9XG4gICAgb3AuX19zZXRNYXRlcmlhbCA9IGZ1bmN0aW9uKG1hdCkge1xuICAgICAgaWYoIHR5cGVvZiBtYXQgPT09ICdzdHJpbmcnICkgbWF0ID0gTWFyY2hpbmcuTWF0ZXJpYWxbIG1hdCBdXG4gICAgICB0aGlzLl9fbWF0ZXJpYWwgPSB0aGlzLm1hdCA9IE1hcmNoaW5nLm1hdGVyaWFscy5hZGRNYXRlcmlhbCggbWF0IClcbiAgICB9XG4gICAgb3AuX19zZXRCdW1wID0gZnVuY3Rpb24odGV4LHByb3BzKSB7XG4gICAgICAvL3RoaXMuYnVtcCA9IHAuYnVtcC5iaW5kKCB0aGlzIClcbiAgICAgIGNvbnN0IGIgPSB0aGlzLmJ1bXAgPSB0aGlzLl9fYnVtcE9iaiA9IE1hcmNoaW5nLkJ1bXAoIHRoaXMsIHRleCwgcHJvcHMgKVxuICAgICAgdGhpcy5idW1wLnRleHR1cmUgPSB0aGlzLmJ1bXAuYW1vdW50LnZhbHVlXG4gICAgICB0aGlzLl9fYnVtcElEID0gdGhpcy5fX2J1bXBPYmouaWRcbiAgICAgIHRoaXMucm90YXRlID0gdGhpcy5idW1wLnJvdGF0ZVxuICAgICAgdGhpcy50cmFuc2xhdGUgPSB0aGlzLmJ1bXAudHJhbnNsYXRlXG4gICAgICB0aGlzLnNjYWxlID0gdGhpcy5idW1wLnNjYWxlXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMuYnVtcCwgJ3N0cmVuZ3RoJywge1xuICAgICAgICBnZXQoKSB7IHJldHVybiBiLnNpemUgfSxcbiAgICAgICAgc2V0KHYpeyBiLnNpemUgPSB2IH1cbiAgICAgIH0pXG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24oIG9wLCB7XG4gICAgICByZW5kZXJpbmdCdW1wIDogZmFsc2UsXG4gICAgICBlbWl0dGluZ0RlY2wgIDogZmFsc2UsXG4gICAgICB1cGxvYWRpbmcgICAgIDogZmFsc2UsXG4gICAgICB1cGRhdGluZyAgICAgIDogZmFsc2VcbiAgICB9KVxuXG4gICAgbGV0IHJlcGVhdCA9IG51bGxcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIG9wLCAncmVwZWF0Jywge1xuICAgICAgZ2V0KCkgeyByZXR1cm4gcmVwZWF0IH0sXG4gICAgICBzZXQodil7IFxuICAgICAgICByZXBlYXQgPSB2XG4gICAgICAgIHRoaXMuYS5yZXBlYXQgPSB2XG4gICAgICAgIHRoaXMuYi5yZXBlYXQgPSB2XG4gICAgICB9XG4gICAgfSlcblxuICAgIG9wLm1hdElkID0gTWF0ZXJpYWxJRC5hbGxvYygpXG5cbiAgICBvcC5wYXJhbXMgPSBbe25hbWU6J2MnfSx7IG5hbWU6J2QnfV1cbiAgICBvcC5fX2Rlc2MgPSB7IHBhcmFtZXRlcnM6IG9wLnBhcmFtcyB9XG5cbiAgICByZXR1cm4gb3BcbiAgfSBcbiAgXG4gIERpc3RhbmNlT3BzWyBuYW1lMiBdID0gZnVuY3Rpb24oIC4uLmFyZ3MgKSB7XG4gICAgLy8gYWNjZXB0cyB1bmxpbWl0ZWQgYXJndW1lbnRzLCBidXQgdGhlIGxhc3Qgb25lIGNvdWxkIGJlIGEgYmxlbmRpbmcgY29lZmZpY2llbnRcbiAgICBsZXQgYmxlbmQgPSAuMjUsIGNvZWZmPTQsIHVcblxuICAgIGlmKCB0eXBlb2YgYXJnc1sgYXJncy5sZW5ndGggLSAxIF0gPT09ICdudW1iZXInICkge1xuICAgICAgYmxlbmQgPSBhcmdzLnBvcCgpXG5cbiAgICAgIC8vIGlmIHRoZXJlIGFyZSB0d28gbm9uLXNkZiBhcmd1bWVudHMgdG8gdGhlIGZ1bmN0aW9uLi4uXG4gICAgICBpZiggdHlwZW9mIGFyZ3NbIGFyZ3MubGVuZ3RoIC0gMSBdID09PSAnbnVtYmVyJyApIHtcbiAgICAgICAgY29lZmYgPSBibGVuZFxuICAgICAgICBibGVuZCA9IGFyZ3MucG9wKClcbiAgICAgIH1cblxuICAgICAgdSA9IGFyZ3MucmVkdWNlKCAoc3RhdGUsbmV4dCkgPT4gRGlzdGFuY2VPcHNbIG5hbWUgXSggc3RhdGUsIG5leHQsIGJsZW5kLCBjb2VmZiApIClcbiAgICB9ZWxzZXtcbiAgICAgIHUgPSBhcmdzLnJlZHVjZSggKHN0YXRlLG5leHQpID0+IERpc3RhbmNlT3BzWyBuYW1lIF0oIHN0YXRlLCBuZXh0ICkgKVxuICAgIH1cblxuICAgIHJldHVybiB1XG4gIH1cblxuICBEaXN0YW5jZU9wc1sgbmFtZSBdLnByb3RvdHlwZSA9IFNjZW5lTm9kZSgpXG5cbiAgRGlzdGFuY2VPcHNbIG5hbWUgXS5wcm90b3R5cGUudGV4dHVyZSA9IGZ1bmN0aW9uKCAuLi5hcmdzICkge1xuICAgIHRoaXMuX19zZXRUZXh0dXJlKCAuLi5hcmdzIClcbiAgICB0aGlzLmEudGV4dHVyZSggdGhpcy5fX3RleHR1cmVPYmogKVxuICAgIHRoaXMuYi50ZXh0dXJlKCB0aGlzLl9fdGV4dHVyZU9iaiApXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG4gIERpc3RhbmNlT3BzWyBuYW1lIF0ucHJvdG90eXBlLm1hdGVyaWFsID0gZnVuY3Rpb24oIC4uLmFyZ3MgKSB7XG4gICAgdGhpcy5fX3NldE1hdGVyaWFsKCAuLi5hcmdzIClcbiAgICB0aGlzLmEubWF0ZXJpYWwoIHRoaXMuX19tYXRlcmlhbCApXG4gICAgdGhpcy5iLm1hdGVyaWFsKCB0aGlzLl9fbWF0ZXJpYWwgKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGNvbnN0IHB1c2hTdHJpbmcgPSBmdW5jdGlvbiggbmFtZSApIHtcbiAgICBjb25zdCBnbHNsb2JqID0gZ2xzbG9wc1sgbmFtZSBdXG4gICAgXG4gICAgLy8gc29tZSBkZWZpbml0aW9ucyBhcmUgYSBzaW5nbGUgc3RyaW5nLCBhbmQgbm90IHNwbGl0IGludG9cbiAgICAvLyBzZXBhcmF0ZSBmbG9hdCBhbmQgb3BPdXQgZnVuY3Rpb25zXG4gICAgaWYoIHR5cGVvZiBnbHNsb2JqID09PSAnc3RyaW5nJyApIHtcbiAgICAgIGlmKCBEaXN0YW5jZU9wcy5fX2dsc2wuaW5kZXhPZiggZ2xzbG9iaiApID09PSAtMSApIHtcbiAgICAgICAgRGlzdGFuY2VPcHMuX19nbHNsLnB1c2goIGdsc2xvYmogKVxuICAgICAgfVxuICAgIH1lbHNle1xuICAgICAgLy8gc29tZSBkaXN0YW5jZSBvcGVyYXRpb25zIGFyZSBkZXBlbmRlbnQgb24gb3RoZXIgb25lcy4uLlxuICAgICAgLy8gaWYgdGhpcyBvbmUgaGFzIGRlcGVuZGVuY2llcyBhZGQgdGhlbS5cbiAgICAgIC8vIGRlcGVuZGVuY2llcyBtdXN0IGJlIGFkZGVkIGJlZm9yZSBhZGRpbmcgb3RoZXIgZnVuY3Rpb25zXG4gICAgICAvLyBzbyB0aGF0IHRoZXkncmUgYWJvdmUgdGhlbSBpbiB0aGUgZmluYWwgR0xTTCBjb2RlLlxuICAgICAgaWYoIGdsc2xvYmouZGVwZW5kZW5jaWVzICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgIGZvciggbGV0IGRuYW1lIG9mIGdsc2xvYmouZGVwZW5kZW5jaWVzICkge1xuICAgICAgICAgIGNvbnN0IGQgPSBnbHNsb3BzWyBkbmFtZSBdXG4gICAgICAgICAgaWYoIERpc3RhbmNlT3BzLl9fZ2xzbC5pbmRleE9mKCBkLmZsb2F0ICkgPT09IC0xICkge1xuICAgICAgICAgICAgRGlzdGFuY2VPcHMuX19nbHNsLnB1c2goIGQuZmxvYXQgKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAgXG4gICAgICBpZiggRGlzdGFuY2VPcHMuX19nbHNsLmluZGV4T2YoIGdsc2xvYmouZmxvYXQgKSA9PT0gLTEgKSB7XG4gICAgICAgIERpc3RhbmNlT3BzLl9fZ2xzbC5wdXNoKCBnbHNsb2JqLmZsb2F0IClcbiAgICAgIH1cbiAgICAgIGlmKCBEaXN0YW5jZU9wcy5fX2dsc2wuaW5kZXhPZiggZ2xzbG9iai52ZWMyKSA9PT0gLTEgKSB7XG4gICAgICAgIERpc3RhbmNlT3BzLl9fZ2xzbC5wdXNoKCBnbHNsb2JqLnZlYzIgKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIERpc3RhbmNlT3BzWyBuYW1lIF0ucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAoIHBuYW1lPSdwJywgdHJhbnNmb3JtID0gbnVsbCApe1xuICAgIGlmKCB0aGlzLl9fYnVtcE9iaiAhPT0gdW5kZWZpbmVkICYmIHRoaXMucmVuZGVyaW5nQnVtcCA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMucmVuZGVyaW5nQnVtcCA9IHRydWVcbiAgICAgIHJldHVybiB0aGlzLl9fYnVtcE9iai5lbWl0KCBwbmFtZSwgdHJhbnNmb3JtIClcbiAgICB9XG4gICAgcHVzaFN0cmluZyggbmFtZSApXG5cbiAgICBpZiggdHJhbnNmb3JtICE9PSBudWxsICkgdGhpcy50cmFuc2Zvcm0uYXBwbHkoIHRyYW5zZm9ybSwgZmFsc2UgKVxuICAgIC8vdGhpcy50cmFuc2Zvcm0uaW50ZXJuYWwoKVxuXG4gICAgLy8gZmlyc3QgdHdvIGFyZ3MgYXJlIGZpeGVkLCByZXN0IGFyZSB2YXJpYWJsZVxuICAgIGxldCBlbWl0dGVycyA9IFtdXG4gICAgY29uc3QgYSA9IHRoaXMuYS5lbWl0KCBwbmFtZSwgdGhpcy50cmFuc2Zvcm0gKSwgXG4gICAgICAgICAgYiA9IHRoaXMuYi5lbWl0KCBwbmFtZSwgdGhpcy50cmFuc2Zvcm0gKSBcblxuICAgIGVtaXR0ZXJzWzBdID0gYS5vdXRcbiAgICBlbWl0dGVyc1sxXSA9IGIub3V0XG4gICAgaWYoIHRoaXMuX19sZW4gPiAyICkgZW1pdHRlcnMucHVzaCggdGhpcy5jLmVtaXQoKSApXG4gICAgaWYoIHRoaXMuX19sZW4gPiAzICkgZW1pdHRlcnMucHVzaCggdGhpcy5kLmVtaXQoKSApXG4gICAgXG4gICAgY29uc3QgYm9keSA9IGBcbiAgICAgICAgdmVjMiBkbyR7dGhpcy5pZH0gPSAke29wKCAuLi5lbWl0dGVycyApfTtcbiAgICAgICAgZG8ke3RoaXMuaWR9LnggKj0gJHt0aGlzLnRyYW5zZm9ybS5lbWl0KCl9X3NjYWxlO1xuICAgIGBcblxuICAgIGNvbnN0IG91dHB1dCA9IHtcbiAgICAgIG91dDogJ2RvJyt0aGlzLmlkLFxuICAgICAgcHJlZmFjZTogKGEucHJlZmFjZSB8fCAnJykgKyAoYi5wcmVmYWNlIHx8ICcnKSArIGJvZHlcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlcmluZ0J1bXAgPSBmYWxzZVxuICAgIHJldHVybiBvdXRwdXRcbiAgfVxuXG4gIERpc3RhbmNlT3BzW25hbWVdLnByb3RvdHlwZS5lbWl0X2RlY2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYoIHRoaXMuX19idW1wT2JqICE9PSB1bmRlZmluZWQgJiYgdGhpcy5lbWl0dGluZ0RlY2wgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmVtaXR0aW5nRGVjbCA9IHRydWVcbiAgICAgIHJldHVybiB0aGlzLl9fYnVtcE9iai5lbWl0X2RlY2woKSBcbiAgICB9XG4gICAgbGV0IHN0ciA9ICB0aGlzLnRyYW5zZm9ybS5lbWl0X2RlY2woKSArIHRoaXMuYS5lbWl0X2RlY2woKSArIHRoaXMuYi5lbWl0X2RlY2woKVxuICAgIGlmKCB0aGlzLmMgIT09IHVuZGVmaW5lZCApIHN0ciArPSB0aGlzLmMuZW1pdF9kZWNsKClcbiAgICBpZiggdGhpcy5kICE9PSB1bmRlZmluZWQgKSBzdHIgKz0gdGhpcy5kLmVtaXRfZGVjbCgpXG5cbiAgICBpZiggb3BzWyBuYW1lIF0uY29kZSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgLy9zdHIgKz0gb3BzWyBuYW1lIF0uY29kZVxuICAgICAgaWYoIE1hcmNoaW5nLnJlcXVpcmVkT3BzLmluZGV4T2YoIG9wc1sgbmFtZSBdLmNvZGUgKSA9PT0gLSAxICkge1xuICAgICAgICBNYXJjaGluZy5yZXF1aXJlZE9wcy5wdXNoKCBvcHNbIG5hbWUgXS5jb2RlIClcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmVtaXR0aW5nRGVjbCA9IGZhbHNlXG4gICAgcmV0dXJuIHN0clxuICB9O1xuXG4gIERpc3RhbmNlT3BzW25hbWVdLnByb3RvdHlwZS51cGRhdGVfbG9jYXRpb24gPSBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgIGlmKCB0aGlzLl9fYnVtcE9iaiAhPT0gdW5kZWZpbmVkICYmIHRoaXMudXBkYXRpbmcgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLnVwZGF0aW5nID0gdHJ1ZVxuICAgICAgcmV0dXJuIHRoaXMuX19idW1wT2JqLnVwZGF0ZV9sb2NhdGlvbiggZ2wsIHByb2dyYW0gKVxuICAgIH1cbiAgICB0aGlzLmEudXBkYXRlX2xvY2F0aW9uKCBnbCwgcHJvZ3JhbSApXG4gICAgdGhpcy50cmFuc2Zvcm0udXBkYXRlX2xvY2F0aW9uKCBnbCwgcHJvZ3JhbSApXG4gICAgdGhpcy5iLnVwZGF0ZV9sb2NhdGlvbiggZ2wsIHByb2dyYW0gKVxuICAgIGlmKCB0aGlzLmMgIT09IHVuZGVmaW5lZCApIHRoaXMuYy51cGRhdGVfbG9jYXRpb24oIGdsLCBwcm9ncmFtIClcbiAgICBpZiggdGhpcy5kICE9PSB1bmRlZmluZWQgKSB0aGlzLmQudXBkYXRlX2xvY2F0aW9uKCBnbCwgcHJvZ3JhbSApXG5cbiAgICB0aGlzLnVwZGF0aW5nID0gZmFsc2VcbiAgfVxuXG4gIERpc3RhbmNlT3BzW25hbWVdLnByb3RvdHlwZS51cGxvYWRfZGF0YSA9IGZ1bmN0aW9uKGdsKSB7XG4gICAgaWYoIHRoaXMuX19idW1wT2JqICE9PSB1bmRlZmluZWQgJiYgdGhpcy51cGxvYWRpbmcgID09PSBmYWxzZSApIHtcbiAgICAgIHRoaXMudXBsb2FkaW5nID0gdHJ1ZVxuICAgICAgcmV0dXJuIHRoaXMuX19idW1wT2JqLnVwbG9hZF9kYXRhKCBnbCApXG4gICAgfVxuICAgIHRoaXMudHJhbnNmb3JtLmludGVybmFsKClcbiAgICB0aGlzLnRyYW5zZm9ybS51cGxvYWRfZGF0YSggZ2wgKVxuICAgIHRoaXMuYS50cmFuc2Zvcm0uYXBwbHkoIHRoaXMudHJhbnNmb3JtIClcbiAgICB0aGlzLmIudHJhbnNmb3JtLmFwcGx5KCB0aGlzLnRyYW5zZm9ybSApXG4gICAgdGhpcy5hLnVwbG9hZF9kYXRhKCBnbCApXG4gICAgdGhpcy5iLnVwbG9hZF9kYXRhKCBnbCApXG4gICAgaWYoIHRoaXMuYyAhPT0gdW5kZWZpbmVkICkgdGhpcy5jLnVwbG9hZF9kYXRhKCBnbCApXG4gICAgaWYoIHRoaXMuZCAhPT0gdW5kZWZpbmVkICkgdGhpcy5kLnVwbG9hZF9kYXRhKCBnbCApXG4gICAgdGhpcy51cGxvYWRpbmcgPSBmYWxzZVxuICAgIFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRGlzdGFuY2VPcHNcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBVbmlvbjp7XG4gICAgZmxvYXQ6YFxuICAgICAgZmxvYXQgb3BVKCBmbG9hdCBkMSwgZmxvYXQgZDIgKSB7XG4gICAgICAgIHJldHVybiBtaW4oZDEsZDIpO1xuICAgICAgfVxuICAgICAgYCxcbiAgICB2ZWMyOmBcbiAgICAgIHZlYzIgb3BVKCB2ZWMyIGQxLCB2ZWMyIGQyICkge1xuICAgICAgICB2ZWMyIG87XG5cbiAgICAgICAgaWYoIGQxLnggPCBkMi54ICkge1xuICAgICAgICAgIG8gPSBkMTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgbyA9IGQyOyBcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfVxuICAgICAgYFxuICB9LFxuICBJbnRlcnNlY3Rpb246e1xuICAgIGZsb2F0OmBcbiAgICAgIGZsb2F0IG9wSSggZmxvYXQgZDEsIGZsb2F0IGQyICkge1xuICAgICAgICByZXR1cm4gbWF4KGQxLGQyKTtcbiAgICAgIH1cbiAgICAgIGAsXG4gICAgdmVjMjpgXG4gICAgICB2ZWMyIG9wSSggdmVjMiBkMSwgdmVjMiBkMiAgKSB7XG4gICAgICAgIHZlYzIgbztcblxuICAgICAgICBpZiggZDEueCA+IGQyLnggKSB7XG4gICAgICAgICAgbyA9IGQxOyBcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgbyA9IGQyOyBcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfVxuICAgICAgYFxuICB9LFxuXG4gIERpZmZlcmVuY2U6e1xuICAgIGZsb2F0OmBcbiAgICAgIGZsb2F0IG9wUyggZmxvYXQgZDEsIGZsb2F0IGQyICkgeyByZXR1cm4gbWF4KGQxLC1kMik7IH1cbiAgICAgIGAsXG4gICAgdmVjMjpgXG4gICAgICB2ZWMyIG9wUyggdmVjMiBkMSwgdmVjMiBkMiAgKSB7XG4gICAgICAgIHZlYzIgbztcblxuICAgICAgICBpZiggZDEueCA+PSAtZDIueCApIHtcbiAgICAgICAgICBvID0gZDE7IFxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICBkMi54ICo9IC0xLjtcbiAgICAgICAgICBvID0gZDI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbztcbiAgICAgIH1cbiAgICAgIGBcbiAgfSxcblxuICBTdGFpcnNVbmlvbjp7XG4gICAgZmxvYXQ6YFxuICAgICAgZmxvYXQgZk9wVW5pb25TdGFpcnMoZmxvYXQgYSwgZmxvYXQgYiwgZmxvYXQgciwgZmxvYXQgbikge1xuICAgICAgICBmbG9hdCBzID0gci9uO1xuICAgICAgICBmbG9hdCB1ID0gYi1yO1xuICAgICAgICByZXR1cm4gbWluKG1pbihhLGIpLCAwLjUgKiAodSArIGEgKyBhYnMgKChtb2QgKHUgLSBhICsgcywgMi4gKiBzKSkgLSBzKSkpO1xuICAgICAgfWAsXG4gICAgdmVjMjpgXG4gICAgICB2ZWMyIGZPcFVuaW9uU3RhaXJzKCB2ZWMyIGQxLCB2ZWMyIGQyLCBmbG9hdCByLCBmbG9hdCBuICApIHtcbiAgICAgICAgdmVjMiBvID0gdmVjMiggMC4sIGQxLnkgKTsgXG5cbiAgICAgICAgaWYoIGQxLnggPD0gZDIueCApIHtcbiAgICAgICAgICBvLnkgPSBkMS55OyBcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgby55ID0gZDIueTsgXG4gICAgICAgIH1cblxuICAgICAgICBvLnggPSBmT3BVbmlvblN0YWlycyggZDEueCwgZDIueCwgciwgbiApO1xuXG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfVxuICAgICAgYFxuICB9LFxuICBTdGFpcnNJbnRlcnNlY3Rpb246e1xuICAgIGRlcGVuZGVuY2llczogWydTdGFpcnNVbmlvbiddLFxuICAgIGZsb2F0OmBcbiAgICAgIC8vIFdlIGNhbiBqdXN0IGNhbGwgVW5pb24gc2luY2Ugc3RhaXJzIGFyZSBzeW1tZXRyaWMuXG4gICAgICBmbG9hdCBmT3BJbnRlcnNlY3Rpb25TdGFpcnMoZmxvYXQgYSwgZmxvYXQgYiwgZmxvYXQgciwgZmxvYXQgbikge1xuICAgICAgICByZXR1cm4gLWZPcFVuaW9uU3RhaXJzKC1hLCAtYiwgciwgbik7XG4gICAgICB9XG4gICAgICBgLFxuICAgIHZlYzI6YFxuICAgICAgdmVjMiBmT3BJbnRlcnNlY3Rpb25TdGFpcnMoIHZlYzIgZDEsIHZlYzIgZDIsIGZsb2F0IHIsIGZsb2F0IG4gICkge1xuICAgICAgICB2ZWMyIG8gPSB2ZWMyKCAwLiwgZDEueSApOyBcbiAgICAgICAgby54ID0gLWZPcFVuaW9uU3RhaXJzKCAtZDEueCwgLWQyLngsIHIsIG4gKTtcblxuICAgICAgICBpZiggLWQxLnggPD0gLWQyLnggKSB7XG4gICAgICAgICAgby55ID0gZDEueTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgby55ID0gZDIueTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfVxuICAgICAgYFxuICB9LFxuICBTdGFpcnNEaWZmZXJlbmNlOntcbiAgICBkZXBlbmRlbmNpZXM6IFsnU3RhaXJzVW5pb24nXSxcbiAgICBmbG9hdDpgXG4gICAgICBmbG9hdCBmT3BTdWJzdHJhY3Rpb25TdGFpcnMoZmxvYXQgYSwgZmxvYXQgYiwgZmxvYXQgciwgZmxvYXQgbikge1xuICAgICAgICByZXR1cm4gLWZPcFVuaW9uU3RhaXJzKC1hLCBiLCByLCBuKTtcbiAgICAgIH1gLFxuICAgIHZlYzI6YFxuICAgICAgdmVjMiBmT3BTdWJzdHJhY3Rpb25TdGFpcnMoIHZlYzIgZDEsIHZlYzIgZDIsIGZsb2F0IHIsIGZsb2F0IG4gICkge1xuICAgICAgICB2ZWMyIG8gPSB2ZWMyKCAwLiwgZDEueSApOyBcbiAgICAgICAgby54ID0gLWZPcFVuaW9uU3RhaXJzKCAtZDEueCwgZDIueCwgciwgbiApO1xuXG4gICAgICAgIGlmKCAtZDEueCA8PSBkMi54ICkge1xuICAgICAgICAgIG8ueSA9IGQxLnk7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIG8ueSA9IGQyLnk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbztcbiAgICAgIH1cbiAgICAgIGBcbiAgfSxcblxuICBSb3VuZFVuaW9uOntcbiAgICBmbG9hdDpgXG4gICAgICBmbG9hdCBmT3BVbmlvblJvdW5kKGZsb2F0IGEsIGZsb2F0IGIsIGZsb2F0IHIpIHtcbiAgICAgICAgdmVjMiB1ID0gbWF4KHZlYzIociAtIGEsciAtIGIpLCB2ZWMyKDApKTtcbiAgICAgICAgcmV0dXJuIG1heChyLCBtaW4gKGEsIGIpKSAtIGxlbmd0aCh1KTtcbiAgICAgIH1gLFxuXG4gICAgdmVjMjpgXG4gICAgICB2ZWMyIGZPcFVuaW9uUm91bmQoIHZlYzIgZDEsIHZlYzIgZDIsIGZsb2F0IHIgICkge1xuICAgICAgICB2ZWMyIG8gPSB2ZWMyKCAwLiwgZDEueSApOyBcbiAgICAgICAgby54ID0gZk9wVW5pb25Sb3VuZCggZDEueCwgZDIueCwgciApO1xuXG4gICAgICAgIGlmKCBkMS54IDw9IGQyLnggKSB7XG4gICAgICAgICAgby55ID0gZDEueTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgby55ID0gZDIueTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfVxuICAgICAgYFxuICB9LFxuICBSb3VuZEludGVyc2VjdGlvbjp7XG4gICAgZmxvYXQ6YFxuICAgICAgZmxvYXQgZk9wSW50ZXJzZWN0aW9uUm91bmQoZmxvYXQgYSwgZmxvYXQgYiwgZmxvYXQgcikge1xuICAgICAgICB2ZWMyIHUgPSBtYXgodmVjMihyICsgYSxyICsgYiksIHZlYzIoMCkpO1xuICAgICAgICByZXR1cm4gbWluKC1yLCBtYXggKGEsIGIpKSArIGxlbmd0aCh1KTtcbiAgICAgIH1gLFxuICAgIHZlYzI6YFxuICAgICAgdmVjMiBmT3BJbnRlcnNlY3Rpb25Sb3VuZCggdmVjMiBkMSwgdmVjMiBkMiwgZmxvYXQgciAgKSB7XG4gICAgICAgIHZlYzIgbyA9IHZlYzIoIDAuLCBkMS55ICk7IFxuICAgICAgICBvLnggPSBmT3BJbnRlcnNlY3Rpb25Sb3VuZCggZDEueCwgZDIueCwgciApO1xuXG4gICAgICAgIGlmKCBkMS54ID49IGQyLnggKSB7XG4gICAgICAgICAgby55ID0gZDEueTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgby55ID0gZDIueTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfVxuICAgICAgYFxuICB9LFxuXG4gIFJvdW5kRGlmZmVyZW5jZTp7XG4gICAgZGVwZW5kZW5jaWVzOiBbJ1JvdW5kSW50ZXJzZWN0aW9uJ10sXG4gICAgZmxvYXQ6YFxuICAgICAgZmxvYXQgZk9wRGlmZmVyZW5jZVJvdW5kIChmbG9hdCBhLCBmbG9hdCBiLCBmbG9hdCByKSB7XG4gICAgICAgIHJldHVybiBmT3BJbnRlcnNlY3Rpb25Sb3VuZChhLCAtYiwgcik7XG4gICAgICB9YCxcbiAgICB2ZWMyOmBcbiAgICAgIHZlYzIgZk9wRGlmZmVyZW5jZVJvdW5kKCB2ZWMyIGQxLCB2ZWMyIGQyLCBmbG9hdCByICApIHtcbiAgICAgICAgdmVjMiBvID0gdmVjMiggMC4sIGQxLnkgKTsgXG4gICAgICAgIG8ueCA9IGZPcERpZmZlcmVuY2VSb3VuZCggZDEueCwgZDIueCwgciApO1xuXG4gICAgICAgIGlmKCBkMS54ID49IC1kMi54ICkge1xuICAgICAgICAgIG8ueSA9IGQxLnk7IFxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICBvLnkgPSBkMi55O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG87XG4gICAgICB9XG4gICAgICBgXG4gIH0sXG4gIENoYW1mZXJVbmlvbjp7XG4gICAgZmxvYXQ6YFxuICAgICAgZmxvYXQgZk9wVW5pb25DaGFtZmVyKGZsb2F0IGEsIGZsb2F0IGIsIGZsb2F0IHIpIHtcbiAgICAgICAgcmV0dXJuIG1pbihtaW4oYSwgYiksIChhIC0gciArIGIpKnNxcnQoMC41KSk7XG4gICAgICB9YCxcbiAgICB2ZWMyOmBcbiAgICAgIHZlYzIgZk9wVW5pb25DaGFtZmVyKCB2ZWMyIGQxLCB2ZWMyIGQyLCBmbG9hdCByICApIHtcbiAgICAgICAgdmVjMiBvID0gdmVjMiggMC4sIGQxLnkgKTsgXG4gICAgICAgIG8ueCA9IGZPcFVuaW9uQ2hhbWZlciggZDEueCwgZDIueCwgciApO1xuXG4gICAgICAgIGlmKCBkMS54IDw9IGQyLnggKSB7XG4gICAgICAgICAgby55ID0gZDEueTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgby55ID0gZDIueTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfVxuICAgICAgYFxuICB9LFxuICBDaGFtZmVySW50ZXJzZWN0aW9uOntcbiAgICBmbG9hdDpgXG4gICAgICBmbG9hdCBmT3BJbnRlcnNlY3Rpb25DaGFtZmVyKGZsb2F0IGEsIGZsb2F0IGIsIGZsb2F0IHIpIHtcbiAgICAgICAgcmV0dXJuIG1heChtYXgoYSwgYiksIChhICsgciArIGIpKnNxcnQoMC41KSk7XG4gICAgICB9YCxcbiAgICB2ZWMyOmBcbiAgICAgIHZlYzIgZk9wSW50ZXJzZWN0aW9uQ2hhbWZlciggdmVjMiBkMSwgdmVjMiBkMiwgZmxvYXQgciAgICkge1xuICAgICAgICB2ZWMyIG8gPSB2ZWMyKCAwLiwgZDEueSApOyBcbiAgICAgICAgby54ID0gZk9wSW50ZXJzZWN0aW9uQ2hhbWZlciggZDEueCwgZDIueCwgciApO1xuXG4gICAgICAgIGlmKCBkMS54ID49IGQyLnggKSB7XG4gICAgICAgICAgby55ID0gZDEueTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgby55ID0gZDIueTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfVxuICAgICAgYFxuICB9LFxuXG4gIENoYW1mZXJEaWZmZXJlbmNlOntcbiAgICBkZXBlbmRlbmNpZXM6WydDaGFtZmVySW50ZXJzZWN0aW9uJ10sXG4gICAgZmxvYXQ6YFxuICAgICAgZmxvYXQgZk9wRGlmZmVyZW5jZUNoYW1mZXIgKGZsb2F0IGEsIGZsb2F0IGIsIGZsb2F0IHIpIHtcbiAgICAgICAgcmV0dXJuIGZPcEludGVyc2VjdGlvbkNoYW1mZXIoYSwgLWIsIHIpO1xuICAgICAgfWAsXG4gICAgdmVjMjpgXG4gICAgICB2ZWMyIGZPcERpZmZlcmVuY2VDaGFtZmVyKCB2ZWMyIGQxLCB2ZWMyIGQyLCBmbG9hdCByICApIHtcbiAgICAgICAgdmVjMiBvID0gdmVjMiggMC4sIGQxLnkgKTsgXG4gICAgICAgIG8ueCA9IGZPcERpZmZlcmVuY2VDaGFtZmVyKCBkMS54LCBkMi54LCByICk7XG5cbiAgICAgICAgaWYoIGQxLnggPj0gLWQyLnggKSB7XG4gICAgICAgICAgby55ID0gZDEueTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgby55ID0gZDIueTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfVxuICAgICAgYFxuICB9LFxuICBQaXBlOmBcbiAgICAgIGZsb2F0IGZPcFBpcGUoZmxvYXQgYSwgZmxvYXQgYiwgZmxvYXQgcikge1xuICAgICAgICByZXR1cm4gbGVuZ3RoKHZlYzIoYSwgYikpIC0gcjtcbiAgICAgIH1cbiAgICAgIHZlYzIgZk9wUGlwZSggdmVjMiBkMSwgdmVjMiBkMiwgZmxvYXQgciAgICkge1xuICAgICAgICB2ZWMyIG8gPSB2ZWMyKCAwLiwgZDEueSApOyBcbiAgICAgICAgby54ID0gZk9wUGlwZSggZDEueCwgZDIueCwgciApO1xuXG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfVxuICAgICAgYCxcblxuICBFbmdyYXZlOmBcbiAgICAgIGZsb2F0IGZPcEVuZ3JhdmUoZmxvYXQgYSwgZmxvYXQgYiwgZmxvYXQgcikge1xuICAgICAgICByZXR1cm4gbWF4KGEsIChhICsgciAtIGFicyhiKSkqc3FydCgwLjUpKTtcbiAgICAgIH1cbiAgICAgIHZlYzIgZk9wRW5ncmF2ZSggdmVjMiBkMSwgdmVjMiBkMiwgZmxvYXQgciAgKSB7XG4gICAgICAgIHZlYzIgbyA9IHZlYzIoIDAuLCBkMS55ICk7IFxuICAgICAgICBvLnggPSBmT3BFbmdyYXZlKCBkMS54LCBkMi54LCByICk7XG5cbiAgICAgICAgcmV0dXJuIG87XG4gICAgICB9XG4gICAgICBgLFxuICBHcm9vdmU6YFxuICAgICAgZmxvYXQgZk9wR3Jvb3ZlKGZsb2F0IGEsIGZsb2F0IGIsIGZsb2F0IHJhLCBmbG9hdCByYikge1xuICAgICAgICByZXR1cm4gbWF4KGEsIG1pbihhICsgcmEsIHJiIC0gYWJzKGIpKSk7XG4gICAgICB9XG4gICAgICB2ZWMyIGZPcEdyb292ZSggdmVjMiBkMSwgdmVjMiBkMiwgZmxvYXQgciwgZmxvYXQgbiAgKSB7XG4gICAgICAgIHZlYzIgbyA9IHZlYzIoIDAuLCBkMS55ICk7IFxuICAgICAgICBvLnggPSBmT3BHcm9vdmUoIGQxLngsIGQyLngsIHIsIG4gKTtcblxuICAgICAgICByZXR1cm4gbztcbiAgICAgIH1cbiAgICAgIGAsXG5cbiAgVG9uZ3VlOmBcbiAgICAgIGZsb2F0IGZPcFRvbmd1ZShmbG9hdCBhLCBmbG9hdCBiLCBmbG9hdCByYSwgZmxvYXQgcmIpIHtcbiAgICAgICAgcmV0dXJuIG1pbihhLCBtYXgoYSAtIHJhLCBhYnMoYikgLSByYikpO1xuICAgICAgfVxuICAgICAgdmVjMiBmT3BUb25ndWUoIHZlYzIgZDEsIHZlYzIgZDIsIGZsb2F0IHIsIGZsb2F0IG4gICkge1xuICAgICAgICB2ZWMyIG8gPSB2ZWMyKCAwLiwgZDEueSApOyBcbiAgICAgICAgby54ID0gZk9wVG9uZ3VlKCBkMS54LCBkMi54LCByLCBuICk7XG5cbiAgICAgICAgcmV0dXJuIG87XG4gICAgICB9XG4gICAgICBgLFxuICBPbmlvbjpgXG4gICAgICBmbG9hdCBvcE9uaW9uKCBpbiBmbG9hdCBzZGYsIGluIGZsb2F0IHRoaWNrbmVzcyApe1xuICAgICAgICByZXR1cm4gYWJzKHNkZiktdGhpY2tuZXNzO1xuICAgICAgfVxuXG4gICAgICBmbG9hdCBvcEhhbHZlKCBpbiBmbG9hdCBzZGYsIHZlYzMgcCwgaW4gaW50IGRpciApe1xuICAgICAgICBmbG9hdCBfb3V0ID0gMC47XG4gICAgICAgIHN3aXRjaCggZGlyICkge1xuICAgICAgICAgIGNhc2UgMDogIFxuICAgICAgICAgICAgX291dCA9IG1heCggc2RmLCBwLnkgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIF9vdXQgPSBtYXgoIHNkZiwgLXAueSApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgX291dCA9IG1heCggc2RmLCBwLnggKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIF9vdXQgPSBtYXgoIHNkZiwgLXAueCApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX291dDtcbiAgICAgIH1cbiAgICAgIGAsXG5cbiAgU3dpdGNoOmBcbiAgICAgIHZlYzIgb3BTd2l0Y2goIHZlYzIgYSwgdmVjMiBiLCBmbG9hdCBjICkge1xuICAgICAgICBpZiggYyA8IC41ICkge1xuICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgfSBcbiAgICAgIH1cbiAgICAgIGBcbn1cbiIsImNvbnN0IHsgVmFyLCBmbG9hdF92YXJfZ2VuLCB2ZWMyX3Zhcl9nZW4sIHZlYzNfdmFyX2dlbiwgdmVjNF92YXJfZ2VuLCBpbnRfdmFyX2dlbiwgVmFyQWxsb2MgfSA9IHJlcXVpcmUoICcuL3Zhci5qcycgKVxuY29uc3QgU2NlbmVOb2RlID0gcmVxdWlyZSggJy4vc2NlbmVOb2RlLmpzJyApXG5jb25zdCB7IHBhcmFtX3dyYXAsIE1hdGVyaWFsSUQgfSA9IHJlcXVpcmUoICcuL3V0aWxzLmpzJyApXG5jb25zdCB7IFZlYzIsIFZlYzMsIFZlYzQgfSA9IHJlcXVpcmUoICcuL3ZlYy5qcycgKVxuY29uc3QgVHJhbnNmb3JtID0gcmVxdWlyZSggJy4vdHJhbnNmb3JtLmpzJyApXG5cbmNvbnN0IGRlc2NyaXB0aW9ucyA9IHtcbiAgRWxvbmdhdGlvbjoge1xuICAgIHBhcmFtZXRlcnM6WyB7IG5hbWU6J2Rpc3RhbmNlJywgdHlwZTondmVjMycsIGRlZmF1bHQ6VmVjMygwKSB9IF0sXG4gICAgZnVuYzpgXG4gICAgICB2ZWM0IG9wRWxvbmdhdGUoIGluIHZlYzMgcCwgaW4gdmVjMyBoICkge1xuICAgICAgICAvL3JldHVybiB2ZWM0KCBwLWNsYW1wKHAsLWgsaCksIDAuMCApOyAvLyBmYXN0ZXIsIGJ1dCBwcm9kdWNlcyB6ZXJvIGluIHRoZSBpbnRlcmlvciBlbG9uZ2F0ZWQgYm94XG4gICAgICAgIFxuICAgICAgICB2ZWMzIHEgPSBhYnMocCktaDtcbiAgICAgICAgcmV0dXJuIHZlYzQoIG1heChxLDAuMCksIG1pbihtYXgocS54LG1heChxLnkscS56KSksMC4wKSApO1xuICAgICAgfWAsXG4gICAgZW1pdCggbmFtZT0ncCcgKSB7XG4gICAgICBjb25zdCBwSWQgPSB0aGlzLmdldElEKClcbiAgICAgIGNvbnN0IHBOYW1lID0gJ3AnICsgcElkXG5cbiAgICAgIGxldCBwcmVmYWNlID1cbiAgICAgICAgYCAgICAgICAgdmVjNCAke3BOYW1lfV94eXp3ID0gb3BFbG9uZ2F0ZSggJHtuYW1lfSwgJHt0aGlzLmRpc3RhbmNlLmVtaXQoKX0gKTtcXG5cbiAgICAgICAgdmVjMyAke3BOYW1lfSA9ICR7cE5hbWV9X3h5encueHl6O1xcbmBcblxuXG4gICAgICBjb25zdCBzZGYgPSB0aGlzLnNkZi5lbWl0KCBwTmFtZSApXG5cbiAgICAgIGlmKCB0eXBlb2Ygc2RmLnByZWZhY2UgPT09ICdzdHJpbmcnICkgcHJlZmFjZSArPSBzZGYucHJlZmFjZSBcblxuICAgICAgcmV0dXJuIHsgb3V0OmB2ZWMyKCR7cE5hbWV9X3h5encudyArICR7c2RmLm91dH0ueCwgJHtzZGYub3V0fS55KWAsIHByZWZhY2UgfVxuICAgIH1cbiAgfSxcbiAgUG9sYXJSZXBldGl0aW9uOiB7XG4gICAgcGFyYW1ldGVyczpbIFxuICAgICAgeyBuYW1lOidjb3VudCcsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDo1IH0sXG4gICAgICB7IG5hbWU6J2Rpc3RhbmNlJywgdHlwZTondmVjMycsIGRlZmF1bHQ6VmVjMyguMjUpIH0sXG5cbiAgICBdLFxuICAgIGVtaXQoIG5hbWU9J3AnLCB0cmFuc2Zvcm09bnVsbCkge1xuICAgICAgY29uc3QgcElkID0gVmFyQWxsb2MuYWxsb2MoKVxuICAgICAgY29uc3QgcE5hbWUgPSAncCcgKyBwSWRcbiAgICAgIGNvbnN0IHBvaW50U3RyaW5nID0gIGAoICR7bmFtZX0gKiAke3RoaXMudHJhbnNmb3JtLmVtaXQoKX0gKS54eXpgXG5cbiAgICAgIGlmKCB0cmFuc2Zvcm0gIT09IG51bGwgKSB0aGlzLnRyYW5zZm9ybS5hcHBseSggdHJhbnNmb3JtLCBmYWxzZSApXG4gICAgICB0aGlzLnRyYW5zZm9ybS5pbnZlcnQoKVxuXG4gICAgICBsZXQgcHJlZmFjZSA9YFxuICAgICAgICAgIHZlYzQgJHtwTmFtZX0gPSB2ZWM0KCBwb2xhclJlcGVhdCggJHtwb2ludFN0cmluZ30sICR7dGhpcy5fX3RhcmdldC5jb3VudC5lbWl0KCkgfSApLCAxLiApOyBcbiAgICAgICAgICAke3BOYW1lfSAtPSB2ZWM0KCR7dGhpcy5fX3RhcmdldC5kaXN0YW5jZS5lbWl0KCl9LngsMC4sMC4sMC4pO1xcbmBcblxuICAgICAgY29uc3Qgc2RmID0gdGhpcy5zZGYuZW1pdCggcE5hbWUgKVxuXG4gICAgICBpZiggdHlwZW9mIHNkZi5wcmVmYWNlID09PSAnc3RyaW5nJyApIHByZWZhY2UgKz0gc2RmLnByZWZhY2VcblxuICAgICAgcmV0dXJuIHsgb3V0OnNkZi5vdXQsIHByZWZhY2UgfVxuICAgIH1cbiAgfSxcbiAgTWlycm9yOiB7XG4gICAgcGFyYW1ldGVyczogWyB7IG5hbWU6J2Rpc3RhbmNlJywgdHlwZTondmVjMycsIGRlZmF1bHQ6VmVjMygwKSB9IF0sXG4gICAgZXh0cmE6W3sgbmFtZTonZGltcycsIHR5cGU6J2xvY2FsJywgZGVmYXVsdDoneHl6JyB9XSxcblxuICAgIGVtaXQoIG5hbWU9J3AnLCB0cmFuc2Zvcm09bnVsbCwgbm90dXNlZD1udWxsLCBzY2FsZT1udWxsICkge1xuICAgICAgY29uc3QgcElkID0gVmFyQWxsb2MuYWxsb2MoKVxuICAgICAgY29uc3QgcE5hbWUgPSAncCcgKyBwSWRcblxuICAgICAgaWYoIHRyYW5zZm9ybSAhPT0gbnVsbCApIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0uYXBwbHkoIHRyYW5zZm9ybSwgZmFsc2UgKVxuICAgICAgfVxuICAgICAgdGhpcy50cmFuc2Zvcm0uaW52ZXJ0KClcbiAgICAgXG4gICAgICBjb25zdCBwb2ludFN0cmluZyA9ICBgKCAke25hbWV9ICogJHt0aGlzLnRyYW5zZm9ybS5lbWl0KCl9ICkueHl6YCxcbiAgICAgICAgICAgIHMgPSBzY2FsZSA9PT0gbnVsbCA/IHRoaXMudHJhbnNmb3JtLmVtaXRfc2NhbGUoKSA6IGAke3RoaXMudHJhbnNmb3JtLmVtaXRfc2NhbGUoKX0gKiAke3NjYWxlfWBcbiBcbiAgICAgIGxldCBwcmVmYWNlID1gXG4gICAgICAgIHZlYzQgJHtwTmFtZX0gPSB2ZWM0KCAoICR7cG9pbnRTdHJpbmd9ICkgLCAxLik7XFxuXG4gICAgICAgICR7cE5hbWV9LiR7dGhpcy5kaW1zfSA9IGFicyggJHtwTmFtZX0uJHt0aGlzLmRpbXN9ICk7XFxuYFxuXG4gICAgICBjb25zdCBzZGYgPSB0aGlzLnNkZi5lbWl0KCBwTmFtZSwgbnVsbCwgbnVsbCwgcyApXG5cbiAgICAgIGlmKCB0eXBlb2Ygc2RmLnByZWZhY2UgPT09ICdzdHJpbmcnICkgcHJlZmFjZSArPSBzZGYucHJlZmFjZSBcblxuICAgICAgcmV0dXJuIHsgb3V0OnNkZi5vdXQsIHByZWZhY2UgfVxuICAgIH1cbiAgfSxcbiAgLy9sZXQgcHJlZmFjZSA9IGAgICAgICAgICB2ZWMzICR7cE5hbWV9ID0gJHtuYW1lfSAvICR7dGhpcy5hbW91bnQuZW1pdCgpfTtcXG5gXG5cbiAgLy9sZXQgc2RmID0gdGhpcy5zZGYuZW1pdCggcE5hbWUgKVxuICAvL2xldCBvdXQgPSBzZGYub3V0IFxuXG4gIC8vc2RmLnByZWZhY2UgKz0gYCAgICAgICR7b3V0fS54ID0gJHtvdXR9LnggKiAke3RoaXMuYW1vdW50LmVtaXQoKX07XFxuYFxuXG4gIC8vaWYoIHR5cGVvZiBzZGYucHJlZmFjZSA9PT0gJ3N0cmluZycgKSBwcmVmYWNlICs9IHNkZi5wcmVmYWNlXG4gIFJlcGV0aXRpb246IHtcbiAgICBwYXJhbWV0ZXJzOiBbIHsgbmFtZTonZGlzdGFuY2UnLCB0eXBlOid2ZWMzJywgZGVmYXVsdDpWZWMzKDApIH0gXSxcbiAgICBlbWl0KCBuYW1lPSdwJywgdHJhbnNmb3JtPW51bGwgKSB7XG4gICAgICBjb25zdCBwSWQgPSBWYXJBbGxvYy5hbGxvYygpXG4gICAgICBjb25zdCBwTmFtZSA9ICdwJyArIHBJZFxuXG4gICAgICBpZiggdHJhbnNmb3JtICE9PSBudWxsICkgdGhpcy50cmFuc2Zvcm0uYXBwbHkoIHRyYW5zZm9ybSwgZmFsc2UgKVxuICAgICAgXG4gICAgICB0aGlzLnRyYW5zZm9ybS5pbnZlcnQoKVxuICAgICBcbiAgICAgIGNvbnN0IHBvaW50U3RyaW5nID0gIGAoICR7bmFtZX0gKiAke3RoaXMudHJhbnNmb3JtLmVtaXQoKX0gKS54eXpgO1xuXG4gICAgICBsZXQgcHJlZmFjZSA9YFxuICAgICAgICB2ZWM0ICR7cE5hbWV9ID0gdmVjNCggKG1vZCggJHtwb2ludFN0cmluZ30sICR7dGhpcy5fX3RhcmdldC5kaXN0YW5jZS5lbWl0KCl9ICkgLSAuNSAqICR7dGhpcy5fX3RhcmdldC5kaXN0YW5jZS5lbWl0KCl9KSAqICR7dGhpcy50cmFuc2Zvcm0uZW1pdF9zY2FsZSgpfSwgMS4pO1xcbmBcblxuICAgICAgY29uc3Qgc2RmID0gdGhpcy5zZGYuZW1pdCggcE5hbWUgKS8vLCB0aGlzLnRyYW5zZm9ybSApLy8sIDEsIHRoaXMuX190YXJnZXQuZGlzdGFuY2UgKVxuXG4gICAgICBpZiggdHlwZW9mIHNkZi5wcmVmYWNlID09PSAnc3RyaW5nJyApIHByZWZhY2UgKz0gc2RmLnByZWZhY2UgXG5cbiAgICAgIHJldHVybiB7IG91dDpzZGYub3V0LCBwcmVmYWNlIH1cbiAgICB9XG4gIH0sXG59XG4gIFxuY29uc3QgZ2V0RG9tYWluT3BzID0gZnVuY3Rpb24oIFNERiApIHtcbiAgY29uc3Qgb3BzID0ge31cblxuICBmb3IoIGxldCBrZXkgaW4gZGVzY3JpcHRpb25zICkge1xuICAgIGNvbnN0IG9wRGVzYyA9IGRlc2NyaXB0aW9uc1sga2V5IF1cbiAgICBcbiAgICBvcHNbIGtleSBdID0gZnVuY3Rpb24oIHNkZiwgLi4uYXJncyApIHtcbiAgICAgIGNvbnN0IG9wID0gT2JqZWN0LmNyZWF0ZSggb3BzWyBrZXkgXS5wcm90b3R5cGUgKVxuICAgICAgb3Auc2RmID0gc2RmXG4gICAgICBvcC5wYXJhbWV0ZXJzID0gW11cbiAgICAgIG9wLnRyYW5zZm9ybSA9IFRyYW5zZm9ybSgpXG4gICAgICBvcC5uYW1lID0ga2V5XG4gICAgICBjb25zdCB0YXJnZXQgPSBvcC5fX3RhcmdldCA9IG9wIC8vIHNkZi5fX3RhcmdldCAhPT0gdW5kZWZpbmVkID8gc2RmLl9fdGFyZ2V0IDogb3BcblxuICAgICAgbGV0IGNvdW50ID0gMFxuICAgICAgZm9yKCBsZXQgcHJvcCBvZiBvcERlc2MucGFyYW1ldGVycyApIHtcbiAgICAgICAgb3AucGFyYW1ldGVycy5wdXNoKCBwcm9wIClcblxuICAgICAgICBsZXQgYXJnID0gYXJnc1sgY291bnQgXVxuICAgICAgICBsZXQgX192YXJcblxuICAgICAgICBzd2l0Y2goIHByb3AudHlwZSApIHtcbiAgICAgICAgICBjYXNlICd2ZWMyJzpcbiAgICAgICAgICAgIGlmKCB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyApIGFyZyA9IFZlYzIoIGFyZyApXG4gICAgICAgICAgICBpZiggYXJnID09PSB1bmRlZmluZWQgKSBhcmcgPSBwcm9wLmRlZmF1bHQuY29weSgpXG5cbiAgICAgICAgICAgIF9fdmFyID0gcGFyYW1fd3JhcCggXG4gICAgICAgICAgICAgIGFyZywgXG4gICAgICAgICAgICAgIHZlYzJfdmFyX2dlbiggcHJvcC5kZWZhdWx0ICkgICAgXG4gICAgICAgICAgICApXG5cbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGFyZ2V0LCBwcm9wLm5hbWUsIHtcbiAgICAgICAgICAgICAgZ2V0KCkgeyByZXR1cm4gX192YXIgfSxcbiAgICAgICAgICAgICAgc2V0KHYpIHtcbiAgICAgICAgICAgICAgICBpZiggdHlwZW9mIHYgPT09ICdvYmplY3QnICkge1xuICAgICAgICAgICAgICAgICAgX192YXIuc2V0KCB2IClcbiAgICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAgIF9fdmFyLnZhbHVlLnggPSB2XG4gICAgICAgICAgICAgICAgICBfX3Zhci52YWx1ZS55ID0gdlxuICAgICAgICAgICAgICAgICAgX192YXIuZGlydHkgPSB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSAgXG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3ZlYzMnOlxuICAgICAgICAgICAgaWYoIHR5cGVvZiBhcmcgPT09ICdudW1iZXInICkgYXJnID0gVmVjMyggYXJnIClcbiAgICAgICAgICAgIGlmKCBhcmcgPT09IHVuZGVmaW5lZCApIGFyZyA9IHByb3AuZGVmYXVsdC5jb3B5KClcblxuICAgICAgICAgICAgX192YXIgPSBwYXJhbV93cmFwKCBcbiAgICAgICAgICAgICAgYXJnLCBcbiAgICAgICAgICAgICAgdmVjM192YXJfZ2VuKCBwcm9wLmRlZmF1bHQgKVxuICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRhcmdldCwgcHJvcC5uYW1lLCB7XG4gICAgICAgICAgICAgIGdldCgpIHsgcmV0dXJuIF9fdmFyIH0sXG4gICAgICAgICAgICAgIHNldCh2KSB7XG4gICAgICAgICAgICAgICAgaWYoIHR5cGVvZiB2ID09PSAnb2JqZWN0JyApIHtcbiAgICAgICAgICAgICAgICAgIF9fdmFyLnNldCggdiApXG4gICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICBfX3Zhci52YWx1ZS54ID0gdlxuICAgICAgICAgICAgICAgICAgX192YXIudmFsdWUueSA9IHZcbiAgICAgICAgICAgICAgICAgIF9fdmFyLnZhbHVlLnogPSB2XG4gICAgICAgICAgICAgICAgICBfX3Zhci5kaXJ0eSA9IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pICBcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndmVjNCc6XG4gICAgICAgICAgICBpZiggdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgKSBhcmcgPSBWZWM0KCBhcmcgKVxuICAgICAgICAgICAgICBfX3ZhciA9IHBhcmFtX3dyYXAoIFxuICAgICAgICAgICAgICBhcmcsIFxuICAgICAgICAgICAgICB2ZWM0X3Zhcl9nZW4oIHByb3AuZGVmYXVsdCApICBcbiAgICAgICAgICAgIClcblxuICAgICAgICAgICAgaWYoIGFyZyA9PT0gdW5kZWZpbmVkICkgYXJnID0gcHJvcC5kZWZhdWx0LmNvcHkoKVxuXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRhcmdldCwgcHJvcC5uYW1lLCB7XG4gICAgICAgICAgICAgIGdldCgpIHsgcmV0dXJuIF9fdmFyIH0sXG4gICAgICAgICAgICAgIHNldCh2KSB7XG4gICAgICAgICAgICAgICAgaWYoIHR5cGVvZiB2ID09PSAnb2JqZWN0JyApIHtcbiAgICAgICAgICAgICAgICAgIF9fdmFyLnNldCggdiApXG4gICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICBfX3Zhci52YWx1ZS54ID0gdlxuICAgICAgICAgICAgICAgICAgX192YXIudmFsdWUueSA9IHZcbiAgICAgICAgICAgICAgICAgIF9fdmFyLnZhbHVlLnogPSB2XG4gICAgICAgICAgICAgICAgICBfX3Zhci52YWx1ZS53ID0gdlxuICAgICAgICAgICAgICAgICAgX192YXIuZGlydHkgPSB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSAgXG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6IC8vIGZsb2F0XG4gICAgICAgICAgICBfX3ZhciA9ICBwYXJhbV93cmFwKCBcbiAgICAgICAgICAgICAgYXJnLCBcbiAgICAgICAgICAgICAgZmxvYXRfdmFyX2dlbiggcHJvcC5kZWZhdWx0IClcbiAgICAgICAgICAgIClcblxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCB0YXJnZXQsIHByb3AubmFtZSwge1xuICAgICAgICAgICAgICBnZXQoKSB7IHJldHVybiBfX3ZhciB9LFxuICAgICAgICAgICAgICBzZXQodikge1xuICAgICAgICAgICAgICAgIF9fdmFyLnNldCggdiApIFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjb3VudCsrXG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmKCBvcERlc2MuZXh0cmEgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgZm9yKCBsZXQgZXh0cmEgb2Ygb3BEZXNjLmV4dHJhICkge1xuICAgICAgICAgIG9wWyBleHRyYS5uYW1lIF0gPSBhcmdzWyBjb3VudCAtIDEgXSB8fCBleHRyYS5kZWZhdWx0XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgb3AuX19zZXRUZXh0dXJlID0gZnVuY3Rpb24odGV4LHByb3BzKSB7XG4gICAgICAgIGlmKCB0eXBlb2YgdGV4ID09PSAnc3RyaW5nJyApIHtcbiAgICAgICAgICB0aGlzLnRleHR1cmUgPSBvcC50ZXh0dXJlLmJpbmQoIHRoaXMgKVxuICAgICAgICAgIHRoaXMuX190ZXh0dXJlT2JqID0gdGhpcy50ZXggPSBNYXJjaGluZy5UZXh0dXJlKCB0ZXgscHJvcHMsdGhpcy50ZXh0dXJlIClcbiAgICAgICAgICB0aGlzLl9fdGV4dHVyZUlEID0gdGhpcy5fX3RleHR1cmVPYmouaWRcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgdGhpcy5fX3RleHR1cmVPYmogPSB0aGlzLnRleCA9IE9iamVjdC5hc3NpZ24oIHRleCwgcHJvcHMgKVxuICAgICAgICAgIHRoaXMuX190ZXh0dXJlSUQgPSB0aGlzLl9fdGV4dHVyZU9iai5pZFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvcC5fX3NldE1hdGVyaWFsID0gZnVuY3Rpb24obWF0KSB7XG4gICAgICAgIGlmKCB0eXBlb2YgbWF0ID09PSAnc3RyaW5nJyApIG1hdCA9IE1hcmNoaW5nLk1hdGVyaWFsWyBtYXQgXVxuICAgICAgICB0aGlzLl9fbWF0ZXJpYWwgPSB0aGlzLm1hdCA9IE1hcmNoaW5nLm1hdGVyaWFscy5hZGRNYXRlcmlhbCggbWF0IClcbiAgICAgIH1cbiAgICAgIG9wLl9fZGVzYyA9IG9wRGVzY1xuXG4gICAgICBpZigga2V5ICE9PSAnTWlycm9yJyApIG9wLnNkZi5yZXBlYXQgPSBvcFxuICAgICAgcmV0dXJuIG9wXG4gICAgfVxuXG4gICAgb3BzWyBrZXkgXS5wcm90b3R5cGUgPSBTY2VuZU5vZGUoKVxuICAgIG9wc1sga2V5IF0ucHJvdG90eXBlLmVtaXQgPSBvcERlc2MuZW1pdFxuICAgIFxuICAgIG9wc1sga2V5IF0ucHJvdG90eXBlLnRleHR1cmUgPSBmdW5jdGlvbiggLi4uYXJncyApIHtcbiAgICAgIHRoaXMuX19zZXRUZXh0dXJlKCAuLi5hcmdzIClcbiAgICAgIHRoaXMuc2RmLnRleHR1cmUoIHRoaXMuX190ZXh0dXJlT2JqIClcblxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgb3BzWyBrZXkgXS5wcm90b3R5cGUubWF0ZXJpYWwgPSBmdW5jdGlvbiggLi4uYXJncyApIHtcbiAgICAgIHRoaXMuX19zZXRNYXRlcmlhbCggLi4uYXJncyApXG4gICAgICB0aGlzLnNkZi5tYXRlcmlhbCggdGhpcy5fX21hdGVyaWFsIClcblxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBvcHNbIGtleSBdLnByb3RvdHlwZS5lbWl0X2RlY2wgPSBmdW5jdGlvbiggc2hvdWxkRW1pdFNERj10cnVlICkge1xuICAgICAgbGV0IGRlY2wgPSAnJ1xuICAgICAgZGVjbCArPSB0aGlzLnRyYW5zZm9ybS5lbWl0X2RlY2woKVxuICAgICAgZm9yKCBsZXQgcGFyYW0gb2YgdGhpcy5wYXJhbWV0ZXJzICkge1xuICAgICAgICBkZWNsICs9IHRoaXMuX190YXJnZXRbIHBhcmFtLm5hbWUgXS5lbWl0X2RlY2woKSBcbiAgICAgIH1cbiAgICAgIGlmKCBzaG91bGRFbWl0U0RGICkgZGVjbCArPSB0aGlzLnNkZi5lbWl0X2RlY2woKVxuICAgICAgXG4gICAgICAvLyBmb3Igcm90YXRpb24gZXRjLi4uIGFueSBleHRyYSBnbHNsIGZ1bmN0aW9uIHRoYXQgbmVlZHMgdG9cbiAgICAgIC8vIGJlIGFkZGVkIHRvIHRoZSBzaGFkZXJcbiAgICAgIGlmKCBvcERlc2MuZ2xzbCAhPT0gdW5kZWZpbmVkICYmIFNERi5tZW1vWyBrZXkgXSA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICBkZWNsICs9IG9wRGVzYy5nbHNsXG4gICAgICAgIFNERi5tZW1vWyBrZXkgXSA9IHRydWVcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlY2xcbiAgICB9XG4gICAgb3BzWyBrZXkgXS5wcm90b3R5cGUudXBkYXRlX2xvY2F0aW9uID0gZnVuY3Rpb24oIGdsLCBwcm9ncmFtLCBzaG91bGRVcGRhdGVTREY9dHJ1ZSApIHtcbiAgICAgIGZvciggbGV0IHBhcmFtIG9mIHRoaXMucGFyYW1ldGVycyApIHRoaXMuX190YXJnZXRbIHBhcmFtLm5hbWUgXS51cGRhdGVfbG9jYXRpb24oIGdsLCBwcm9ncmFtKVxuICAgICAgaWYoIHNob3VsZFVwZGF0ZVNERiApIHRoaXMuc2RmLnVwZGF0ZV9sb2NhdGlvbiggZ2wsIHByb2dyYW0gKVxuICAgICAgdGhpcy50cmFuc2Zvcm0udXBkYXRlX2xvY2F0aW9uKCBnbCwgcHJvZ3JhbSApXG4gICAgfVxuICAgIG9wc1sga2V5IF0ucHJvdG90eXBlLnVwbG9hZF9kYXRhID0gZnVuY3Rpb24oIGdsLCBzaG91bGRVcGxvYWRTREY9dHJ1ZSApIHtcbiAgICAgIGZvciggbGV0IHBhcmFtIG9mIHRoaXMucGFyYW1ldGVycyApIHRoaXMuX190YXJnZXRbIHBhcmFtLm5hbWUgXS51cGxvYWRfZGF0YSggZ2wgKVxuICAgICAgdGhpcy50cmFuc2Zvcm0udXBsb2FkX2RhdGEoIGdsIClcbiAgICAgIGlmKCBzaG91bGRVcGxvYWRTREYgKSB0aGlzLnNkZi51cGxvYWRfZGF0YSggZ2wgKVxuICAgIH1cbiAgfVxuICBcbiAgb3BzLlJlcGVhdCA9IG9wcy5SZXBldGl0aW9uXG4gIG9wcy5SZXBlYXRTY2FsZSA9IG9wcy5SZXBldGl0aW9uU2hyaW5rXG4gIG9wcy5Qb2xhclJlcGVhdCA9IG9wcy5Qb2xhclJlcGV0aXRpb25cblxuICByZXR1cm4gb3BzXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RG9tYWluT3BzXG4iLCIvLyBtYXRyaXguanMgLSB0YWtlbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9ldmFudy9saWdodGdsLmpzL1xuXG4vLyBSZXByZXNlbnRzIGEgNHg0IG1hdHJpeCBzdG9yZWQgaW4gcm93LW1ham9yIG9yZGVyIHRoYXQgdXNlcyBGbG9hdDMyQXJyYXlzXG4vLyB3aGVuIGF2YWlsYWJsZS4gTWF0cml4IG9wZXJhdGlvbnMgY2FuIGVpdGhlciBiZSBkb25lIHVzaW5nIGNvbnZlbmllbnRcbi8vIG1ldGhvZHMgdGhhdCByZXR1cm4gYSBuZXcgbWF0cml4IGZvciB0aGUgcmVzdWx0IG9yIG9wdGltaXplZCBtZXRob2RzXG4vLyB0aGF0IHN0b3JlIHRoZSByZXN1bHQgaW4gYW4gZXhpc3RpbmcgbWF0cml4IHRvIGF2b2lkIGdlbmVyYXRpbmcgZ2FyYmFnZS5cblxudmFyIGhhc0Zsb2F0MzJBcnJheSA9ICh0eXBlb2YgRmxvYXQzMkFycmF5ICE9ICd1bmRlZmluZWQnKTtcblxuLy8gIyMjIG5ldyBHTC5NYXRyaXgoW2VsZW1lbnRzXSlcbi8vXG4vLyBUaGlzIGNvbnN0cnVjdG9yIHRha2VzIDE2IGFyZ3VtZW50cyBpbiByb3ctbWFqb3Igb3JkZXIsIHdoaWNoIGNhbiBiZSBwYXNzZWRcbi8vIGluZGl2aWR1YWxseSwgYXMgYSBsaXN0LCBvciBldmVuIGFzIGZvdXIgbGlzdHMsIG9uZSBmb3IgZWFjaCByb3cuIElmIHRoZVxuLy8gYXJndW1lbnRzIGFyZSBvbWl0dGVkIHRoZW4gdGhlIGlkZW50aXR5IG1hdHJpeCBpcyBjb25zdHJ1Y3RlZCBpbnN0ZWFkLlxuZnVuY3Rpb24gTWF0cml4KCkge1xuICB2YXIgbSA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGFyZ3VtZW50cyk7XG4gIGlmICghbS5sZW5ndGgpIHtcbiAgICBtID0gW1xuICAgICAgMSwgMCwgMCwgMCxcbiAgICAgIDAsIDEsIDAsIDAsXG4gICAgICAwLCAwLCAxLCAwLFxuICAgICAgMCwgMCwgMCwgMVxuICAgIF07XG4gIH1cbiAgdGhpcy5tID0gaGFzRmxvYXQzMkFycmF5ID8gbmV3IEZsb2F0MzJBcnJheShtKSA6IG07XG59XG5cbk1hdHJpeC5wcm90b3R5cGUgPSB7XG4gIC8vICMjIyAuaW52ZXJzZSgpXG4gIC8vXG4gIC8vIFJldHVybnMgdGhlIG1hdHJpeCB0aGF0IHdoZW4gbXVsdGlwbGllZCB3aXRoIHRoaXMgbWF0cml4IHJlc3VsdHMgaW4gdGhlXG4gIC8vIGlkZW50aXR5IG1hdHJpeC5cbiAgaW52ZXJzZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIE1hdHJpeC5pbnZlcnNlKHRoaXMsIG5ldyBNYXRyaXgoKSk7XG4gIH0sXG5cbiAgLy8gIyMjIC50cmFuc3Bvc2UoKVxuICAvL1xuICAvLyBSZXR1cm5zIHRoaXMgbWF0cml4LCBleGNoYW5naW5nIGNvbHVtbnMgZm9yIHJvd3MuXG4gIHRyYW5zcG9zZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIE1hdHJpeC50cmFuc3Bvc2UodGhpcywgbmV3IE1hdHJpeCgpKTtcbiAgfSxcblxuICAvLyAjIyMgLm11bHRpcGx5KG1hdHJpeClcbiAgLy9cbiAgLy8gUmV0dXJucyB0aGUgY29uY2F0ZW5hdGlvbiBvZiB0aGUgdHJhbnNmb3JtcyBmb3IgdGhpcyBtYXRyaXggYW5kIGBtYXRyaXhgLlxuICAvLyBUaGlzIGVtdWxhdGVzIHRoZSBPcGVuR0wgZnVuY3Rpb24gYGdsTXVsdE1hdHJpeCgpYC5cbiAgbXVsdGlwbHk6IGZ1bmN0aW9uKG1hdHJpeCkge1xuICAgIHJldHVybiBNYXRyaXgubXVsdGlwbHkodGhpcywgbWF0cml4LCBuZXcgTWF0cml4KCkpO1xuICB9LFxuXG4gIC8vICMjIyAudHJhbnNmb3JtUG9pbnQocG9pbnQpXG4gIC8vXG4gIC8vIFRyYW5zZm9ybXMgdGhlIHZlY3RvciBhcyBhIHBvaW50IHdpdGggYSB3IGNvb3JkaW5hdGUgb2YgMS4gVGhpc1xuICAvLyBtZWFucyB0cmFuc2xhdGlvbnMgd2lsbCBoYXZlIGFuIGVmZmVjdCwgZm9yIGV4YW1wbGUuXG4gIHRyYW5zZm9ybVBvaW50OiBmdW5jdGlvbih2KSB7XG4gICAgdmFyIG0gPSB0aGlzLm07XG4gICAgcmV0dXJuIG5ldyBWZWN0b3IoXG4gICAgICBtWzBdICogdi54ICsgbVsxXSAqIHYueSArIG1bMl0gKiB2LnogKyBtWzNdLFxuICAgICAgbVs0XSAqIHYueCArIG1bNV0gKiB2LnkgKyBtWzZdICogdi56ICsgbVs3XSxcbiAgICAgIG1bOF0gKiB2LnggKyBtWzldICogdi55ICsgbVsxMF0gKiB2LnogKyBtWzExXVxuICAgICkuZGl2aWRlKG1bMTJdICogdi54ICsgbVsxM10gKiB2LnkgKyBtWzE0XSAqIHYueiArIG1bMTVdKTtcbiAgfSxcblxuICAvLyAjIyMgLnRyYW5zZm9ybVBvaW50KHZlY3RvcilcbiAgLy9cbiAgLy8gVHJhbnNmb3JtcyB0aGUgdmVjdG9yIGFzIGEgdmVjdG9yIHdpdGggYSB3IGNvb3JkaW5hdGUgb2YgMC4gVGhpc1xuICAvLyBtZWFucyB0cmFuc2xhdGlvbnMgd2lsbCBoYXZlIG5vIGVmZmVjdCwgZm9yIGV4YW1wbGUuXG4gIHRyYW5zZm9ybVZlY3RvcjogZnVuY3Rpb24odikge1xuICAgIHZhciBtID0gdGhpcy5tO1xuICAgIHJldHVybiBuZXcgVmVjdG9yKFxuICAgICAgbVswXSAqIHYueCArIG1bMV0gKiB2LnkgKyBtWzJdICogdi56LFxuICAgICAgbVs0XSAqIHYueCArIG1bNV0gKiB2LnkgKyBtWzZdICogdi56LFxuICAgICAgbVs4XSAqIHYueCArIG1bOV0gKiB2LnkgKyBtWzEwXSAqIHYuelxuICAgICk7XG4gIH1cbn07XG5cbi8vICMjIyBHTC5NYXRyaXguaW52ZXJzZShtYXRyaXhbLCByZXN1bHRdKVxuLy9cbi8vIFJldHVybnMgdGhlIG1hdHJpeCB0aGF0IHdoZW4gbXVsdGlwbGllZCB3aXRoIGBtYXRyaXhgIHJlc3VsdHMgaW4gdGhlXG4vLyBpZGVudGl0eSBtYXRyaXguIFlvdSBjYW4gb3B0aW9uYWxseSBwYXNzIGFuIGV4aXN0aW5nIG1hdHJpeCBpbiBgcmVzdWx0YFxuLy8gdG8gYXZvaWQgYWxsb2NhdGluZyBhIG5ldyBtYXRyaXguIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgZnJvbSB0aGUgTWVzYVxuLy8gT3BlbkdMIGZ1bmN0aW9uIGBfX2dsdUludmVydE1hdHJpeGQoKWAgZm91bmQgaW4gYHByb2plY3QuY2AuXG5NYXRyaXguaW52ZXJzZSA9IGZ1bmN0aW9uKG1hdHJpeCwgcmVzdWx0KSB7XG4gIHJlc3VsdCA9IHJlc3VsdCB8fCBuZXcgTWF0cml4KCk7XG4gIHZhciBtID0gbWF0cml4Lm0sIHIgPSByZXN1bHQubTtcblxuICByWzBdID0gbVs1XSptWzEwXSptWzE1XSAtIG1bNV0qbVsxNF0qbVsxMV0gLSBtWzZdKm1bOV0qbVsxNV0gKyBtWzZdKm1bMTNdKm1bMTFdICsgbVs3XSptWzldKm1bMTRdIC0gbVs3XSptWzEzXSptWzEwXTtcbiAgclsxXSA9IC1tWzFdKm1bMTBdKm1bMTVdICsgbVsxXSptWzE0XSptWzExXSArIG1bMl0qbVs5XSptWzE1XSAtIG1bMl0qbVsxM10qbVsxMV0gLSBtWzNdKm1bOV0qbVsxNF0gKyBtWzNdKm1bMTNdKm1bMTBdO1xuICByWzJdID0gbVsxXSptWzZdKm1bMTVdIC0gbVsxXSptWzE0XSptWzddIC0gbVsyXSptWzVdKm1bMTVdICsgbVsyXSptWzEzXSptWzddICsgbVszXSptWzVdKm1bMTRdIC0gbVszXSptWzEzXSptWzZdO1xuICByWzNdID0gLW1bMV0qbVs2XSptWzExXSArIG1bMV0qbVsxMF0qbVs3XSArIG1bMl0qbVs1XSptWzExXSAtIG1bMl0qbVs5XSptWzddIC0gbVszXSptWzVdKm1bMTBdICsgbVszXSptWzldKm1bNl07XG5cbiAgcls0XSA9IC1tWzRdKm1bMTBdKm1bMTVdICsgbVs0XSptWzE0XSptWzExXSArIG1bNl0qbVs4XSptWzE1XSAtIG1bNl0qbVsxMl0qbVsxMV0gLSBtWzddKm1bOF0qbVsxNF0gKyBtWzddKm1bMTJdKm1bMTBdO1xuICByWzVdID0gbVswXSptWzEwXSptWzE1XSAtIG1bMF0qbVsxNF0qbVsxMV0gLSBtWzJdKm1bOF0qbVsxNV0gKyBtWzJdKm1bMTJdKm1bMTFdICsgbVszXSptWzhdKm1bMTRdIC0gbVszXSptWzEyXSptWzEwXTtcbiAgcls2XSA9IC1tWzBdKm1bNl0qbVsxNV0gKyBtWzBdKm1bMTRdKm1bN10gKyBtWzJdKm1bNF0qbVsxNV0gLSBtWzJdKm1bMTJdKm1bN10gLSBtWzNdKm1bNF0qbVsxNF0gKyBtWzNdKm1bMTJdKm1bNl07XG4gIHJbN10gPSBtWzBdKm1bNl0qbVsxMV0gLSBtWzBdKm1bMTBdKm1bN10gLSBtWzJdKm1bNF0qbVsxMV0gKyBtWzJdKm1bOF0qbVs3XSArIG1bM10qbVs0XSptWzEwXSAtIG1bM10qbVs4XSptWzZdO1xuXG4gIHJbOF0gPSBtWzRdKm1bOV0qbVsxNV0gLSBtWzRdKm1bMTNdKm1bMTFdIC0gbVs1XSptWzhdKm1bMTVdICsgbVs1XSptWzEyXSptWzExXSArIG1bN10qbVs4XSptWzEzXSAtIG1bN10qbVsxMl0qbVs5XTtcbiAgcls5XSA9IC1tWzBdKm1bOV0qbVsxNV0gKyBtWzBdKm1bMTNdKm1bMTFdICsgbVsxXSptWzhdKm1bMTVdIC0gbVsxXSptWzEyXSptWzExXSAtIG1bM10qbVs4XSptWzEzXSArIG1bM10qbVsxMl0qbVs5XTtcbiAgclsxMF0gPSBtWzBdKm1bNV0qbVsxNV0gLSBtWzBdKm1bMTNdKm1bN10gLSBtWzFdKm1bNF0qbVsxNV0gKyBtWzFdKm1bMTJdKm1bN10gKyBtWzNdKm1bNF0qbVsxM10gLSBtWzNdKm1bMTJdKm1bNV07XG4gIHJbMTFdID0gLW1bMF0qbVs1XSptWzExXSArIG1bMF0qbVs5XSptWzddICsgbVsxXSptWzRdKm1bMTFdIC0gbVsxXSptWzhdKm1bN10gLSBtWzNdKm1bNF0qbVs5XSArIG1bM10qbVs4XSptWzVdO1xuXG4gIHJbMTJdID0gLW1bNF0qbVs5XSptWzE0XSArIG1bNF0qbVsxM10qbVsxMF0gKyBtWzVdKm1bOF0qbVsxNF0gLSBtWzVdKm1bMTJdKm1bMTBdIC0gbVs2XSptWzhdKm1bMTNdICsgbVs2XSptWzEyXSptWzldO1xuICByWzEzXSA9IG1bMF0qbVs5XSptWzE0XSAtIG1bMF0qbVsxM10qbVsxMF0gLSBtWzFdKm1bOF0qbVsxNF0gKyBtWzFdKm1bMTJdKm1bMTBdICsgbVsyXSptWzhdKm1bMTNdIC0gbVsyXSptWzEyXSptWzldO1xuICByWzE0XSA9IC1tWzBdKm1bNV0qbVsxNF0gKyBtWzBdKm1bMTNdKm1bNl0gKyBtWzFdKm1bNF0qbVsxNF0gLSBtWzFdKm1bMTJdKm1bNl0gLSBtWzJdKm1bNF0qbVsxM10gKyBtWzJdKm1bMTJdKm1bNV07XG4gIHJbMTVdID0gbVswXSptWzVdKm1bMTBdIC0gbVswXSptWzldKm1bNl0gLSBtWzFdKm1bNF0qbVsxMF0gKyBtWzFdKm1bOF0qbVs2XSArIG1bMl0qbVs0XSptWzldIC0gbVsyXSptWzhdKm1bNV07XG5cbiAgdmFyIGRldCA9IG1bMF0qclswXSArIG1bMV0qcls0XSArIG1bMl0qcls4XSArIG1bM10qclsxMl07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykgcltpXSAvPSBkZXQ7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyAjIyMgR0wuTWF0cml4LnRyYW5zcG9zZShtYXRyaXhbLCByZXN1bHRdKVxuLy9cbi8vIFJldHVybnMgYG1hdHJpeGAsIGV4Y2hhbmdpbmcgY29sdW1ucyBmb3Igcm93cy4gWW91IGNhbiBvcHRpb25hbGx5IHBhc3MgYW5cbi8vIGV4aXN0aW5nIG1hdHJpeCBpbiBgcmVzdWx0YCB0byBhdm9pZCBhbGxvY2F0aW5nIGEgbmV3IG1hdHJpeC5cbk1hdHJpeC50cmFuc3Bvc2UgPSBmdW5jdGlvbihtYXRyaXgsIHJlc3VsdCkge1xuICByZXN1bHQgPSByZXN1bHQgfHwgbmV3IE1hdHJpeCgpO1xuICB2YXIgbSA9IG1hdHJpeC5tLCByID0gcmVzdWx0Lm07XG4gIHJbMF0gPSBtWzBdOyByWzFdID0gbVs0XTsgclsyXSA9IG1bOF07IHJbM10gPSBtWzEyXTtcbiAgcls0XSA9IG1bMV07IHJbNV0gPSBtWzVdOyByWzZdID0gbVs5XTsgcls3XSA9IG1bMTNdO1xuICByWzhdID0gbVsyXTsgcls5XSA9IG1bNl07IHJbMTBdID0gbVsxMF07IHJbMTFdID0gbVsxNF07XG4gIHJbMTJdID0gbVszXTsgclsxM10gPSBtWzddOyByWzE0XSA9IG1bMTFdOyByWzE1XSA9IG1bMTVdO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gIyMjIEdMLk1hdHJpeC5tdWx0aXBseShsZWZ0LCByaWdodFssIHJlc3VsdF0pXG4vL1xuLy8gUmV0dXJucyB0aGUgY29uY2F0ZW5hdGlvbiBvZiB0aGUgdHJhbnNmb3JtcyBmb3IgYGxlZnRgIGFuZCBgcmlnaHRgLiBZb3UgY2FuXG4vLyBvcHRpb25hbGx5IHBhc3MgYW4gZXhpc3RpbmcgbWF0cml4IGluIGByZXN1bHRgIHRvIGF2b2lkIGFsbG9jYXRpbmcgYSBuZXdcbi8vIG1hdHJpeC4gVGhpcyBlbXVsYXRlcyB0aGUgT3BlbkdMIGZ1bmN0aW9uIGBnbE11bHRNYXRyaXgoKWAuXG5NYXRyaXgubXVsdGlwbHkgPSBmdW5jdGlvbihsZWZ0LCByaWdodCwgcmVzdWx0KSB7XG4gIHJlc3VsdCA9IHJlc3VsdCB8fCBuZXcgTWF0cml4KCk7XG4gIHZhciBhID0gbGVmdC5tLCBiID0gcmlnaHQubSwgciA9IHJlc3VsdC5tO1xuXG4gIHJbMF0gPSBhWzBdICogYlswXSArIGFbMV0gKiBiWzRdICsgYVsyXSAqIGJbOF0gKyBhWzNdICogYlsxMl07XG4gIHJbMV0gPSBhWzBdICogYlsxXSArIGFbMV0gKiBiWzVdICsgYVsyXSAqIGJbOV0gKyBhWzNdICogYlsxM107XG4gIHJbMl0gPSBhWzBdICogYlsyXSArIGFbMV0gKiBiWzZdICsgYVsyXSAqIGJbMTBdICsgYVszXSAqIGJbMTRdO1xuICByWzNdID0gYVswXSAqIGJbM10gKyBhWzFdICogYls3XSArIGFbMl0gKiBiWzExXSArIGFbM10gKiBiWzE1XTtcblxuICByWzRdID0gYVs0XSAqIGJbMF0gKyBhWzVdICogYls0XSArIGFbNl0gKiBiWzhdICsgYVs3XSAqIGJbMTJdO1xuICByWzVdID0gYVs0XSAqIGJbMV0gKyBhWzVdICogYls1XSArIGFbNl0gKiBiWzldICsgYVs3XSAqIGJbMTNdO1xuICByWzZdID0gYVs0XSAqIGJbMl0gKyBhWzVdICogYls2XSArIGFbNl0gKiBiWzEwXSArIGFbN10gKiBiWzE0XTtcbiAgcls3XSA9IGFbNF0gKiBiWzNdICsgYVs1XSAqIGJbN10gKyBhWzZdICogYlsxMV0gKyBhWzddICogYlsxNV07XG5cbiAgcls4XSA9IGFbOF0gKiBiWzBdICsgYVs5XSAqIGJbNF0gKyBhWzEwXSAqIGJbOF0gKyBhWzExXSAqIGJbMTJdO1xuICByWzldID0gYVs4XSAqIGJbMV0gKyBhWzldICogYls1XSArIGFbMTBdICogYls5XSArIGFbMTFdICogYlsxM107XG4gIHJbMTBdID0gYVs4XSAqIGJbMl0gKyBhWzldICogYls2XSArIGFbMTBdICogYlsxMF0gKyBhWzExXSAqIGJbMTRdO1xuICByWzExXSA9IGFbOF0gKiBiWzNdICsgYVs5XSAqIGJbN10gKyBhWzEwXSAqIGJbMTFdICsgYVsxMV0gKiBiWzE1XTtcblxuICByWzEyXSA9IGFbMTJdICogYlswXSArIGFbMTNdICogYls0XSArIGFbMTRdICogYls4XSArIGFbMTVdICogYlsxMl07XG4gIHJbMTNdID0gYVsxMl0gKiBiWzFdICsgYVsxM10gKiBiWzVdICsgYVsxNF0gKiBiWzldICsgYVsxNV0gKiBiWzEzXTtcbiAgclsxNF0gPSBhWzEyXSAqIGJbMl0gKyBhWzEzXSAqIGJbNl0gKyBhWzE0XSAqIGJbMTBdICsgYVsxNV0gKiBiWzE0XTtcbiAgclsxNV0gPSBhWzEyXSAqIGJbM10gKyBhWzEzXSAqIGJbN10gKyBhWzE0XSAqIGJbMTFdICsgYVsxNV0gKiBiWzE1XTtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gIyMjIEdMLk1hdHJpeC5pZGVudGl0eShbcmVzdWx0XSlcbi8vXG4vLyBSZXR1cm5zIGFuIGlkZW50aXR5IG1hdHJpeC4gWW91IGNhbiBvcHRpb25hbGx5IHBhc3MgYW4gZXhpc3RpbmcgbWF0cml4IGluXG4vLyBgcmVzdWx0YCB0byBhdm9pZCBhbGxvY2F0aW5nIGEgbmV3IG1hdHJpeC4gVGhpcyBlbXVsYXRlcyB0aGUgT3BlbkdMIGZ1bmN0aW9uXG4vLyBgZ2xMb2FkSWRlbnRpdHkoKWAuXG5NYXRyaXguaWRlbnRpdHkgPSBmdW5jdGlvbihyZXN1bHQpIHtcbiAgcmVzdWx0ID0gcmVzdWx0IHx8IG5ldyBNYXRyaXgoKTtcbiAgdmFyIG0gPSByZXN1bHQubTtcbiAgbVswXSA9IG1bNV0gPSBtWzEwXSA9IG1bMTVdID0gMTtcbiAgbVsxXSA9IG1bMl0gPSBtWzNdID0gbVs0XSA9IG1bNl0gPSBtWzddID0gbVs4XSA9IG1bOV0gPSBtWzExXSA9IG1bMTJdID0gbVsxM10gPSBtWzE0XSA9IDA7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyAjIyMgR0wuTWF0cml4LnBlcnNwZWN0aXZlKGZvdiwgYXNwZWN0LCBuZWFyLCBmYXJbLCByZXN1bHRdKVxuLy9cbi8vIFJldHVybnMgYSBwZXJzcGVjdGl2ZSB0cmFuc2Zvcm0gbWF0cml4LCB3aGljaCBtYWtlcyBmYXIgYXdheSBvYmplY3RzIGFwcGVhclxuLy8gc21hbGxlciB0aGFuIG5lYXJieSBvYmplY3RzLiBUaGUgYGFzcGVjdGAgYXJndW1lbnQgc2hvdWxkIGJlIHRoZSB3aWR0aFxuLy8gZGl2aWRlZCBieSB0aGUgaGVpZ2h0IG9mIHlvdXIgdmlld3BvcnQgYW5kIGBmb3ZgIGlzIHRoZSB0b3AtdG8tYm90dG9tIGFuZ2xlXG4vLyBvZiB0aGUgZmllbGQgb2YgdmlldyBpbiBkZWdyZWVzLiBZb3UgY2FuIG9wdGlvbmFsbHkgcGFzcyBhbiBleGlzdGluZyBtYXRyaXhcbi8vIGluIGByZXN1bHRgIHRvIGF2b2lkIGFsbG9jYXRpbmcgYSBuZXcgbWF0cml4LiBUaGlzIGVtdWxhdGVzIHRoZSBPcGVuR0xcbi8vIGZ1bmN0aW9uIGBnbHVQZXJzcGVjdGl2ZSgpYC5cbk1hdHJpeC5wZXJzcGVjdGl2ZSA9IGZ1bmN0aW9uKGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIsIHJlc3VsdCkge1xuICB2YXIgeSA9IE1hdGgudGFuKGZvdiAqIE1hdGguUEkgLyAzNjApICogbmVhcjtcbiAgdmFyIHggPSB5ICogYXNwZWN0O1xuICByZXR1cm4gTWF0cml4LmZydXN0dW0oLXgsIHgsIC15LCB5LCBuZWFyLCBmYXIsIHJlc3VsdCk7XG59O1xuXG4vLyAjIyMgR0wuTWF0cml4LmZydXN0dW0obGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXJbLCByZXN1bHRdKVxuLy9cbi8vIFNldHMgdXAgYSB2aWV3aW5nIGZydXN0dW0sIHdoaWNoIGlzIHNoYXBlZCBsaWtlIGEgdHJ1bmNhdGVkIHB5cmFtaWQgd2l0aCB0aGVcbi8vIGNhbWVyYSB3aGVyZSB0aGUgcG9pbnQgb2YgdGhlIHB5cmFtaWQgd291bGQgYmUuIFlvdSBjYW4gb3B0aW9uYWxseSBwYXNzIGFuXG4vLyBleGlzdGluZyBtYXRyaXggaW4gYHJlc3VsdGAgdG8gYXZvaWQgYWxsb2NhdGluZyBhIG5ldyBtYXRyaXguIFRoaXMgZW11bGF0ZXNcbi8vIHRoZSBPcGVuR0wgZnVuY3Rpb24gYGdsRnJ1c3R1bSgpYC5cbk1hdHJpeC5mcnVzdHVtID0gZnVuY3Rpb24obCwgciwgYiwgdCwgbiwgZiwgcmVzdWx0KSB7XG4gIHJlc3VsdCA9IHJlc3VsdCB8fCBuZXcgTWF0cml4KCk7XG4gIHZhciBtID0gcmVzdWx0Lm07XG5cbiAgbVswXSA9IDIgKiBuIC8gKHIgLSBsKTtcbiAgbVsxXSA9IDA7XG4gIG1bMl0gPSAociArIGwpIC8gKHIgLSBsKTtcbiAgbVszXSA9IDA7XG5cbiAgbVs0XSA9IDA7XG4gIG1bNV0gPSAyICogbiAvICh0IC0gYik7XG4gIG1bNl0gPSAodCArIGIpIC8gKHQgLSBiKTtcbiAgbVs3XSA9IDA7XG5cbiAgbVs4XSA9IDA7XG4gIG1bOV0gPSAwO1xuICBtWzEwXSA9IC0oZiArIG4pIC8gKGYgLSBuKTtcbiAgbVsxMV0gPSAtMiAqIGYgKiBuIC8gKGYgLSBuKTtcblxuICBtWzEyXSA9IDA7XG4gIG1bMTNdID0gMDtcbiAgbVsxNF0gPSAtMTtcbiAgbVsxNV0gPSAwO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyAjIyMgR0wuTWF0cml4Lm9ydGhvKGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyWywgcmVzdWx0XSlcbi8vXG4vLyBSZXR1cm5zIGFuIG9ydGhvZ3JhcGhpYyBwcm9qZWN0aW9uLCBpbiB3aGljaCBvYmplY3RzIGFyZSB0aGUgc2FtZSBzaXplIG5vXG4vLyBtYXR0ZXIgaG93IGZhciBhd2F5IG9yIG5lYXJieSB0aGV5IGFyZS4gWW91IGNhbiBvcHRpb25hbGx5IHBhc3MgYW4gZXhpc3Rpbmdcbi8vIG1hdHJpeCBpbiBgcmVzdWx0YCB0byBhdm9pZCBhbGxvY2F0aW5nIGEgbmV3IG1hdHJpeC4gVGhpcyBlbXVsYXRlcyB0aGUgT3BlbkdMXG4vLyBmdW5jdGlvbiBgZ2xPcnRobygpYC5cbk1hdHJpeC5vcnRobyA9IGZ1bmN0aW9uKGwsIHIsIGIsIHQsIG4sIGYsIHJlc3VsdCkge1xuICByZXN1bHQgPSByZXN1bHQgfHwgbmV3IE1hdHJpeCgpO1xuICB2YXIgbSA9IHJlc3VsdC5tO1xuXG4gIG1bMF0gPSAyIC8gKHIgLSBsKTtcbiAgbVsxXSA9IDA7XG4gIG1bMl0gPSAwO1xuICBtWzNdID0gLShyICsgbCkgLyAociAtIGwpO1xuXG4gIG1bNF0gPSAwO1xuICBtWzVdID0gMiAvICh0IC0gYik7XG4gIG1bNl0gPSAwO1xuICBtWzddID0gLSh0ICsgYikgLyAodCAtIGIpO1xuXG4gIG1bOF0gPSAwO1xuICBtWzldID0gMDtcbiAgbVsxMF0gPSAtMiAvIChmIC0gbik7XG4gIG1bMTFdID0gLShmICsgbikgLyAoZiAtIG4pO1xuXG4gIG1bMTJdID0gMDtcbiAgbVsxM10gPSAwO1xuICBtWzE0XSA9IDA7XG4gIG1bMTVdID0gMTtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gIyMjIEdMLk1hdHJpeC5zY2FsZSh4LCB5LCB6WywgcmVzdWx0XSlcbi8vXG4vLyBUaGlzIGVtdWxhdGVzIHRoZSBPcGVuR0wgZnVuY3Rpb24gYGdsU2NhbGUoKWAuIFlvdSBjYW4gb3B0aW9uYWxseSBwYXNzIGFuXG4vLyBleGlzdGluZyBtYXRyaXggaW4gYHJlc3VsdGAgdG8gYXZvaWQgYWxsb2NhdGluZyBhIG5ldyBtYXRyaXguXG5NYXRyaXguc2NhbGUgPSBmdW5jdGlvbih4LCB5LCB6LCByZXN1bHQpIHtcbiAgcmVzdWx0ID0gcmVzdWx0IHx8IG5ldyBNYXRyaXgoKTtcbiAgdmFyIG0gPSByZXN1bHQubTtcblxuICBtWzBdID0geDtcbiAgbVsxXSA9IDA7XG4gIG1bMl0gPSAwO1xuICBtWzNdID0gMDtcblxuICBtWzRdID0gMDtcbiAgbVs1XSA9IHk7XG4gIG1bNl0gPSAwO1xuICBtWzddID0gMDtcblxuICBtWzhdID0gMDtcbiAgbVs5XSA9IDA7XG4gIG1bMTBdID0gejtcbiAgbVsxMV0gPSAwO1xuXG4gIG1bMTJdID0gMDtcbiAgbVsxM10gPSAwO1xuICBtWzE0XSA9IDA7XG4gIG1bMTVdID0gMTtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gIyMjIEdMLk1hdHJpeC50cmFuc2xhdGUoeCwgeSwgelssIHJlc3VsdF0pXG4vL1xuLy8gVGhpcyBlbXVsYXRlcyB0aGUgT3BlbkdMIGZ1bmN0aW9uIGBnbFRyYW5zbGF0ZSgpYC4gWW91IGNhbiBvcHRpb25hbGx5IHBhc3Ncbi8vIGFuIGV4aXN0aW5nIG1hdHJpeCBpbiBgcmVzdWx0YCB0byBhdm9pZCBhbGxvY2F0aW5nIGEgbmV3IG1hdHJpeC5cbk1hdHJpeC50cmFuc2xhdGUgPSBmdW5jdGlvbih4LCB5LCB6LCByZXN1bHQpIHtcbiAgcmVzdWx0ID0gcmVzdWx0IHx8IG5ldyBNYXRyaXgoKTtcbiAgdmFyIG0gPSByZXN1bHQubTtcblxuICBtWzBdID0gMTtcbiAgbVsxXSA9IDA7XG4gIG1bMl0gPSAwO1xuICBtWzNdID0geDtcblxuICBtWzRdID0gMDtcbiAgbVs1XSA9IDE7XG4gIG1bNl0gPSAwO1xuICBtWzddID0geTtcblxuICBtWzhdID0gMDtcbiAgbVs5XSA9IDA7XG4gIG1bMTBdID0gMTtcbiAgbVsxMV0gPSB6O1xuXG4gIG1bMTJdID0gMDtcbiAgbVsxM10gPSAwO1xuICBtWzE0XSA9IDA7XG4gIG1bMTVdID0gMTtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gIyMjIEdMLk1hdHJpeC5yb3RhdGUoYSwgeCwgeSwgelssIHJlc3VsdF0pXG4vL1xuLy8gUmV0dXJucyBhIG1hdHJpeCB0aGF0IHJvdGF0ZXMgYnkgYGFgIGRlZ3JlZXMgYXJvdW5kIHRoZSB2ZWN0b3IgYHgsIHksIHpgLlxuLy8gWW91IGNhbiBvcHRpb25hbGx5IHBhc3MgYW4gZXhpc3RpbmcgbWF0cml4IGluIGByZXN1bHRgIHRvIGF2b2lkIGFsbG9jYXRpbmdcbi8vIGEgbmV3IG1hdHJpeC4gVGhpcyBlbXVsYXRlcyB0aGUgT3BlbkdMIGZ1bmN0aW9uIGBnbFJvdGF0ZSgpYC5cbk1hdHJpeC5yb3RhdGUgPSBmdW5jdGlvbihhLCB4LCB5LCB6LCByZXN1bHQpIHtcbiAgaWYgKCFhIHx8ICgheCAmJiAheSAmJiAheikpIHtcbiAgICByZXR1cm4gTWF0cml4LmlkZW50aXR5KHJlc3VsdCk7XG4gIH1cblxuICByZXN1bHQgPSByZXN1bHQgfHwgbmV3IE1hdHJpeCgpO1xuICB2YXIgbSA9IHJlc3VsdC5tO1xuXG4gIHZhciBkID0gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeik7XG4gIGEgKj0gTWF0aC5QSSAvIDE4MDsgeCAvPSBkOyB5IC89IGQ7IHogLz0gZDtcbiAgdmFyIGMgPSBNYXRoLmNvcyhhKSwgcyA9IE1hdGguc2luKGEpLCB0ID0gMSAtIGM7XG5cbiAgbVswXSA9IHggKiB4ICogdCArIGM7XG4gIG1bMV0gPSB4ICogeSAqIHQgLSB6ICogcztcbiAgbVsyXSA9IHggKiB6ICogdCArIHkgKiBzO1xuICBtWzNdID0gMDtcblxuICBtWzRdID0geSAqIHggKiB0ICsgeiAqIHM7XG4gIG1bNV0gPSB5ICogeSAqIHQgKyBjO1xuICBtWzZdID0geSAqIHogKiB0IC0geCAqIHM7XG4gIG1bN10gPSAwO1xuXG4gIG1bOF0gPSB6ICogeCAqIHQgLSB5ICogcztcbiAgbVs5XSA9IHogKiB5ICogdCArIHggKiBzO1xuICBtWzEwXSA9IHogKiB6ICogdCArIGM7XG4gIG1bMTFdID0gMDtcblxuICBtWzEyXSA9IDA7XG4gIG1bMTNdID0gMDtcbiAgbVsxNF0gPSAwO1xuICBtWzE1XSA9IDE7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vICMjIyBHTC5NYXRyaXgubG9va0F0KGV4LCBleSwgZXosIGN4LCBjeSwgY3osIHV4LCB1eSwgdXpbLCByZXN1bHRdKVxuLy9cbi8vIFJldHVybnMgYSBtYXRyaXggdGhhdCBwdXRzIHRoZSBjYW1lcmEgYXQgdGhlIGV5ZSBwb2ludCBgZXgsIGV5LCBlemAgbG9va2luZ1xuLy8gdG93YXJkIHRoZSBjZW50ZXIgcG9pbnQgYGN4LCBjeSwgY3pgIHdpdGggYW4gdXAgZGlyZWN0aW9uIG9mIGB1eCwgdXksIHV6YC5cbi8vIFlvdSBjYW4gb3B0aW9uYWxseSBwYXNzIGFuIGV4aXN0aW5nIG1hdHJpeCBpbiBgcmVzdWx0YCB0byBhdm9pZCBhbGxvY2F0aW5nXG4vLyBhIG5ldyBtYXRyaXguIFRoaXMgZW11bGF0ZXMgdGhlIE9wZW5HTCBmdW5jdGlvbiBgZ2x1TG9va0F0KClgLlxuTWF0cml4Lmxvb2tBdCA9IGZ1bmN0aW9uKGV4LCBleSwgZXosIGN4LCBjeSwgY3osIHV4LCB1eSwgdXosIHJlc3VsdCkge1xuICByZXN1bHQgPSByZXN1bHQgfHwgbmV3IE1hdHJpeCgpO1xuICB2YXIgbSA9IHJlc3VsdC5tO1xuXG4gIHZhciBlID0gbmV3IFZlY3RvcihleCwgZXksIGV6KTtcbiAgdmFyIGMgPSBuZXcgVmVjdG9yKGN4LCBjeSwgY3opO1xuICB2YXIgdSA9IG5ldyBWZWN0b3IodXgsIHV5LCB1eik7XG4gIHZhciBmID0gZS5zdWJ0cmFjdChjKS51bml0KCk7XG4gIHZhciBzID0gdS5jcm9zcyhmKS51bml0KCk7XG4gIHZhciB0ID0gZi5jcm9zcyhzKS51bml0KCk7XG5cbiAgbVswXSA9IHMueDtcbiAgbVsxXSA9IHMueTtcbiAgbVsyXSA9IHMuejtcbiAgbVszXSA9IC1zLmRvdChlKTtcblxuICBtWzRdID0gdC54O1xuICBtWzVdID0gdC55O1xuICBtWzZdID0gdC56O1xuICBtWzddID0gLXQuZG90KGUpO1xuXG4gIG1bOF0gPSBmLng7XG4gIG1bOV0gPSBmLnk7XG4gIG1bMTBdID0gZi56O1xuICBtWzExXSA9IC1mLmRvdChlKTtcblxuICBtWzEyXSA9IDA7XG4gIG1bMTNdID0gMDtcbiAgbVsxNF0gPSAwO1xuICBtWzE1XSA9IDE7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTWF0cml4XG4iLCJjb25zdCBlbWl0X2Zsb2F0ID0gZnVuY3Rpb24oIGEgKSB7XG5cdGlmIChhICUgMSA9PT0gMClcblx0XHRyZXR1cm4gYS50b0ZpeGVkKCAxIClcblx0ZWxzZVxuXHRcdHJldHVybiBhXG59XG5cbmNvbnN0IEZsb2F0UHJvdG90eXBlID0ge1xuICB0eXBlOiAnZmxvYXQnLFxuXHRlbWl0KCkgeyByZXR1cm4gZW1pdF9mbG9hdCggdGhpcy54ICkgfSxcblx0ZW1pdF9kZWNsKCkgeyByZXR1cm4gXCJcIiB9XG59XG5cblxuY29uc3QgRmxvYXQgPSBmdW5jdGlvbiggeD0wICkge1xuICBjb25zdCBmID0gT2JqZWN0LmNyZWF0ZSggRmxvYXRQcm90b3R5cGUgKVxuICBmLnggPSB4XG4gIHJldHVybiBmXG59XG5cbm1vZHVsZS5leHBvcnRzID0gRmxvYXRcbiIsImNvbnN0IFNjZW5lTm9kZSA9IHJlcXVpcmUoICcuL3NjZW5lTm9kZS5qcycgKSxcbiAgICAgIHsgcGFyYW1fd3JhcCwgTWF0ZXJpYWxJRCB9ID0gcmVxdWlyZSggJy4vdXRpbHMuanMnICksXG4gICAgICB7IFZhciwgZmxvYXRfdmFyX2dlbiwgdmVjMl92YXJfZ2VuLCB2ZWMzX3Zhcl9nZW4sIHZlYzRfdmFyX2dlbiwgaW50X3Zhcl9nZW4sIFZhckFsbG9jIH0gPSByZXF1aXJlKCAnLi92YXIuanMnIClcblxuY29uc3QgeyBWZWMyLCBWZWMzLCBWZWM0IH0gPSByZXF1aXJlKCAnLi92ZWMuanMnIClcblxuY29uc3QgRm9nZ2VyID0gZnVuY3Rpb24oIFNjZW5lLCBTREYgKSB7XG5cbiAgY29uc3QgRm9nID0gZnVuY3Rpb24oIGFtb3VudD0wLjA1NSwgY29sb3IgKSB7XG4gICAgY29uc3QgZm9nID0gT2JqZWN0LmNyZWF0ZSggRm9nLnByb3RvdHlwZSApXG4gICAgY29uc3QgX19hbW91bnQgPSBwYXJhbV93cmFwKCBhbW91bnQsIGZsb2F0X3Zhcl9nZW4oIGFtb3VudCApICkgIFxuICAgIFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggZm9nLCAnYW1vdW50Jywge1xuICAgICAgZ2V0KCkgeyByZXR1cm4gX19hbW91bnQgfSxcbiAgICAgIHNldCggdiApIHtcbiAgICAgICAgX19hbW91bnQuc2V0KCB2IClcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgY29uc3QgX19jb2xvciA9IHBhcmFtX3dyYXAoIFZlYzMoY29sb3IpLCB2ZWMzX3Zhcl9nZW4oIDAsMCwwICkgKSAgXG4gICAgXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBmb2csICdjb2xvcicsIHtcbiAgICAgIGdldCgpIHsgcmV0dXJuIF9fY29sb3IgfSxcbiAgICAgIHNldCggdiApIHtcbiAgICAgICAgX19jb2xvci52YXIuc2V0KCB2IClcbiAgICAgIH1cbiAgICB9KVxuICAgIFxuICAgIC8vIHRoaXMgcmVmZXJzIHRvIHRoZSBjdXJyZW50IHNjZW5lIHZpYSBpbXBsaWNpdCBiaW5kaW5nIGluIHNjZW5lLmpzXG4gICAgdGhpcy5wb3N0cHJvY2Vzc2luZy5wdXNoKCBmb2cgKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIEZvZy5wcm90b3R5cGUgPSBTY2VuZU5vZGUoKVxuIFxuICBPYmplY3QuYXNzaWduKCBGb2cucHJvdG90eXBlLCB7XG4gICAgZW1pdCgpIHtcbiAgICAgIHJldHVybiBgICBjb2xvciA9IGFwcGx5Rm9nKCBjb2xvciwgdC54LCAke3RoaXMuYW1vdW50LmVtaXQoKX0gKTtgXG4gICAgfSxcbiAgIFxuICAgIGVtaXRfZGVjbCgpIHtcbiAgICAgIGxldCBzdHIgPSB0aGlzLmFtb3VudC5lbWl0X2RlY2woKSArIHRoaXMuY29sb3IuZW1pdF9kZWNsKClcbiAgICAgIGNvbnN0IHByZWZhY2UgPSBgICB2ZWMzIGFwcGx5Rm9nKCBpbiB2ZWMzIHJnYiwgaW4gZmxvYXQgZGlzdGFuY2UsIGluIGZsb2F0IGFtb3VudCApIHtcbiAgICBmbG9hdCBmb2dBbW91bnQgPSAxLiAtIGV4cCggLWRpc3RhbmNlICogYW1vdW50ICk7XG4gICAgdmVjMyAgZm9nQ29sb3IgID0gJHt0aGlzLmNvbG9yLmVtaXQoKX07XG4gICAgcmV0dXJuIG1peCggcmdiLCBmb2dDb2xvciwgZm9nQW1vdW50ICk7XG4gIH1cbiAgYFxuICAgICAgaWYoIFNERi5tZW1vLmZvZyA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICBzdHIgPSBzdHIgKyBwcmVmYWNlXG4gICAgICAgIFNERi5tZW1vLmZvZyA9IHRydWVcbiAgICAgIH1lbHNle1xuICAgICAgICBzdHIgPSAnJ1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RyXG4gICAgfSxcblxuICAgIHVwZGF0ZV9sb2NhdGlvbiggZ2wsIHByb2dyYW0gKSB7XG4gICAgICB0aGlzLmFtb3VudC51cGRhdGVfbG9jYXRpb24oIGdsLCBwcm9ncmFtIClcbiAgICAgIHRoaXMuY29sb3IudXBkYXRlX2xvY2F0aW9uKCBnbCwgcHJvZ3JhbSApXG4gICAgfSxcblxuICAgIHVwbG9hZF9kYXRhKCBnbCApIHtcbiAgICAgIHRoaXMuYW1vdW50LnVwbG9hZF9kYXRhKCBnbCApXG4gICAgICB0aGlzLmNvbG9yLnVwbG9hZF9kYXRhKCBnbCApXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiBGb2dcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBGb2dnZXJcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBNYXJjaGluZyA9IHJlcXVpcmUoICcuL21haW4uanMnIClcblxuTWFyY2hpbmcuX19leHBvcnQgPSBNYXJjaGluZy5leHBvcnRcbk1hcmNoaW5nLmV4cG9ydCA9IG9iaiA9PiB7XG4gIG9iai5tYXJjaCA9IE1hcmNoaW5nLmNyZWF0ZVNjZW5lLmJpbmQoIE1hcmNoaW5nIClcbiAgTWFyY2hpbmcuX19leHBvcnQoIG9iaiApXG59XG5cbndpbmRvdy5NYXJjaGluZyA9IE1hcmNoaW5nXG5cbm1vZHVsZS5leHBvcnRzID0gTWFyY2hpbmdcbiIsImNvbnN0IGVtaXRfaW50ID0gZnVuY3Rpb24oIGEgKSB7XG5cdGlmKCBhICUgMSAhPT0gMCApXG5cdFx0cmV0dXJuIE1hdGgucm91bmQoIGEgKVxuXHRlbHNlXG5cdFx0cmV0dXJuIGFcbn1cblxuY29uc3QgSW50UHJvdG90eXBlID0ge1xuICB0eXBlOiAnaW50Jyxcblx0ZW1pdCgpIHsgcmV0dXJuIGVtaXRfaW50KCB0aGlzLnggKSB9LFxuXHRlbWl0X2RlY2woKSB7IHJldHVybiBcIlwiIH1cbn1cblxuXG5jb25zdCBJbnQgPSBmdW5jdGlvbiggeD0wICkge1xuICBjb25zdCBmID0gT2JqZWN0LmNyZWF0ZSggSW50UHJvdG90eXBlIClcbiAgZi54ID0geFxuICByZXR1cm4gZlxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEludFxuIiwiY29uc3QgU2NlbmVOb2RlID0gcmVxdWlyZSggJy4vc2NlbmVOb2RlLmpzJyApLFxuICAgICAgeyBwYXJhbV93cmFwLCBNYXRlcmlhbElEIH0gPSByZXF1aXJlKCAnLi91dGlscy5qcycgKSxcbiAgICAgIHsgVmFyLCBmbG9hdF92YXJfZ2VuLCB2ZWMyX3Zhcl9nZW4sIHZlYzNfdmFyX2dlbiwgdmVjNF92YXJfZ2VuIH0gPSByZXF1aXJlKCAnLi92YXIuanMnICksXG4gICAgICB7IFZlYzIsIFZlYzMsIFZlYzQgfSA9IHJlcXVpcmUoICcuL3ZlYy5qcycgKVxuXG5jb25zdCBnbHNsID0gcmVxdWlyZSggJ2dsc2xpZnknIClcblxuY29uc3QgTGlnaHRzID0gZnVuY3Rpb24oIFNERiApIHtcblxuICBjb25zdCBMaWdodCA9IHtcbiAgICBsaWdodHM6W10sXG4gICAgbWF0ZXJpYWxzOltdLFxuXG4gICAgZGVmYXVsdExpZ2h0czpgXG4gICAgICBMaWdodCBsaWdodHNbMl0gPSBMaWdodFsyXShcbiAgICAgICAgTGlnaHQoIHZlYzMoIDIuLDIuLDMuICksICB2ZWMzKDAuMjUsMC4yNSwuMjUpLCAxLiApLFxuICAgICAgICBMaWdodCggdmVjMyggLTIuLDIuLDMuICksIHZlYzMoLjI1LDAuMjUsMC4yNSksIDEuIClcbiAgICAgICk7XG4gICAgYCxcblxuICAgIGRlZmF1bHRNYXRlcmlhbHM6YFxuICAgICAgTWF0ZXJpYWwgbWF0ZXJpYWxzWzJdID0gTWF0ZXJpYWxbMl0oXG4gICAgICAgIE1hdGVyaWFsKCAwLCB2ZWMzKCAxLiApLCB2ZWMzKDAuLDAuLDAuKSwgdmVjMygxLiksIDguLCBGcmVzbmVsKCAwLiwgMS4sIDIuKSwgMCApLFxuICAgICAgICBNYXRlcmlhbCggMCwgdmVjMyggMS4gKSwgdmVjMygxLiwwLiwwLiksIHZlYzMoMS4pLCA4LiwgRnJlc25lbCggMC4sIDEuLCAyLiksIDAgKVxuICAgICAgKTtcbiAgICBgLFxuXG4gICAgbGlnaHQoIF9fcG9zPVZlYzMoMiwyLDMpLCBfX2NvbG9yPVZlYzMoMCwwLDEpLCBhdHRlbnVhdGlvbj0xICkge1xuICAgICAgY29uc3QgbGlnaHQgPSB7IFxuICAgICAgICBfX2F0dGVudWF0aW9uOiBwYXJhbV93cmFwKCBhdHRlbnVhdGlvbiwgZmxvYXRfdmFyX2dlbiggMSApICksXG4gICAgICB9XG5cbiAgICAgIHBvcyA9IHR5cGVvZiBfX3BvcyA9PT0gJ251bWJlcicgPyBWZWMzKCBfX3BvcyApIDogX19wb3NcblxuICAgICAgY29uc3QgX192YXJwb3MgPSBwYXJhbV93cmFwKCBcbiAgICAgICAgcG9zLCBcbiAgICAgICAgdmVjM192YXJfZ2VuKCBbMiwyLDNdIClcbiAgICAgIClcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBsaWdodCwgJ3BvcycsIHtcbiAgICAgICAgZ2V0KCkgeyByZXR1cm4gX192YXJwb3MgfSxcbiAgICAgICAgc2V0KHYpIHtcbiAgICAgICAgICBpZiggdHlwZW9mIHYgPT09ICdvYmplY3QnICkge1xuICAgICAgICAgICAgX192YXJwb3Muc2V0KCB2IClcbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIF9fdmFycG9zLnZhbHVlLnggPSB2XG4gICAgICAgICAgICBfX3ZhcnBvcy52YWx1ZS55ID0gdlxuICAgICAgICAgICAgX192YXJwb3MudmFsdWUueiA9IHZcbiAgICAgICAgICAgIF9fdmFycG9zLmRpcnR5ID0gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSkgIFxuXG4gICAgICBjb2xvciA9IHR5cGVvZiBfX2NvbG9yID09PSAnbnVtYmVyJyA/IFZlYzMoIF9fY29sb3IgKSA6IF9fY29sb3JcblxuICAgICAgY29uc3QgX192YXJjb2wgPSBwYXJhbV93cmFwKCBcbiAgICAgICAgY29sb3IsIFxuICAgICAgICB2ZWMzX3Zhcl9nZW4oIFswLDAsMV0gKVxuICAgICAgKVxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIGxpZ2h0LCAnY29sb3InLCB7XG4gICAgICAgIGdldCgpIHsgcmV0dXJuIF9fdmFyY29sIH0sXG4gICAgICAgIHNldCh2KSB7XG4gICAgICAgICAgaWYoIHR5cGVvZiB2ID09PSAnb2JqZWN0JyApIHtcbiAgICAgICAgICAgIF9fdmFyY29sLnNldCggdiApXG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBfX3ZhcmNvbC52YWx1ZS54ID0gdlxuICAgICAgICAgICAgX192YXJjb2wudmFsdWUueSA9IHZcbiAgICAgICAgICAgIF9fdmFyY29sLnZhbHVlLnogPSB2XG4gICAgICAgICAgICBfX3ZhcmNvbC5kaXJ0eSA9IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pICBcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBsaWdodCwgJ2F0dGVudWF0aW9uJywge1xuICAgICAgICBnZXQoKSB7IHJldHVybiBsaWdodC5fX2F0dGVudWF0aW9uLnZhbHVlIH0sXG4gICAgICAgIHNldCh2KXtcbiAgICAgICAgICBsaWdodC5fX2F0dGVudWF0aW9uLnZhbHVlID0gdlxuICAgICAgICAgIGxpZ2h0Ll9fYXR0ZW51YXRpb24uZGlydHkgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIHJldHVybiBsaWdodFxuICAgIH0sXG5cbiAgICBlbWl0X2xpZ2h0cygpIHtcbiAgICAgIGlmKCB0aGlzLmxpZ2h0cy5sZW5ndGggPT09IDAgKSByZXR1cm4gdGhpcy5kZWZhdWx0TGlnaHRzXG5cbiAgICAgIGxldCBzdHIgPSBgTGlnaHQgbGlnaHRzWyR7dGhpcy5saWdodHMubGVuZ3RofV0gPSBMaWdodFske3RoaXMubGlnaHRzLmxlbmd0aH1dKGBcblxuICAgICAgZm9yKCBsZXQgbGlnaHQgb2YgdGhpcy5saWdodHMgKSB7XG4gICAgICAgIHN0ciArPSBgXFxuICAgICAgICBMaWdodCggJHtsaWdodC5wb3MuZW1pdCgpfSwgJHtsaWdodC5jb2xvci5lbWl0KCl9LCAke2xpZ2h0Ll9fYXR0ZW51YXRpb24uZW1pdCgpfSksYCBcbiAgICAgIH1cbiAgICAgIFxuICAgICAgc3RyID0gc3RyLnNsaWNlKDAsLTEpIC8vIHJlbW92ZSB0cmFpbGluZyBjb21tYVxuXG4gICAgICBzdHIgKz0gJ1xcbiAgICAgICk7J1xuXG4gICAgICByZXR1cm4gc3RyXG4gICAgfSxcblxuICAgIG1vZGU6J2dsb2JhbCcsXG5cbiAgICBnZW4oIHNoYWRvd3M9OCwgZ2VvbWV0cmllcyApIHtcbiAgICAgIC8vY29uc3Qgc3RyID0gdGhpcy5tb2Rlc1sgdGhpcy5tb2RlIF0oIHRoaXMubGlnaHRzLmxlbmd0aCB8fCAyLCB0aGlzLmVtaXRfbGlnaHRzKCksIFNERi5tYXRlcmlhbHMuZW1pdF9tYXRlcmlhbHMoKSwgc2hhZG93cyApXG4gICBcbiAgICAgIGNvbnN0IG1vZGVDb25zdGFudHMgPSBTREYubWF0ZXJpYWxzLm1vZGVDb25zdGFudHNcbiAgICAgIHRoaXMubW9kZXNFbXBsb3llZC5sZW5ndGggPSAwXG5cbiAgICAgIGxldCBsaWdodGluZ0Z1bmN0aW9ucyA9IFtdXG5cbiAgICAgIC8vIGxvb3AgdGhyb3VnaCBhbGwgbWF0ZXJpYWxzIHVzZWQgYW5kIGFkZCBjb3JyZXNwb25kaW5nIGxpZ2h0aW5nIGZ1bmN0aW9ucyBhcyBuZWVkZWRcbiAgICAgIGZvciggbGV0IG1hdCBvZiBTREYubWF0ZXJpYWxzLm1hdGVyaWFscyApIHtcbiAgICAgICAgaWYoIHRoaXMubW9kZXNFbXBsb3llZC5pbmRleE9mKCBtYXQubW9kZSApID09PSAtMSApIHtcbiAgICAgICAgICBsaWdodGluZ0Z1bmN0aW9ucy5wdXNoKCB0aGlzLm1vZGVzWyBtYXQubW9kZSBdKCkgKSAgXG5cbiAgICAgICAgICB0aGlzLm1vZGVzRW1wbG95ZWQucHVzaCggbWF0Lm1vZGUgKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIGFsbCBtb2RlcyB0byBzZWUgaWYgdGhleSdyZSBsaWdodGluZyBmdW5jdGlvbiBoYXMgYmVlbiBhZGRlZCB0byB0aGUgc2hhZGVyLFxuICAgICAgLy8gaWYgbm90LCBhZGQgdGhlaXIgZnVuY3Rpb24gc3R1YlxuICAgICAgZm9yKCBsZXQgbW9kZSBvZiBtb2RlQ29uc3RhbnRzICkge1xuICAgICAgICAvLyBrZXkgaXMgaXRlcmF0ZWQgYXMgc3RyaW5nLCBtdXN0IHVzZSBwYXJzZUludFxuICAgICAgICBpZiggdGhpcy5tb2Rlc0VtcGxveWVkLmluZGV4T2YoIG1vZGUgKSA9PT0gLTEgKSB7XG4gICAgICAgICAgbGlnaHRpbmdGdW5jdGlvbnMucHVzaCggdGhpcy5kZWZhdWx0RnVuY3Rpb25EZWNsYXJhdGlvbnNbIG1vZGVDb25zdGFudHMuaW5kZXhPZiggbW9kZSApIF0gKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRleHR1cmVzID0gTWFyY2hpbmcudGV4dHVyZXMuX19lbWl0RnVuY3Rpb24oKVxuICAgICAgY29uc3QgbGlnaHRpbmcgPSB0aGlzLnNoZWxsKCBcbiAgICAgICAgdGhpcy5saWdodHMubGVuZ3RoIHx8IDIsIFxuICAgICAgICB0aGlzLmVtaXRfbGlnaHRzKCksIFxuICAgICAgICBTREYubWF0ZXJpYWxzLmVtaXRfbWF0ZXJpYWxzKCksIFxuICAgICAgICBzaGFkb3dzLFxuICAgICAgICBnZW9tZXRyaWVzLCBcbiAgICAgICAgdGV4dHVyZXMuZ2xzbGRlZnMsXG4gICAgICAgIHRleHR1cmVzLm1haW5mdW5jXG4gICAgICApXG5cbiAgICAgIGxldCBsaWdodGluZ0Z1bmNTdHIgPSBsaWdodGluZ0Z1bmN0aW9ucy5qb2luKCdcXG4nKVxuICAgICAgbGlnaHRpbmdGdW5jU3RyID0gbGlnaHRpbmdGdW5jU3RyLnJlcGxhY2UoIC8oTUFYXFxfTElHSFRTKS9nLCB0aGlzLmxpZ2h0cy5sZW5ndGggfHwgMiApXG4gICAgICByZXR1cm4gbGlnaHRpbmdbMF0gKyBsaWdodGluZ0Z1bmNTdHIgKyBsaWdodGluZ1sxXVxuICAgIH0sXG5cbiAgICBlbWl0X2RlY2woKSB7XG4gICAgICBsZXQgc3RyID0gJydcbiAgICAgIGZvciggbGV0IGxpZ2h0IG9mIHRoaXMubGlnaHRzICkge1xuICAgICAgICBzdHIgKz0gbGlnaHQucG9zLmVtaXRfZGVjbCgpXG4gICAgICAgIHN0ciArPSBsaWdodC5jb2xvci5lbWl0X2RlY2woKVxuICAgICAgICBzdHIgKz0gbGlnaHQuX19hdHRlbnVhdGlvbi5lbWl0X2RlY2woKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RyXG4gICAgfSxcblxuICAgIHVwZGF0ZV9sb2NhdGlvbiggZ2wsIHByb2dyYW0gKSB7XG4gICAgICBmb3IoIGxldCBsaWdodCBvZiB0aGlzLmxpZ2h0cyApIHtcbiAgICAgICAgaWYoIGxpZ2h0LnBvcy5kaXJ0eSA9PT0gdHJ1ZSApICBsaWdodC5wb3MudXBkYXRlX2xvY2F0aW9uKCBnbCwgcHJvZ3JhbSApXG4gICAgICAgIGlmKCBsaWdodC5jb2xvci5kaXJ0eSA9PT0gdHJ1ZSApICBsaWdodC5jb2xvci51cGRhdGVfbG9jYXRpb24oIGdsLCBwcm9ncmFtIClcbiAgICAgICAgaWYoIGxpZ2h0Ll9fYXR0ZW51YXRpb24uZGlydHkgPT09IHRydWUgKSBsaWdodC5fX2F0dGVudWF0aW9uLnVwZGF0ZV9sb2NhdGlvbiggZ2wsIHByb2dyYW0gKVxuICAgICAgfVxuXG4gICAgfSxcblxuICAgIHVwbG9hZF9kYXRhKCBnbCwgcHJvZ3JhbT0nJyApIHtcbiAgICAgIGZvciggbGV0IGxpZ2h0IG9mIHRoaXMubGlnaHRzICkge1xuICAgICAgICBpZiggbGlnaHQucG9zLmRpcnR5ID09PSB0cnVlICkgICBsaWdodC5wb3MudXBsb2FkX2RhdGEoIGdsLCBwcm9ncmFtIClcbiAgICAgICAgaWYoIGxpZ2h0LmNvbG9yLmRpcnR5ID09PSB0cnVlICkgIGxpZ2h0LmNvbG9yLnVwbG9hZF9kYXRhKCBnbCwgcHJvZ3JhbSApXG4gICAgICAgIGlmKCBsaWdodC5fX2F0dGVudWF0aW9uLmRpcnR5ID09PSB0cnVlICkgIGxpZ2h0Ll9fYXR0ZW51YXRpb24udXBsb2FkX2RhdGEoIGdsLCBwcm9ncmFtIClcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgbW9kZXNFbXBsb3llZDpbXSxcblxuICAgIC8vIHRoZXNlIHN0dWJzIGFyZSBwbGFjZWQgaW4gdGhlIHNoYWRlciBieSBkZWZhdWx0IGFzIHBsYWNlaG9sZGVycyBzbyB0aGF0IHRoZXkgY2FuIGJlIHJlZmVyZW5jZWQgaW4gXG4gICAgLy8gYSBzd2l0Y2ggc3RhdGVtZW50IHNlbGVjdGluZyBsaWdodGluZy4gVGhleSBhcmUgb3ZlcnJpZGRlbiBieSBhY3R1YWwgbGlnaHRpbmcgZnVuY3Rpb25zIGlmIGFueVxuICAgIC8vIG1hdGVyaWFsIGluIHRoZSBzY2VuZSB1c2VzIGEgY29ycmVzcG9uZGluZyBmdW5jdGlvbi5cbiAgICBkZWZhdWx0RnVuY3Rpb25EZWNsYXJhdGlvbnM6IFtcbiAgICAgICcgICAgdmVjMyBnbG9iYWwoIHZlYzMgc3VyZmFjZVBvc2l0aW9uLCB2ZWMzIG5vcm1hbCwgdmVjMyByYXlPcmlnaW4sIHZlYzMgcmF5RGlyZWN0aW9uLCBNYXRlcmlhbCBtYXQsIExpZ2h0IGxpZ2h0c1tNQVhfTElHSFRTXSwgdmVjMyB0ZXh0dXJlQ29sb3IgKSB7IHJldHVybiB2ZWMzKDAuKTsgfScsXG4gICAgICAnICAgIHZlYzMgbm9ybWFsKCB2ZWMzIHN1cmZhY2VQb3NpdGlvbiwgdmVjMyBub3JtYWwsIHZlYzMgcmF5T3JpZ2luLCB2ZWMzIHJheURpcmVjdGlvbiwgTWF0ZXJpYWwgbWF0LCBMaWdodCBsaWdodHNbTUFYX0xJR0hUU10gKSB7IHJldHVybiB2ZWMzKDAuKTsgfScsXG4gICAgICAnICAgIHZlYzMgZGlyZWN0aW9uYWwoIHZlYzMgc3VyZmFjZVBvc2l0aW9uLCB2ZWMzIG5vcm1hbCwgdmVjMyByYXlPcmlnaW4sIHZlYzMgcmF5RGlyZWN0aW9uLCBNYXRlcmlhbCBtYXQsIExpZ2h0IGxpZ2h0c1tNQVhfTElHSFRTXSwgdmVjMyB0ZXh0dXJlQ29sb3IgKSB7IHJldHVybiB2ZWMzKDAuKTsgfScsXG4gICAgICAnICAgIHZlYzMgb3Jlbm4oIHZlYzMgc3VyZmFjZVBvc2l0aW9uLCB2ZWMzIG5vcm1hbCwgdmVjMyByYXlPcmlnaW4sIHZlYzMgcmF5RGlyZWN0aW9uLCBNYXRlcmlhbCBtYXQsIExpZ2h0IGxpZ2h0c1tNQVhfTElHSFRTXSApIHsgcmV0dXJuIHZlYzMoMC4pOyB9JyxcbiAgICBdLFxuXG4gICAgc2hlbGwoIG51bWxpZ2h0cywgbGlnaHRzLCBtYXRlcmlhbHMsIHNoYWRvdz0wLCBzZGZzLCB0ZXh0dXJlUHJlZmFjZSwgdGV4dHVyZUJvZHkgKSB7XG4gICAgICBjb25zdCBfX3NoYWRvdyA9IHNoYWRvdyA+IDBcbiAgICAgICAgPyBgZGlmZnVzZUNvZWZmaWNpZW50ICo9IHNvZnRzaGFkb3coIHN1cmZhY2VQb3NpdGlvbiwgbm9ybWFsaXplKCBsaWdodC5wb3NpdGlvbiApLCAwLjAyLCAyLjUsICR7c2hhZG93LnRvRml4ZWQoMSl9ICk7YCBcbiAgICAgICAgOiAnJ1xuXG5cbiAgICAgIGxldCBwcmVmYWNlID0gZ2xzbChbXCIjZGVmaW5lIEdMU0xJRlkgMVxcbiAgaW50IE1BWF9MSUdIVFMgPSBcIixcIjtcXG4gICAgZmxvYXQgYW8oIGluIHZlYzMgcG9zLCBpbiB2ZWMzIG5vciApe1xcbiAgICAgIGZsb2F0IG9jYyA9IDAuMDtcXG4gICAgICBmbG9hdCBzY2EgPSAxLjA7XFxuICAgICAgZm9yKCBpbnQgaT0wOyBpPDU7IGkrKyApXFxuICAgICAge1xcbiAgICAgICAgICBmbG9hdCBociA9IDAuMDEgKyAwLjEyICogZmxvYXQoIGkgKSAvIDQuMDtcXG4gICAgICAgICAgdmVjMyBhb3BvcyA9ICBub3IgKiBociArIHBvcztcXG4gICAgICAgICAgZmxvYXQgZGQgPSBzY2VuZSAoIGFvcG9zICkueDtcXG4gICAgICAgICAgb2NjICs9IC0oZGQtaHIpKnNjYTtcXG4gICAgICAgICAgc2NhICo9IDAuOTU7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBjbGFtcCggMS4wIC0gMy4wKm9jYywgMC4wLCAxLjAgKTsgICAgXFxuICAgIH1cXG5cXG4gICAgXFxuICAgIFwiLFwiXFxuICAgIFwiLFwiXFxuICAgIFwiLFwiXCJdLG51bWxpZ2h0cyx0ZXh0dXJlUHJlZmFjZSx0ZXh0dXJlQm9keSlcbiAgICAgIGxldCBmdW5jID0gYFxuXG4gICAgdmVjMyBsaWdodGluZyggdmVjMyBzdXJmYWNlUG9zaXRpb24sIHZlYzMgbm9ybWFsLCB2ZWMzIHJheU9yaWdpbiwgdmVjMyByYXlEaXJlY3Rpb24sIGZsb2F0IHNkZklELCBib29sIHVzZVRleHR1cmVUcmFuc2Zvcm0gKSB7XG4gICAgICAke3NkZnN9XG4gICAgICBTREYgc2RmID0gc2Rmc1sgaW50KCBzZGZJRCApIF07XG5cbiAgICAgICR7bWF0ZXJpYWxzfVxuICAgICAgTWF0ZXJpYWwgbWF0ID0gbWF0ZXJpYWxzWyBzZGYubWF0ZXJpYWxJRCBdO1xuXG4gICAgICBpbnQgTUFYX0xJR0hUUyA9ICR7bnVtbGlnaHRzfTsgICAgIFxuXG4gICAgICAke2xpZ2h0c31cbiBcbiAgICAgIHZlYzMgdGV4ID0gZ2V0VGV4dHVyZSggaW50KHNkZi50ZXh0dXJlSUQpLCBzdXJmYWNlUG9zaXRpb24sIG5vcm1hbCwgc2RmLCB1c2VUZXh0dXJlVHJhbnNmb3JtICk7XG5cbiAgICAgIHZlYzMgY2xyO1xuICAgICAgc3dpdGNoKCBtYXQubW9kZSApIHtcbiAgICAgICAgY2FzZSAwOiBjbHIgPSBnbG9iYWwoIHN1cmZhY2VQb3NpdGlvbiwgbm9ybWFsLCByYXlPcmlnaW4sIHJheURpcmVjdGlvbiwgbWF0LCBsaWdodHMsIHRleCApOyBicmVhaztcbiAgICAgICAgY2FzZSAxOiBjbHIgPSBub3JtYWw7IGJyZWFrO1xuICAgICAgICBjYXNlIDI6IGNsciA9IGRpcmVjdGlvbmFsKCBzdXJmYWNlUG9zaXRpb24sIG5vcm1hbCwgcmF5T3JpZ2luLCByYXlEaXJlY3Rpb24sIG1hdCwgbGlnaHRzLCB0ZXggKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogY2xyID0gb3Jlbm4oIHN1cmZhY2VQb3NpdGlvbiwgbm9ybWFsLCByYXlPcmlnaW4sIHJheURpcmVjdGlvbiwgbWF0LCBsaWdodHMgKTsgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY2xyID0gbm9ybWFsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2xyOyBcbiAgICB9XG5gXG4gICAgICByZXR1cm4gWyBwcmVmYWNlLCBmdW5jIF1cbiAgICB9LCBcblxuICAgIG1vZGVzOntcbiAgICAgIGdsb2JhbCgpIHtcbiAgICAgICAgY29uc3Qgc2hhZG93ID0gU0RGLl9fc2NlbmUuX19zaGFkb3dcblxuICAgICAgICBjb25zdCBzdHIgPSBnbHNsKFtcIiNkZWZpbmUgR0xTTElGWSAxXFxuXFxuXFxuICAgICAgICB2ZWMzIGdsb2JhbCggdmVjMyBwb3MsIHZlYzMgbm9yLCB2ZWMzIHJvLCB2ZWMzIHJkLCBNYXRlcmlhbCBtYXQsIExpZ2h0IGxpZ2h0c1tNQVhfTElHSFRTXSwgdmVjMyB0ZXh0dXJlQ29sb3IgKSB7XFxuICAgICAgICAgIExpZ2h0IGxpZ2h0ID0gbGlnaHRzWyAwIF07XFxuICAgICAgICAgIHZlYzMgIHJlZiA9IHJlZmxlY3QoIHJkLCBub3IgKTsgLy8gcmVmbGVjdGlvbiBhbmdsZVxcbiAgICAgICAgICBmbG9hdCBvY2MgPSBhbyggcG9zLCBub3IgKTtcXG4gICAgICAgICAgdmVjMyAgbGlnID0gbm9ybWFsaXplKCBsaWdodC5wb3NpdGlvbiApOyAvLyBsaWdodCBwb3NpdGlvblxcbiAgICAgICAgICBmbG9hdCBhbWIgPSBjbGFtcCggMC41ICsgMC41ICogbm9yLnksIDAuMCwgMS4wICk7XFxuICAgICAgICAgIGZsb2F0IGRpZiA9IGNsYW1wKCBkb3QoIG5vciwgbGlnICksIDAuMCwgMS4wICk7XFxuXFxuICAgICAgICAgIC8vIHNpbXVsYXRlZCBiYWNrbGlnaHRcXG4gICAgICAgICAgZmxvYXQgYmFjID0gY2xhbXAoIGRvdCggbm9yLCBub3JtYWxpemUoIHZlYzMoIC1saWcueCwgMC4wICwgLWxpZy56ICkpKSwgMC4wLCAxLjAgKSAqIGNsYW1wKCAxLjAtcG9zLnksIDAuMCAsMS4wICk7XFxuXFxuICAgICAgICAgIC8vIHNpbXVsYXRlZCBza3lkb21lIGxpZ2h0XFxuICAgICAgICAgIGZsb2F0IGRvbSA9IHNtb290aHN0ZXAoIC0wLjEsIDAuMSwgcmVmLnkgKTtcXG4gICAgICAgICAgZmxvYXQgZnJlID0gcG93KCBjbGFtcCggMS4wICsgZG90KCBub3IscmQgKSwwLjAsMS4wICksIDMuMCk7XFxuICAgICAgICAgIGZsb2F0IHNwZSA9IHBvdyggY2xhbXAoIGRvdCggcmVmLCBsaWcgKSwgMC4wLCAxLjAgKSwgOC4wICk7XFxuXFxuICAgICAgICAgIGRpZiAqPSBzb2Z0c2hhZG93KCBwb3MsIGxpZywgMC4wMiwgMi41LCBcIixcIiApO1xcbiAgICAgICAgICBkb20gKj0gc29mdHNoYWRvdyggcG9zLCByZWYsIDAuMDIsIDIuNSwgXCIsXCIgKTtcXG5cXG4gICAgICAgICAgdmVjMyBicmRmID0gdGV4dHVyZUNvbG9yOy8vdmVjMyggMC4wICk7XFxuICAgICAgICAgIGJyZGYgKz0gMS4yMCAqIGRpZiAqIHZlYzMoIDEuMDAsMC45MCwwLjYwICkgKiBtYXQuZGlmZnVzZSAqIGxpZ2h0LmNvbG9yO1xcbiAgICAgICAgICBicmRmICs9IDIuMjAgKiBzcGUgKiB2ZWMzKCAxLjAwLDAuOTAsMC42MCApICogZGlmICogbWF0LnNwZWN1bGFyICogbGlnaHQuY29sb3I7XFxuICAgICAgICAgIGJyZGYgKz0gMC4zMCAqIGFtYiAqIHZlYzMoIDAuNTAsMC43MCwxLjAwICkgKiBvY2MgKiBtYXQuYW1iaWVudCAqIGxpZ2h0LmNvbG9yO1xcbiAgICAgICAgICBicmRmICs9IDAuNDAgKiBkb20gKiB2ZWMzKCAwLjUwLDAuNzAsMS4wMCApO1xcbiAgICAgICAgICBicmRmICs9IDAuNzAgKiBiYWMgKiB2ZWMzKCAwLjI1ICk7XFxuICAgICAgICAgIGJyZGYgKz0gMC40MCAqIChmcmUgKiBsaWdodC5jb2xvcik7XFxuXFxuICAgICAgICAgIHJldHVybiBicmRmO1xcbiAgICAgICAgfVxcbiAgICAgICAgXCIsXCJcIl0sc2hhZG93LnRvRml4ZWQoMSksc2hhZG93LnRvRml4ZWQoMSkpXG5cbiAgICAgICAgcmV0dXJuIHN0clxuICAgICAgfSxcblxuICAgICAgcGhvbmcoIG51bWxpZ2h0cywgbGlnaHRzLCBtYXRlcmlhbHMgKSB7XG4gICAgICAgIGNvbnN0IHNoYWRvdyA9IFNERi5fX3NjZW5lLl9fc2hhZG93XG5cbiAgICAgICAgY29uc3QgX19zaGFkb3cgPSBzaGFkb3cgPiAwXG4gICAgICAgICAgPyBgZGlmZnVzZUNvZWZmaWNpZW50ICo9IHNvZnRzaGFkb3coIHN1cmZhY2VQb3NpdGlvbiwgbm9ybWFsaXplKCBsaWdodC5wb3NpdGlvbiApLCAwLjAyLCAyLjUsICR7c2hhZG93LnRvRml4ZWQoMSl9ICk7YCBcbiAgICAgICAgICA6ICcnXG5cbiAgICAgICAgY29uc3Qgc3RyID0gZ2xzbChbXCIjZGVmaW5lIEdMU0xJRlkgMVxcbiAgXFxuICAgICAgICBcXG4gICAgICAgIHZlYzMgZGlyZWN0aW9uYWwoIHZlYzMgc3VyZmFjZVBvc2l0aW9uLCB2ZWMzIG5vcm1hbCwgdmVjMyByYXlPcmlnaW4sIHZlYzMgcmF5RGlyZWN0aW9uLCBNYXRlcmlhbCBtYXQsIExpZ2h0IGxpZ2h0c1tNQVhfTElHSFRTXSwgdmVjMyB0ZXh0dXJlQ29sb3IgKSB7XFxuICAgICAgICAgIHZlYzMgIG91dHB1dENvbG9yICAgPSB0ZXh0dXJlQ29sb3I7Ly92ZWMzKCAwLiApO1xcbiAgIFxcbiAgICAgICAgICAvLyBhcHBsaWVzIHRvIGFsbCBsaWdodHNcXG4gICAgICAgICAgZmxvYXQgb2NjbHVzaW9uID0gYW8oIHN1cmZhY2VQb3NpdGlvbiwgbm9ybWFsICk7XFxuXFxuICAgICAgICAgIGZvciggaW50IGkgPSAwOyBpIDwgMjAwMDA7IGkrKyApIHtcXG4gICAgICAgICAgICBpZiggaSA+PSBNQVhfTElHSFRTICkgYnJlYWs7XFxuXFxuICAgICAgICAgICAgTGlnaHQgbGlnaHQgPSBsaWdodHNbIGkgXTtcXG5cXG4gICAgICAgICAgICB2ZWMzIHN1cmZhY2VUb0xpZ2h0RGlyZWN0aW9uID0gbm9ybWFsaXplKCBsaWdodC5wb3NpdGlvbiAtIHN1cmZhY2VQb3NpdGlvbiApO1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIC8vIGdldCBzaW1pbGFyaXR5IGJldHdlZW4gbm9ybWFsIGFuZCBkaXJlY3Rpb24gdG8gbGlnaHRcXG4gICAgICAgICAgICBmbG9hdCBkaWZmdXNlQ29lZmZpY2llbnQgPSBkb3QoIG5vcm1hbCwgc3VyZmFjZVRvTGlnaHREaXJlY3Rpb24gKTsgXFxuXFxuICAgICAgICAgICAgLy8gZ2V0IHJlZmxlY3Rpb24gYW5nbGUgZm9yIGxpZ2h0IHN0cmlraW5nIHN1cmZhY2VcXG4gICAgICAgICAgICB2ZWMzIGFuZ2xlT2ZSZWZsZWN0aW9uID0gcmVmbGVjdCggLXN1cmZhY2VUb0xpZ2h0RGlyZWN0aW9uLCBub3JtYWwgKTtcXG5cXG4gICAgICAgICAgICAvLyBzZWUgaWYgcmVmbGVjdGVkIGxpZ2h0IHRyYXZlbHMgdG8gY2FtZXJhIGFuZCBnZW5lcmF0ZSBjb2VmZmljaWVudCBhY2NvcmRpbmdseVxcbiAgICAgICAgICAgIGZsb2F0IHNwZWN1bGFyQW5nbGUgPSBjbGFtcCggZG90KCBhbmdsZU9mUmVmbGVjdGlvbiwgLXJheURpcmVjdGlvbiApLCAwLiwgMS4gKTtcXG4gICAgICAgICAgICBmbG9hdCBzcGVjdWxhckNvZWZmaWNpZW50ID0gcG93KCBzcGVjdWxhckFuZ2xlLCBtYXQuc2hpbmluZXNzICk7XFxuXFxuICAgICAgICAgICAgLy8gbGlnaHRzIHNob3VsZCBoYXZlIGFuIGF0dGVudWF0aW9uIGZhY3RvclxcbiAgICAgICAgICAgIGZsb2F0IGF0dGVudWF0aW9uID0gMS4gLyAoIGxpZ2h0LmF0dGVudWF0aW9uICogcG93KCBsZW5ndGgoIGxpZ2h0LnBvc2l0aW9uIC0gc3VyZmFjZVBvc2l0aW9uICksIDIuICkgKTsgXFxuXFxuICAgICAgICAgICAgLy8gYmlhcywgc2NhbGUsIHBvd2VyXFxuICAgICAgICAgICAgZmxvYXQgZnJlc25lbCA9IG1hdC5mcmVzbmVsLnggKyBtYXQuZnJlc25lbC55ICogcG93KCAxLjAgKyBkb3QoIHJheURpcmVjdGlvbiwgbm9ybWFsICksIG1hdC5mcmVzbmVsLnogKTsgXFxuXFxuICAgICAgICAgICAgXCIsXCJcXG5cXG4gICAgICAgICAgICB2ZWMzIGNvbG9yID0gdmVjMyggMC4gKTtcXG4gICAgICAgICAgICBjb2xvciArPSAxLjIgKiBkaWZmdXNlQ29lZmZpY2llbnQgKiBtYXQuZGlmZnVzZSAqIGxpZ2h0LmNvbG9yO1xcbiAgICAgICAgICAgIGNvbG9yICs9IDIuMiAqIHNwZWN1bGFyQ29lZmZpY2llbnQgKiBtYXQuc3BlY3VsYXIgKiBsaWdodC5jb2xvcjtcXG4gICAgICAgICAgICBjb2xvciArPSAwLjMgKiAobWF0LmFtYmllbnQgKiBsaWdodC5jb2xvcikgKiBvY2NsdXNpb247XFxuICAgICAgICAgICAgY29sb3IgKz0gKGZyZXNuZWwgKiBsaWdodC5jb2xvcik7XFxuXFxuICAgICAgICAgICAgLy8gdGV4dHVyZVxcbiAgICAgICAgICAgIC8vY29sb3IgKj0gdGV4dHVyZUNvbG9yLnh5ejtcXG5cXG4gICAgICAgICAgICAvLyBnYW1tYSBjb3JyZWN0aW9uIG11c3Qgb2NjdXIgYmVmb3JlIGxpZ2h0IGF0dGVudWF0aW9uXFxuICAgICAgICAgICAgLy8gd2hpY2ggbWVhbnMgaXQgbXVzdCBiZSBhcHBsaWVkIG9uIGEgcGVyLWxpZ2h0IGJhc2lzIHVuZm9ydHVuYXRlbHlcXG4gICAgICAgICAgICB2ZWMzIGdhbW1hQ29ycmVjdGVkQ29sb3IgPSBwb3coIGNvbG9yLCB2ZWMzKCAxLi8yLjIgKSApO1xcbiAgICAgICAgICAgIHZlYzMgYXR0ZW51YXRlZENvbG9yID0gMi4gKiBnYW1tYUNvcnJlY3RlZENvbG9yICogYXR0ZW51YXRpb247IFxcblxcbiAgICAgICAgICAgIG91dHB1dENvbG9yICs9IGF0dGVudWF0ZWRDb2xvcjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICByZXR1cm4gb3V0cHV0Q29sb3I7XFxuICAgICAgICB9XFxuICAgICAgICBcIixcIlwiXSxfX3NoYWRvdylcblxuICAgICAgICByZXR1cm4gc3RyXG4gICAgICB9LCBcbiAgICAgIHBob25nVCggbnVtbGlnaHRzLCBsaWdodHMsIG1hdGVyaWFscyApIHtcbiAgICAgICAgY29uc3Qgc2hhZG93ID0gU0RGLl9fc2NlbmUuX19zaGFkb3dcblxuICAgICAgICBjb25zdCBfX3NoYWRvdyA9IHNoYWRvdyA+IDBcbiAgICAgICAgICA/IGBkaWZmdXNlQ29lZmZpY2llbnQgKj0gc29mdHNoYWRvdyggc3VyZmFjZVBvc2l0aW9uLCBub3JtYWxpemUoIGxpZ2h0LnBvc2l0aW9uICksIDAuMDIsIDIuNSwgJHtzaGFkb3cudG9GaXhlZCgxKX0gKTtgIFxuICAgICAgICAgIDogJydcblxuICAgICAgICBjb25zdCBzdHIgPSBnbHNsKFtcIiNkZWZpbmUgR0xTTElGWSAxXFxuICBcXG5cXG4gICAgICAgIHZlYzMgZGlyZWN0aW9uYWwoIHZlYzMgc3VyZmFjZVBvc2l0aW9uLCB2ZWMzIG5vcm1hbCwgdmVjMyByYXlPcmlnaW4sIHZlYzMgcmF5RGlyZWN0aW9uLCBNYXRlcmlhbCBtYXQsIExpZ2h0IGxpZ2h0c1tNQVhfTElHSFRTXSApIHtcXG4gICAgICAgICAgdmVjMyAgb3V0cHV0Q29sb3IgICA9IHZlYzMoIDAuICk7XFxuICAgXFxuICAgICAgICAgIC8vIGFwcGxpZXMgdG8gYWxsIGxpZ2h0c1xcbiAgICAgICAgICBmbG9hdCBvY2NsdXNpb24gPSBhbyggc3VyZmFjZVBvc2l0aW9uLCBub3JtYWwgKTtcXG5cXG4gICAgICAgICAgdmVjNCB0ZXh0dXJlQ29sb3I7XFxuICAgICAgICAgIGlmKCBtYXQudGV4dHVyZUlEID4gLTEgKSB7XFxuICAgICAgICAgICAgLy90ZXh0dXJlQ29sb3IgPSB0ZXhjdWJlKCB0ZXh0dXJlc1sgbWF0LnRleHR1cmVJRCBdLCBzdXJmYWNlUG9zaXRpb24sIG5vcm1hbCwgMS4gKTsvL3RleHR1cmUoIHRleHR1cmVzWyBtYXQudGV4dHVyZUlEIF0sIHN1cmZhY2VQb3NpdGlvbi54eSAtIG5vcm1hbC54eSApOyBcXG4gICAgICAgICAgICB2ZWMyIHV2ID0gZ2V0VVZDdWJpYyggc3VyZmFjZVBvc2l0aW9uLCB2ZWMzKDAuKSApOy8vc3VyZmFjZVBvc2l0aW9uLnh6KnZlYzIoMC4wMywwLjA3KTtcXG4gICAgICAgICAgICB0ZXh0dXJlQ29sb3IgPSB0ZXh0dXJlKCB0ZXh0dXJlc1sgbWF0LnRleHR1cmVJRCBdLCB1diApO1xcbiAgICAgICAgICB9ZWxzZXtcXG4gICAgICAgICAgICB0ZXh0dXJlQ29sb3IgPSB2ZWM0KDAuKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBvdXRwdXRDb2xvciA9IDA7Ly90ZXh0dXJlQ29sb3IueHl6O1xcblxcbiAgICAgICAgICBmb3IoIGludCBpID0gMDsgaSA8IDIwMDAwOyBpKysgKSB7XFxuICAgICAgICAgICAgaWYoIGkgPj0gTUFYX0xJR0hUUyApIGJyZWFrO1xcblxcbiAgICAgICAgICAgIExpZ2h0IGxpZ2h0ID0gbGlnaHRzWyBpIF07XFxuXFxuICAgICAgICAgICAgdmVjMyBzdXJmYWNlVG9MaWdodERpcmVjdGlvbiA9IG5vcm1hbGl6ZSggbGlnaHQucG9zaXRpb24gLSBzdXJmYWNlUG9zaXRpb24gKTtcXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICAvLyBnZXQgc2ltaWxhcml0eSBiZXR3ZWVuIG5vcm1hbCBhbmQgZGlyZWN0aW9uIHRvIGxpZ2h0XFxuICAgICAgICAgICAgZmxvYXQgZGlmZnVzZUNvZWZmaWNpZW50ID0gZG90KCBub3JtYWwsIHN1cmZhY2VUb0xpZ2h0RGlyZWN0aW9uICk7IFxcblxcbiAgICAgICAgICAgIC8vIGdldCByZWZsZWN0aW9uIGFuZ2xlIGZvciBsaWdodCBzdHJpa2luZyBzdXJmYWNlXFxuICAgICAgICAgICAgdmVjMyBhbmdsZU9mUmVmbGVjdGlvbiA9IHJlZmxlY3QoIC1zdXJmYWNlVG9MaWdodERpcmVjdGlvbiwgbm9ybWFsICk7XFxuXFxuICAgICAgICAgICAgLy8gc2VlIGlmIHJlZmxlY3RlZCBsaWdodCB0cmF2ZWxzIHRvIGNhbWVyYSBhbmQgZ2VuZXJhdGUgY29lZmZpY2llbnQgYWNjb3JkaW5nbHlcXG4gICAgICAgICAgICBmbG9hdCBzcGVjdWxhckFuZ2xlID0gY2xhbXAoIGRvdCggYW5nbGVPZlJlZmxlY3Rpb24sIC1yYXlEaXJlY3Rpb24gKSwgMC4sIDEuICk7XFxuICAgICAgICAgICAgZmxvYXQgc3BlY3VsYXJDb2VmZmljaWVudCA9IHBvdyggc3BlY3VsYXJBbmdsZSwgbWF0LnNoaW5pbmVzcyApO1xcblxcbiAgICAgICAgICAgIC8vIGxpZ2h0cyBzaG91bGQgaGF2ZSBhbiBhdHRlbnVhdGlvbiBmYWN0b3JcXG4gICAgICAgICAgICBmbG9hdCBhdHRlbnVhdGlvbiA9IDEuIC8gKCBsaWdodC5hdHRlbnVhdGlvbiAqIHBvdyggbGVuZ3RoKCBsaWdodC5wb3NpdGlvbiAtIHN1cmZhY2VQb3NpdGlvbiApLCAyLiApICk7IFxcblxcbiAgICAgICAgICAgIC8vIGJpYXMsIHNjYWxlLCBwb3dlclxcbiAgICAgICAgICAgIGZsb2F0IGZyZXNuZWwgPSBtYXQuZnJlc25lbC54ICsgbWF0LmZyZXNuZWwueSAqIHBvdyggMS4wICsgZG90KCByYXlEaXJlY3Rpb24sIG5vcm1hbCApLCBtYXQuZnJlc25lbC56ICk7IFxcblxcbiAgICAgICAgICAgIFwiLFwiXFxuXFxuICAgICAgICAgICAgdmVjMyBjb2xvciA9IHZlYzMoIDAuICk7XFxuICAgICAgICAgICAgY29sb3IgKz0gMS4yICogZGlmZnVzZUNvZWZmaWNpZW50ICogdGV4dHVyZUNvbG9yLnh5eiAqIGxpZ2h0LmNvbG9yO1xcbiAgICAgICAgICAgIGNvbG9yICs9IDIuMiAqIHNwZWN1bGFyQ29lZmZpY2llbnQgKiB0ZXh0dXJlQ29sb3IueHl6ICogbGlnaHQuY29sb3I7XFxuICAgICAgICAgICAgY29sb3IgKz0gMC4zICogKG1hdC5hbWJpZW50ICogbGlnaHQuY29sb3IpICogb2NjbHVzaW9uO1xcbiAgICAgICAgICAgIGNvbG9yICs9IChmcmVzbmVsICogbGlnaHQuY29sb3IpO1xcblxcbiAgICAgICAgICAgIC8vIHRleHR1cmVcXG4gICAgICAgICAgICAvL2NvbG9yICo9IHRleHR1cmVDb2xvci54eXo7XFxuXFxuICAgICAgICAgICAgLy8gZ2FtbWEgY29ycmVjdGlvbiBtdXN0IG9jY3VyIGJlZm9yZSBsaWdodCBhdHRlbnVhdGlvblxcbiAgICAgICAgICAgIC8vIHdoaWNoIG1lYW5zIGl0IG11c3QgYmUgYXBwbGllZCBvbiBhIHBlci1saWdodCBiYXNpcyB1bmZvcnR1bmF0ZWx5XFxuICAgICAgICAgICAgdmVjMyBnYW1tYUNvcnJlY3RlZENvbG9yID0gcG93KCBjb2xvciwgdmVjMyggMS4vMi4yICkgKTtcXG4gICAgICAgICAgICB2ZWMzIGF0dGVudWF0ZWRDb2xvciA9IDIuICogZ2FtbWFDb3JyZWN0ZWRDb2xvciAqIGF0dGVudWF0aW9uOyBcXG5cXG4gICAgICAgICAgICBvdXRwdXRDb2xvciArPSBhdHRlbnVhdGVkQ29sb3I7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcmV0dXJuIG91dHB1dENvbG9yO1xcbiAgICAgICAgfVxcbiAgICAgICAgXCIsXCJcIl0sX19zaGFkb3cpXG5cbiAgICAgICAgcmV0dXJuIHN0clxuICAgICAgfSwgXG5cblxuICAgICAgb3Jlbm4oIG51bWxpZ2h0cywgbGlnaHRzLCBtYXRlcmlhbHMgKSB7XG4gICAgICAgIGNvbnN0IHNoYWRvdyA9IFNERi5fX3NjZW5lLl9fc2hhZG93XG4gICAgICAgIGNvbnN0IF9fc2hhZG93ID0gc2hhZG93ID4gMFxuICAgICAgICAgID8gYGRpZmZ1c2VDb2VmZmljaWVudCAqPSBzb2Z0c2hhZG93KCBzdXJmYWNlUG9zaXRpb24sIG5vcm1hbGl6ZSggbGlnaHQucG9zaXRpb24gKSwgMC4wMiwgMi41LCAke3NoYWRvdy50b0ZpeGVkKDEpfSApO2AgXG4gICAgICAgICAgOiAnJ1xuXG4gICAgICAgIGNvbnN0IHN0ciA9IGdsc2woW1wiI2RlZmluZSBHTFNMSUZZIDFcXG4gIFxcbiAgICAgICAgZmxvYXQgb3Jlbk5heWFyRGlmZnVzZShcXG4gIHZlYzMgbGlnaHREaXJlY3Rpb24sXFxuICB2ZWMzIHZpZXdEaXJlY3Rpb24sXFxuICB2ZWMzIHN1cmZhY2VOb3JtYWwsXFxuICBmbG9hdCByb3VnaG5lc3MsXFxuICBmbG9hdCBhbGJlZG8pIHtcXG4gIFxcbiAgZmxvYXQgTGRvdFYgPSBkb3QobGlnaHREaXJlY3Rpb24sIHZpZXdEaXJlY3Rpb24pO1xcbiAgZmxvYXQgTmRvdEwgPSBkb3QobGlnaHREaXJlY3Rpb24sIHN1cmZhY2VOb3JtYWwpO1xcbiAgZmxvYXQgTmRvdFYgPSBkb3Qoc3VyZmFjZU5vcm1hbCwgdmlld0RpcmVjdGlvbik7XFxuXFxuICBmbG9hdCBzID0gTGRvdFYgLSBOZG90TCAqIE5kb3RWO1xcbiAgZmxvYXQgdCA9IG1peCgxLjAsIG1heChOZG90TCwgTmRvdFYpLCBzdGVwKDAuMCwgcykpO1xcblxcbiAgZmxvYXQgc2lnbWEyID0gcm91Z2huZXNzICogcm91Z2huZXNzO1xcbiAgZmxvYXQgQSA9IDEuMCArIHNpZ21hMiAqIChhbGJlZG8gLyAoc2lnbWEyICsgMC4xMykgKyAwLjUgLyAoc2lnbWEyICsgMC4zMykpO1xcbiAgZmxvYXQgQiA9IDAuNDUgKiBzaWdtYTIgLyAoc2lnbWEyICsgMC4wOSk7XFxuXFxuICByZXR1cm4gYWxiZWRvICogbWF4KDAuMCwgTmRvdEwpICogKEEgKyBCICogcyAvIHQpIC8gMy4xNDE1OTI2NTtcXG59XFxuXFxuICAgICAgICBmbG9hdCBnYXVzc2lhblNwZWN1bGFyKFxcbiAgdmVjMyBsaWdodERpcmVjdGlvbixcXG4gIHZlYzMgdmlld0RpcmVjdGlvbixcXG4gIHZlYzMgc3VyZmFjZU5vcm1hbCxcXG4gIGZsb2F0IHNoaW5pbmVzcykge1xcbiAgdmVjMyBIID0gbm9ybWFsaXplKGxpZ2h0RGlyZWN0aW9uICsgdmlld0RpcmVjdGlvbik7XFxuICBmbG9hdCB0aGV0YSA9IGFjb3MoZG90KEgsIHN1cmZhY2VOb3JtYWwpKTtcXG4gIGZsb2F0IHcgPSB0aGV0YSAvIHNoaW5pbmVzcztcXG4gIHJldHVybiBleHAoLXcqdyk7XFxufVxcblxcbiAgICAgICAgdmVjMyBvcmVubiggdmVjMyBzdXJmYWNlUG9zaXRpb24sIHZlYzMgbm9ybWFsLCB2ZWMzIHJheU9yaWdpbiwgdmVjMyByYXlEaXJlY3Rpb24sIE1hdGVyaWFsIG1hdCwgTGlnaHQgbGlnaHRzW01BWF9MSUdIVFNdICkge1xcbiAgICAgICAgICB2ZWMzICBvdXRwdXRDb2xvciAgID0gdmVjMyggMC4gKTtcXG4gICBcXG4gICAgICAgICAgLy8gYXBwbGllcyB0byBhbGwgbGlnaHRzXFxuICAgICAgICAgIGZsb2F0IG9jY2x1c2lvbiA9IGFvKCBzdXJmYWNlUG9zaXRpb24sIG5vcm1hbCApO1xcblxcbiAgICAgICAgICBmb3IoIGludCBpID0gMDsgaSA8IDIwMDAwOyBpKysgKSB7XFxuICAgICAgICAgICAgaWYoIGkgPj0gTUFYX0xJR0hUUyApIGJyZWFrO1xcblxcbiAgICAgICAgICAgIExpZ2h0IGxpZ2h0ID0gbGlnaHRzWyBpIF07XFxuXFxuICAgICAgICAgICAgdmVjMyBzdXJmYWNlVG9MaWdodERpcmVjdGlvbiA9IG5vcm1hbGl6ZSggbGlnaHQucG9zaXRpb24gLSBzdXJmYWNlUG9zaXRpb24gKTtcXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICAvLyBnZXQgc2ltaWxhcml0eSBiZXR3ZWVuIG5vcm1hbCBhbmQgZGlyZWN0aW9uIHRvIGxpZ2h0XFxuICAgICAgICAgICAgZmxvYXQgZGlmZnVzZUNvZWZmaWNpZW50ID0gb3Jlbk5heWFyRGlmZnVzZSggc3VyZmFjZVRvTGlnaHREaXJlY3Rpb24sIC1yYXlEaXJlY3Rpb24sIG5vcm1hbCwgMC4xNSwgNC4wKTtcXG5cXG4gICAgICAgICAgICAvLyBnZXQgcmVmbGVjdGlvbiBhbmdsZSBmb3IgbGlnaHQgc3RyaWtpbmcgc3VyZmFjZVxcbiAgICAgICAgICAgIHZlYzMgYW5nbGVPZlJlZmxlY3Rpb24gPSByZWZsZWN0KCAtc3VyZmFjZVRvTGlnaHREaXJlY3Rpb24sIG5vcm1hbCApO1xcblxcbiAgICAgICAgICAgIC8vIHNlZSBpZiByZWZsZWN0ZWQgbGlnaHQgdHJhdmVscyB0byBjYW1lcmEgYW5kIGdlbmVyYXRlIGNvZWZmaWNpZW50IGFjY29yZGluZ2x5XFxuICAgICAgICAgICAgZmxvYXQgc3BlY3VsYXJBbmdsZSA9IGNsYW1wKCBkb3QoIGFuZ2xlT2ZSZWZsZWN0aW9uLCAtcmF5RGlyZWN0aW9uICksIDAuLCAxLiApO1xcbiAgICAgICAgICAgIGZsb2F0IHNwZWN1bGFyQ29lZmZpY2llbnQgPSBnYXVzc2lhblNwZWN1bGFyKCBzdXJmYWNlVG9MaWdodERpcmVjdGlvbiwgLXJheURpcmVjdGlvbiwgbm9ybWFsLCAuNSApOyBcXG5cXG4gICAgICAgICAgICAvLyBsaWdodHMgc2hvdWxkIGhhdmUgYW4gYXR0ZW51YXRpb24gZmFjdG9yXFxuICAgICAgICAgICAgZmxvYXQgYXR0ZW51YXRpb24gPSAxLiAvICggbGlnaHQuYXR0ZW51YXRpb24gKiBwb3coIGxlbmd0aCggbGlnaHQucG9zaXRpb24gLSBzdXJmYWNlUG9zaXRpb24gKSwgMi4gKSApOyBcXG5cXG4gICAgICAgICAgICBmbG9hdCBmcmVzbmVsID0gbWF0LmZyZXNuZWwueCArIG1hdC5mcmVzbmVsLnkgKiBwb3coIDEuMCArIGRvdCggcmF5RGlyZWN0aW9uLCBub3JtYWwgKSwgbWF0LmZyZXNuZWwueiApOyBcXG5cXG4gICAgICAgICAgICBcIixcIlxcblxcbiAgICAgICAgICAgIHZlYzMgY29sb3IgPSB2ZWMzKCAwLiApO1xcbiAgICAgICAgICAgIGNvbG9yICs9IDEuMiAqIGRpZmZ1c2VDb2VmZmljaWVudCAqIG1hdC5kaWZmdXNlICogbGlnaHQuY29sb3I7XFxuICAgICAgICAgICAgY29sb3IgKz0gMi4yICogc3BlY3VsYXJDb2VmZmljaWVudCAqIG1hdC5zcGVjdWxhciAqIGxpZ2h0LmNvbG9yO1xcbiAgICAgICAgICAgIGNvbG9yICs9IDAuMyAqIChtYXQuYW1iaWVudCAqIGxpZ2h0LmNvbG9yKSAqIG9jY2x1c2lvbjtcXG4gICAgICAgICAgICBjb2xvciArPSAoZnJlc25lbCAqIGxpZ2h0LmNvbG9yKTtcXG5cXG4gICAgICAgICAgICAvLyBnYW1tYSBjb3JyZWN0aW9uIG11c3Qgb2NjdXIgYmVmb3JlIGxpZ2h0IGF0dGVudWF0aW9uXFxuICAgICAgICAgICAgLy8gd2hpY2ggbWVhbnMgaXQgbXVzdCBiZSBhcHBsaWVkIG9uIGEgcGVyLWxpZ2h0IGJhc2lzIHVuZm9ydHVuYXRlbHlcXG4gICAgICAgICAgICB2ZWMzIGdhbW1hQ29ycmVjdGVkQ29sb3IgPSBwb3coIGNvbG9yLCB2ZWMzKCAxLi8yLjIgKSApO1xcbiAgICAgICAgICAgIHZlYzMgYXR0ZW51YXRlZENvbG9yID0gMi4gKiBnYW1tYUNvcnJlY3RlZENvbG9yICogYXR0ZW51YXRpb247IFxcblxcbiAgICAgICAgICAgIG91dHB1dENvbG9yICs9IGF0dGVudWF0ZWRDb2xvcjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICByZXR1cm4gb3V0cHV0Q29sb3I7XFxuICAgICAgICB9XCIsXCJcIl0sX19zaGFkb3cpXG5cbiAgICAgICAgcmV0dXJuIHN0clxuICAgICAgfSwgXG5cblxuICAgICAgZ2xvYmFsX3NhdmUoIG51bWxpZ2h0cywgbGlnaHRzLCBtYXRlcmlhbHMsIHNoYWRvdz0nJyApIHtcbiAgICAgICAgY29uc3Qgc3RyID0gZ2xzbChbXCIjZGVmaW5lIEdMU0xJRlkgMVxcblxcbiAgICAgICAgZmxvYXQgYW8oIGluIHZlYzMgcG9zLCBpbiB2ZWMzIG5vciApXFxue1xcblxcdGZsb2F0IG9jYyA9IDAuMDtcXG4gICAgZmxvYXQgc2NhID0gMS4wO1xcbiAgICBmb3IoIGludCBpPTA7IGk8NTsgaSsrIClcXG4gICAge1xcbiAgICAgICAgZmxvYXQgaHIgPSAwLjAxICsgMC4xMiAqIGZsb2F0KCBpICkgLyA0LjA7XFxuICAgICAgICB2ZWMzIGFvcG9zID0gIG5vciAqIGhyICsgcG9zO1xcbiAgICAgICAgZmxvYXQgZGQgPSBzY2VuZSAoIGFvcG9zICkueDtcXG4gICAgICAgIG9jYyArPSAtKGRkLWhyKSpzY2E7XFxuICAgICAgICBzY2EgKj0gMC45NTtcXG4gICAgfVxcbiAgICByZXR1cm4gY2xhbXAoIDEuMCAtIDMuMCpvY2MsIDAuMCwgMS4wICk7ICAgIFxcbn1cXG5cXG4gICAgICAgIFwiLFwiXFxuXFxuICAgICAgICBcIixcIlxcblxcbiAgICAgICAgdmVjMyBsaWdodGluZyggdmVjMyBwb3MsIHZlYzMgbm9yLCB2ZWMzIHJvLCB2ZWMzIHJkLCBmbG9hdCBtYXRlcmlhbElEICkge1xcbiAgICAgICAgICBMaWdodCBsaWdodCA9IGxpZ2h0c1sgMCBdO1xcbiAgICAgICAgICB2ZWMzICByZWYgPSByZWZsZWN0KCByZCwgbm9yICk7IC8vIHJlZmxlY3Rpb24gYW5nbGVcXG4gICAgICAgICAgZmxvYXQgb2NjID0gYW8oIHBvcywgbm9yICk7XFxuICAgICAgICAgIHZlYzMgIGxpZyA9IG5vcm1hbGl6ZSggbGlnaHQucG9zaXRpb24gKTsgLy8gbGlnaHQgcG9zaXRpb25cXG4gICAgICAgICAgZmxvYXQgYW1iID0gY2xhbXAoIDAuNSArIDAuNSAqIG5vci55LCAwLjAsIDEuMCApO1xcbiAgICAgICAgICBmbG9hdCBkaWYgPSBjbGFtcCggZG90KCBub3IsIGxpZyApLCAwLjAsIDEuMCApO1xcblxcbiAgICAgICAgICAvLyBzaW11bGF0ZWQgYmFja2xpZ2h0XFxuICAgICAgICAgIGZsb2F0IGJhYyA9IGNsYW1wKCBkb3QoIG5vciwgbm9ybWFsaXplKCB2ZWMzKCAtbGlnLngsIDAuMCAsIC1saWcueiApKSksIDAuMCwgMS4wICkgKiBjbGFtcCggMS4wLXBvcy55LCAwLjAgLDEuMCApO1xcblxcbiAgICAgICAgICAvLyBzaW11bGF0ZWQgc2t5ZG9tZSBsaWdodFxcbiAgICAgICAgICBmbG9hdCBkb20gPSBzbW9vdGhzdGVwKCAtMC4xLCAwLjEsIHJlZi55ICk7XFxuICAgICAgICAgIGZsb2F0IGZyZSA9IHBvdyggY2xhbXAoIDEuMCArIGRvdCggbm9yLHJkICksMC4wLDEuMCApLCAyLjAgKTtcXG4gICAgICAgICAgZmxvYXQgc3BlID0gcG93KCBjbGFtcCggZG90KCByZWYsIGxpZyApLCAwLjAsIDEuMCApLCA4LjAgKTtcXG5cXG4gICAgICAgICAgZGlmICo9IHNvZnRzaGFkb3coIHBvcywgbGlnLCAwLjAyLCAyLjUsIDguICk7XFxuICAgICAgICAgIGRvbSAqPSBzb2Z0c2hhZG93KCBwb3MsIHJlZiwgMC4wMiwgMi41LCA4LiApO1xcblxcbiAgICAgICAgICBNYXRlcmlhbCBtYXQgPSBtYXRlcmlhbHNbIGludChtYXRlcmlhbElEKSBdO1xcblxcbiAgICAgICAgICB2ZWMzIGJyZGYgPSB2ZWMzKCAwLjAgKTtcXG4gICAgICAgICAgYnJkZiArPSAxLjIwICogZGlmICogdmVjMyggMS4wMCwwLjkwLDAuNjAgKSAqIG1hdC5kaWZmdXNlICogbGlnaHQuY29sb3I7XFxuICAgICAgICAgIGJyZGYgKz0gMi4yMCAqIHNwZSAqIHZlYzMoIDEuMDAsMC45MCwwLjYwICkgKiBkaWYgKiBtYXQuc3BlY3VsYXIgKiBsaWdodC5jb2xvcjtcXG4gICAgICAgICAgYnJkZiArPSAwLjMwICogYW1iICogdmVjMyggMC41MCwwLjcwLDEuMDAgKSAqIG9jYyAqIG1hdC5hbWJpZW50ICogbGlnaHQuY29sb3I7XFxuICAgICAgICAgIGJyZGYgKz0gMC40MCAqIGRvbSAqIHZlYzMoIDAuNTAsMC43MCwxLjAwICkgKiBvY2M7XFxuICAgICAgICAgIGJyZGYgKz0gMC43MCAqIGJhYyAqIHZlYzMoIDAuMjUgKSAqIG9jYztcXG4gICAgICAgICAgYnJkZiArPSAwLjQwICogKGZyZSAqIGxpZ2h0LmNvbG9yKSAqIG9jYztcXG5cXG4gICAgICAgICAgcmV0dXJuIGJyZGY7XFxuICAgICAgICB9XCIsXCJcIl0sbWF0ZXJpYWxzLGxpZ2h0cylcblxuICAgICAgICByZXR1cm4gc3RyXG5cbiAgICAgIH0sXG5cbiAgICAgIG5vcm1hbCgpIHsgcmV0dXJuICcnIH0sXG4gICAgICBub2lzZSgpIHsgcmV0dXJuICcnIH1cbiAgICB9LFxuICB9XG5cbiAgcmV0dXJuIExpZ2h0XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTGlnaHRzXG5cbi8vIG9sZCBsaWdodGluZ1xuLypcbiovXG4iLCJjb25zdCBNUCAgID0gcmVxdWlyZSggJy4uL25vZGVfbW9kdWxlcy9tZXJnZS1wYXNzL2Rpc3QvaW5kZXguanMnIClcclxuY29uc3QgU0RGID0ge1xyXG4gIGNhbWVyYTogICAgICAgICAgIHJlcXVpcmUoICcuL2NhbWVyYS5qcycgKSxcclxuICBfX3ByaW1pdGl2ZXM6ICAgICByZXF1aXJlKCAnLi9wcmltaXRpdmVzLmpzJyApLFxyXG4gIHZlY3RvcnM6ICAgICAgICAgIHJlcXVpcmUoICcuL3ZlYy5qcycgKSxcclxuICBkaXN0YW5jZU9wczogICAgICByZXF1aXJlKCAnLi9kaXN0YW5jZU9wZXJhdGlvbnMuanMnICksXHJcbiAgYWx0ZXJhdGlvbnM6ICAgICAgcmVxdWlyZSggJy4vYWx0ZXJhdGlvbnMuanMnICksXHJcbiAgZGlzdGFuY2VEZWZvcm1zOiAgcmVxdWlyZSggJy4vZGlzdGFuY2VEZWZvcm1hdGlvbnMuanMnICksXHJcbiAgX19kb21haW5PcHM6ICAgICAgcmVxdWlyZSggJy4vZG9tYWluT3BlcmF0aW9ucy5qcycgKSxcclxuICBfX25vaXNlOiAgICAgICAgICByZXF1aXJlKCAnLi9ub2lzZS5qcycgKSxcclxuICBfX3NjZW5lOiAgICAgICAgICByZXF1aXJlKCAnLi9zY2VuZS5qcycgKSxcclxuICBfX2xpZ2h0aW5nOiAgICAgICByZXF1aXJlKCAnLi9saWdodGluZy5qcycgKSxcclxuICBfX21hdGVyaWFsczogICAgICByZXF1aXJlKCAnLi9tYXRlcmlhbC5qcycgKSxcclxuICBfX3RleHR1cmVzOiAgICAgICByZXF1aXJlKCAnLi90ZXh0dXJlLmpzJyApLFxyXG4gIFZhcjogICAgICAgICAgICAgIHJlcXVpcmUoICcuL3Zhci5qcycgKS5WYXIsXHJcbiAgLy9Db2xvcjogICAgICAgICAgICByZXF1aXJlKCAnLi9jb2xvci5qcycgKSxcclxuICBGRlQ6ICAgICAgICAgICAgICByZXF1aXJlKCAnLi9hdWRpby5qcycgKSxcclxuXHJcbiAgLy8gYSBmdW5jdGlvbiB0aGF0IGdlbmVyYXRlcyB0aGUgZnJhZ21lbnQgc2hhZGVyXHJcbiAgcmVuZGVyRnJhZ21lbnRTaGFkZXI6IHJlcXVpcmUoICcuL3JlbmRlckZyYWdtZW50U2hhZGVyLmpzJyApLFxyXG5cclxuICAvLyBhZGRpdGlvbmFsIGNhbGxiYWNrcyB0aGF0IGFyZSBydW4gb25jZSBwZXIgZnJhbWVcclxuICBjYWxsYmFja3M6IFtdLFxyXG4gIGdlb21ldHJpZXM6IFtdLFxyXG5cclxuICAvLyB0aGUgbWFpbiBkcmF3aW5nIGNhbGxiYWNrXHJcbiAgcmVuZGVyOiBudWxsLFxyXG5cclxuICAvLyB0aGUgc2NlbmUgaXMgYSBjaGFpbiBvZiBVbmlvbnMgY29tYmluaW5nIGFsbCBlbGVtZW50cyB0b2dldGhlclxyXG4gIHNjZW5lOiAgbnVsbCxcclxuXHJcbiAgLy8gYSBzcGVlZCBvZiAxIGNvcnJlc3BvbmRzIHRvIDYwIGZwcy5cclxuICBkZWxheTogMCxcclxuICBfX2lzUGF1c2VkOmZhbHNlLFxyXG5cclxuICBkZWZhdWx0VmVydGV4U291cmNlOmAgICAgI3ZlcnNpb24gMzAwIGVzXHJcbiAgICBpbiB2ZWMzIGFfcG9zO1xyXG5cdFx0aW4gdmVjMiBhX3V2O1xyXG5cdFx0b3V0IHZlYzIgdl91djtcclxuXHJcblx0XHR2b2lkIG1haW4oKSB7XHJcblx0XHRcdHZfdXYgPSBhX3V2O1xyXG5cdFx0XHRnbF9Qb3NpdGlvbiA9IHZlYzQoYV9wb3MsIDEuMCk7XHJcbiAgICB9YFxyXG4gICxcclxuXHJcbiAgZXhwb3J0KCBvYmogKSB7XHJcbiAgICBPYmplY3QuYXNzaWduKCBcclxuICAgICAgb2JqLCBcclxuICAgICAgdGhpcy5wcmltaXRpdmVzLFxyXG4gICAgICB0aGlzLnZlY3RvcnMsXHJcbiAgICAgIHRoaXMuZGlzdGFuY2VPcHMsXHJcbiAgICAgIHRoaXMuZG9tYWluT3BzLFxyXG4gICAgICB0aGlzLmRpc3RhbmNlRGVmb3JtcyxcclxuICAgICAgdGhpcy5hbHRlcmF0aW9uc1xyXG4gICAgKVxyXG5cclxuICAgIG9iai5MaWdodCA9IHRoaXMuTGlnaHRcclxuICAgIG9iai5NYXRlcmlhbCA9IHRoaXMuTWF0ZXJpYWxcclxuICAgIG9iai5UZXh0dXJlICA9IHRoaXMuVGV4dHVyZVxyXG4gICAgb2JqLmNhbWVyYSA9IHRoaXMuY2FtZXJhXHJcbiAgICBvYmouY2FsbGJhY2tzID0gdGhpcy5jYWxsYmFja3MgLy8gWFhYIHJlbW92ZSBvbmNlIEFQSSBzdG9wcyB1c2luZyBjYWxsYmFja3NcclxuICAgIG9iai5GRlQgPSB0aGlzLkZGVFxyXG4gIH0sXHJcblxyXG4gIGluaXQoIGNhbnZhcywgc2hvdWxkSW5pdCA9IGZhbHNlICkge1xyXG4gICAgdGhpcy5wcmltaXRpdmVzID0gdGhpcy5fX3ByaW1pdGl2ZXMoIHRoaXMgKVxyXG4gICAgdGhpcy5TY2VuZSAgICAgID0gdGhpcy5fX3NjZW5lKCB0aGlzIClcclxuICAgIHRoaXMuZG9tYWluT3BzICA9IHRoaXMuX19kb21haW5PcHMoIHRoaXMgKVxyXG4gICAgdGhpcy5ub2lzZSAgICAgPSB0aGlzLl9fbm9pc2UoIHRoaXMgKVxyXG4gICAgdGhpcy5leHBvcnQoIHRoaXMgKVxyXG5cclxuICAgIHRoaXMuY2FudmFzID0gY2FudmFzLy9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxyXG4gICAgdGhpcy5jYW52YXNNUCA9IGNhbnZhc1xyXG5cclxuICAgIHRoaXMubGlnaHRpbmcgICA9IHRoaXMuX19saWdodGluZyggdGhpcyApXHJcbiAgICB0aGlzLkxpZ2h0ID0gdGhpcy5saWdodGluZy5saWdodFxyXG4gICAgdGhpcy5tYXRlcmlhbHMgID0gdGhpcy5fX21hdGVyaWFscyggdGhpcyApXHJcbiAgICB0aGlzLk1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbHMubWF0ZXJpYWxcclxuICAgIHRoaXMudGV4dHVyZXMgPSB0aGlzLl9fdGV4dHVyZXMoIHRoaXMgKVxyXG4gICAgdGhpcy5UZXh0dXJlID0gdGhpcy50ZXh0dXJlcy50ZXh0dXJlXHJcblxyXG4gICAgdGhpcy5jYW52YXMud2lkdGggPSB0aGlzLmNhbnZhc01QLndpZHRoID0gd2luZG93LmlubmVyV2lkdGggXHJcbiAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSB0aGlzLmNhbnZhc01QLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodFxyXG4gICAgdGhpcy5nbCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoICd3ZWJnbDInLCB7IGFudGlhbGlhczp0cnVlLCBhbHBoYTp0cnVlIH0pXHJcbiAgICAvL3RoaXMuZ2xNUCA9IHRoaXMuY2FudmFzTVAuZ2V0Q29udGV4dCggJ3dlYmdsMicsIHsgYW50aWFsaWFzOnRydWUsIGFscGhhOnRydWUgfSlcclxuICB9LFxyXG4gIC8vIGdlbmVyYXRlIHNoYWRlcnMsIGluaXRpYWxpemUgY2FtZXJhLCBzdGFydCByZW5kZXJpbmcgbG9vcCBcclxuICBjcmVhdGVTY2VuZSggLi4uYXJncyApIHtcclxuICAgIGNvbnN0IHNjZW5lID0gdGhpcy5TY2VuZSggYXJncywgdGhpcy5jYW52YXMgKVxyXG5cclxuICAgIHRoaXMucmVxdWlyZWRHZW9tZXRyaWVzID0gW11cclxuICAgIHRoaXMucmVxdWlyZWRPcHMgPSBbXVxyXG4gICAgdGhpcy5tZW1vID0ge31cclxuXHJcbiAgICByZXR1cm4gc2NlbmVcclxuICB9LFxyXG5cclxuICBzdGFydCggZnMsIHdpZHRoLCBoZWlnaHQsIHNob3VsZEFuaW1hdGUgKSB7XHJcbiAgICBpZiggdGhpcy5yZW5kZXIgIT09IG51bGwgKSB0aGlzLnJlbmRlci5ydW5uaW5nID0gZmFsc2VcclxuXHJcbiAgICB0aGlzLmZzID0gZnNcclxuICAgIHRoaXMuY2FsbGJhY2tzLmxlbmd0aCA9IDBcclxuXHJcbiAgICB0aGlzLnJlbmRlciA9IHRoaXMuaW5pdFdlYkdMKCB0aGlzLmRlZmF1bHRWZXJ0ZXhTb3VyY2UsIGZzLCB3aWR0aCwgaGVpZ2h0LCBzaG91bGRBbmltYXRlIClcclxuICAgIHRoaXMucmVuZGVyLnJ1bm5pbmcgPSB0cnVlXHJcblxyXG4gICAgdGhpcy5jYW1lcmEuaW5pdCggdGhpcy5nbCwgdGhpcy5wcm9ncmFtLCBjYiA9PiB7IFxyXG4gICAgICB0aGlzLmNhbGxiYWNrcy5wdXNoKCBjYiApXHJcbiAgICB9KVxyXG5cclxuICAgIHNldFRpbWVvdXQoICgpPT4gdGhpcy5yZW5kZXIoIDAuMCApLCAwIClcclxuICB9LFxyXG5cclxuICBnZW5lcmF0ZVNERiggX19zY2VuZSApIHtcclxuICAgIGxldCBzY2VuZSA9IHsgcHJlZmFjZTonJyB9XHJcblxyXG4gICAgLyogaWYgdGhlcmUgaXMgbW9yZSB0aGFuIG9uZSBvYmplY3QgaW4gb3VyIHNjZW5lLCBjaGFpbiBwYWlycyBvZiBvYmplY3RzXHJcbiAgICAgICBpbiBVbmlvbnMuIFNvLCBnaXZlbiBvYmplY3RzIGEsYixjLCBhbmQgZCBjcmVhdGU6XHJcblxyXG4gICAgICAgVW5pb24oIGEsIFVuaW9uKCBiLCBVbmlvbiggYyxkICkgKSApXHJcblxyXG4gICAgICAgLi4uIG9yIHNvbWV0aGluZyBsaWtlIHRoYXQuIElmIHRoZXJlIGlzIG9ubHkgYSBzaW5nbGUgb2JqZWN0LFxyXG4gICAgICAgdXNlIHRoYXQgb2JqZWN0IGFzIHRoZSBlbnRpcmUgc2NlbmUuXHJcbiAgICAgKi9cclxuXHJcbiAgICBsZXQgb2JqcyA9IF9fc2NlbmUub2Jqc1xyXG4gICAgaWYoIG9ianMubGVuZ3RoID4gMSApIHtcclxuICAgICAgLy8gcmVkdWNlIG9iamVjdHMgdG8gbmVzdGVkIFVuaW9uc1xyXG4gICAgICBzY2VuZS5vdXRwdXQgPSBvYmpzLnJlZHVjZSggKCBjdXJyZW50LCBuZXh0ICkgPT4gdGhpcy5VbmlvbiggY3VycmVudCwgbmV4dCApIClcclxuICAgIH1lbHNle1xyXG4gICAgICBzY2VuZS5vdXRwdXQgPSBvYmpzWzBdXHJcbiAgICB9XHJcblxyXG4gICAgLy8gY3JlYXRlIGFuIGZhbmN5IGVtaXQoKSBmdW5jdGlvbiB0aGF0IHdyYXBzIHRoZSBzY2VuZVxyXG4gICAgLy8gd2l0aCBhbiBpZCAjLlxyXG5cclxuICAgIHNjZW5lLm91dHB1dC5fX2VtaXQgPSBzY2VuZS5vdXRwdXQuZW1pdC5iaW5kKCBzY2VuZS5vdXRwdXQgKVxyXG4gICAgc2NlbmUub3V0cHV0LmVtaXQgPSBmdW5jdGlvbiggLi4uYXJncyApIHtcclxuICAgICAgY29uc3QgZW1pdHRlZCA9IHNjZW5lLm91dHB1dC5fX2VtaXQoLi4uYXJncylcclxuICAgICAgY29uc3Qgb3V0cHV0ID0ge1xyXG4gICAgICAgIG91dDogICAgIGVtaXR0ZWQub3V0LFxyXG4gICAgICAgIHByZWZhY2U6IGVtaXR0ZWQucHJlZmFjZSB8fCAnJyBcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIG91dHB1dCBcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLnNjZW5lID0gc2NlbmUub3V0cHV0XHJcblxyXG4gICAgbGV0IHZhcmlhYmxlc0RlY2xhcmF0aW9uID0gc2NlbmUub3V0cHV0LmVtaXRfZGVjbCgpXHJcbiAgICBjb25zdCBzY2VuZVJlbmRlcmluZyA9IHNjZW5lLm91dHB1dC5lbWl0KClcclxuXHJcbiAgICAvLyBmb2cgZXRjLiBtYXliZSBtc2FhP1xyXG4gICAgbGV0IHBwID0gJydcclxuICAgIGZvciggbGV0IHByb2Nlc3NvciBvZiBfX3NjZW5lLnBvc3Rwcm9jZXNzaW5nICkge1xyXG4gICAgICBwcCArPSBwcm9jZXNzb3IuZW1pdCgpXHJcbiAgICAgIHZhcmlhYmxlc0RlY2xhcmF0aW9uICs9IHByb2Nlc3Nvci5lbWl0X2RlY2woKVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICB0aGlzLnBvc3Rwcm9jZXNzaW5nID0gX19zY2VuZS5wb3N0cHJvY2Vzc2luZ1xyXG5cclxuICAgIHJldHVybiBbIHZhcmlhYmxlc0RlY2xhcmF0aW9uLCBzY2VuZVJlbmRlcmluZywgcHAgXVxyXG4gIH0sXHJcblxyXG5cdGNvbXBpbGUoIHR5cGUsIHNvdXJjZSApIHtcclxuICAgIGNvbnN0IGdsID0gdGhpcy5nbFxyXG5cclxuXHRcdGNvbnN0IHNoYWRlciA9IHRoaXMuc2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKCB0eXBlICk7XHJcblx0XHRnbC5zaGFkZXJTb3VyY2UoIHNoYWRlciwgc291cmNlIClcclxuXHRcdGdsLmNvbXBpbGVTaGFkZXIoIHNoYWRlciApXHJcblxyXG5cdFx0aWYoIGdsLmdldFNoYWRlclBhcmFtZXRlciggc2hhZGVyLCBnbC5DT01QSUxFX1NUQVRVUykgIT09IHRydWUgKSB7XHJcblx0XHRcdGxldCBsb2cgPSBnbC5nZXRTaGFkZXJJbmZvTG9nKCBzaGFkZXIgKVxyXG5cdFx0XHRnbC5kZWxldGVTaGFkZXIoIHNoYWRlciApXHJcblxyXG5cdFx0XHRjb25zb2xlLmxvZyggc291cmNlIClcclxuXHRcdFx0Y29uc29sZS5sb2coIGxvZyApXHJcblxyXG5cdFx0XHRyZXR1cm4gbnVsbFxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBzaGFkZXJcclxuXHR9LFxyXG5cclxuICBjcmVhdGVQcm9ncmFtKCB2c19zb3VyY2UsIGZzX3NvdXJjZSApIHtcclxuICAgIGNvbnN0IGdsID0gdGhpcy5nbFxyXG5cdFx0Y29uc3QgdnMgPSB0aGlzLmNvbXBpbGUoIGdsLlZFUlRFWF9TSEFERVIsIHZzX3NvdXJjZSApXHJcblx0XHRjb25zdCBmcyA9IHRoaXMuY29tcGlsZSggZ2wuRlJBR01FTlRfU0hBREVSLCBmc19zb3VyY2UgKVxyXG5cclxuXHRcdGlmKCBudWxsID09PSB2cyB8fCBudWxsID09PSBmcyApIHJldHVybiBudWxsXHJcblxyXG5cdFx0Y29uc3QgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKVxyXG5cdFx0Z2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCB2cyApXHJcblx0XHRnbC5hdHRhY2hTaGFkZXIoIHByb2dyYW0sIGZzIClcclxuXHRcdGdsLmxpbmtQcm9ncmFtKCBwcm9ncmFtIClcclxuXHJcblx0XHRpZiggZ2wuZ2V0UHJvZ3JhbVBhcmFtZXRlciggcHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMgKSAhPT0gdHJ1ZSApe1xyXG5cdFx0XHRjb25zdCBsb2cgPSBnbC5nZXRQcm9ncmFtSW5mb0xvZyggcHJvZ3JhbSApXHJcblx0XHRcdGdsLmRlbGV0ZVNoYWRlcih2cylcclxuXHRcdFx0Z2wuZGVsZXRlU2hhZGVyKGZzKVxyXG5cdFx0XHRnbC5kZWxldGVQcm9ncmFtKHByb2dyYW0pXHJcblxyXG5cdFx0XHRjb25zb2xlLmVycm9yKCBsb2cgKVxyXG5cdFx0XHRyZXR1cm4gbnVsbFxyXG5cdFx0fVxyXG5cclxuICAgIGNvbnN0IGRyYXdQcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpXHJcbiAgICBjb25zdCBmcmFnU291cmNlID0gYCAjdmVyc2lvbiAzMDAgZXNcclxuICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcclxuXHJcbiAgdW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XHJcbiAgdW5pZm9ybSB2ZWMyIHJlc29sdXRpb247XHJcblxyXG4gIG91dCB2ZWM0IGNvbDtcclxuICB2b2lkIG1haW4oKSB7XHJcbiAgICAvLyBjb3B5IGNvbG9yIGluZm8gZnJvbSB0ZXh0dXJlXHJcbiAgICBjb2wgPSB2ZWM0KCB0ZXh0dXJlKCB1U2FtcGxlciwgZ2xfRnJhZ0Nvb3JkLnh5IC8gcmVzb2x1dGlvbiApLnJnYiwgMS4gKTtcclxuICB9YFxyXG5cclxuICAgIGNvbnN0IGZzX2RyYXcgPSB0aGlzLmNvbXBpbGUoIGdsLkZSQUdNRU5UX1NIQURFUiwgZnJhZ1NvdXJjZSApXHJcbiAgICBjb25zdCB2c19kcmF3ID0gdGhpcy5jb21waWxlKCBnbC5WRVJURVhfU0hBREVSLCB2c19zb3VyY2UgKVxyXG5cclxuICAgIGdsLmF0dGFjaFNoYWRlciggZHJhd1Byb2dyYW0sIHZzX2RyYXcgKVxyXG5cdFx0Z2wuYXR0YWNoU2hhZGVyKCBkcmF3UHJvZ3JhbSwgZnNfZHJhdyApXHJcblx0XHRnbC5saW5rUHJvZ3JhbSggZHJhd1Byb2dyYW0gKVxyXG5cclxuICAgIHJldHVybiBbIHByb2dyYW0sIGRyYXdQcm9ncmFtIF1cclxuICB9LFxyXG5cclxuICBjbGVhcigpIHtcclxuICAgIGlmKCB0aGlzLmNhbGxiYWNrcyAhPT0gdW5kZWZpbmVkICkgdGhpcy5jYWxsYmFja3MubGVuZ3RoID0gMFxyXG4gICAgaWYoIHRoaXMucmVuZGVyICE9PSBudWxsICkgdGhpcy5yZW5kZXIucnVubmluZyA9IGZhbHNlXHJcbiAgICB0aGlzLmdlb21ldHJpZXMubGVuZ3RoID0gMFxyXG5cclxuICAgIGNvbnN0IGdsID0gdGhpcy5nbFxyXG4gICAgZ2wuY2xlYXIoIGdsLkNPTE9SX0JVRkZFUl9CSVQgfCBnbC5ERVBUSF9CVUZGRVJfQklUIHwgZ2wuU1RFTkNJTF9CVUZGRVJfQklUIClcclxuICB9LFxyXG5cclxuICBwYXVzZSgpIHtcclxuICAgIHRoaXMuX19pc1BhdXNlZCA9ICF0aGlzLl9faXNQYXVzZWRcclxuICB9LFxyXG5cclxuICBpbml0QnVmZmVycyggd2lkdGgsIGhlaWdodCApIHtcclxuICAgIGNvbnN0IGdsID0gdGhpcy5nbFxyXG4gICAgZ2wuY2xlYXJDb2xvciggMC4wLCAwLjAsIDAuMCwgMC4wIClcclxuICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpXHJcblxyXG4gICAgY29uc3QgdmJvID0gZ2wuY3JlYXRlQnVmZmVyKClcclxuXHJcbiAgICBjb25zdCB2ZXJ0aWNlcyA9IG5ldyBGbG9hdDMyQXJyYXkoW1xyXG4gICAgICAtMS4wLCAtMS4wLCAwLjAsIDAuMCwgMC4wLFxyXG4gICAgICAxLjAsIC0xLjAsIDAuMCwgMS4wLCAwLjAsXHJcbiAgICAgIC0xLjAsIDEuMCwgMC4wLCAwLjAsIDEuMCxcclxuICAgICAgMS4wLCAxLjAsIDAuMCwgMS4wLCAxLjBcclxuICAgIF0pXHJcblxyXG4gICAgZ2wuYmluZEJ1ZmZlciAoZ2wuQVJSQVlfQlVGRkVSLCB2Ym8gKVxyXG4gICAgZ2wuYnVmZmVyRGF0YSggZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0aWNlcywgZ2wuU1RBVElDX0RSQVcgKVxyXG5cclxuICAgIGNvbnN0IGlibyA9IGdsLmNyZWF0ZUJ1ZmZlcigpXHJcblxyXG4gICAgY29uc3QgaW5kaWNlcyA9IG5ldyBVaW50MTZBcnJheSggWzAsIDEsIDIsIDIsIDEsIDNdIClcclxuXHJcbiAgICBnbC5iaW5kQnVmZmVyKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgaWJvIClcclxuICAgIGdsLmJ1ZmZlckRhdGEoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBpbmRpY2VzLCBnbC5TVEFUSUNfRFJBVyApXHJcbiAgICBcclxuICAgIHJldHVybiB7IHZibywgaWJvLCB2ZXJ0aWNlcywgaW5kaWNlcyB9XHJcbiAgfSxcclxuXHJcbiAgaW5pdFdlYkdMKCB2c19zb3VyY2UsIGZzX3NvdXJjZSwgd2lkdGgsIGhlaWdodCxzaG91bGRBbmltYXRlPWZhbHNlICkge1xyXG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsXHJcbiAgICAvL2lmKCBzaG91bGRJbml0ID09PSB0cnVlICkgdGhpcy5pbml0QnVmZmVycygpXHJcbiAgICBcclxuICAgIC8vIFhYWCBjbGVhbiBhbGwgdGhpcyB1cCFcclxuICAgIGNvbnN0IGNvbG9yVGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcclxuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGNvbG9yVGV4dHVyZSk7XHJcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XHJcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVCk7XHJcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcclxuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xyXG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCB3aWR0aCwgaGVpZ2h0LCAwLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBudWxsKTtcclxuXHJcbiAgICBjb25zdCBkZXB0aFRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKCk7XHJcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBkZXB0aFRleHR1cmUpO1xyXG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpO1xyXG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpO1xyXG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XHJcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCBnbC5DTEFNUF9UT19FREdFKTtcclxuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgd2lkdGgsIGhlaWdodCwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XHJcblxyXG4gICAgY29uc3QgbGVuRXhwciA9IE1QLm9wKE1QLmxlbihNUC5uY2Zjb29yZCgpKSwgXCIqXCIsIDMpO1xyXG4gICAgLy9jb25zdCBtZXJnZXIgPSBuZXcgTVAuTWVyZ2VyKFtNUC5ibHVyMmQobGVuRXhwciwgbGVuRXhwciwgNildLCBzb3VyY2VDYW52YXMsIGdsKTtcclxuICAgIHdpbmRvdy5NUCA9IE1QXHJcbiAgICB3aW5kb3cuZmwgPSBNUC5mbG9hdChNUC5tdXQoMSkpO1xyXG4gICAgd2luZG93LmZsMiA9IE1QLmZsb2F0KE1QLm11dCgxKSk7XHJcbiAgICB3aW5kb3cuZG9mID0gTVAuZG9mKClcclxuICAgIGNvbnN0IG0gPSBuZXcgTVAuTWVyZ2VyKFtcclxuXHJcbiAgICAgIGRvZlxyXG4gICAgICAvL01QLmJsdXIyZChsZW5FeHByLCBsZW5FeHByLCAyKSAgICAgXHJcbiAgICAgIC8vTVAuZnhhYSgpXHJcbiAgICAgIC8vTVAuYmx1cjJkKGZsLCBmbDIpXHJcbiAgICAgIC8vTVAuaHN2MnJnYigoYyA9IE1QLmNoYW5nZWNvbXAoTVAucmdiMmhzdihNUC5mY29sb3IoKSksIE1QLm11dCgwLjUpLCBcInJcIiwgXCIrXCIpKSlcclxuICAgICAgLy9NUC5oc3YycmdiKE1QLmNoYW5nZWNvbXAoTVAucmdiMmhzdihNUC5mY29sb3IoKSksIE1QLm9wKE1QLnRpbWUoKSwgJy8nLCA1KSwgXCJyXCIsIFwiK1wiKSlcclxuICAgIF0sIGNvbG9yVGV4dHVyZSwgdGhpcy5nbCwgeyBjaGFubmVsczogW2RlcHRoVGV4dHVyZV0gfSk7XHJcbiAgICBcclxuICAgIGNvbnN0IHByb2dyYW1zID0gdGhpcy5jcmVhdGVQcm9ncmFtKCB2c19zb3VyY2UsIGZzX3NvdXJjZSApXHJcbiAgICBjb25zdCBwcm9ncmFtID0gdGhpcy5wcm9ncmFtID0gcHJvZ3JhbXNbMF1cclxuICAgIGdsLnVzZVByb2dyYW0oIHRoaXMucHJvZ3JhbSApXHJcblxyXG4gICAgY29uc3QgeyB2Ym8sIGlibywgdmVydGljZXMsIGluZGljZXMgfSA9IHRoaXMuaW5pdEJ1ZmZlcnMoIHdpZHRoLCBoZWlnaHQgKVxyXG5cclxuICAgIGNvbnN0IGZyYW1lYnVmZmVyID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKVxyXG4gXHJcbiAgICBjb25zdCBsb2NfYV9wb3MgPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBcImFfcG9zXCIpO1xyXG4gICAgY29uc3QgbG9jX2FfdXYgPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBcImFfdXZcIik7XHJcblxyXG4gICAgY29uc3QgbG9jX3VfdGltZSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcInRpbWVcIik7XHJcbiAgICBjb25zdCBsb2NfdV9yZXNvbHV0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwicmVzb2x1dGlvblwiIClcclxuXHJcbiAgICB0aGlzLnBvc3Rwcm9jZXNzaW5nLmZvckVhY2goIHBwID0+IHBwLnVwZGF0ZV9sb2NhdGlvbiggZ2wsIHByb2dyYW0gKSApXHJcblxyXG4gICAgdGhpcy5zY2VuZS51cGRhdGVfbG9jYXRpb24oIGdsLCBwcm9ncmFtIClcclxuICAgIHRoaXMudGV4dHVyZXMudXBkYXRlX2xvY2F0aW9uKCBnbCwgcHJvZ3JhbSApXHJcbiAgICB0aGlzLm1hdGVyaWFscy51cGRhdGVfbG9jYXRpb24oIGdsLCBwcm9ncmFtIClcclxuICAgIHRoaXMubGlnaHRpbmcudXBkYXRlX2xvY2F0aW9uKCBnbCwgcHJvZ3JhbSApXHJcblxyXG4gICAgLy9nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShsb2NfYV9wb3MpXHJcbiAgICAvL2dsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGxvY19hX3V2KVxyXG5cclxuICAgIC8vZ2wudmVydGV4QXR0cmliUG9pbnRlcihsb2NfYV9wb3MsIDMsIGdsLkZMT0FULCBmYWxzZSwgMjAsIDApXHJcbiAgICAvL2dsLnZlcnRleEF0dHJpYlBvaW50ZXIobG9jX2FfdXYsIDIsIGdsLkZMT0FULCBmYWxzZSwgMjAsIDEyKVxyXG5cclxuICAgIGdsLnZpZXdwb3J0KCAwLDAsd2lkdGgsaGVpZ2h0IClcclxuICAgIGdsLnVuaWZvcm0yZiggbG9jX3VfcmVzb2x1dGlvbiwgd2lkdGgsIGhlaWdodCApXHJcblxyXG4gICAgbGV0IHRvdGFsX3RpbWUgPSAwLjA7XHJcblxyXG4gICAgbGV0IGZyYW1lQ291bnQgPSAwXHJcbiAgICBjb25zdCByZW5kZXIgPSBmdW5jdGlvbiggdGltZXN0YW1wICl7XHJcbiAgICAgIGdsLnVzZVByb2dyYW0oIHRoaXMucHJvZ3JhbSApXHJcbiAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVidWZmZXIpO1xyXG4gICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIGNvbG9yVGV4dHVyZSwgMCk7XHJcbiAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMSwgZ2wuVEVYVFVSRV8yRCwgZGVwdGhUZXh0dXJlLCAwKTtcclxuXHJcbiAgICAgIGlmKCByZW5kZXIucnVubmluZyA9PT0gdHJ1ZSAmJiBzaG91bGRBbmltYXRlID09PSB0cnVlICkge1xyXG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIHJlbmRlciApXHJcbiAgICAgIH1lbHNlIGlmKCByZW5kZXIucnVubmluZyA9PT0gZmFsc2UgKSB7XHJcbiAgICAgICAgZ2wuY2xlYXIoIGdsLkNPTE9SX0JVRkZFUl9CSVQgfCBnbC5ERVBUSF9CVUZGRVJfQklUIHwgZ2wuU1RFTkNJTF9CVUZGRVJfQklUIClcclxuICAgICAgICByZXR1cm5cclxuICAgICAgfVxyXG5cclxuICAgICAgaWYoIHRoaXMuX19pc1BhdXNlZCA9PT0gZmFsc2UgKSB7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50VGltZSA9IHRpbWVzdGFtcFxyXG5cclxuICAgICAgICBpZiggdGhpcy5kZWxheSAhPT0gMCAmJiB0aGlzLmRlbGF5ID49IGZyYW1lQ291bnQgKSB7XHJcbiAgICAgICAgICBmcmFtZUNvdW50KytcclxuICAgICAgICAgIHJldHVyblxyXG4gICAgICAgIH1lbHNlIGlmKCB0aGlzLmRlbGF5ICE9PSAwICkge1xyXG4gICAgICAgICAgZnJhbWVDb3VudCA9IDBcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRvdGFsX3RpbWUgPSB0aW1lc3RhbXAgLyAxMDAwLjBcclxuICAgICAgICBnbC51bmlmb3JtMWYoIGxvY191X3RpbWUsIHRvdGFsX3RpbWUgKVxyXG5cclxuICAgICAgICB0aGlzLmNhbGxiYWNrcy5mb3JFYWNoKCBjYiA9PiBjYiggdG90YWxfdGltZSwgdGhpcy5jdXJyZW50VGltZSApIClcclxuXHJcbiAgICAgICAgaWYoIHR5cGVvZiB3aW5kb3cub25mcmFtZSA9PT0gJ2Z1bmN0aW9uJyApIHtcclxuICAgICAgICAgIHdpbmRvdy5vbmZyYW1lKCB0b3RhbF90aW1lIClcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHRoaXMubWF0ZXJpYWxzLnVwbG9hZF9kYXRhKCBnbCApXHJcbiAgICAgIHRoaXMudGV4dHVyZXMudXBsb2FkX2RhdGEoIGdsIClcclxuICAgICAgdGhpcy5zY2VuZS51cGxvYWRfZGF0YSggZ2wgKVxyXG4gICAgICB0aGlzLmxpZ2h0aW5nLnVwbG9hZF9kYXRhKCBnbCApXHJcbiAgICAgIHRoaXMucG9zdHByb2Nlc3NpbmcuZm9yRWFjaCggcHAgPT4gcHAudXBsb2FkX2RhdGEoIGdsICkgKVxyXG5cclxuICAgICAgZ2wuYmluZEJ1ZmZlciAoZ2wuQVJSQVlfQlVGRkVSLCB2Ym8gKVxyXG4gICAgICBnbC5idWZmZXJEYXRhKCBnbC5BUlJBWV9CVUZGRVIsIHZlcnRpY2VzLCBnbC5TVEFUSUNfRFJBVyApXHJcbiAgICAgIGdsLmJpbmRCdWZmZXIoIGdsLkVMRU1FTlRfQVJSQVlfQlVGRkVSLCBpYm8gKVxyXG4gICAgICBnbC5idWZmZXJEYXRhKCBnbC5FTEVNRU5UX0FSUkFZX0JVRkZFUiwgaW5kaWNlcywgZ2wuU1RBVElDX0RSQVcgKVxyXG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheShsb2NfYV9wb3MpXHJcbiAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGxvY19hX3V2KVxyXG5cclxuICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihsb2NfYV9wb3MsIDMsIGdsLkZMT0FULCBmYWxzZSwgMjAsIDApXHJcbiAgICAgIGdsLnZlcnRleEF0dHJpYlBvaW50ZXIobG9jX2FfdXYsIDIsIGdsLkZMT0FULCBmYWxzZSwgMjAsIDEyKVxyXG5cclxuICAgICAgZ2wuZHJhd0J1ZmZlcnMoW1xyXG4gICAgICAgIGdsLkNPTE9SX0FUVEFDSE1FTlQwLFxyXG4gICAgICAgIGdsLkNPTE9SX0FUVEFDSE1FTlQxIFxyXG4gICAgICBdKVxyXG4gICAgICAvLyBDcmVhdGUgYSBjb2xvciB0ZXh0dXJlXHJcbiAgICAgIGdsLmRyYXdFbGVtZW50cyggZ2wuVFJJQU5HTEVTLCA2LCBnbC5VTlNJR05FRF9TSE9SVCwgMCApXHJcblxyXG4gICAgICAvL2dsLmJpbmRCdWZmZXIgKGdsLkFSUkFZX0JVRkZFUiwgbnVsbCApXHJcbiAgICAgIC8vZ2wuYmluZEJ1ZmZlciggZ2wuRUxFTUVOVF9BUlJBWV9CVUZGRVIsIG51bGwgKVxyXG4gICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwgKTtcclxuICAgICAgLy9nbC52aWV3cG9ydCgwLCAwLCB3aWR0aCwgaGVpZ2h0IClcclxuXHJcbiAgICAgIGdsLmFjdGl2ZVRleHR1cmUoIGdsLlRFWFRVUkUwIClcclxuICAgICAgZ2wuYmluZFRleHR1cmUoIGdsLlRFWFRVUkVfMkQsIGNvbG9yVGV4dHVyZSApXHJcbiAgICAgIGdsLnVzZVByb2dyYW0oIHByb2dyYW1zWzFdIClcclxuICAgICAgLy9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGxvY19hX3BvcywgMywgZ2wuRkxPQVQsIGZhbHNlLCAyMCwgMClcclxuICAgICAgLy9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGxvY19hX3V2LCAyLCBnbC5GTE9BVCwgZmFsc2UsIDIwLCAxMilcclxuICAgICAgLy8vL3RoaXMuaW5pdEJ1ZmZlcnMoKVxyXG4gICAgICBjb25zdCB1X3Jlc29sdXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbXNbMV0sIFwicmVzb2x1dGlvblwiIClcclxuICAgICAgZ2wudW5pZm9ybTJmKCB1X3Jlc29sdXRpb24sIHdpZHRoLCBoZWlnaHQgKVxyXG4gICAgICBnbC5kcmF3RWxlbWVudHMoIGdsLlRSSUFOR0xFUywgNiwgZ2wuVU5TSUdORURfU0hPUlQsIDAgKVxyXG5cclxuICAgICAgLy9nbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIGNvbG9yVGV4dHVyZSwgMCk7XHJcbiAgICAgIG0uZHJhdyggdG90YWxfdGltZSApXHJcbiAgICB9LmJpbmQoIFNERiApXHJcblxyXG4gICAgcmVuZGVyLnJ1bm5pbmcgPSB0cnVlXHJcblxyXG4gICAgcmV0dXJuIHJlbmRlciAgICBcclxuICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU0RGXHJcbiIsImNvbnN0IFNjZW5lTm9kZSA9IHJlcXVpcmUoICcuL3NjZW5lTm9kZS5qcycgKSxcbiAgICAgIHsgcGFyYW1fd3JhcCwgTWF0ZXJpYWxJRCB9ID0gcmVxdWlyZSggJy4vdXRpbHMuanMnICksXG4gICAgICB7IFZhciwgZmxvYXRfdmFyX2dlbiwgdmVjMl92YXJfZ2VuLCB2ZWMzX3Zhcl9nZW4sIHZlYzRfdmFyX2dlbiB9ID0gcmVxdWlyZSggJy4vdmFyLmpzJyApLFxuICAgICAgeyBWZWMyLCBWZWMzLCBWZWM0IH0gPSByZXF1aXJlKCAnLi92ZWMuanMnIClcblxuXG5jb25zdCBnbHNsID0gcmVxdWlyZSggJ2dsc2xpZnknIClcblxuY29uc3QgX19NYXRlcmlhbHMgPSBmdW5jdGlvbiggU0RGICkge1xuXG4gIGNvbnN0IE1hdGVyaWFscyA9IHtcbiAgICBtYXRlcmlhbHM6W10sXG4gICAgX19tYXRlcmlhbHM6W10sXG4gICAgbW9kZUNvbnN0YW50cyA6IFtcbiAgICAgICdnbG9iYWwnLFxuICAgICAgJ25vcm1hbCcsXG4gICAgICAncGhvbmcnLFxuICAgICAgJ29yZW5uJyxcbiAgICAgICdub2lzZSdcbiAgICBdLFxuXG4gICAgZGVmYXVsdDogJ2dsb2JhbCcsXG5cbiAgICAvL2RlZmF1bHRNYXRlcmlhbHM6YFxuICAgIC8vICBNYXRlcmlhbCBtYXRlcmlhbHNbMl0gPSBNYXRlcmlhbFsyXShcbiAgICAvLyAgICBNYXRlcmlhbCggMCwgdmVjMyggMS4gKSwgdmVjMygwLiwwLiwwLiksIHZlYzMoMS4pLCA4LiwgRnJlc25lbCggMC4sIDEuLCAyLikgKSxcbiAgICAvLyAgICBNYXRlcmlhbCggMCwgdmVjMyggMS4gKSwgdmVjMygxLiwwLiwwLiksIHZlYzMoMS4pLCA4LiwgRnJlc25lbCggMC4sIDEuLCAyLikgKVxuICAgIC8vICApO1xuICAgIC8vYCxcblxuICAgIGFkZE1hdGVyaWFsKCBtYXQgKSB7XG4gICAgICBpZiggbWF0ID09PSB1bmRlZmluZWQgKSBtYXQgPSBNYXRlcmlhbHMubWF0ZXJpYWwuZGVmYXVsdFxuXG4gICAgICBpZiggTWF0ZXJpYWxzLm1hdGVyaWFscy5pbmRleE9mKCBtYXQgKSA9PT0gLTEgKSB7XG4gICAgICAgIG1hdC5pZCA9IE1hdGVyaWFsSUQuYWxsb2MoKVxuXG4gICAgICAgIC8vIHdlIGhhdmUgdG8gZGlydHkgdGhlIG1hdGVyaWFsIHNvIHRoYXQgaXRzIGRhdGFcbiAgICAgICAgLy8gd2lsbCBiZSB1cGxvYWRlZCB0byBuZXcgc2hhZGVycywgb3RoZXJ3aXNlIHRoZVxuICAgICAgICAvLyBtYXRlcmlhbCB3aWxsIG9ubHkgd29yayB0aGUgZmlyc3QgdGltZSBpdCdzIHVzZWQsIHdoZW5cbiAgICAgICAgLy8gaXQncyBkaXJ0eSBvbiBpbml0aWFsaXphdGlvbi5cbiAgICAgICAgTWF0ZXJpYWxzLmRpcnR5KCBtYXQgKVxuXG4gICAgICAgIE1hdGVyaWFscy5tYXRlcmlhbHMucHVzaCggbWF0IClcbiAgICAgIH0gXG5cbiAgICAgIHJldHVybiBtYXRcbiAgICB9LFxuXG4gICAgbWF0ZXJpYWwoIG1vZGU9J2dsb2JhbCcsIF9fYW1iaWVudCwgX19kaWZmdXNlLCBfX3NwZWN1bGFyLCBfX3NoaW5pbmVzcywgX19mcmVzbmVsLCBfX3RleHR1cmU9bnVsbCApe1xuICAgICAgbGV0IG1vZGVJZHggPSBNYXRlcmlhbHMubW9kZUNvbnN0YW50cy5pbmRleE9mKCBtb2RlIClcbiAgICAgIGlmKCBtb2RlSWR4ID09PSAtMSApIHtcbiAgICAgICAgY29uc29sZS53YXJuKCBgVGhlcmUgaXMgbm8gbWF0ZXJpYWwgdHlwZSBuYW1lZCAke21vZGV9LiBVc2luZyB0aGUgZGVmYXVsdCBtYXRlcmlhbCwgJHtNYXRlcmlhbHMuZGVmYXVsdH0sIGluc3RlYWQuYCApXG4gICAgICAgIG1vZGUgPSBNYXRlcmlhbHMuZGVmYXVsdFxuICAgICAgICBtb2RlSWR4ID0gTWF0ZXJpYWxzLm1vZGVDb25zdGFudHMuaW5kZXhPZiggbW9kZSApXG4gICAgICB9XG5cbiAgICAgIGlmKCB0eXBlb2YgX19hbWJpZW50ID09PSAnbnVtYmVyJyApIF9fYW1iaWVudCA9IFZlYzMoIF9fYW1iaWVudCApXG4gICAgICBjb25zdCBhbWJpZW50ID0gcGFyYW1fd3JhcCggX19hbWJpZW50LCB2ZWMzX3Zhcl9nZW4oLjEsLjEsLjEpIClcbiAgICAgIGlmKCB0eXBlb2YgX19kaWZmdXNlPT09ICdudW1iZXInICkgX19kaWZmdXNlPSBWZWMzKCBfX2RpZmZ1c2UgKVxuICAgICAgY29uc3QgZGlmZnVzZSA9IHBhcmFtX3dyYXAoIF9fZGlmZnVzZSwgdmVjM192YXJfZ2VuKDAsMCwxKSApXG4gICAgICBpZiggdHlwZW9mIF9fc3BlY3VsYXIgPT09ICdudW1iZXInICkgX19zcGVjdWxhciA9IFZlYzMoIF9fc3BlY3VsYXIgKVxuICAgICAgY29uc3Qgc3BlY3VsYXIgPSBwYXJhbV93cmFwKCBfX3NwZWN1bGFyLCB2ZWMzX3Zhcl9nZW4oMSwxLDEpIClcbiAgICAgIGNvbnN0IHNoaW5pbmVzcyA9IHBhcmFtX3dyYXAoIF9fc2hpbmluZXNzLCBmbG9hdF92YXJfZ2VuKDgpIClcbiAgICAgIGlmKCB0eXBlb2YgX19mcmVzbmVsID09PSAnbnVtYmVyJyApIF9fZnJlc25lbCA9IFZlYzMoIF9fZnJlc25lbCApXG4gICAgICBjb25zdCBmcmVzbmVsID0gcGFyYW1fd3JhcCggX19mcmVzbmVsLCB2ZWMzX3Zhcl9nZW4oMCwxLDIpIClcblxuICAgICAgY29uc3QgbWF0ID0geyBzaGluaW5lc3MsIG1vZGUsIHRleHR1cmU6X190ZXh0dXJlLCB0eXBlOidtYXRlcmlhbCcgfVxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIG1hdCwgJ2FtYmllbnQnLCB7XG4gICAgICAgIGdldCgpIHsgcmV0dXJuIGFtYmllbnQgfSxcbiAgICAgICAgc2V0KHYpIHtcbiAgICAgICAgICBpZiggdHlwZW9mIHYgPT09ICdvYmplY3QnICkge1xuICAgICAgICAgICAgYW1iaWVudC5zZXQoIHYgKVxuICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgYW1iaWVudC52YWx1ZS54ID0gdlxuICAgICAgICAgICAgYW1iaWVudC52YWx1ZS55ID0gdlxuICAgICAgICAgICAgYW1iaWVudC52YWx1ZS56ID0gdlxuICAgICAgICAgICAgYW1iaWVudC5kaXJ0eSA9IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pICBcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggbWF0LCAnZGlmZnVzZScsIHtcbiAgICAgICAgZ2V0KCkgeyByZXR1cm4gZGlmZnVzZSB9LFxuICAgICAgICBzZXQodikge1xuICAgICAgICAgIGlmKCB0eXBlb2YgdiA9PT0gJ29iamVjdCcgKSB7XG4gICAgICAgICAgICBkaWZmdXNlLnNldCggdiApXG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBkaWZmdXNlLnZhbHVlLnggPSB2XG4gICAgICAgICAgICBkaWZmdXNlLnZhbHVlLnkgPSB2XG4gICAgICAgICAgICBkaWZmdXNlLnZhbHVlLnogPSB2XG4gICAgICAgICAgICBkaWZmdXNlLmRpcnR5ID0gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSkgIFxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBtYXQsICdzcGVjdWxhcicsIHtcbiAgICAgICAgZ2V0KCkgeyByZXR1cm4gc3BlY3VsYXIgfSxcbiAgICAgICAgc2V0KHYpIHtcbiAgICAgICAgICBpZiggdHlwZW9mIHYgPT09ICdvYmplY3QnICkge1xuICAgICAgICAgICAgc3BlY3VsYXIuc2V0KCB2IClcbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHNwZWN1bGFyLnZhbHVlLnggPSB2XG4gICAgICAgICAgICBzcGVjdWxhci52YWx1ZS55ID0gdlxuICAgICAgICAgICAgc3BlY3VsYXIudmFsdWUueiA9IHZcbiAgICAgICAgICAgIHNwZWN1bGFyLmRpcnR5ID0gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSkgIFxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBtYXQsICdmcmVzbmVsJywge1xuICAgICAgICBnZXQoKSB7IHJldHVybiBmcmVzbmVsIH0sXG4gICAgICAgIHNldCh2KSB7XG4gICAgICAgICAgaWYoIHR5cGVvZiB2ID09PSAnb2JqZWN0JyApIHtcbiAgICAgICAgICAgIGZyZXNuZWwuc2V0KCB2IClcbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIGZyZXNuZWwudmFsdWUueCA9IHZcbiAgICAgICAgICAgIGZyZXNuZWwudmFsdWUueSA9IHZcbiAgICAgICAgICAgIGZyZXNuZWwudmFsdWUueiA9IHZcbiAgICAgICAgICAgIGZyZXNuZWwuZGlydHkgPSB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KSAgXG4gICAgICAvL09iamVjdC5kZWZpbmVQcm9wZXJ0eSggbWF0LCAnc2hpbmluZXNzJywge1xuICAgICAgLy8gIGdldCgpIHsgcmV0dXJuIG1hdC5zaGluaW5lc3MudmFsdWUgfSxcbiAgICAgIC8vICBzZXQodil7XG4gICAgICAvLyAgICBtYXQuc2hpbmluZXNzLnZhbHVlID0gdlxuICAgICAgLy8gICAgbWF0LnNoaW5pbmVzcy5kaXJ0eSA9IHRydWVcbiAgICAgIC8vICB9XG4gICAgICAvL30pICAgICAvL1xuICAgICAgXG4gICAgICByZXR1cm4gbWF0IFxuICAgIH0sXG5cbiAgICBkaXJ0eSggbWF0ICkge1xuICAgICAgbWF0LmFtYmllbnQuZGlydHkgPSB0cnVlXG4gICAgICBtYXQuZGlmZnVzZS5kaXJ0eSA9IHRydWVcbiAgICAgIG1hdC5zcGVjdWxhci5kaXJ0eSA9IHRydWVcbiAgICAgIG1hdC5zaGluaW5lc3MuZGlydHkgPSB0cnVlXG4gICAgICBtYXQuZnJlc25lbC5kaXJ0eSA9IHRydWVcbiAgICAgIGlmKCBtYXQudGV4dHVyZSAhPT0gbnVsbCApIG1hdC50ZXh0dXJlLmRpcnR5ID0gdHJ1ZVxuICAgIH0sXG4gICBcbiAgICBlbWl0X21hdGVyaWFscygpIHtcbiAgICAgIGlmKCB0aGlzLm1hdGVyaWFscy5sZW5ndGggPT09IDAgKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCAncmV0dXJuaW5nIHVuZGVmaW5lZD8nLCB0aGlzLmRlZmF1bHRNYXRlcmlhbHMgKVxuICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0TWF0ZXJpYWxzLy90aGlzLmFkZE1hdGVyaWFsKCkgXG4gICAgICB9XG5cbiAgICAgIGxldCBzdHIgPSBgTWF0ZXJpYWwgbWF0ZXJpYWxzWyR7dGhpcy5tYXRlcmlhbHMubGVuZ3RofV0gPSBNYXRlcmlhbFske3RoaXMubWF0ZXJpYWxzLmxlbmd0aH1dKGBcblxuICAgICAgdGhpcy5tYXRlcmlhbHMuc29ydCggKGEsYikgPT4gYS5pZCA+IGIuaWQgPyAxIDogLTEgKSBcblxuICAgICAgZm9yKCBsZXQgbWF0IG9mIHRoaXMubWF0ZXJpYWxzICkge1xuICAgICAgICBjb25zdCBmcmVzbmVsID0gYEZyZXNuZWwoICR7ZihtYXQuZnJlc25lbC54KX0sICR7ZihtYXQuZnJlc25lbC55KX0sICR7ZihtYXQuZnJlc25lbC56KX0gKWBcblxuICAgICAgICBjb25zdCB0ZXhpZCA9IDAvL1NERi50ZXh0dXJlcy50ZXh0dXJlcy5pbmRleE9mKCBtYXQudGV4dHVyZSApXG4gICAgICAgIHN0ciArPSBtYXQudGV4dHVyZSA9PT0gbnVsbCBcbiAgICAgICAgICA/IGBcXG4gICAgICAgIE1hdGVyaWFsKCAke3RoaXMubW9kZUNvbnN0YW50cy5pbmRleE9mKCBtYXQubW9kZSApfSwgJHttYXQuYW1iaWVudC5lbWl0KCl9LCAke21hdC5kaWZmdXNlLmVtaXQoKX0sICR7bWF0LnNwZWN1bGFyLmVtaXQoKX0sICR7bWF0LnNoaW5pbmVzcy5lbWl0KCl9LCAke21hdC5mcmVzbmVsLmVtaXQoKX0sICR7IHRleGlkIH0gKSxgIFxuICAgICAgICAgIDogYFxcbiAgICAgICAgTWF0ZXJpYWwoICR7dGhpcy5tb2RlQ29uc3RhbnRzLmluZGV4T2YoIG1hdC5tb2RlICl9LCAke21hdC5hbWJpZW50LmVtaXQoKX0sICR7bWF0LmRpZmZ1c2UuZW1pdCgpfSwgJHttYXQuc3BlY3VsYXIuZW1pdCgpfSwgJHttYXQuc2hpbmluZXNzLmVtaXQoKX0sICR7bWF0LmZyZXNuZWwuZW1pdCgpfSwgJHsgdGV4aWQgfSApLGAgXG4gICAgICB9XG4gICAgICBcbiAgICAgIHN0ciA9IHN0ci5zbGljZSgwLC0xKSAvLyByZW1vdmUgdHJhaWxpbmcgY29tbWFcblxuICAgICAgc3RyICs9ICdcXG4gICAgICApOydcblxuICAgICAgdGhpcy5fX21hdGVyaWFscyA9IHRoaXMubWF0ZXJpYWxzLnNsaWNlKCAwIClcbiAgICAgIHRoaXMubWF0ZXJpYWxzLmxlbmd0aCA9IDBcblxuICAgICAgcmV0dXJuIHN0clxuICAgIH0sXG5cbiAgICBlbWl0X2RlY2woKSB7XG4gICAgICBsZXQgc3RyID0gJydcbiAgICAgIGZvciggbGV0IG1hdCBvZiB0aGlzLl9fbWF0ZXJpYWxzICkge1xuICAgICAgICBzdHIgKz0gbWF0LmFtYmllbnQuZW1pdF9kZWNsKClcbiAgICAgICAgc3RyICs9IG1hdC5kaWZmdXNlLmVtaXRfZGVjbCgpXG4gICAgICAgIHN0ciArPSBtYXQuc3BlY3VsYXIuZW1pdF9kZWNsKClcbiAgICAgICAgc3RyICs9IG1hdC5zaGluaW5lc3MuZW1pdF9kZWNsKClcbiAgICAgICAgc3RyICs9IG1hdC5mcmVzbmVsLmVtaXRfZGVjbCgpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHJcbiAgICB9LFxuXG4gICAgdXBkYXRlX2xvY2F0aW9uKCBnbCwgcHJvZ3JhbSApIHtcbiAgICAgIGZvciggbGV0IG1hdCBvZiB0aGlzLl9fbWF0ZXJpYWxzICkge1xuICAgICAgICBpZiggbWF0LmFtYmllbnQuZGlydHkgPT09IHRydWUgKSAgIG1hdC5hbWJpZW50LnVwZGF0ZV9sb2NhdGlvbiggZ2wsIHByb2dyYW0gKVxuICAgICAgICBpZiggbWF0LmRpZmZ1c2UuZGlydHkgPT09IHRydWUgKSAgIG1hdC5kaWZmdXNlLnVwZGF0ZV9sb2NhdGlvbiggZ2wsIHByb2dyYW0gKVxuICAgICAgICBpZiggbWF0LnNwZWN1bGFyLmRpcnR5ID09PSB0cnVlICkgIG1hdC5zcGVjdWxhci51cGRhdGVfbG9jYXRpb24oIGdsLCBwcm9ncmFtIClcbiAgICAgICAgaWYoIG1hdC5zaGluaW5lc3MuZGlydHkgPT09IHRydWUgKSBtYXQuc2hpbmluZXNzLnVwZGF0ZV9sb2NhdGlvbiggZ2wsIHByb2dyYW0gKVxuICAgICAgICBpZiggbWF0LmZyZXNuZWwuZGlydHkgPT09IHRydWUgKSAgIG1hdC5mcmVzbmVsLnVwZGF0ZV9sb2NhdGlvbiggZ2wsIHByb2dyYW0gKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICB1cGxvYWRfZGF0YSggZ2wsIHByb2dyYW09JycgKSB7XG4gICAgICBmb3IoIGxldCBtYXQgb2YgdGhpcy5fX21hdGVyaWFscyApIHtcbiAgICAgICAgaWYoIG1hdC5hbWJpZW50LmRpcnR5ID09PSB0cnVlICkgICBtYXQuYW1iaWVudC51cGxvYWRfZGF0YSggZ2wsIHByb2dyYW0gKVxuICAgICAgICBpZiggbWF0LmRpZmZ1c2UuZGlydHkgPT09IHRydWUgKSAgIG1hdC5kaWZmdXNlLnVwbG9hZF9kYXRhKCBnbCwgcHJvZ3JhbSApXG4gICAgICAgIGlmKCBtYXQuc3BlY3VsYXIuZGlydHkgPT09IHRydWUgKSAgbWF0LnNwZWN1bGFyLnVwbG9hZF9kYXRhKCBnbCwgcHJvZ3JhbSApXG4gICAgICAgIGlmKCBtYXQuc2hpbmluZXNzLmRpcnR5ID09PSB0cnVlICkgbWF0LnNoaW5pbmVzcy51cGxvYWRfZGF0YSggZ2wsIHByb2dyYW0gKVxuICAgICAgICBpZiggbWF0LmZyZXNuZWwuZGlydHkgPT09IHRydWUgKSAgIG1hdC5mcmVzbmVsLnVwbG9hZF9kYXRhKCBnbCwgcHJvZ3JhbSApXG4gICAgICB9XG4gICAgfVxuXG4gIH1cblxuICBjb25zdCBmID0gdmFsdWUgPT4gdmFsdWUgJSAxID09PSAwID8gdmFsdWUudG9GaXhlZCgxKSA6IHZhbHVlIFxuXG4gIE9iamVjdC5hc3NpZ24oIE1hdGVyaWFscy5tYXRlcmlhbCwge1xuICAgIGRlZmF1bHQgOiBNYXRlcmlhbHMubWF0ZXJpYWwoICdnbG9iYWwnLCBWZWMzKCAuMTUgKSwgVmVjMygwKSwgVmVjMygxKSwgOCwgVmVjMyggMCwgMSwgLjUgKSApLCAgXG4gICAgcmVkICAgICA6IE1hdGVyaWFscy5tYXRlcmlhbCggJ2dsb2JhbCcsIFZlYzMoLjI1LDAsMCksIFZlYzMoMSwwLDApLCBWZWMzKDApLCAyLCBWZWMzKDApICksXG4gICAgZ3JlZW4gICA6IE1hdGVyaWFscy5tYXRlcmlhbCggJ2dsb2JhbCcsIFZlYzMoMCwuMjUsMCksIFZlYzMoMCwxLDApLCBWZWMzKDApLCAyLCBWZWMzKDApICksXG4gICAgYmx1ZSAgICA6IE1hdGVyaWFscy5tYXRlcmlhbCggJ2dsb2JhbCcsIFZlYzMoMCwwLC4yNSksIFZlYzMoMCwwLDEpLCBWZWMzKDApLCAyLCBWZWMzKDApICksXG4gICAgY3lhbiAgICA6IE1hdGVyaWFscy5tYXRlcmlhbCggJ2dsb2JhbCcsIFZlYzMoMCwuMjUsLjI1KSwgVmVjMygwLDEsMSksIFZlYzMoMCksIDIsIFZlYzMoMCkgKSxcbiAgICBtYWdlbnRhIDogTWF0ZXJpYWxzLm1hdGVyaWFsKCAnZ2xvYmFsJywgVmVjMyguMjUsMCwuMjUpLCBWZWMzKDEsMCwxKSwgVmVjMygwKSwgMiwgVmVjMygwKSApLFxuICAgIHllbGxvdyAgOiBNYXRlcmlhbHMubWF0ZXJpYWwoICdnbG9iYWwnLCBWZWMzKC4yNSwuMjUsLjApLCBWZWMzKDEsMSwwKSwgVmVjMygwKSwgMiwgVmVjMygwKSApLFxuICAgIGJsYWNrICAgOiBNYXRlcmlhbHMubWF0ZXJpYWwoICdnbG9iYWwnLCBWZWMzKDAsIDAsIDApLCBWZWMzKDAsMCwwKSwgVmVjMygwKSwgMiwgVmVjMygwKSApLFxuICAgIHdoaXRlICAgOiBNYXRlcmlhbHMubWF0ZXJpYWwoICdnbG9iYWwnLCBWZWMzKC4yNSksIFZlYzMoMSksIFZlYzMoMSksIDIsIFZlYzMoMCkgKSxcbiAgICBncmV5ICAgIDogTWF0ZXJpYWxzLm1hdGVyaWFsKCAnZ2xvYmFsJywgVmVjMyguMjUpLCBWZWMzKC4zMyksIFZlYzMoMSksIDIsIFZlYzMoMCkgKSxcblxuICAgICd3aGl0ZSBnbG93JyA6IE1hdGVyaWFscy5tYXRlcmlhbCggJ3Bob25nJywgIFZlYzMoLjAxNSksIFZlYzMoMSksIFZlYzMoMSksIDE2LCBWZWMzKDAsMjAwLDUpICksXG4gICAgZ2x1ZSAgICA6IE1hdGVyaWFscy5tYXRlcmlhbCggJ3Bob25nJywgIFZlYzMoLjAxNSksIFZlYzMoMSksIFZlYzMoMSksIDE2LCBWZWMzKDAsMTUsLS4xKSApLFxuICAgIGludmVyc2UgOiBNYXRlcmlhbHMubWF0ZXJpYWwoICdwaG9uZycsIDEsIC41LCAxLCAxNiwgVmVjMygxLC41LC0yKSApLFxuXG4gICAgbm9ybWFsICA6IE1hdGVyaWFscy5tYXRlcmlhbCggJ25vcm1hbCcgKSxcbiAgICBub2lzZSAgIDogTWF0ZXJpYWxzLm1hdGVyaWFsKCAnbm9pc2UnLCAgVmVjMyggLjE1ICksIFZlYzMoMSwwLDApLCBWZWMzKDEpLCA4LCBWZWMzKCAwLCAxLCAuNSApKVxuICB9KVxuXG4gIHJldHVybiBNYXRlcmlhbHNcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfX01hdGVyaWFsc1xuIiwiY29uc3QgZ2xzbCA9IHJlcXVpcmUoICdnbHNsaWZ5JyApXG5jb25zdCBTY2VuZU5vZGUgPSByZXF1aXJlKCAnLi9zY2VuZU5vZGUuanMnIClcbmNvbnN0IHsgcGFyYW1fd3JhcCwgTWF0ZXJpYWxJRCB9ID0gcmVxdWlyZSggJy4vdXRpbHMuanMnIClcbmNvbnN0IHsgVmFyLCBmbG9hdF92YXJfZ2VuLCB2ZWMyX3Zhcl9nZW4sIHZlYzNfdmFyX2dlbiwgdmVjNF92YXJfZ2VuIH0gPSByZXF1aXJlKCAnLi92YXIuanMnIClcblxuY29uc3QgZ2V0Tm9pc2UgPSBmdW5jdGlvbiggU0RGICkge1xuTm9pc2UgPSBmdW5jdGlvbiggc3RyZW5ndGg9LjI1LCBiaWFzPTEsIHRpbWVNb2Q9MSApIHtcbiAgY29uc3Qgb3AgPSBPYmplY3QuY3JlYXRlKCBOb2lzZS5wcm90b3R5cGUgKVxuICBvcC50eXBlID0gJ3N0cmluZydcbiAgb3AuaXNHZW4gPSB0cnVlXG5cbiAgY29uc3QgZGVmYXVsdFZhbHVlcyA9IFsuNSwuNSwuNV1cblxuICBvcC5tYXRJZCA9IE1hdGVyaWFsSUQuYWxsb2MoKVxuXG4gIGNvbnN0IF9fc3RyZW5ndGggPSBwYXJhbV93cmFwKCBzdHJlbmd0aCwgZmxvYXRfdmFyX2dlbiggc3RyZW5ndGggKSApXG4gIGNvbnN0IF9fdGltZU1vZCAgPSBwYXJhbV93cmFwKCB0aW1lTW9kLCBmbG9hdF92YXJfZ2VuKCB0aW1lTW9kICkgKVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb3AsICdzdHJlbmd0aCcsIHtcbiAgICBnZXQoKSB7IHJldHVybiBfX3N0cmVuZ3RoIH0sXG4gICAgc2V0KHYpIHtcbiAgICAgX19zdHJlbmd0aC52YXIuc2V0KCB2IClcbiAgICB9XG4gIH0pXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb3AsICd0aW1lTW9kJywge1xuICAgIGdldCgpIHsgcmV0dXJuIF9fdGltZU1vZCB9LFxuICAgIHNldCh2KSB7XG4gICAgIF9fdGltZU1vZC52YXIuc2V0KCB2IClcbiAgICB9XG4gIH0pXG4gIGNvbnN0IF9fYmlhcyAgPSBwYXJhbV93cmFwKCBiaWFzLCBmbG9hdF92YXJfZ2VuKCBiaWFzICkgKVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb3AsICdiaWFzJywge1xuICAgIGdldCgpIHsgcmV0dXJuIF9fYmlhc30sXG4gICAgc2V0KHYpIHtcbiAgICAgX19iaWFzLnZhci5zZXQoIHYgKVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIG9wXG59IFxuXG5Ob2lzZS5wcm90b3R5cGUgPSBTY2VuZU5vZGUoKVxuXG5Ob2lzZS5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uICggX19uYW1lICkge1xuICBsZXQgbmFtZSA9IF9fbmFtZSA9PT0gdW5kZWZpbmVkID8gJ3AnIDogX19uYW1lXG5cbiAgY29uc3Qgb3V0ID0gYCgke3RoaXMuYmlhcy5lbWl0KCl9ICsgc25vaXNlKCB2ZWM0KCBwLnh5eiwgdGltZSAqICR7dGhpcy50aW1lTW9kLmVtaXQoKX0gKSkgKiAke3RoaXMuc3RyZW5ndGguZW1pdCgpfSlgICBcblxuICBjb25zdCBvdXRwdXQgPSB7XG4gICAgb3V0LFxuICAgIHByZWZhY2U6JydcbiAgfVxuXG4gIHJldHVybiBvdXRwdXRcbn1cbk5vaXNlLnByb3RvdHlwZS5nbHNsID0gZ2xzbChbXCIjZGVmaW5lIEdMU0xJRlkgMVxcbiAgICAvL1xcbi8vIERlc2NyaXB0aW9uIDogQXJyYXkgYW5kIHRleHR1cmVsZXNzIEdMU0wgMkQvM0QvNEQgc2ltcGxleFxcbi8vICAgICAgICAgICAgICAgbm9pc2UgZnVuY3Rpb25zLlxcbi8vICAgICAgQXV0aG9yIDogSWFuIE1jRXdhbiwgQXNoaW1hIEFydHMuXFxuLy8gIE1haW50YWluZXIgOiBpam1cXG4vLyAgICAgTGFzdG1vZCA6IDIwMTEwODIyIChpam0pXFxuLy8gICAgIExpY2Vuc2UgOiBDb3B5cmlnaHQgKEMpIDIwMTEgQXNoaW1hIEFydHMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXFxuLy8gICAgICAgICAgICAgICBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMSUNFTlNFIGZpbGUuXFxuLy8gICAgICAgICAgICAgICBodHRwczovL2dpdGh1Yi5jb20vYXNoaW1hL3dlYmdsLW5vaXNlXFxuLy9cXG5cXG52ZWM0IG1vZDI4OSh2ZWM0IHgpIHtcXG4gIHJldHVybiB4IC0gZmxvb3IoeCAqICgxLjAgLyAyODkuMCkpICogMjg5LjA7IH1cXG5cXG5mbG9hdCBtb2QyODkoZmxvYXQgeCkge1xcbiAgcmV0dXJuIHggLSBmbG9vcih4ICogKDEuMCAvIDI4OS4wKSkgKiAyODkuMDsgfVxcblxcbnZlYzQgcGVybXV0ZSh2ZWM0IHgpIHtcXG4gICAgIHJldHVybiBtb2QyODkoKCh4KjM0LjApKzEuMCkqeCk7XFxufVxcblxcbmZsb2F0IHBlcm11dGUoZmxvYXQgeCkge1xcbiAgICAgcmV0dXJuIG1vZDI4OSgoKHgqMzQuMCkrMS4wKSp4KTtcXG59XFxuXFxudmVjNCB0YXlsb3JJbnZTcXJ0KHZlYzQgcilcXG57XFxuICByZXR1cm4gMS43OTI4NDI5MTQwMDE1OSAtIDAuODUzNzM0NzIwOTUzMTQgKiByO1xcbn1cXG5cXG5mbG9hdCB0YXlsb3JJbnZTcXJ0KGZsb2F0IHIpXFxue1xcbiAgcmV0dXJuIDEuNzkyODQyOTE0MDAxNTkgLSAwLjg1MzczNDcyMDk1MzE0ICogcjtcXG59XFxuXFxudmVjNCBncmFkNChmbG9hdCBqLCB2ZWM0IGlwKVxcbiAge1xcbiAgY29uc3QgdmVjNCBvbmVzID0gdmVjNCgxLjAsIDEuMCwgMS4wLCAtMS4wKTtcXG4gIHZlYzQgcCxzO1xcblxcbiAgcC54eXogPSBmbG9vciggZnJhY3QgKHZlYzMoaikgKiBpcC54eXopICogNy4wKSAqIGlwLnogLSAxLjA7XFxuICBwLncgPSAxLjUgLSBkb3QoYWJzKHAueHl6KSwgb25lcy54eXopO1xcbiAgcyA9IHZlYzQobGVzc1RoYW4ocCwgdmVjNCgwLjApKSk7XFxuICBwLnh5eiA9IHAueHl6ICsgKHMueHl6KjIuMCAtIDEuMCkgKiBzLnd3dztcXG5cXG4gIHJldHVybiBwO1xcbiAgfVxcblxcbi8vIChzcXJ0KDUpIC0gMSkvNCA9IEY0LCB1c2VkIG9uY2UgYmVsb3dcXG4jZGVmaW5lIEY0IDAuMzA5MDE2OTk0Mzc0OTQ3NDUxXFxuXFxuZmxvYXQgc25vaXNlKHZlYzQgdilcXG4gIHtcXG4gIGNvbnN0IHZlYzQgIEMgPSB2ZWM0KCAwLjEzODE5NjYwMTEyNTAxMSwgIC8vICg1IC0gc3FydCg1KSkvMjAgIEc0XFxuICAgICAgICAgICAgICAgICAgICAgICAgMC4yNzYzOTMyMDIyNTAwMjEsICAvLyAyICogRzRcXG4gICAgICAgICAgICAgICAgICAgICAgICAwLjQxNDU4OTgwMzM3NTAzMiwgIC8vIDMgKiBHNFxcbiAgICAgICAgICAgICAgICAgICAgICAgLTAuNDQ3MjEzNTk1NDk5OTU4KTsgLy8gLTEgKyA0ICogRzRcXG5cXG4vLyBGaXJzdCBjb3JuZXJcXG4gIHZlYzQgaSAgPSBmbG9vcih2ICsgZG90KHYsIHZlYzQoRjQpKSApO1xcbiAgdmVjNCB4MCA9IHYgLSAgIGkgKyBkb3QoaSwgQy54eHh4KTtcXG5cXG4vLyBPdGhlciBjb3JuZXJzXFxuXFxuLy8gUmFuayBzb3J0aW5nIG9yaWdpbmFsbHkgY29udHJpYnV0ZWQgYnkgQmlsbCBMaWNlYS1LYW5lLCBBTUQgKGZvcm1lcmx5IEFUSSlcXG4gIHZlYzQgaTA7XFxuICB2ZWMzIGlzWCA9IHN0ZXAoIHgwLnl6dywgeDAueHh4ICk7XFxuICB2ZWMzIGlzWVogPSBzdGVwKCB4MC56d3csIHgwLnl5eiApO1xcbi8vICBpMC54ID0gZG90KCBpc1gsIHZlYzMoIDEuMCApICk7XFxuICBpMC54ID0gaXNYLnggKyBpc1gueSArIGlzWC56O1xcbiAgaTAueXp3ID0gMS4wIC0gaXNYO1xcbi8vICBpMC55ICs9IGRvdCggaXNZWi54eSwgdmVjMiggMS4wICkgKTtcXG4gIGkwLnkgKz0gaXNZWi54ICsgaXNZWi55O1xcbiAgaTAuencgKz0gMS4wIC0gaXNZWi54eTtcXG4gIGkwLnogKz0gaXNZWi56O1xcbiAgaTAudyArPSAxLjAgLSBpc1laLno7XFxuXFxuICAvLyBpMCBub3cgY29udGFpbnMgdGhlIHVuaXF1ZSB2YWx1ZXMgMCwxLDIsMyBpbiBlYWNoIGNoYW5uZWxcXG4gIHZlYzQgaTMgPSBjbGFtcCggaTAsIDAuMCwgMS4wICk7XFxuICB2ZWM0IGkyID0gY2xhbXAoIGkwLTEuMCwgMC4wLCAxLjAgKTtcXG4gIHZlYzQgaTEgPSBjbGFtcCggaTAtMi4wLCAwLjAsIDEuMCApO1xcblxcbiAgLy8gIHgwID0geDAgLSAwLjAgKyAwLjAgKiBDLnh4eHhcXG4gIC8vICB4MSA9IHgwIC0gaTEgICsgMS4wICogQy54eHh4XFxuICAvLyAgeDIgPSB4MCAtIGkyICArIDIuMCAqIEMueHh4eFxcbiAgLy8gIHgzID0geDAgLSBpMyAgKyAzLjAgKiBDLnh4eHhcXG4gIC8vICB4NCA9IHgwIC0gMS4wICsgNC4wICogQy54eHh4XFxuICB2ZWM0IHgxID0geDAgLSBpMSArIEMueHh4eDtcXG4gIHZlYzQgeDIgPSB4MCAtIGkyICsgQy55eXl5O1xcbiAgdmVjNCB4MyA9IHgwIC0gaTMgKyBDLnp6eno7XFxuICB2ZWM0IHg0ID0geDAgKyBDLnd3d3c7XFxuXFxuLy8gUGVybXV0YXRpb25zXFxuICBpID0gbW9kMjg5KGkpO1xcbiAgZmxvYXQgajAgPSBwZXJtdXRlKCBwZXJtdXRlKCBwZXJtdXRlKCBwZXJtdXRlKGkudykgKyBpLnopICsgaS55KSArIGkueCk7XFxuICB2ZWM0IGoxID0gcGVybXV0ZSggcGVybXV0ZSggcGVybXV0ZSggcGVybXV0ZSAoXFxuICAgICAgICAgICAgIGkudyArIHZlYzQoaTEudywgaTIudywgaTMudywgMS4wICkpXFxuICAgICAgICAgICArIGkueiArIHZlYzQoaTEueiwgaTIueiwgaTMueiwgMS4wICkpXFxuICAgICAgICAgICArIGkueSArIHZlYzQoaTEueSwgaTIueSwgaTMueSwgMS4wICkpXFxuICAgICAgICAgICArIGkueCArIHZlYzQoaTEueCwgaTIueCwgaTMueCwgMS4wICkpO1xcblxcbi8vIEdyYWRpZW50czogN3g3eDYgcG9pbnRzIG92ZXIgYSBjdWJlLCBtYXBwZWQgb250byBhIDQtY3Jvc3MgcG9seXRvcGVcXG4vLyA3KjcqNiA9IDI5NCwgd2hpY2ggaXMgY2xvc2UgdG8gdGhlIHJpbmcgc2l6ZSAxNyoxNyA9IDI4OS5cXG4gIHZlYzQgaXAgPSB2ZWM0KDEuMC8yOTQuMCwgMS4wLzQ5LjAsIDEuMC83LjAsIDAuMCkgO1xcblxcbiAgdmVjNCBwMCA9IGdyYWQ0KGowLCAgIGlwKTtcXG4gIHZlYzQgcDEgPSBncmFkNChqMS54LCBpcCk7XFxuICB2ZWM0IHAyID0gZ3JhZDQoajEueSwgaXApO1xcbiAgdmVjNCBwMyA9IGdyYWQ0KGoxLnosIGlwKTtcXG4gIHZlYzQgcDQgPSBncmFkNChqMS53LCBpcCk7XFxuXFxuLy8gTm9ybWFsaXNlIGdyYWRpZW50c1xcbiAgdmVjNCBub3JtID0gdGF5bG9ySW52U3FydCh2ZWM0KGRvdChwMCxwMCksIGRvdChwMSxwMSksIGRvdChwMiwgcDIpLCBkb3QocDMscDMpKSk7XFxuICBwMCAqPSBub3JtLng7XFxuICBwMSAqPSBub3JtLnk7XFxuICBwMiAqPSBub3JtLno7XFxuICBwMyAqPSBub3JtLnc7XFxuICBwNCAqPSB0YXlsb3JJbnZTcXJ0KGRvdChwNCxwNCkpO1xcblxcbi8vIE1peCBjb250cmlidXRpb25zIGZyb20gdGhlIGZpdmUgY29ybmVyc1xcbiAgdmVjMyBtMCA9IG1heCgwLjYgLSB2ZWMzKGRvdCh4MCx4MCksIGRvdCh4MSx4MSksIGRvdCh4Mix4MikpLCAwLjApO1xcbiAgdmVjMiBtMSA9IG1heCgwLjYgLSB2ZWMyKGRvdCh4Myx4MyksIGRvdCh4NCx4NCkgICAgICAgICAgICApLCAwLjApO1xcbiAgbTAgPSBtMCAqIG0wO1xcbiAgbTEgPSBtMSAqIG0xO1xcbiAgcmV0dXJuIDQ5LjAgKiAoIGRvdChtMCptMCwgdmVjMyggZG90KCBwMCwgeDAgKSwgZG90KCBwMSwgeDEgKSwgZG90KCBwMiwgeDIgKSkpXFxuICAgICAgICAgICAgICAgKyBkb3QobTEqbTEsIHZlYzIoIGRvdCggcDMsIHgzICksIGRvdCggcDQsIHg0ICkgKSApICkgO1xcblxcbiAgfVxcblxcblwiXSlcblxuTm9pc2UucHJvdG90eXBlLmVtaXRfZGVjbCA9IGZ1bmN0aW9uICgpIHtcbiAgbGV0IHN0ciA9IHRoaXMuc3RyZW5ndGguZW1pdF9kZWNsKCkgKyB0aGlzLnRpbWVNb2QuZW1pdF9kZWNsKCkgKyB0aGlzLmJpYXMuZW1pdF9kZWNsKClcblxuICBpZiggU0RGLm1lbW8ubm9pc2UgPT09IHVuZGVmaW5lZCApIHtcbiAgICBzdHIgPSBOb2lzZS5wcm90b3R5cGUuZ2xzbCArIHN0clxuICAgIFNERi5tZW1vLm5vaXNlID0gdHJ1ZVxuICB9XG5cbiAgcmV0dXJuIHN0clxufTtcblxuTm9pc2UucHJvdG90eXBlLnVwZGF0ZV9sb2NhdGlvbiA9IGZ1bmN0aW9uKGdsLCBwcm9ncmFtKSB7XG4gIHRoaXMuc3RyZW5ndGgudXBkYXRlX2xvY2F0aW9uKCBnbCwgcHJvZ3JhbSApXG4gIHRoaXMudGltZU1vZC51cGRhdGVfbG9jYXRpb24oIGdsLCBwcm9ncmFtIClcbiAgdGhpcy5iaWFzLnVwZGF0ZV9sb2NhdGlvbiggZ2wsIHByb2dyYW0gKVxufVxuXG5Ob2lzZS5wcm90b3R5cGUudXBsb2FkX2RhdGEgPSBmdW5jdGlvbihnbCkge1xuICB0aGlzLnN0cmVuZ3RoLnVwbG9hZF9kYXRhKCBnbCApXG4gIHRoaXMudGltZU1vZC51cGxvYWRfZGF0YSggZ2wgKVxuICB0aGlzLmJpYXMudXBsb2FkX2RhdGEoIGdsIClcbn1cblxucmV0dXJuIE5vaXNlXG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXROb2lzZSBcbiIsImNvbnN0IGdsc2wgPSByZXF1aXJlKCAnZ2xzbGlmeScgKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQm94OiB7XG4gICAgcGFyYW1ldGVyczpbXG4gICAgICB7IG5hbWU6J3NpemUnLCB0eXBlOid2ZWMzJywgZGVmYXVsdDpbMSwxLDFdLCBtaW46LjAwMSwgbWF4OjUgfSxcbiAgICBdLFxuXG4gICAgcHJpbWl0aXZlU3RyaW5nKCBwTmFtZSApIHsgXG5cdCAgICByZXR1cm4gYHNkQm94KCAke3BOYW1lfSwgJHt0aGlzLnNpemUuZW1pdCgpfSApYDtcbiAgICB9LFxuXG4gICAgZ2xzbGlmeTpnbHNsKFtcIiNkZWZpbmUgR0xTTElGWSAxXFxuICAgIGZsb2F0IHNkQm94KCB2ZWMzIHAsIHZlYzMgYiApXFxue1xcbiAgdmVjMyBkID0gYWJzKHApIC0gYjtcXG4gIHJldHVybiBtaW4obWF4KGQueCxtYXgoZC55LGQueikpLDAuMCkgK1xcbiAgICAgICAgIGxlbmd0aChtYXgoZCwwLjApKTtcXG59XFxuXFxuXCJdKVxuICB9LCBcblxuICAvLyBYWFggd2Ugc2hvdWxkIG5vcm1hbGl6ZSBkaW1lbnNpb25zIGluIHRoZSBzaGFkZXIuLi4gXG4gIENvbmU6IHtcbiAgICBwYXJhbWV0ZXJzOltcbiAgICAgIHsgbmFtZTonZGltZW5zaW9ucycsIHR5cGU6J3ZlYzMnLCBkZWZhdWx0OlsuOCwuNiwuM10sIG1pbjouMDAxLCBtYXg6NSB9LFxuICAgIF0sXG5cbiAgICBwcmltaXRpdmVTdHJpbmcoIHBOYW1lICkgeyBcbiAgICAgIHJldHVybiBgc2RDb25lKCAke3BOYW1lfSwgJHt0aGlzLmRpbWVuc2lvbnMuZW1pdCgpfSApYFxuICAgIH0sXG4gICAgZ2xzbGlmeTpnbHNsKFtcIiNkZWZpbmUgR0xTTElGWSAxXFxuICAgIGZsb2F0IHNkQ29uZSggaW4gdmVjMyBwLCBpbiB2ZWMzIGMgKVxcbntcXG4gICAgdmVjMiBxID0gdmVjMiggbGVuZ3RoKHAueHopLCBwLnkgKTtcXG4gICAgZmxvYXQgZDEgPSAtcC55LWMuejtcXG4gICAgZmxvYXQgZDIgPSBtYXgoIGRvdChxLGMueHkpLCBwLnkpO1xcbiAgICByZXR1cm4gbGVuZ3RoKG1heCh2ZWMyKGQxLGQyKSwwLjApKSArIG1pbihtYXgoZDEsZDIpLCAwLik7XFxufVxcblxcblwiXSlcbiAgfSwgXG5cblx0Q3lsaW5kZXI6IHtcbiAgICBwYXJhbWV0ZXJzOltcbiAgICAgIHsgbmFtZTonZGltZW5zaW9ucycsIHR5cGU6J3ZlYzInLCBkZWZhdWx0OlsuOCwuNl0sIG1pbjouMDAxLCBtYXg6NSB9LFxuICAgIF0sXG5cbiAgICBwcmltaXRpdmVTdHJpbmcoIHBOYW1lICkgeyBcbiAgICAgIHJldHVybiBgc2RDYXBwZWRDeWxpbmRlciggJHtwTmFtZX0sICR7dGhpcy5kaW1lbnNpb25zLmVtaXQoKX0gKWBcbiAgICB9LFxuXG4gICAgZ2xzbGlmeTpgICAgIGZsb2F0IHNkQ2FwcGVkQ3lsaW5kZXIoIHZlYzMgcCwgdmVjMiBoICkge1xuICAgIHZlYzIgZCA9IGFicyh2ZWMyKGxlbmd0aChwLnh6KSxwLnkpKSAtIGg7XG4gICAgcmV0dXJuIG1pbihtYXgoZC54LGQueSksMC4wKSArIGxlbmd0aChtYXgoZCwwLjApKTtcbiAgfWBcbiAgfSwgXG5cbiAgQ2Fwc3VsZToge1x0XG4gICAgcGFyYW1ldGVyczpbXG4gICAgICB7IG5hbWU6J3N0YXJ0JywgdHlwZTondmVjMycsIGRlZmF1bHQ6WzAsMCwwXSwgbWluOjAsIG1heDouNSB9LFxuICAgICAgeyBuYW1lOidlbmQnLCB0eXBlOid2ZWMzJywgZGVmYXVsdDpbLjgsMSwwXSwgbWluOi41LCBtYXg6MSB9LFxuICAgICAgeyBuYW1lOidyYWRpdXMnLCB0eXBlOidmbG9hdCcsIGRlZmF1bHQ6LjUsIG1pbjouMDAxLCBtYXg6NSB9LFxuICAgIF0sXG5cbiAgICBwcmltaXRpdmVTdHJpbmcoIHBOYW1lICkgeyBcbiAgICAgIHJldHVybiBgc2RDYXBzdWxlKCAke3BOYW1lfSwgJHt0aGlzLnN0YXJ0LmVtaXQoKX0sICR7dGhpcy5lbmQuZW1pdCgpfSwgJHt0aGlzLnJhZGl1cy5lbWl0KCl9IClgXG4gICAgfSxcbiAgICBnbHNsaWZ5Omdsc2woW1wiI2RlZmluZSBHTFNMSUZZIDFcXG4gICAgICBmbG9hdCBzZENhcHN1bGUoIHZlYzMgcCwgdmVjMyBhLCB2ZWMzIGIsIGZsb2F0IHIgKVxcbntcXG4gICAgdmVjMyBwYSA9IHAgLSBhLCBiYSA9IGIgLSBhO1xcbiAgICBmbG9hdCBoID0gY2xhbXAoIGRvdChwYSxiYSkvZG90KGJhLGJhKSwgMC4wLCAxLjAgKTtcXG4gICAgcmV0dXJuIGxlbmd0aCggcGEgLSBiYSpoICkgLSByO1xcbn1cXG5cXG5cIl0pXG5cbiAgfSxcblxuICAvLyBYWFggTm8gY3lsaW5kZXIgZGVzY3JpcHRpb25cbiAgLy9gICNwcmFnbWEgZ2xzbGlmeTogc2RDeWxpbmRlclx0PSByZXF1aXJlKCdnbHNsLXNkZi1wcmltaXRpdmVzL3NkQ3lsaW5kZXInKWBcbiBcdEhleFByaXNtOiB7XG4gICAgcGFyYW1ldGVyczpbXG4gICAgICB7IG5hbWU6J2RpbWVuc2lvbnMnLCB0eXBlOid2ZWMyJywgZGVmYXVsdDpbLjgsLjZdLCBtaW46LjAwMSwgbWF4OjUgfSxcbiAgICBdLFxuXG4gICAgcHJpbWl0aXZlU3RyaW5nKCBwTmFtZSApIHsgXG4gICAgICByZXR1cm4gYHNkSGV4UHJpc20oICR7cE5hbWV9LCAke3RoaXMuZGltZW5zaW9ucy5lbWl0KCl9IClgXG4gICAgfSxcbiAgICBnbHNsaWZ5Omdsc2woW1wiI2RlZmluZSBHTFNMSUZZIDFcXG4gICAgICBmbG9hdCBzZEhleFByaXNtKCB2ZWMzIHAsIHZlYzIgaCApXFxue1xcbiAgICB2ZWMzIHEgPSBhYnMocCk7XFxuICAgIHJldHVybiBtYXgocS56LWgueSxtYXgoKHEueCowLjg2NjAyNStxLnkqMC41KSxxLnkpLWgueCk7XFxufVxcblxcblwiXSlcbiAgfSxcblxuICBKdWxpYToge1xuICAgIHBhcmFtZXRlcnM6W1xuICAgICAgeyBuYW1lOidmb2xkJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjAsIG1pbjowLCBtYXg6MTAgfSxcbiAgICBdLFxuXG4gICAgcHJpbWl0aXZlU3RyaW5nKCBwTmFtZSApIHsgXG4gICAgICByZXR1cm4gYGp1bGlhKCAke3BOYW1lfSwgJHt0aGlzLmZvbGQuZW1pdCgpfSApYFxuICAgIH0sXG5cbiAgICAvLyBodHRwczovL3d3dy5zaGFkZXJ0b3kuY29tL3ZpZXcvTXNmR1JyXG4gICAgZ2xzbGlmeTpnbHNsKFtcIiNkZWZpbmUgR0xTTElGWSAxXFxuICB2ZWM0IHFzcXIoIGluIHZlYzQgYSApIHtcXG4gICAgcmV0dXJuIHZlYzQoIGEueCphLnggLSBhLnkqYS55IC0gYS56KmEueiAtIGEudyphLncsXFxuICAgICAgICAgICAgICAgICAyLjAqYS54KmEueSxcXG4gICAgICAgICAgICAgICAgIDIuMCphLngqYS56LFxcbiAgICAgICAgICAgICAgICAgMi4wKmEueCphLncgKTtcXG4gIH1cXG5cXG4gIGZsb2F0IGp1bGlhKCBpbiB2ZWMzIHAsIGZsb2F0IGF0aW1lICl7XFxuICAgIHZlYzQgYyA9IDAuNDUqY29zKCB2ZWM0KDAuNSwzLjksMS40LDEuMSkgKyBhdGltZSAqIHZlYzQoMS4yLDEuNywxLjMsMi41KSApIC0gdmVjNCgwLjMsMC4wLDAuMCwwLjApO1xcbiAgICB2ZWM0IHogPSB2ZWM0KHAsMC4pO1xcbiAgICBmbG9hdCBtZDIgPSAxLjA7XFxuICAgIGZsb2F0IG16MiA9IGRvdCh6LHopO1xcblxcbiAgICBmb3IoIGludCBpPTA7IGk8MTE7IGkrKyApe1xcbiAgICAgIG1kMiAqPSA0LjAqbXoyOyAgIFxcbiAgICAgIC8vIGR6IC0+IDLCt3rCt2R6LCBtZWFuaW5nIHxkenwgLT4gMsK3fHp8wrd8ZHp8IChjYW4gdGFrZSB0aGUgNCBvdXQgb2YgdGhlIGxvb3AgYW5kIGRvIGFuIGV4cDIoKSBhZnRlcndhcmRzKVxcbiAgICAgIHogPSBxc3FyKHopICsgYzsgIC8vIHogIC0+IHpeMiArIGNcXG5cXG4gICAgICBtejIgPSBkb3Qoeix6KTtcXG4gICAgICBpZihtejI+NC4wKSBicmVhaztcXG4gICAgfVxcbiAgICBcXG4gICAgcmV0dXJuIDAuMjUqc3FydChtejIvbWQyKSpsb2cobXoyKTsgIC8vIGQgPSAwLjXCt3x6fMK3bG9nfHp8IC8gfGR6fFxcbiAgfVwiLFwiXCJdKSxcbiAgfSxcbiAgS0lGUzoge1xuICAgIHBhcmFtZXRlcnM6W1xuICAgICAgeyBuYW1lOidjb3VudCcsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDo4IH0sXG4gICAgICB7IG5hbWU6J2ZvbGQnLCB0eXBlOidmbG9hdCcsIGRlZmF1bHQ6MCB9LFxuICAgICAgeyBuYW1lOidyYWRpdXMnLCB0eXBlOidmbG9hdCcsIGRlZmF1bHQ6LjAxIH0sXG4gICAgICB7IG5hbWU6J3RocmVzaG9sZCcsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDouMDA0IH0sXG4gICAgICB7IG5hbWU6J3NjYWxlJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjIgfSxcbiAgICBdLFxuXG4gICAgcHJpbWl0aXZlU3RyaW5nKCBwTmFtZSApIHsgXG4gICAgICByZXR1cm4gYGtpZnMoICR7cE5hbWV9LCAke3RoaXMuY291bnQuZW1pdCgpfSwgJHt0aGlzLmZvbGQuZW1pdCgpfSwgJHt0aGlzLnJhZGl1cy5lbWl0KCl9LCAke3RoaXMudGhyZXNob2xkLmVtaXQoKX0sICR7dGhpcy5zY2FsZS5lbWl0KCl9IClgXG4gICAgfSxcblxuICAgIC8vIGFkYXB0ZWQgZnJvbSBodHRwOi8vcm95LnJlZC9mb2xkaW5nLXRoZS1rb2NoLXNub3dmbGFrZS0uaHRtbFxuICAgIGdsc2xpZnk6Z2xzbChbXCIjZGVmaW5lIEdMU0xJRlkgMVxcbiAgICAgIGZsb2F0IGJveCggdmVjMyBwLCB2ZWMzIGIgKXtcXG4gICAgICB2ZWMzIGQgPSBhYnMocCkgLSBiO1xcbiAgICAgIHJldHVybiBtaW4obWF4KGQueCxtYXgoZC55LGQueikpLDAuMCkgK1xcbiAgICAgICAgICAgICBsZW5ndGgobWF4KGQsMC4wKSk7XFxuICAgIH1cXG4gICAgdmVjMiBmb2xkKHZlYzIgcCwgZmxvYXQgYW5nKXsgICAgXFxuICAgICAgICB2ZWMyIG49dmVjMihjb3MoLWFuZyksc2luKC1hbmcpKTtcXG4gICAgICAgIHAtPTIuKm1pbigwLixkb3QocCxuKSkqbjtcXG4gICAgICAgIHJldHVybiBwO1xcbiAgICB9XFxuICAgICNkZWZpbmUgS1BJIDMuMTQxNTlcXG4gICAgdmVjMyB0cmlfZm9sZCh2ZWMzIHB0LCBmbG9hdCBmb2xkYW10KSB7XFxuICAgICAgICBwdC54eSA9IGZvbGQocHQueHksS1BJLzMuICsgZm9sZGFtdCApO1xcbiAgICAgICAgcHQueHkgPSBmb2xkKHB0Lnh5LC1LUEkvMy4gKyBmb2xkYW10ICk7XFxuICAgICAgICBwdC55eiA9IGZvbGQocHQueXosS1BJLzYuKy43ICsgZm9sZGFtdCApO1xcbiAgICAgICAgcHQueXogPSBmb2xkKHB0Lnl6LC1LUEkvNi4gKyBmb2xkYW10ICk7XFxuICAgICAgICByZXR1cm4gcHQ7XFxuICAgIH1cXG4gICAgdmVjMyB0cmlfY3VydmUodmVjMyBwdCwgZmxvYXQgaXRlciwgZmxvYXQgZm9sZCwgZmxvYXQgc2NhbGUgKSB7XFxuICAgICAgICBpbnQgY291bnQgPSBpbnQoaXRlcik7XFxuICAgICAgICBmb3IoaW50IGk9MDtpPGNvdW50O2krKyl7XFxuICAgICAgICAgICAgcHQqPXNjYWxlO1xcbiAgICAgICAgICAgIHB0LngtPTIuNjtcXG4gICAgICAgICAgICBwdD10cmlfZm9sZChwdCxmb2xkKTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBwdDtcXG4gICAgfVxcbiAgICBmbG9hdCBraWZzKGluIHZlYzMgcCwgZmxvYXQgYSwgZmxvYXQgZm9sZCwgZmxvYXQgcmFkaXVzLCBmbG9hdCB0aHJlc2gsIGZsb2F0IHNjYWxlICl7XFxuICAgICAgICBwLngrPTEuNTtcXG4gICAgICAgIHA9dHJpX2N1cnZlKHAsYSxmb2xkLHNjYWxlKTtcXG4gICAgICAgIC8vIHVuY29tbWVudCBiZWxvdyBsaW5lIHRvIHVzZSBzcGhlcmVzIGluc3RlYWQgb2YgYm94ZXNcXG4gICAgICAgIHJldHVybiAobGVuZ3RoKCBwKnRocmVzaCApIC0gcmFkaXVzICk7XFxuICAgICAgICAvL3JldHVybiBib3goIHAqdGhyZXNoLCB2ZWMzKHJhZGl1cykgKTtcXG4gICAgfVxcblwiLFwiXCJdKSxcbiAgfSxcblxuICBNYW5kYWxheToge1xuICAgIHBhcmFtZXRlcnM6W1xuICAgICAgeyBuYW1lOidzaXplJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjUsIG1pbjoxLCBtYXg6MTAgfSxcbiAgICAgIHsgbmFtZTonbWlucmFkJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjEvMywgbWluOjAsIG1heDoxIH0sICAgIFxuICAgICAgeyBuYW1lOidpdGVyYXRpb25zJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjUsIG1pbjoxLCBtYXg6MTAsIHN0ZXA6MSB9LCAgICBcbiAgICBdLFxuICAgIGdsc2xpZnk6YCAgICAgICAgICAgICAgICAgXG4gIGZsb2F0IHNyID0gNC4wO1xuICB2ZWMzIGZvID12ZWMzICgwLjcsLjk1MjgsLjkpO1xuICB2ZWMzIGdoID0gdmVjMyAoLjgsLjcsMC41NjM4KTtcbiAgdmVjMyBndyA9IHZlYzMgKC4zLCAwLjUgLC4yKTtcbiAgdmVjNCBYID0gdmVjNCggLjEsMC41LDAuMSwuMyk7XG4gIHZlYzQgWSA9IHZlYzQoLjEsIDAuOCwgLjEsIC4xKTtcbiAgdmVjNCBaID0gdmVjNCguMiwwLjIsLjIsLjQ1OTAyKTtcbiAgdmVjNCBSID0gdmVjNCgwLjE5LC4xLC4xLC4yKTtcbiAgdmVjNCBvcmJpdFRyYXAgPSB2ZWM0KDQwMDAwLjApO1xuICBmbG9hdCBEQkZvbGQoIHZlYzMgcCwgZmxvYXQgZm8sIGZsb2F0IGcsIGZsb2F0IHcgKXtcbiAgICAgIGlmKHAuej5wLnkpIHAueXo9cC56eTtcbiAgICAgIGZsb2F0IHZ4PXAueC0yLipmbztcbiAgICAgIGZsb2F0IHZ5PXAueS00LipmbztcbiAgICAgIGZsb2F0IHY9bWF4KGFicyh2eCtmbyktZm8sdnkpO1xuICAgICAgZmxvYXQgdjE9bWF4KHZ4LWcscC55LXcpO1xuICAgICAgdj1taW4odix2MSk7XG4gICAgICB2MT1tYXgodjEsLWFicyhwLngpKTtcbiAgICAgIHJldHVybiBtaW4odixwLngpO1xuICB9XG4gICBcbiAgdmVjMyBEQkZvbGRQYXJhbGxlbCh2ZWMzIHAsIHZlYzMgZm8sIHZlYzMgZywgdmVjMyB3KXtcbiAgICB2ZWMzIHAxPXA7XG4gICAgcC54PURCRm9sZChwMSxmby54LGcueCx3LngpO1xuICAgIHAueT1EQkZvbGQocDEueXp4LGZvLnksZy55LHcueSk7XG4gICAgcC56PURCRm9sZChwMS56eHksZm8ueixnLnosdy56KTtcbiAgICByZXR1cm4gcDtcbiAgfVxuXG4gIHZlYzMgREJGb2xkU2VyaWFsKHZlYzMgcCwgdmVjMyBmbywgdmVjMyBnLHZlYzMgdyl7XG4gICAgcC54PURCRm9sZChwLGZvLngsZy54LHcueCk7XG4gICAgcC55PURCRm9sZChwLnl6eCxmby55LGcueSx3LnkpO1xuICAgIHAuej1EQkZvbGQocC56eHksZm8ueixnLnosdy56KTtcbiAgICByZXR1cm4gcDtcbiAgfVxuICBmbG9hdCBzaW5lU3BvbmdlKHZlYzMgcCwgZmxvYXQgc2NhbGUsIGZsb2F0IG1pbnJhZCwgZmxvYXQgaXRlcmF0aW9ucyApIHtcbiAgICB2ZWM0IEpDPXZlYzQocCwxLik7XG4gICAgZmxvYXQgcjI9ZG90KHAscCk7XG4gICAgZmxvYXQgZGQgPSAxLjtcbiAgICBmb3IoaW50IGkgPSAwOyBpPGludChpdGVyYXRpb25zKTsgaSsrKXtcbiAgICAgIHAgPSBwIC0gY2xhbXAocC54eXosIC0xLjAsIDEuMCkgKiAyLjA7ICAvLyBtYW5kZWxib3gncyBib3ggZm9sZFxuICAgXG4gICAgICB2ZWMzIHNpZ25zPXNpZ24ocCk7Ly9TYXZlIFx0dGhlIG9yaWdpbmFsIHNpZ25zXG4gICAgICBwPWFicyhwKTtcbiAgICAgIHA9REJGb2xkUGFyYWxsZWwocCxmbyxnaCxndyk7XG4gICAgICBcbiAgICAgIHAqPXNpZ25zOy8vcmVzb3JlIHNpZ25zOiB0aGlzIHdheSB0aGUgbWFuZGVsYnJvdCBzZXQgd29uJ3QgZXh0ZW5kIGluIG5lZ2F0aXZlIGRpcmVjdGlvbnNcbiAgICAgIFxuXG4gICAgICByMj1kb3QocCxwKTtcbiAgICAgIGZsb2F0ICB0ID0gY2xhbXAoMS4vcjIsIDEuLCAxLi9taW5yYWQpO1xuICAgICAgcCo9dDsgZGQqPXQ7XG4gICAgICAgXG5cbiAgICAgIHA9cCpzY2FsZStKQy54eXo7IGRkPWRkKnNjYWxlK0pDLnc7XG4gICAgICBwPXZlYzMoMS4wLDEuMCwuOTIpKnA7XG4gICBcbiAgICAgIHIyPWRvdChwLHApO1xuICAgICAgb3JiaXRUcmFwID0gbWluKG9yYml0VHJhcCwgYWJzKHZlYzQocC54LHAueSxwLnoscjIpKSk7XHRcbiAgICB9XG4gICAgZGQ9YWJzKGRkKTtcbiAgICAgICNpZiAwXG4gICAgICAgIHJldHVybiAoc3FydChyMiktc3IpL2RkOy8vYm91bmRpbmcgdm9sdW1lIGlzIGEgc3BoZXJlXG4gICAgICAjZWxzZVxuICAgICAgICBwPWFicyhwKTsgcmV0dXJuIChtYXgocC54LG1heChwLnkscC56KSktc3IpL2RkOy8vYm91bmRpbmcgdm9sdW1lIGlzIGEgY3ViZVxuICAgICAgI2VuZGlmXG4gICAgfVxuICAgIGAsXG4gICBcbiAgICBwcmltaXRpdmVTdHJpbmcoIHBOYW1lICkgeyBcbiAgICAgIHJldHVybiBgc2luZVNwb25nZSggJHtwTmFtZX0sICR7dGhpcy5zaXplLmVtaXQoKX0sICR7dGhpcy5taW5yYWQuZW1pdCgpfSwgJHt0aGlzLml0ZXJhdGlvbnMuZW1pdCgpfSApYFxuICAgIH1cbiAgfSwgIFxuICBNYW5kZWxidWxiOiB7XG4gICAgcGFyYW1ldGVyczpbXG4gICAgICB7IG5hbWU6J2ZvbGQnLCB0eXBlOidmbG9hdCcsIGRlZmF1bHQ6OCwgbWluOjEsIG1heDoxNSB9LFxuICAgICAgeyBuYW1lOidpdGVyYXRpb25zJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjQsIG1pbjoxLCBtYXg6Niwgc3RlcDoxIH0sICAgIFxuICAgIF0sXG5cbiAgICBwcmltaXRpdmVTdHJpbmcoIHBOYW1lICkgeyBcbiAgICAgIHJldHVybiBgbWFuZGVsYnVsYiggJHtwTmFtZX0sICR7dGhpcy5mb2xkLmVtaXQoKX0sICR7dGhpcy5pdGVyYXRpb25zLmVtaXQoKX0gKWBcbiAgICB9LFxuXG4gICAgLy8gYWRhcHRlZCBmcm9tOiBodHRwczovL3d3dy5zaGFkZXJ0b3kuY29tL3ZpZXcvbHRmU1duXG4gICAgZ2xzbGlmeTpnbHNsKFtcIiNkZWZpbmUgR0xTTElGWSAxXFxuICAgICAgZmxvYXQgbWFuZGVsYnVsYiggaW4gdmVjMyBwLCBpbiBmbG9hdCBhYSwgZmxvYXQgaXRlcmF0aW9ucyApe1xcbiAgICAgICAgdmVjMyB3ID0gcDtcXG4gICAgICAgIGZsb2F0IG0gPSBkb3Qodyx3KTtcXG5cXG4gICAgICAgIHZlYzQgdHJhcCA9IHZlYzQoYWJzKHcpLG0pO1xcbiAgICAgICAgZmxvYXQgZHogPSAxLjA7XFxuICAgICAgICAgICAgICAgIFxcbiAgICAgICAgZm9yKCBpbnQgaT0wOyBpPGludChpdGVyYXRpb25zKTsgaSsrICkge1xcbiAgICAgICAgICBkeiA9IGFhKnBvdyhzcXJ0KG0pLGFhIC0gMS4pKmR6ICsgMS4wO1xcblxcbiAgICAgICAgICBmbG9hdCByID0gbGVuZ3RoKHcpO1xcbiAgICAgICAgICBmbG9hdCBiID0gYWEqYWNvcyggdy55IC9yKTtcXG4gICAgICAgICAgZmxvYXQgYSA9IGFhKmF0YW4oIHcueCwgdy56ICk7XFxuICAgICAgICAgIHcgPSBwICsgcG93KHIsYWEpICogdmVjMyggc2luKGIpKnNpbihhKSwgY29zKGIpLCBzaW4oYikqY29zKGEpICk7XFxuXFxuICAgICAgICAgIHRyYXAgPSBtaW4oIHRyYXAsIHZlYzQoYWJzKHcpLG0pICk7XFxuXFxuICAgICAgICAgIG0gPSBkb3Qodyx3KTtcXG4gICAgICAgICAgaWYoIG0gPiAyNTYuMCApIHtcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIDAuMjUqbG9nKG0pKnNxcnQobSkvZHo7XFxuICAgICAgfVxcbiAgICBcIixcIlwiXSksXG4gIH0sXG5cbiAgLy8gYWRhcHRlZCBmcm9tIGh0dHBzOi8vd3d3LnNoYWRlcnRveS5jb20vdmlldy9sbEdYRFJcbiAgTWFuZGVsYm94OiB7XG4gICAgcGFyYW1ldGVyczpbXG4gICAgICB7IG5hbWU6J2ZvbGQnLCB0eXBlOidmbG9hdCcsIGRlZmF1bHQ6LjEgfSxcbiAgICAgIHsgbmFtZTonc2NhbGUnLCB0eXBlOidmbG9hdCcsIGRlZmF1bHQ6My4sIG1pbjoxLCBtYXg6MTAgfSxcbiAgICAgIHsgbmFtZTonaXRlcmF0aW9ucycsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDo1LCBtaW46MSwgbWF4OjEwLCBzdGVwOjEgfSxcbiAgICBdLFxuXG4gICAgZ2xzbGlmeTpgZmxvYXQgbWFuZGVsYm94KCBmbG9hdCBNUjIsIGZsb2F0IFNDQUxFLCBmbG9hdCBJVEVSLCB2ZWMzIHBvc2l0aW9uICl7XG4gICAgICB2ZWM0IHNjYWxldmVjID0gdmVjNChTQ0FMRSwgU0NBTEUsIFNDQUxFLCBhYnMoU0NBTEUpKSAvIE1SMjtcbiAgICAgIGZsb2F0IEMxID0gYWJzKFNDQUxFLTEuMCksIEMyID0gcG93KGFicyhTQ0FMRSksIDEuLUlURVIpOyAvLyAxMCBpcyBJVEVSU1xuICAgICAgdmVjNCBwID0gdmVjNChwb3NpdGlvbi54eXosIDEuMCksIHAwID0gdmVjNChwb3NpdGlvbi54eXosIDEuMCk7ICAvLyBwLncgaXMga25pZ2h0eSdzIERFZmFjdG9yXG4gICAgICBmb3IgKGludCBpPTA7IGk8aW50KElURVIpOyBpKyspIHtcbiAgICAgICAgcC54eXogPSBjbGFtcChwLnh5eiwgLTEuMCwgMS4wKSAqIDIuMCAtIHAueHl6OyAgLy8gYm94IGZvbGQ6IG1pbjMsIG1heDNnZywgbWFkM1xuICAgICAgICBmbG9hdCByMiA9IGRvdChwLnh5eiwgcC54eXopOyAgLy8gZHAzXG4gICAgICAgIHAueHl6dyAqPSBjbGFtcChtYXgoTVIyL3IyLCBNUjIpLCAwLjAsIDEuMCk7ICAvLyBzcGhlcmUgZm9sZDogZGl2MSwgbWF4MS5zYXQsIG11bDRcbiAgICAgICAgcC54eXp3ID0gcCpzY2FsZXZlYyArIHAwOyAgLy8gbWFkNFxuICAgICAgfVxuICAgICAgcmV0dXJuIChsZW5ndGgocC54eXopIC0gQzEpIC8gcC53IC0gQzI7XG4gIH1gLFxuXG4gICAgcHJpbWl0aXZlU3RyaW5nKCBwTmFtZSApIHtcbiAgICAgIHJldHVybiBgbWFuZGVsYm94KCAke3RoaXMuZm9sZC5lbWl0KCl9LCAke3RoaXMuc2NhbGUuZW1pdCgpfSwgJHt0aGlzLml0ZXJhdGlvbnMuZW1pdCgpfSwgJHtwTmFtZX0gKWBcbiAgICB9XG4gIH0sXG5cblx0T2N0YWhlZHJvbjoge1xuICAgIHBhcmFtZXRlcnM6W1xuICAgICAgeyBuYW1lOidyYWRpdXMnLCB0eXBlOidmbG9hdCcsIGRlZmF1bHQ6MSwgbWluOjAsIG1heDo0IH0sXG4gICAgXSxcblxuICAgIHByaW1pdGl2ZVN0cmluZyggcE5hbWUgKSB7IFxuICAgICAgcmV0dXJuIGBzZE9jdGFoZWRyb24oICR7cE5hbWV9LCAke3RoaXMucmFkaXVzLmVtaXQoKX0gKWBcbiAgICB9LFxuXG4gICAgZ2xzbGlmeTpgICAgIGZsb2F0IHNkT2N0YWhlZHJvbih2ZWMzIHAsIGZsb2F0IGgpIHtcbiAgICBwLnkgPSBwLnkgKyBoOyAvLyBjZW50ZXIgdmVydGljYWxseS4uLiBpcyBpdCBjZW50ZXJlZCBvbiB0aGUgei1heGlzP1xuICAgIHZlYzIgZCA9IC41KihhYnMocC54eikrcC55KSAtIG1pbihoLHAueSk7XG4gICAgcmV0dXJuIGxlbmd0aChtYXgoZCwwLikpICsgbWluKG1heChkLngsZC55KSwgMC4pO1xuICB9YFxuICB9LCBcblxuIFx0UGxhbmU6IHtcbiAgICBwYXJhbWV0ZXJzOltcbiAgICAgIHsgbmFtZTonbm9ybWFsJywgdHlwZTondmVjMycsIGRlZmF1bHQ6WzAsMSwwXSwgbWluOjAsIG1heDoxIH0sXG4gICAgICB7IG5hbWU6J2Rpc3RhbmNlJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjEsIG1pbjowLCBtYXg6NSB9LFxuICAgIF0sXG5cbiAgICBwcmltaXRpdmVTdHJpbmcoIHBOYW1lICkgeyBcbiAgICAgIHJldHVybiBgc2RQbGFuZSggJHtwTmFtZX0sIHZlYzQoICR7dGhpcy5ub3JtYWwuZW1pdCgpfSwgJHt0aGlzLmRpc3RhbmNlLmVtaXQoKX0gKSlgXG4gICAgfSxcbiAgICBcbiAgICBnbHNsaWZ5Omdsc2woW1wiI2RlZmluZSBHTFNMSUZZIDFcXG5mbG9hdCBzZFBsYW5lKCB2ZWMzIHAsIHZlYzQgbiApXFxue1xcbiAgLy8gbiBtdXN0IGJlIG5vcm1hbGl6ZWRcXG4gIHJldHVybiBkb3QocCxuLnh5eikgKyBuLnc7XFxufVxcblxcblwiXSlcbiAgICBcbiAgfSwgIFxuIFx0UXVhZDoge1xuICAgIHBhcmFtZXRlcnM6W1xuICAgICAgeyBuYW1lOid2MScsIHR5cGU6J3ZlYzMnLCBkZWZhdWx0OlstLjUsLS41LDBdIH0sXG4gICAgICB7IG5hbWU6J3YyJywgdHlwZTondmVjMycsIGRlZmF1bHQ6Wy41LC0uNSwwXSB9LFxuICAgICAgeyBuYW1lOid2MycsIHR5cGU6J3ZlYzMnLCBkZWZhdWx0OlsuNSwuNSwwXSB9LFxuICAgICAgeyBuYW1lOid2NCcsIHR5cGU6J3ZlYzMnLCBkZWZhdWx0OlstLjUsLjUsMF0gfSxcbiAgICBdLFxuXG4gICAgcHJpbWl0aXZlU3RyaW5nKCBwTmFtZSApIHsgXG4gICAgICByZXR1cm4gYHVkUXVhZCggJHtwTmFtZX0sICR7dGhpcy52MS5lbWl0KCl9LCAke3RoaXMudjIuZW1pdCgpfSwgJHt0aGlzLnYzLmVtaXQoKX0sICR7dGhpcy52NC5lbWl0KCl9IClgXG4gICAgfSxcbiAgICBnbHNsaWZ5Omdsc2woW1wiI2RlZmluZSBHTFNMSUZZIDFcXG4gICAgZmxvYXQgZG90MiggaW4gdmVjMyB2ICkgeyByZXR1cm4gZG90KHYsdik7IH1cXG5mbG9hdCB1ZFF1YWQoIHZlYzMgcCwgdmVjMyBhLCB2ZWMzIGIsIHZlYzMgYywgdmVjMyBkIClcXG57XFxuICAgIHZlYzMgYmEgPSBiIC0gYTsgdmVjMyBwYSA9IHAgLSBhO1xcbiAgICB2ZWMzIGNiID0gYyAtIGI7IHZlYzMgcGIgPSBwIC0gYjtcXG4gICAgdmVjMyBkYyA9IGQgLSBjOyB2ZWMzIHBjID0gcCAtIGM7XFxuICAgIHZlYzMgYWQgPSBhIC0gZDsgdmVjMyBwZCA9IHAgLSBkO1xcbiAgICB2ZWMzIG5vciA9IGNyb3NzKCBiYSwgYWQgKTtcXG5cXG4gICAgcmV0dXJuIHNxcnQoXFxuICAgIChzaWduKGRvdChjcm9zcyhiYSxub3IpLHBhKSkgK1xcbiAgICAgc2lnbihkb3QoY3Jvc3MoY2Isbm9yKSxwYikpICtcXG4gICAgIHNpZ24oZG90KGNyb3NzKGRjLG5vcikscGMpKSArXFxuICAgICBzaWduKGRvdChjcm9zcyhhZCxub3IpLHBkKSk8My4wKVxcbiAgICAgP1xcbiAgICAgbWluKCBtaW4oIG1pbihcXG4gICAgIGRvdDIoYmEqY2xhbXAoZG90KGJhLHBhKS9kb3QyKGJhKSwwLjAsMS4wKS1wYSksXFxuICAgICBkb3QyKGNiKmNsYW1wKGRvdChjYixwYikvZG90MihjYiksMC4wLDEuMCktcGIpICksXFxuICAgICBkb3QyKGRjKmNsYW1wKGRvdChkYyxwYykvZG90MihkYyksMC4wLDEuMCktcGMpICksXFxuICAgICBkb3QyKGFkKmNsYW1wKGRvdChhZCxwZCkvZG90MihhZCksMC4wLDEuMCktcGQpIClcXG4gICAgIDpcXG4gICAgIGRvdChub3IscGEpKmRvdChub3IscGEpL2RvdDIobm9yKSApO1xcbn1cXG5cXG5cIl0pXG4gIH0sIFxuXG4gIFJvdW5kQm94OiB7XG4gICAgcGFyYW1ldGVyczpbXG4gICAgICB7IG5hbWU6J3NpemUnLCB0eXBlOid2ZWMzJywgZGVmYXVsdDpbMSwxLDFdLCBtaW46MCwgbWF4OjMgfSxcbiAgICAgIHsgbmFtZToncmFkaXVzJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjEsIG1pbjowLCBtYXg6MyB9LFxuICAgIF0sXG5cbiAgICBwcmltaXRpdmVTdHJpbmcoIHBOYW1lICkgeyBcbiAgICAgIHJldHVybiBgdWRSb3VuZEJveCggJHtwTmFtZX0sICR7dGhpcy5zaXplLmVtaXQoKX0sICAke3RoaXMucmFkaXVzLmVtaXQoKX0gKWBcbiAgICB9LCBcbiAgICBnbHNsaWZ5Omdsc2woW1wiI2RlZmluZSBHTFNMSUZZIDFcXG4gICAgZmxvYXQgdWRSb3VuZEJveCggdmVjMyBwLCB2ZWMzIGIsIGZsb2F0IHIgKVxcbntcXG4gIHJldHVybiBsZW5ndGgobWF4KGFicyhwKS1iLDAuMCkpLXI7XFxufVxcblxcblwiXSlcbiAgfSwgXG4gIFNwaGVyZTp7XG4gICAgcGFyYW1ldGVyczpbXG4gICAgICB7IG5hbWU6J3JhZGl1cycsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDoxLCBtaW46MCwgbWF4OjMgfSxcbiAgICBdLFxuXG4gICAgcHJpbWl0aXZlU3RyaW5nKCBwTmFtZSApIHsgXG4gICAgICByZXR1cm4gYChsZW5ndGgoJHtwTmFtZX0pIC0gJHt0aGlzLnJhZGl1cy5lbWl0KCl9KWBcbiAgICB9LFxuICAgIGdsc2xpZnk6Z2xzbChbXCIjZGVmaW5lIEdMU0xJRlkgMVxcbiAgICBmbG9hdCBzZFNwaGVyZSggdmVjMyBwLCBmbG9hdCBzIClcXG57XFxuICByZXR1cm4gbGVuZ3RoKCBwICkgLSBzO1xcbn1cXG5cXG5cIl0pXG4gIH0sXG4gIC8vIHBoaSwgbSwgbjEsIG4yLCBuMywgYSwgYlxuICBTdXBlckZvcm11bGE6e1xuICAgIHBhcmFtZXRlcnM6W1xuICAgICAgeyBuYW1lOidtXzEnLCB0eXBlOidmbG9hdCcsICBkZWZhdWx0OjEsIG1pbjotTWF0aC5QSSo0LCBtYXg6TWF0aC5QSSo0IH0sXG4gICAgICB7IG5hbWU6J24xXzEnLCB0eXBlOidmbG9hdCcsIGRlZmF1bHQ6MSwgbWluOi1NYXRoLlBJKjQsIG1heDpNYXRoLlBJKjQgfSxcbiAgICAgIHsgbmFtZTonbjJfMScsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDoxLCBtaW46LU1hdGguUEkqNCwgbWF4Ok1hdGguUEkqNCB9LFxuICAgICAgeyBuYW1lOiduM18xJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjEsIG1pbjotTWF0aC5QSSo0LCBtYXg6TWF0aC5QSSo0IH0sXG4gICAgICB7IG5hbWU6J2FfMScsIHR5cGU6J2Zsb2F0JywgIGRlZmF1bHQ6MSwgbWluOi1NYXRoLlBJKjQsIG1heDpNYXRoLlBJKjQgfSxcbiAgICAgIHsgbmFtZTonYl8xJywgdHlwZTonZmxvYXQnLCAgZGVmYXVsdDoxLCBtaW46LU1hdGguUEkqNCwgbWF4Ok1hdGguUEkqNCB9LFxuICAgICAgeyBuYW1lOidtXzInLCB0eXBlOidmbG9hdCcsICBkZWZhdWx0OjEsIG1pbjotTWF0aC5QSSo0LCBtYXg6TWF0aC5QSSo0IH0sXG4gICAgICB7IG5hbWU6J24xXzInLCB0eXBlOidmbG9hdCcsIGRlZmF1bHQ6MSwgbWluOi1NYXRoLlBJKjQsIG1heDpNYXRoLlBJKjQgfSxcbiAgICAgIHsgbmFtZTonbjJfMicsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDoxLCBtaW46LU1hdGguUEkqNCwgbWF4Ok1hdGguUEkqNCB9LFxuICAgICAgeyBuYW1lOiduM18yJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjEsIG1pbjotTWF0aC5QSSo0LCBtYXg6TWF0aC5QSSo0IH0sXG4gICAgICB7IG5hbWU6J2FfMicsIHR5cGU6J2Zsb2F0JywgIGRlZmF1bHQ6MSwgbWluOi1NYXRoLlBJKjQsIG1heDpNYXRoLlBJKjQgfSxcbiAgICAgIHsgbmFtZTonYl8yJywgdHlwZTonZmxvYXQnLCAgZGVmYXVsdDoxLCBtaW46LU1hdGguUEkqNCwgbWF4Ok1hdGguUEkqNCB9LFxuICAgIF0sXG5cbiAgICBwcmltaXRpdmVTdHJpbmcoIHBOYW1lICkgeyBcbiAgICAgIHJldHVybiBgc3VwZXJmb3JtdWxhKCAke3BOYW1lfSwgJHt0aGlzLm1fMS5lbWl0KCl9LCAke3RoaXMubjFfMS5lbWl0KCl9LCR7dGhpcy5uMl8xLmVtaXQoKX0sJHt0aGlzLm4zXzEuZW1pdCgpfSwke3RoaXMuYV8xLmVtaXQoKX0sJHt0aGlzLmJfMS5lbWl0KCl9LCAke3RoaXMubV8yLmVtaXQoKX0sICR7dGhpcy5uMV8yLmVtaXQoKX0sJHt0aGlzLm4yXzIuZW1pdCgpfSwke3RoaXMubjNfMi5lbWl0KCl9LCR7dGhpcy5hXzIuZW1pdCgpfSwke3RoaXMuYl8yLmVtaXQoKX0gKWBcbiAgICB9LFxuICAgIGdsc2xpZnk6Z2xzbChbXCIjZGVmaW5lIEdMU0xJRlkgMVxcbiAgICBmbG9hdCBTdXBlckZvcm11bGEoIGZsb2F0IHBoaSwgZmxvYXQgbSwgZmxvYXQgbjEsIGZsb2F0IG4yLCBmbG9hdCBuMywgZmxvYXQgYSwgZmxvYXQgYiApe1xcblxcdFxcblxcdGZsb2F0IHQxID0gYWJzKCgxLjAgLyBhKSAqIGNvcyhtICogcGhpIC8gNC4wKSk7XFxuXFx0dDEgPSBwb3codDEsIG4yKTtcXG5cXG5cXHRmbG9hdCB0MiA9IGFicygoYSAvIGIpICogc2luKG0gKiBwaGkgLyA0LjApKTtcXG5cXHR0MiA9IHBvdyh0MiwgbjMpO1xcblxcblxcdGZsb2F0IHQzID0gdDEgKyB0MjtcXG5cXG5cXHRmbG9hdCByID0gcG93KHQzLCAtMS4wIC8gbjEpO1xcblxcblxcdHJldHVybiByO1xcbn1cXG5cXG4gZmxvYXQgc3VwZXJmb3JtdWxhKCB2ZWMzIHAsIGZsb2F0IG1fMSwgZmxvYXQgbjFfMSwgZmxvYXQgbjJfMSwgZmxvYXQgbjNfMSwgZmxvYXQgYV8xLCBmbG9hdCBiXzEsIGZsb2F0IG1fMiwgZmxvYXQgbjFfMiwgZmxvYXQgbjJfMiwgZmxvYXQgbjNfMiwgZmxvYXQgYV8yLCBmbG9hdCBiXzIgKSB7XFxuICAgIGZsb2F0IGQgPSBsZW5ndGgoIHAgKTtcXG4gICAgZmxvYXQgdGhldGEgPSBhdGFuKHAueSwgcC54KTtcXG4gICAgZmxvYXQgcGhpID0gZCA9PSAwLiA/IDAuIDogYXNpbihwLnogLyBkKTtcXG4gICAgZmxvYXQgcjEgPSBTdXBlckZvcm11bGEoIHRoZXRhLCBtXzEsIG4xXzEsIG4yXzEsIG4zXzEsIGFfMSwgYl8xICk7XFxuICAgIGZsb2F0IHIyID0gU3VwZXJGb3JtdWxhKCBwaGksIG1fMiwgbjFfMiwgbjJfMiwgbjNfMiwgYV8yLCBiXzIgKTtcXG4gICAgdmVjMyBxID0gcjIgKiB2ZWMzKHIxICogY29zKHRoZXRhKSAqIGNvcyhwaGkpLCByMSAqIHNpbih0aGV0YSkgKiBjb3MocGhpKSwgc2luKHBoaSkpO1xcbiAgICBkID0gZCAtIGxlbmd0aChxKTtcXG5cXG4gICAgcmV0dXJuIGQ7XFxuICB9ICAgIFxcblwiLFwiXCJdKSB9LFxuIFxuICBUb3J1czp7XG4gICAgcGFyYW1ldGVyczpbXG4gICAgICB7IG5hbWU6J3JhZGlpJywgIHR5cGU6J3ZlYzInLCBkZWZhdWx0OlsuNSwuMV0sIG1pbjowLCBtYXg6MyB9LFxuICAgIF0sXG5cbiAgICBwcmltaXRpdmVTdHJpbmcoIHBuYW1lICkgeyBcbiAgICAgIHJldHVybiBgc2RUb3J1cyggJHtwbmFtZX0sICR7dGhpcy5yYWRpaS5lbWl0KCl9IClgXG4gICAgfSxcbiAgICBnbHNsaWZ5Omdsc2woW1wiI2RlZmluZSBHTFNMSUZZIDFcXG4gICAgZmxvYXQgc2RUb3J1cyggdmVjMyBwLCB2ZWMyIHQgKVxcbntcXG4gIHZlYzIgcSA9IHZlYzIobGVuZ3RoKHAueHopLXQueCxwLnkpO1xcbiAgcmV0dXJuIGxlbmd0aChxKS10Lnk7XFxufVxcblxcblwiXSlcblxuICB9LCAgXG4gIFRvcnVzODg6e1xuICAgIHBhcmFtZXRlcnM6W1xuICAgICAgeyBuYW1lOidyYWRpaScsICB0eXBlOid2ZWMyJywgZGVmYXVsdDpbLjUsLjFdLCBtaW46MCwgbWF4OjMgfSxcbiAgICBdLFxuXG4gICAgcHJpbWl0aXZlU3RyaW5nKCBwbmFtZSApIHsgXG4gICAgICByZXR1cm4gYHNkVG9ydXM4OCggJHtwbmFtZX0sICR7dGhpcy5yYWRpaS5lbWl0KCl9IClgXG4gICAgfSxcbiAgICBnbHNsaWZ5OmBmbG9hdCBzZFRvcnVzODgoIHZlYzMgcCwgdmVjMiB0ICkge1xuICAgICAgICB2ZWMyIHEgPSB2ZWMyKCBsZW5ndGg4KCBwLnh6ICkgLSB0LngsIHAueSApO1xuICAgICAgICByZXR1cm4gbGVuZ3RoOCggcSApIC0gdC55O1xuICAgICAgfVxcbmAsXG4gIH0sXG4gIFRvcnVzODI6e1xuICAgIHBhcmFtZXRlcnM6W1xuICAgICAgeyBuYW1lOidyYWRpaScsICB0eXBlOid2ZWMyJywgZGVmYXVsdDpbLjUsLjFdLCBtaW46MCwgbWF4OjMgfSxcbiAgICBdLFxuXG4gICAgcHJpbWl0aXZlU3RyaW5nKCBwbmFtZSApIHsgXG4gICAgICByZXR1cm4gYHNkVG9ydXM4MiggJHtwbmFtZX0sICR7dGhpcy5yYWRpaS5lbWl0KCl9IClgXG4gICAgfSxcbiAgICBnbHNsaWZ5OmBmbG9hdCBzZFRvcnVzODIoIHZlYzMgcCwgdmVjMiB0ICkge1xuICAgICAgICB2ZWMyIHEgPSB2ZWMyKCBsZW5ndGgoIHAueHogKSAtIHQueCwgcC55ICk7XG4gICAgICAgIHJldHVybiBsZW5ndGg4KCBxICkgLSB0Lnk7XG4gICAgICB9XFxuYFxuICB9LFxuIFx0VHJpYW5nbGU6IHtcbiAgICBwYXJhbWV0ZXJzOltcbiAgICAgIHsgbmFtZTondjEnLCB0eXBlOid2ZWMzJywgZGVmYXVsdDpbMCwtLjUsMF0gfSxcbiAgICAgIHsgbmFtZTondjInLCB0eXBlOid2ZWMzJywgZGVmYXVsdDpbLS41LC4wLDBdIH0sXG4gICAgICB7IG5hbWU6J3YzJywgdHlwZTondmVjMycsIGRlZmF1bHQ6Wy41LC4wLDBdIH0sXG4gICAgXSxcblxuICAgIHByaW1pdGl2ZXN0cmluZyggcG5hbWUgKSB7IFxuICAgICAgcmV0dXJuIGB1ZHRyaWFuZ2xlKCAke3BuYW1lfSwgJHt0aGlzLnYxLmVtaXQoKX0sICR7dGhpcy52Mi5lbWl0KCl9LCAke3RoaXMudjMuZW1pdCgpfSApYFxuICAgIH0sXG4gICAgZ2xzbGlmeTpnbHNsKFtcIiNkZWZpbmUgR0xTTElGWSAxXFxuICAgIGZsb2F0IGRvdDIoIGluIHZlYzMgdiApIHsgcmV0dXJuIGRvdCh2LHYpOyB9XFxuZmxvYXQgdWRUcmlhbmdsZSggdmVjMyBwLCB2ZWMzIGEsIHZlYzMgYiwgdmVjMyBjIClcXG57XFxuICAgIHZlYzMgYmEgPSBiIC0gYTsgdmVjMyBwYSA9IHAgLSBhO1xcbiAgICB2ZWMzIGNiID0gYyAtIGI7IHZlYzMgcGIgPSBwIC0gYjtcXG4gICAgdmVjMyBhYyA9IGEgLSBjOyB2ZWMzIHBjID0gcCAtIGM7XFxuICAgIHZlYzMgbm9yID0gY3Jvc3MoIGJhLCBhYyApO1xcblxcbiAgICByZXR1cm4gc3FydChcXG4gICAgKHNpZ24oZG90KGNyb3NzKGJhLG5vcikscGEpKSArXFxuICAgICBzaWduKGRvdChjcm9zcyhjYixub3IpLHBiKSkgK1xcbiAgICAgc2lnbihkb3QoY3Jvc3MoYWMsbm9yKSxwYykpPDIuMClcXG4gICAgID9cXG4gICAgIG1pbiggbWluKFxcbiAgICAgZG90MihiYSpjbGFtcChkb3QoYmEscGEpL2RvdDIoYmEpLDAuMCwxLjApLXBhKSxcXG4gICAgIGRvdDIoY2IqY2xhbXAoZG90KGNiLHBiKS9kb3QyKGNiKSwwLjAsMS4wKS1wYikgKSxcXG4gICAgIGRvdDIoYWMqY2xhbXAoZG90KGFjLHBjKS9kb3QyKGFjKSwwLjAsMS4wKS1wYykgKVxcbiAgICAgOlxcbiAgICAgZG90KG5vcixwYSkqZG90KG5vcixwYSkvZG90Mihub3IpICk7XFxufVxcblxcblwiXSlcbiAgfSwgXG5cbiAgVHJpUHJpc206IHtcbiAgICBwYXJhbWV0ZXJzOltcbiAgICAgIHsgbmFtZTonZGltZW5zaW9ucycsIHR5cGU6J3ZlYzInLCBkZWZhdWx0OlsuNSwuNV0sIG1pbjowLCBtYXg6MyB9LFxuICAgIF0sXG5cbiAgICBwcmltaXRpdmVTdHJpbmcoIHBOYW1lICkgeyBcbiAgICAgIHJldHVybiBgc2RUcmlQcmlzbSggJHtwTmFtZX0sICR7dGhpcy5kaW1lbnNpb25zLmVtaXQoKX0pYFxuICAgIH0sXG4gICAgZ2xzbGlmeTpnbHNsKFtcIiNkZWZpbmUgR0xTTElGWSAxXFxuICAgICAgZmxvYXQgc2RUcmlQcmlzbSggdmVjMyBwLCB2ZWMyIGggKVxcbntcXG4gICAgdmVjMyBxID0gYWJzKHApO1xcbiAgICByZXR1cm4gbWF4KHEuei1oLnksbWF4KHEueCowLjg2NjAyNStwLnkqMC41LC1wLnkpLWgueCowLjUpO1xcbn1cXG5cXG5cIl0pXG5cbiAgfSxcblxufVxuIiwiY29uc3QgeyBWYXIsIGZsb2F0X3Zhcl9nZW4sIHZlYzJfdmFyX2dlbiwgdmVjM192YXJfZ2VuLCB2ZWM0X3Zhcl9nZW4sIGludF92YXJfZ2VuLCBWYXJBbGxvYyB9ICA9IHJlcXVpcmUoICcuL3Zhci5qcycgKVxuY29uc3QgU2NlbmVOb2RlID0gcmVxdWlyZSggJy4vc2NlbmVOb2RlLmpzJyApXG5jb25zdCB7IHBhcmFtX3dyYXAsIE1hdGVyaWFsSUQgfSA9IHJlcXVpcmUoICcuL3V0aWxzLmpzJyApXG5jb25zdCB7IFZlYzIsIFZlYzMsIFZlYzQgfSA9IHJlcXVpcmUoICcuL3ZlYy5qcycgKVxuY29uc3QgVHJhbnNmb3JtID0gcmVxdWlyZSggJy4vdHJhbnNmb3JtLmpzJyApXG5cbmNvbnN0IGNyZWF0ZVByaW1pdGl2ZXMgPSBmdW5jdGlvbiggU0RGICkge1xuXG4gIGNvbnN0IGdlbnMgPSB7IFxuICAgIGludDogICBpbnRfdmFyX2dlbixcbiAgICBmbG9hdDogZmxvYXRfdmFyX2dlbixcbiAgICB2ZWMyOiB2ZWMyX3Zhcl9nZW4sXG4gICAgdmVjMzogdmVjM192YXJfZ2VuLFxuICAgIHZlYzQ6IHZlYzRfdmFyX2dlbixcbiAgfVxuXG4gIGNvbnN0IHZhcnMgPSB7IFxuICAgIHZlYzI6IFZlYzIsXG4gICAgdmVjMzogVmVjMyxcbiAgICB2ZWM0OiBWZWM0XG4gIH1cblxuICAvLyBsb2FkIGRlc2NyaXB0aW9ucyBvZiBhbGwgcHJpbXRpdmVzXG4gIGNvbnN0IGRlc2NyaXB0aW9ucyA9IHJlcXVpcmUoICcuL3ByaW1pdGl2ZURlc2NyaXB0aW9ucy5qcycgKVxuXG4gIGNvbnN0IFByaW1pdGl2ZXMgPSB7IFxuICAgIGRlc2NyaXB0aW9ucyxcblxuICAgIHRleHR1cmVNZW1vOiBbXSxcblxuICAgIGVtaXRfZ2VvbWV0cmllcygpIHtcbiAgICAgIGNvbnN0IGhlYWQgPSBBcnJheS5pc0FycmF5KCBTREYuX19zY2VuZS5fX3ByZXJlbmRlciApID8gU0RGLl9fc2NlbmUuX19wcmVyZW5kZXJbMF0gOiBTREYuX19zY2VuZS5fX3ByZXJlbmRlclxuICAgICAgY29uc3QgZ2VvcyA9IFByaW1pdGl2ZXMuY3Jhd2xOb2RlKCBoZWFkLCBbXSApXG5cbiAgICAgIGdlb3MuZm9yRWFjaCggKGdlbyxpKSA9PiB7XG4gICAgICAgIGdlby5fX3NkZklEID0gaSBcbiAgICAgICAgaWYoIGdlby5fX3RleHR1cmVPYmogIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICBTREYudGV4dHVyZXMuYWRkVGV4dHVyZSggZ2VvLl9fdGV4dHVyZU9iaiApXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IGxlbmd0aCA9IGdlb3MubGVuZ3RoXG4gICAgICBjb25zdCBtYXRlcmlhbHMgPSBTREYubWF0ZXJpYWxzLm1hdGVyaWFsc1xuXG4gICAgICBsZXQgZGVjbCA9IGBTREYgc2Rmc1ske2xlbmd0aH1dID0gU0RGWyR7bGVuZ3RofV0oXFxuYFxuICAgICAgZ2Vvcy5mb3JFYWNoKCAoZ2VvLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IHRleHR1cmVJRCA9IGdlby5fX3RleHR1cmVPYmogPT09IHVuZGVmaW5lZCA/IDUwMDAwIDogZ2VvLl9fdGV4dHVyZU9iai5pZFxuICAgICAgICBjb25zdCBoYXNSZXBlYXQgPSBnZW8ucmVwZWF0ICE9PSBudWxsICYmIGdlby5yZXBlYXQgIT09IHVuZGVmaW5lZFxuICAgICAgICBkZWNsICs9IGAgICAgICAgIFNERiggJHttYXRlcmlhbHMuaW5kZXhPZiggZ2VvLl9fbWF0ZXJpYWwgKX0sICR7Z2VvLnRyYW5zZm9ybS52YXJOYW1lfSwgJHt0ZXh0dXJlSUR9LCAke2hhc1JlcGVhdCA/IGdlby5yZXBlYXQuZGlzdGFuY2UuZW1pdCgpIDogJ3ZlYzMoMC4pJ30sICR7aGFzUmVwZWF0ID8gZ2VvLnJlcGVhdC50cmFuc2Zvcm0uZW1pdCgpIDogYG1hdDQoMS4pYH0gKWBcbiAgICAgICAgaWYoIGkgPCBnZW9zLmxlbmd0aCAtIDEgKSBkZWNsICs9ICcsJ1xuICAgICAgICBkZWNsICs9ICdcXG4nXG4gICAgICB9KVxuXG4gICAgICBkZWNsICs9IGAgICAgICApO1xcbmBcblxuICAgICAgdGhpcy5nZW9tZXRyaWVzID0gZ2Vvc1xuXG4gICAgICByZXR1cm4gZGVjbFxuICAgIH0sXG5cbiAgICBjcmF3bE5vZGUoIG5vZGUsIGFyciApIHtcbiAgICAgIGlmKCBub2RlLnR5cGUgPT09ICdnZW9tZXRyeScgKSB7XG4gICAgICAgIGFyci5wdXNoKCBub2RlIClcbiAgICAgIH1lbHNle1xuICAgICAgICBpZiggbm9kZS5hICE9PSB1bmRlZmluZWQgKSBQcmltaXRpdmVzLmNyYXdsTm9kZSggbm9kZS5hLCBhcnIgKVxuICAgICAgICBpZiggbm9kZS5iICE9PSB1bmRlZmluZWQgKSBQcmltaXRpdmVzLmNyYXdsTm9kZSggbm9kZS5iLCBhcnIgKVxuICAgICAgICBpZiggbm9kZS5zZGYgIT09IHVuZGVmaW5lZCApIFByaW1pdGl2ZXMuY3Jhd2xOb2RlKCBub2RlLnNkZiwgYXJyIClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGFyclxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGNyZWF0ZVByaW1pdGl2ZSA9IGZ1bmN0aW9uKCBuYW1lLCBkZXNjICkge1xuXG4gICAgY29uc3QgcGFyYW1zID0gZGVzYy5wYXJhbWV0ZXJzXG4gICAgLy8gY3JlYXRlIGNvbnN0cnVjdG9yXG4gICAgUHJpbWl0aXZlc1sgbmFtZSBdID0gZnVuY3Rpb24oIC4uLmFyZ3MgKSB7XG4gICAgICBjb25zdCBwID0gT2JqZWN0LmNyZWF0ZSggUHJpbWl0aXZlc1sgbmFtZSBdLnByb3RvdHlwZSApXG4gICAgICBwLnBhcmFtcyA9IHBhcmFtc1xuICAgICAgcC50cmFuc2Zvcm0gPSBUcmFuc2Zvcm0oKVxuICAgICAgcC50cmFuc2Zvcm0uc2hvdWxkSW52ZXJ0ID0gdHJ1ZVxuICAgICAgcC50eXBlID0gJ2dlb21ldHJ5J1xuICAgICAgcC5uYW1lID0gbmFtZVxuICAgICAgcC5yZXBlYXQgPSBudWxsLy9WYXIoIHZhcnMudmVjMyggMCApLCBudWxsLCAndmVjMycgKVxuXG4gICAgICBwLl9fbWF0ZXJpYWwgPSBudWxsXG4gICAgICBwLl9fdGV4dHVyZUlEICA9IDUwMDAwMFxuICAgICAgXG4gICAgICBsZXQgY291bnQgPSAwXG5cbiAgICAgIC8vIHdyYXAgZWFjaCBwYXJhbSBpbiBhIFZhciBvYmplY3QgZm9yIGNvZGVnZW5cbiAgICAgIGZvciggbGV0IHBhcmFtIG9mIHBhcmFtcyApIHtcbiAgICAgICAgaWYoIHBhcmFtLm5hbWUgPT09ICdjb2xvcicgKSB7XG4gICAgICAgICAgcC5jb2xvciA9IGFyZ3NbIGNvdW50IF0gPT09IHVuZGVmaW5lZCA/IHBhcmFtLmRlZmF1bHQgOiBhcmdzWyBjb3VudCsrIF1cbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICAgIGlmKCBwYXJhbS50eXBlID09PSAnb2JqJyApIHtcbiAgICAgICAgICBsZXQgX192YWx1ZSA9IGFyZ3NbIGNvdW50KysgXVxuICAgICAgICAgIHBbIHBhcmFtLm5hbWUgXSA9IHtcbiAgICAgICAgICAgIGdldCB2YWx1ZSgpIHsgcmV0dXJuIF9fdmFsdWUgfSxcbiAgICAgICAgICAgIHNldCB2YWx1ZSh2KXsgX192YWx1ZSA9IHYgfSxcbiAgICAgICAgICAgIGVtaXQoKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG91dHB1dCA9ICBwWyBwYXJhbS5uYW1lIF0udmFsdWUuZW1pdCgpXG4gICAgICAgICAgICAgIHJldHVybiBvdXRwdXRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbWl0X2RlY2woKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwWyBwYXJhbS5uYW1lIF0udmFsdWUuYS5lbWl0X2RlY2woKSArIHBbcGFyYW0ubmFtZV0udmFsdWUuYi5lbWl0X2RlY2woKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZXMgPSBwYXJhbS5kZWZhdWx0XG4gICAgICAgIGNvbnN0IGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KCBkZWZhdWx0VmFsdWVzIClcblxuICAgICAgICBpZiggaXNBcnJheSApIHtcbiAgICAgICAgICBsZXQgdmFsID0gYXJnc1sgY291bnQrKyBdLCBfX3ZhclxuXG4gICAgICAgICAgaWYoIHR5cGVvZiB2YWwgPT09ICdudW1iZXInICkge1xuICAgICAgICAgICAgX192YXIgPSBWYXIoIHZhcnNbIHBhcmFtLnR5cGUgXSggdmFsICksIG51bGwsICd2ZWMzJyApXG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBfX3ZhciA9ICBwYXJhbV93cmFwKFxuICAgICAgICAgICAgICB2YWwsXG4gICAgICAgICAgICAgIGdlbnNbIHBhcmFtLnR5cGUgXSggLi4uZGVmYXVsdFZhbHVlcyApIFxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGZvciBhc3NpZ25pbmcgZW50aXJlIG5ldyB2ZWN0b3JzIHRvIHByb3BlcnR5XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBwLCBwYXJhbS5uYW1lLCB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6dHJ1ZSxcbiAgICAgICAgICAgIGdldCgpIHsgcmV0dXJuIF9fdmFyIH0sXG4gICAgICAgICAgICBzZXQodikge1xuICAgICAgICAgICAgICBpZiggdHlwZW9mIHYgPT09ICdvYmplY3QnICkge1xuICAgICAgICAgICAgICAgIF9fdmFyLnNldCggdiApXG4gICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIF9fdmFyLnZhbHVlLnggPSB2XG4gICAgICAgICAgICAgICAgX192YXIudmFsdWUueSA9IHZcbiAgICAgICAgICAgICAgICBfX3Zhci52YWx1ZS56ID0gdlxuICAgICAgICAgICAgICAgIF9fdmFyLnZhbHVlLncgPSB2XG4gICAgICAgICAgICAgICAgX192YXIuZGlydHkgPSB0cnVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIGxldCBfX3ZhciAgPSBwYXJhbV93cmFwKCBcbiAgICAgICAgICAgIGFyZ3NbIGNvdW50KysgXSwgXG4gICAgICAgICAgICBnZW5zWyBwYXJhbS50eXBlIF0oIGRlZmF1bHRWYWx1ZXMgKSBcbiAgICAgICAgICApXG5cbiAgICAgICAgICAvL19fdmFyLnNldCggZGVmYXVsdFZhbHVlcyApXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBwLCBwYXJhbS5uYW1lLCB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6dHJ1ZSxcbiAgICAgICAgICAgIGdldCgpIHsgcmV0dXJuIF9fdmFyIH0sXG4gICAgICAgICAgICBzZXQodikge1xuICAgICAgICAgICAgICBfX3Zhci5zZXQoIHYgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcC5pZCA9IFZhckFsbG9jLmFsbG9jKClcblxuICAgICAgcC5fX2Rlc2MgPSBkZXNjXG4gICAgICBwLl9fc2V0TWF0ZXJpYWwgPSBmdW5jdGlvbihtYXQpIHtcbiAgICAgICAgaWYoIHR5cGVvZiBtYXQgPT09ICdzdHJpbmcnICkgbWF0ID0gU0RGLk1hdGVyaWFsWyBtYXQgXVxuICAgICAgICB0aGlzLl9fbWF0ZXJpYWwgPSB0aGlzLm1hdCA9IFNERi5tYXRlcmlhbHMuYWRkTWF0ZXJpYWwoIG1hdCApXG4gICAgICB9XG5cbiAgICAgIHAuX19zZXRUZXh0dXJlID0gZnVuY3Rpb24odGV4LHByb3BzKSB7XG4gICAgICAgIGlmKCB0eXBlb2YgdGV4ID09PSAnc3RyaW5nJyApIHtcbiAgICAgICAgICB0aGlzLnRleHR1cmUgPSBwLnRleHR1cmUuYmluZCggdGhpcyApXG4gICAgICAgICAgdGhpcy5fX3RleHR1cmVPYmogPSB0aGlzLnRleCA9IFNERi5UZXh0dXJlKCB0ZXgscHJvcHMsdGhpcy50ZXh0dXJlIClcbiAgICAgICAgICB0aGlzLl9fdGV4dHVyZUlEID0gdGhpcy5fX3RleHR1cmVPYmouaWRcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgdGhpcy5fX3RleHR1cmVPYmogPSB0aGlzLnRleCA9IE9iamVjdC5hc3NpZ24oIHRleCwgcHJvcHMgKVxuICAgICAgICAgIHRoaXMuX190ZXh0dXJlSUQgPSB0aGlzLl9fdGV4dHVyZU9iai5pZFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwLl9fc2V0QnVtcCA9IGZ1bmN0aW9uKHRleCxwcm9wcykge1xuICAgICAgICAvL3RoaXMuYnVtcCA9IHAuYnVtcC5iaW5kKCB0aGlzIClcbiAgICAgICAgY29uc3QgYiA9IHRoaXMuYnVtcCA9IHRoaXMuX19idW1wT2JqID0gU0RGLkJ1bXAoIHRoaXMsIHRleCwgcHJvcHMgKVxuICAgICAgICB0aGlzLmJ1bXAudGV4dHVyZSA9IHRoaXMuYnVtcC5hbW91bnQudmFsdWVcbiAgICAgICAgdGhpcy5fX2J1bXBJRCA9IHRoaXMuX19idW1wT2JqLmlkXG4gICAgICAgIHRoaXMucm90YXRlID0gdGhpcy5idW1wLnJvdGF0ZVxuICAgICAgICB0aGlzLnRyYW5zbGF0ZSA9IHRoaXMuYnVtcC50cmFuc2xhdGVcbiAgICAgICAgdGhpcy5zY2FsZSA9IHRoaXMuYnVtcC5zY2FsZVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMuYnVtcCwgJ3N0cmVuZ3RoJywge1xuICAgICAgICAgIGdldCgpIHsgcmV0dXJuIGIuc2l6ZSB9LFxuICAgICAgICAgIHNldCh2KXsgYi5zaXplID0gdiB9XG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIE9iamVjdC5hc3NpZ24oIHAsIHtcbiAgICAgICAgcmVuZGVyaW5nQnVtcCA6IGZhbHNlLFxuICAgICAgICBlbWl0dGluZ0RlY2wgIDogZmFsc2UsXG4gICAgICAgIHVwbG9hZGluZyAgICAgOiBmYWxzZSxcbiAgICAgICAgdXBkYXRpbmcgICAgICA6IGZhbHNlXG4gICAgICB9KVxuXG4gICAgICBpZiggcC5fX21hdGVyaWFsID09PSBudWxsICkgcC5fX3NldE1hdGVyaWFsKClcblxuICAgICAgU0RGLmdlb21ldHJpZXMucHVzaCggcCApXG5cbiAgICAgIHJldHVybiBwXG4gICAgfVxuXG4gICAgLy8gZGVmaW5lIHByb3RvdHlwZSB0byB1c2VcbiAgICBQcmltaXRpdmVzWyBuYW1lIF0ucHJvdG90eXBlID0gU2NlbmVOb2RlKClcbiAgICBQcmltaXRpdmVzWyBuYW1lIF0ucHJvdG90eXBlLnR5cGUgPSAnZ2VvbWV0cnknXG4gICAgXG4gICAgLy8gY3JlYXRlIGNvZGVnZW4gc3RyaW5nXG5cblxuICAgIFByaW1pdGl2ZXNbIG5hbWUgXS5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uICggX19uYW1lLCB0cmFuc2Zvcm0gPSBudWxsLCBidW1wPW51bGwsIHNjYWxlPW51bGwgKSB7XG4gICAgICBpZiggU0RGLm1lbW9bIHRoaXMuaWQgXSAhPT0gdW5kZWZpbmVkICkgcmV0dXJuIHsgcHJlZmFjZTonJywgb3V0Om5hbWUrdGhpcy5tYXRJZCB9XG4gICAgICBpZiggdGhpcy5fX2J1bXBPYmogIT09IHVuZGVmaW5lZCAmJiB0aGlzLnJlbmRlcmluZ0J1bXAgPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMucmVuZGVyaW5nQnVtcCA9IHRydWVcbiAgICAgICAgcmV0dXJuIHRoaXMuX19idW1wT2JqLmVtaXQoIF9fbmFtZSwgdHJhbnNmb3JtIClcbiAgICAgIH1cbiAgICAgIFxuICAgICAgY29uc3Qgc2hhZGVyQ29kZSA9IGRlc2MuZ2xzbGlmeS5pbmRleE9mKCcjJykgPiAtMSBcbiAgICAgICAgPyBkZXNjLmdsc2xpZnkuc2xpY2UoMTgpIFxuICAgICAgICA6IGRlc2MuZ2xzbGlmeVxuXG4gICAgICBpZiggU0RGLnJlcXVpcmVkR2VvbWV0cmllcy5pbmRleE9mKCBzaGFkZXJDb2RlICkgPT09IC0gMSApIHtcbiAgICAgICAgU0RGLnJlcXVpcmVkR2VvbWV0cmllcy5wdXNoKCBzaGFkZXJDb2RlIClcbiAgICAgIH0gXG5cbiAgICAgIGlmKCB0cmFuc2Zvcm0gIT09IG51bGwgKSB0aGlzLnRyYW5zZm9ybS5hcHBseSggdHJhbnNmb3JtLCBmYWxzZSApXG4gICAgICAvL3RoaXMudHJhbnNmb3JtLmludmVydCggdHJ1ZSApXG4gICAgICB0aGlzLnRyYW5zZm9ybS5pbnRlcm5hbCgpXG5cbiAgICAgIGNvbnN0IHBuYW1lID0gdHlwZW9mIF9fbmFtZSAhPT0gJ3N0cmluZycgPyAncCcgOiBfX25hbWUsXG4gICAgICAgICAgICBpZCA9IHRoaXMuX19zZGZJRCxcbiAgICAgICAgICAgIHMgPSBzY2FsZSA9PT0gbnVsbCA/IHRoaXMudHJhbnNmb3JtLmVtaXRfc2NhbGUoKSA6IGAke3RoaXMudHJhbnNmb3JtLmVtaXRfc2NhbGUoKX0gKiAke3NjYWxlfWAsXG4gICAgICAgICAgICB0c3RyaW5nID0gYCggJHtwbmFtZX0gKiAke3RoaXMudHJhbnNmb3JtLmVtaXQoKX0gKS54eXpgXG4gICAgICBcbiAgICAgIGNvbnN0IHByaW1pdGl2ZSA9IGBcbiAgICAgICAgdmVjMiAke25hbWV9JHt0aGlzLmlkfSA9IHZlYzIoICR7ZGVzYy5wcmltaXRpdmVTdHJpbmcuY2FsbCggdGhpcywgdHN0cmluZywgYnVtcCApfSAqICR7c30sICR7aWR9Lik7XG4gICAgICBgXG4gICAgICBTREYubWVtb1sgdGhpcy5pZCBdID0gbmFtZSArIHRoaXMuaWRcblxuICAgICAgdGhpcy5yZW5kZXJpbmdCdW1wID0gZmFsc2VcbiAgICAgIHJldHVybiB7IHByZWZhY2U6cHJpbWl0aXZlLCBvdXQ6bmFtZSt0aGlzLmlkICB9XG4gICAgfVxuICAgIFxuICAgIC8vIGRlY2xhcmUgYW55IHVuaWZvcm0gdmFyaWFibGVzXG4gICAgUHJpbWl0aXZlc1sgbmFtZSBdLnByb3RvdHlwZS5lbWl0X2RlY2wgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmKCB0aGlzLl9fYnVtcE9iaiAhPT0gdW5kZWZpbmVkICYmIHRoaXMuZW1pdHRpbmdEZWNsID09PSBmYWxzZSkge1xuICAgICAgICB0aGlzLmVtaXR0aW5nRGVjbCA9IHRydWVcbiAgICAgICAgcmV0dXJuIHRoaXMuX19idW1wT2JqLmVtaXRfZGVjbCgpIFxuICAgICAgfVxuICAgICAgbGV0IGRlY2wgPSAnJ1xuICAgICAgZGVjbCArPSB0aGlzLnRyYW5zZm9ybS5lbWl0X2RlY2woKVxuXG4gICAgICAvL2RlYnVnZ2VyXG4gICAgICBpZiggdGhpcy5fX3JlcGVhdCAhPT0gdW5kZWZpbmVkICkgZGVjbCArPSB0aGlzLl9fcmVwZWF0LmVtaXRfZGVjbCggZmFsc2UgKVxuICAgICAgaWYoIHRoaXMuX19wb2xhclJlcGVhdCAhPT0gdW5kZWZpbmVkICkgZGVjbCArPSB0aGlzLl9fcG9sYXJSZXBlYXQuZW1pdF9kZWNsKCBmYWxzZSApXG5cbiAgICAgIGZvciggbGV0IHBhcmFtIG9mIHBhcmFtcyApIHtcbiAgICAgICAgaWYoIHBhcmFtLm5hbWUgIT09ICdtYXRlcmlhbCcgKVxuICAgICAgICAgIGRlY2wgKz0gdGhpc1sgcGFyYW0ubmFtZSBdLmVtaXRfZGVjbCggKVxuICAgICAgfVxuXG4gICAgICB0aGlzLmVtaXR0aW5nRGVjbCA9IGZhbHNlXG4gICAgICByZXR1cm4gZGVjbFxuICAgIH1cblxuICAgIFByaW1pdGl2ZXNbIG5hbWUgXS5wcm90b3R5cGUudXBkYXRlX2xvY2F0aW9uID0gZnVuY3Rpb24oIGdsLCBwcm9ncmFtICkge1xuICAgICAgaWYoIHRoaXMuX19idW1wT2JqICE9PSB1bmRlZmluZWQgJiYgdGhpcy51cGRhdGluZyA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy51cGRhdGluZyA9IHRydWVcbiAgICAgICAgcmV0dXJuIHRoaXMuX19idW1wT2JqLnVwZGF0ZV9sb2NhdGlvbiggZ2wsIHByb2dyYW0gKVxuICAgICAgfVxuXG4gICAgICBmb3IoIGxldCBwYXJhbSBvZiBwYXJhbXMgKSB7XG4gICAgICAgIGlmKCBwYXJhbS50eXBlICE9PSAnb2JqJyApIHtcbiAgICAgICAgICBpZiggcGFyYW0ubmFtZSAhPT0gJ21hdGVyaWFsJyApIFxuICAgICAgICAgICAgdGhpc1sgcGFyYW0ubmFtZSBdLnVwZGF0ZV9sb2NhdGlvbiggZ2wscHJvZ3JhbSApXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoIHRoaXMuX19yZXBlYXQgIT09IHVuZGVmaW5lZCApIHRoaXMuX19yZXBlYXQudXBkYXRlX2xvY2F0aW9uKCBnbCwgcHJvZ3JhbSwgZmFsc2UgKVxuICAgICAgaWYoIHRoaXMuX19wb2xhclJlcGVhdCAhPT0gdW5kZWZpbmVkICkgdGhpcy5fX3BvbGFyUmVwZWF0LnVwZGF0ZV9sb2NhdGlvbiggZ2wsIHByb2dyYW0sIGZhbHNlIClcbiAgICAgIHRoaXMudHJhbnNmb3JtLnVwZGF0ZV9sb2NhdGlvbiggZ2wsIHByb2dyYW0gKVxuICAgICAgdGhpcy51cGRhdGluZyA9IGZhbHNlXG4gICAgfVxuXG4gICAgUHJpbWl0aXZlc1sgbmFtZSBdLnByb3RvdHlwZS51cGxvYWRfZGF0YSA9IGZ1bmN0aW9uKCBnbCApIHtcbiAgICAgIGlmKCB0aGlzLl9fYnVtcE9iaiAhPT0gdW5kZWZpbmVkICYmIHRoaXMudXBsb2FkaW5nICA9PT0gZmFsc2UgKSB7XG4gICAgICAgIHRoaXMudXBsb2FkaW5nID0gdHJ1ZVxuICAgICAgICByZXR1cm4gdGhpcy5fX2J1bXBPYmoudXBsb2FkX2RhdGEoIGdsIClcbiAgICAgIH1cbiAgICAgIGZvciggbGV0IHBhcmFtIG9mIHBhcmFtcyApIHtcbiAgICAgICAgaWYoIHBhcmFtLnR5cGUgIT09ICdvYmonICYmIHBhcmFtLm5hbWUgIT09ICdtYXRlcmlhbCcgKVxuICAgICAgICAgIHRoaXNbIHBhcmFtLm5hbWUgXS51cGxvYWRfZGF0YSggZ2wgKVxuICAgICAgfVxuXG4gICAgICBpZiggdGhpcy5fX3BvbGFyUmVwZWF0ICE9PSB1bmRlZmluZWQgKSB0aGlzLl9fcG9sYXJSZXBlYXQudXBsb2FkX2RhdGEoIGdsLCBmYWxzZSApXG4gICAgICB0aGlzLnRyYW5zZm9ybS51cGxvYWRfZGF0YSggZ2wgKVxuICAgICAgdGhpcy51cGxvYWRpbmcgPSBmYWxzZVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gUHJpbWl0aXZlc1sgbmFtZSBdXG4gIH1cbiAgXG4gIGZvciggbGV0IG5hbWUgaW4gZGVzY3JpcHRpb25zICkge1xuICAgIGNvbnN0IGRlc2MgPSBkZXNjcmlwdGlvbnNbIG5hbWUgXVxuICAgIGNyZWF0ZVByaW1pdGl2ZSggbmFtZSwgZGVzYyApXG4gIH1cblxuICBQcmltaXRpdmVzLmNyZWF0ZSA9IGNyZWF0ZVByaW1pdGl2ZVxuXG4gIHJldHVybiBQcmltaXRpdmVzXG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlUHJpbWl0aXZlc1xuIiwiY29uc3QgZ2xzbCA9IHJlcXVpcmUoICdnbHNsaWZ5JyApXG5cbmNvbnN0IGdldE1haW5Db250aW51b3VzID0gZnVuY3Rpb24oIHN0ZXBzLCBtaW5EaXN0YW5jZSwgbWF4RGlzdGFuY2UsIHBvc3Rwcm9jZXNzaW5nICkge1xuICBjb25zdCBvdXQgPSBgXG4gIC8vIGFkYXB0ZWQgZnJvbSBodHRwczovL3d3dy5zaGFkZXJ0b3kuY29tL3ZpZXcvbGRmU1dzXG4gIHZlYzMgY2FsY05vcm1hbCh2ZWMzIHBvcywgZmxvYXQgZXBzKSB7XG4gICAgY29uc3QgdmVjMyB2MSA9IHZlYzMoIDEuMCwtMS4wLC0xLjApO1xuICAgIGNvbnN0IHZlYzMgdjIgPSB2ZWMzKC0xLjAsLTEuMCwgMS4wKTtcbiAgICBjb25zdCB2ZWMzIHYzID0gdmVjMygtMS4wLCAxLjAsLTEuMCk7XG4gICAgY29uc3QgdmVjMyB2NCA9IHZlYzMoIDEuMCwgMS4wLCAxLjApO1xuXG4gICAgcmV0dXJuIG5vcm1hbGl6ZSggdjEgKiBzY2VuZSAoIHBvcyArIHYxKmVwcyApLngrXG4gICAgICAgICAgICAgICAgICAgICAgdjIgKiBzY2VuZSAoIHBvcyArIHYyKmVwcyApLngrXG4gICAgICAgICAgICAgICAgICAgICAgdjMgKiBzY2VuZSAoIHBvcyArIHYzKmVwcyApLngrXG4gICAgICAgICAgICAgICAgICAgICAgdjQgKiBzY2VuZSAoIHBvcyArIHY0KmVwcyApLngpO1xuICB9XG5cbiAgdmVjMyBjYWxjTm9ybWFsKHZlYzMgcG9zKSB7XG4gICAgcmV0dXJuIGNhbGNOb3JtYWwocG9zLCAwLjAwMik7XG4gIH1cblxuICAvLyBBZGFwdGVkIGZyb20gZnJvbSBodHRwczovL3d3dy5zaGFkZXJ0b3kuY29tL3ZpZXcvbGRmU1dzXG4gIHZlYzIgY2FsY1JheUludGVyc2VjdGlvbiggdmVjMyByYXlPcmlnaW4sIHZlYzMgcmF5RGlyLCBmbG9hdCBtYXhkLCBmbG9hdCBwcmVjaXMgKSB7XG4gICAgZmxvYXQgbGF0ZXN0ID0gcHJlY2lzICogMi4wO1xuICAgIGZsb2F0IGRpc3QgICA9ICswLjA7XG4gICAgZmxvYXQgdHlwZSAgID0gLTEuMDtcbiAgICB2ZWMyIHJlc3VsdDtcbiAgICB2ZWMyIHJlcyA9IHZlYzIoLTUwMDAwLiwgLTEuKTs7XG5cbiAgICBmb3IgKGludCBpID0gMDsgaSA8ICR7c3RlcHN9IDsgaSsrKSB7XG4gICAgICBpZiAobGF0ZXN0IDwgcHJlY2lzIHx8IGRpc3QgPiBtYXhkKSBicmVhaztcblxuICAgICAgcmVzdWx0ID0gc2NlbmUocmF5T3JpZ2luICsgcmF5RGlyICogZGlzdCk7XG5cbiAgICAgIGxhdGVzdCA9IHJlc3VsdC54O1xuICAgICAgZGlzdCAgKz0gbGF0ZXN0O1xuICAgIH1cblxuICAgIGlmKCBkaXN0IDwgbWF4ZCApIHtcbiAgICAgIHJlc3VsdC54ID0gZGlzdDtcbiAgICAgIHJlcyA9IHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgbGF5b3V0KGxvY2F0aW9uID0gMCkgb3V0IHZlYzQgY29sO1xuICBsYXlvdXQobG9jYXRpb24gPSAxKSBvdXQgdmVjNCBkZXB0aDtcbiAgdm9pZCBtYWluKCkge1xuICAgIHZlYzIgcG9zID0gdl91diAqIDIuMCAtIDEuMDtcblxuICAgIC8vIG5vdCBzdXJlIHdoeSBJIG5lZWQgdGhlIC15IGF4aXMgYnV0IHdpdGhvdXQgaXRcbiAgICAvLyBldmVyeXRoaW5nIGlzIGZsaXBwZWQgdXNpbmcgcGVyc3BlY3RpdmUtY2FtZXJhXG4gICAgcG9zLnggKj0gKCByZXNvbHV0aW9uLnggLyAtcmVzb2x1dGlvbi55ICk7XG5cbiAgICB2ZWMzIGNvbG9yID0gYmc7IFxuICAgIHZlYzMgcm8gPSBjYW1lcmFfcG9zO1xuICAgIHZlYzMgcmQgPSBub3JtYWxpemUoIG1hdDMoY2FtZXJhKSAqIHZlYzMoIHBvcywgMi4gKSApOyBcbiAgICBcbiAgICB2ZWMyIHQgPSBjYWxjUmF5SW50ZXJzZWN0aW9uKCBybywgcmQsICR7bWF4RGlzdGFuY2V9LCAke21pbkRpc3RhbmNlfSApO1xuXG4gICAgdmVjMyBzYW1wbGVQb3MgPSB2ZWMzKDEwMC5mKTtcbiAgICBmbG9hdCB6ZGlzdCA9IDEwMDAwMC47Ly92ZWMzKDEwMDAwMC5mKTtcbiAgICBpZiggdC54ID4gLTAuNSApIHtcbiAgICAgIHNhbXBsZVBvcyA9IHJvICsgcmQgKiB0Lng7XG4gICAgICB6ZGlzdCA9IHJkLnogKiB0Lng7XG4gICAgICB2ZWMzIG5vciA9IGNhbGNOb3JtYWwoIHNhbXBsZVBvcyApO1xuXG4gICAgICBjb2xvciA9IGxpZ2h0aW5nKCBzYW1wbGVQb3MsIG5vciwgcm8sIHJkLCB0LnksIHRydWUgKTsgXG4gICAgfVxuXG4gICAgJHtwb3N0cHJvY2Vzc2luZ31cbiAgICBcbiAgICBjb2wgPSBjbGFtcCggdmVjNCggY29sb3IsIDEuMCApLCAwLiwgMS4gKTtcbiAgICAvL2Zsb2F0IG5vcm1hbGl6ZWREZXB0aCA9IDEuLSAoKHNhbXBsZVBvcy56KSAvICR7bWF4RGlzdGFuY2V9KTtcblxuICAgIGZsb2F0IG5vcm1hbGl6ZWREZXB0aCA9IDEuIC8gKDEuIC0gc2FtcGxlUG9zLnopO1xuICAgIGRlcHRoID0gc2FtcGxlUG9zLnogPCAke21heERpc3RhbmNlfSA/IHZlYzQoIHZlYzMoIG5vcm1hbGl6ZWREZXB0aCApLCAxLiApIDogdmVjNCgwLik7XG4gICAgLy9kZXB0aCA9IHNhbXBsZVBvcy56IDwgJHttYXhEaXN0YW5jZX0gPyB2ZWM0KCB2ZWMzKCAxLi8oMS4rbm9ybWFsaXplZERlcHRoKSAqIDI1NS4gKSwgMS4gKSA6IHZlYzQoMC4pO1xuLy8vL3ZlYzQoMS4vKDEuICsgemRpc3QgKSk7XG4gIH1gXG5cbiAgcmV0dXJuIG91dFxufVxuXG5jb25zdCBnZXRNYWluVm94ZWxzID0gZnVuY3Rpb24oIHN0ZXBzLCBwb3N0cHJvY2Vzc2luZywgdm94ZWxTaXplID0gLjEgKSB7XG4gIGNvbnN0IG91dCA9IGBcbiAgc3RydWN0IFZveGVsRGlzdGFuY2Uge1xuICAgIGJ2ZWMzIG1hc2s7XG4gICAgdmVjMyAgZGlzdGFuY2U7XG4gICAgZmxvYXQgZm9nQ29lZmY7XG4gICAgaW50ICAgaWQ7XG4gIH07XG5cbiAgVm94ZWxEaXN0YW5jZSBjYWxjUmF5SW50ZXJzZWN0aW9uKCB2ZWMzIHJheU9yaWdpbiwgdmVjMyByYXlEaXIgKSB7XG4gICAgdmVjMiByZXN1bHQ7XG5cbiAgICBmbG9hdCBtID0gJHt2b3hlbFNpemV9O1xuICAgIHJheU9yaWdpbiAqPSAxLi9tO1xuICAgIHZlYzMgbWFwUG9zID0gdmVjMyhmbG9vcihyYXlPcmlnaW4pKTtcbiAgICB2ZWMzIGRpZmYgPSBtYXBQb3MgLSByYXlPcmlnaW47XG5cbiAgICB2ZWMzIGRlbHRhRGlzdCA9IGFicyh2ZWMzKGxlbmd0aChyYXlEaXIpKSAvIHJheURpcik7XG4gICAgdmVjMyByYXlTdGVwID0gdmVjMyhzaWduKHJheURpcikpO1xuICAgIHZlYzMgc2lkZURpc3QgPSAoc2lnbihyYXlEaXIpICogZGlmZiArIChzaWduKHJheURpcikgKiAwLjUpICsgMC41KSAqIGRlbHRhRGlzdDsgXG5cbiAgICBidmVjMyBtYXNrO1xuICAgIHZlYzMgZCA9IHZlYzMoLTEwMDAwMC4pO1xuICAgIGZsb2F0IGZvZ0NvZWZmID0gMC47XG5cbiAgICBmb3IgKGludCBpID0gMDsgaSA8ICR7TWF0aC5yb3VuZChzdGVwcyoxL3ZveGVsU2l6ZSl9IDsgaSsrKSB7XG4gICAgICByZXN1bHQgPSBzY2VuZShtYXBQb3MqbSk7XG4gICAgICBpZiggcmVzdWx0LnggPD0gMC4gKSB7XG4gICAgICAgIGQgPSBtYXBQb3MqbStyZXN1bHQueDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIG1hc2sgPSBidmVjMyggbGVzc1RoYW5FcXVhbChzaWRlRGlzdC54eXosIG1pbihzaWRlRGlzdC55engsIHNpZGVEaXN0Lnp4eSkpICk7XG4gICAgICBzaWRlRGlzdCArPSB2ZWMzKCBtYXNrICkgKiBkZWx0YURpc3Q7IFxuICAgICAgbWFwUG9zICs9IHZlYzMobWFzaykgKiByYXlTdGVwO1xuICAgICAgZm9nQ29lZmYgKz0gcmVzdWx0LnggKiBtO1xuICAgIH1cblxuICAgIFZveGVsRGlzdGFuY2UgdmQgPSBWb3hlbERpc3RhbmNlKCBtYXNrLCBkLCBmb2dDb2VmZiwgaW50KHJlc3VsdC55KSApO1xuICAgIHJldHVybiB2ZDtcbiAgfVxuXG4gIG91dCB2ZWM0IGNvbDtcbiAgdm9pZCBtYWluKCkge1xuICAgIHZlYzIgcG9zID0gdl91diAqIDIuMCAtIDEuMDtcblxuICAgIC8vIG5vdCBzdXJlIHdoeSBJIG5lZWQgdGhlIC15IGF4aXMgYnV0IHdpdGhvdXQgaXRcbiAgICAvLyBldmVyeXRoaW5nIGlzIGZsaXBwZWQgdXNpbmcgcGVyc3BlY3RpdmUtY2FtZXJhXG4gICAgcG9zLnggKj0gKCByZXNvbHV0aW9uLnggLyAtcmVzb2x1dGlvbi55ICk7XG4gICAgXG4gICAgdmVjMyBjb2xvciA9IGJnOyBcbiAgICB2ZWMzIHJvID0gY2FtZXJhX3BvcztcbiAgICB2ZWMzIHJkID0gbm9ybWFsaXplKCBtYXQzKGNhbWVyYSkgKiB2ZWMzKCBwb3MsIDIuICkgKTsgXG4gICAgICAgICAgICAgICAgIFxuICAgIFZveGVsRGlzdGFuY2UgdmQgPSBjYWxjUmF5SW50ZXJzZWN0aW9uKCBybywgcmQgKTtcbiAgICBidmVjMyBtYXNrID0gdmQubWFzaztcbiAgICBcbiAgICB2ZWMzIG5vcjtcbiAgICBpZiAobWFzay54KSB7XG4gICAgICBjb2xvciA9IHZlYzMoMC41KTtcbiAgICAgIG5vciA9IHZlYzMoMS4sMC4sMC4pO1xuICAgIH1cbiAgICBpZiAobWFzay55KSB7XG4gICAgICBjb2xvciA9IHZlYzMoMS4wKTtcbiAgICAgIG5vciA9IHZlYzMoMC4sMS4sMC4pO1xuICAgIH1cbiAgICBpZiAobWFzay56KSB7XG4gICAgICBjb2xvciA9IHZlYzMoMC43NSk7XG4gICAgICBub3IgPSB2ZWMzKDAuLDAuLDEuKTtcbiAgICB9XG4gICAgaWYoIHZkLmRpc3RhbmNlLnggPT0gLTEwMDAwMC4gKSB7XG4gICAgICBjb2xvciA9IGJnO1xuICAgIH1cbiAgICBcbiAgICBmbG9hdCBtb2RBbW91bnQgPSAkeygxLi92b3hlbFNpemUpLnRvRml4ZWQoMSl9O1xuICAgIGlmKCBjb2xvciAhPSBiZyApIHtcbiAgICAgIHZlYzMgcG9zID0gdmQuZGlzdGFuY2U7IFxuICAgICAgLy92ZWMzIHBvcyA9IHJvICsgcmQgKiB2ZC5mb2dDb2VmZjtcblxuICAgICAgY29sb3IgKj0gbGlnaHRpbmcoIHBvcyAqIG1vZEFtb3VudCwgbm9yLCBybywgcmQsIGZsb2F0KHZkLmlkKSwgZmFsc2UgKTsgXG4gICAgICAvL2NvbG9yICo9IGxpZ2h0aW5nKCBwb3MsIG5vciwgcm8sIHJkLCBmbG9hdCh2ZC5pZCksIGZhbHNlICk7IFxuICAgICAgLy9jb2xvciA9IG1pbihjb2xvciwxLik7XG4gICAgICAvL2NvbG9yID0gZ2V0VGV4dHVyZSggMCwgcG9zICk7XG4gICAgICBcbiAgICB9XG4gICAgXG4gICAgdmVjMiB0ID0gdmVjMiggdmQuZm9nQ29lZmYsIHZkLmlkICk7XG4gICR7cG9zdHByb2Nlc3Npbmd9OyBcbiAgICBjb2wgPSB2ZWM0KCBjb2xvciwgMS4gKTsgXG4gIH1gXG5cbiAgcmV0dXJuIG91dFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCB2YXJpYWJsZXMsIHNjZW5lLCBwcmVmYWNlLCBnZW9tZXRyaWVzLCBsaWdodGluZywgcG9zdHByb2Nlc3NpbmcsIHN0ZXBzPTkwLCBtaW5EaXN0YW5jZT0uMDAxLCBtYXhEaXN0YW5jZT0yMCwgb3BzLCB2b3hlbFNpemU9MCApIHtcblxuICBjb25zdCBtYWluID0gdm94ZWxTaXplID09PSAwXG4gICAgPyBnZXRNYWluQ29udGludW91cyggc3RlcHMsIG1pbkRpc3RhbmNlLCBtYXhEaXN0YW5jZSwgcG9zdHByb2Nlc3NpbmcgKSBcbiAgICA6IGdldE1haW5Wb3hlbHMoIHN0ZXBzLCBwb3N0cHJvY2Vzc2luZywgdm94ZWxTaXplIClcblxuICAgIGNvbnN0IGZzX3NvdXJjZSA9IGdsc2woW1wiICAgICAjdmVyc2lvbiAzMDAgZXNcXG4gICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG4jZGVmaW5lIEdMU0xJRlkgMVxcblxcblxcbiAgICAgIGZsb2F0IFBJID0gMy4xNDE1OTI2NTM1ODk3OTM7XFxuXFxuICAgICAgaW4gdmVjMiB2X3V2O1xcblxcbiAgICAgIHN0cnVjdCBMaWdodCB7XFxuICAgICAgICB2ZWMzIHBvc2l0aW9uO1xcbiAgICAgICAgdmVjMyBjb2xvcjtcXG4gICAgICAgIGZsb2F0IGF0dGVudWF0aW9uO1xcbiAgICAgIH07XFxuXFxuICAgICAgaW50IHJvdGF0aW9uQ291bnQgPSAxO1xcblxcbiAgICAgIG1hdDQgcm90YXRpb25zWzRdID0gbWF0NFs0XShcXG4gICAgICAgIG1hdDQoMC4pLCBtYXQ0KDAuKSwgbWF0NCgwLiksIG1hdDQoMC4pXFxuICAgICAgKTtcXG5cXG4gICAgICBzdHJ1Y3QgTWF0ZXJpYWwge1xcbiAgICAgICAgaW50ICBtb2RlO1xcbiAgICAgICAgdmVjMyBhbWJpZW50O1xcbiAgICAgICAgdmVjMyBkaWZmdXNlO1xcbiAgICAgICAgdmVjMyBzcGVjdWxhcjtcXG4gICAgICAgIGZsb2F0IHNoaW5pbmVzcztcXG4gICAgICAgIHZlYzMgZnJlc25lbDtcXG4gICAgICAgIGludCB0ZXh0dXJlSUQ7XFxuICAgICAgfTsgICAgIFxcblxcbiAgICAgIHN0cnVjdCBTREYge1xcbiAgICAgICAgaW50IG1hdGVyaWFsSUQ7XFxuICAgICAgICBtYXQ0IHRyYW5zZm9ybTtcXG4gICAgICAgIGludCB0ZXh0dXJlSUQ7XFxuICAgICAgICB2ZWMzIHJlcGVhdDtcXG4gICAgICAgIG1hdDQgcmVwZWF0VHJhbnNmb3JtO1xcbiAgICAgIH07XFxuXFxuICAgICAgdW5pZm9ybSBmbG9hdCB0aW1lO1xcbiAgICAgIHVuaWZvcm0gdmVjMiByZXNvbHV0aW9uO1xcbiAgICAgIHVuaWZvcm0gdmVjMyBjYW1lcmFfcG9zO1xcbiAgICAgIHVuaWZvcm0gdmVjMyBjYW1lcmFfbm9ybWFsO1xcbiAgICAgIHVuaWZvcm0gZmxvYXQgY2FtZXJhX3JvdDtcXG4gICAgICB1bmlmb3JtIG1hdDQgY2FtZXJhO1xcblxcbiAgICAgIFwiLFwiXFxuXFxuICAgICAgLy8gbXVzdCBiZSBiZWZvcmUgZ2VvbWV0cmllcyFcXG4gICAgICBmbG9hdCBsZW5ndGg4KCB2ZWMyIHAgKSB7IFxcbiAgICAgICAgcmV0dXJuIGZsb2F0KCBwb3coIHBvdyhwLngsOC4pK3BvdyhwLnksOC4pLCAxLi84LiApICk7IFxcbiAgICAgIH1cXG5cXG4gICAgICBcIixcIlxcblxcbiAgICAgIC8qIEdFT01FVFJJRVMgKi9cXG4gICAgICBcIixcIlxcblxcbiAgICAgIHZlYzIgc2NlbmUodmVjMyBwKTtcXG5cXG4gICAgICAvLyBYWFggdG9kbyBwdXQgdGhpcyBpbiBkb21haW5PcGVyYXRpb25zLmpzXFxuICAgICAgdmVjMyBwb2xhclJlcGVhdCh2ZWMzIHAsIGZsb2F0IHJlcGV0aXRpb25zKSB7XFxuICAgICAgICBmbG9hdCBhbmdsZSA9IDIuKlBJL3JlcGV0aXRpb25zO1xcbiAgICAgICAgZmxvYXQgYSA9IGF0YW4ocC56LCBwLngpICsgYW5nbGUvMi47XFxuICAgICAgICBmbG9hdCByID0gbGVuZ3RoKHAueHopO1xcbiAgICAgICAgZmxvYXQgYyA9IGZsb29yKGEvYW5nbGUpO1xcbiAgICAgICAgYSA9IG1vZChhLGFuZ2xlKSAtIGFuZ2xlLzIuO1xcbiAgICAgICAgdmVjMyBfcCA9IHZlYzMoIGNvcyhhKSAqIHIsIHAueSwgIHNpbihhKSAqIHIgKTtcXG4gICAgICAgIC8vIEZvciBhbiBvZGQgbnVtYmVyIG9mIHJlcGV0aXRpb25zLCBmaXggY2VsbCBpbmRleCBvZiB0aGUgY2VsbCBpbiAteCBkaXJlY3Rpb25cXG4gICAgICAgIC8vIChjZWxsIGluZGV4IHdvdWxkIGJlIGUuZy4gLTUgYW5kIDUgaW4gdGhlIHR3byBoYWx2ZXMgb2YgdGhlIGNlbGwpOlxcbiAgICAgICAgaWYgKGFicyhjKSA+PSAocmVwZXRpdGlvbnMvMi4pKSBjID0gYWJzKGMpO1xcbiAgICAgICAgcmV0dXJuIF9wO1xcbiAgICAgIH1cXG5cXG4gICAgICAvLyBhZGRlZCBrIHZhbHVlIHRvIGdsc2wtc2RmLW9wcy9zb2Z0LXNoYWRvd1xcbiAgICAgIGZsb2F0IHNvZnRzaGFkb3coIGluIHZlYzMgcm8sIGluIHZlYzMgcmQsIGluIGZsb2F0IG1pbnQsIGluIGZsb2F0IHRtYXgsIGluIGZsb2F0IGsgKXtcXG4gICAgICAgIGZsb2F0IHJlcyA9IDEuMDtcXG4gICAgICAgIGZsb2F0IHQgPSBtaW50O1xcblxcbiAgICAgICAgZm9yKCBpbnQgaSA9IDA7IGkgPCAxMjsgaSsrICkge1xcbiAgICAgICAgICBmbG9hdCBoID0gc2NlbmUoIHJvICsgcmQgKiB0ICkueDtcXG4gICAgICAgICAgcmVzID0gbWluKCByZXMsIGsgKiBoIC8gdCApO1xcbiAgICAgICAgICB0ICs9IGNsYW1wKCBoLCAwLjAyLCAwLjEwICk7XFxuICAgICAgICAgIGlmKCBoPDAuMDAxIHx8IHQ+dG1heCApIGJyZWFrO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIGNsYW1wKCByZXMsIDAuMCwgMS4wICk7XFxuICAgICAgfVxcblxcblwiLFwiXFxuXFxuICAgIHZlYzIgc2NlbmUodmVjMyBfcCApIHtcXG4gICAgICB2ZWM0IHAgPSB2ZWM0KCBfcCwgMS4gKTtcXG5cIixcIlxcbiAgICAgIHJldHVybiBcIixcIjtcXG4gICAgfVxcbiBcXG5cIixcIlxcblwiLFwiXCJdLHZhcmlhYmxlcyxvcHMsZ2VvbWV0cmllcyxsaWdodGluZyxwcmVmYWNlLHNjZW5lLG1haW4pXG5cbiAgICByZXR1cm4gZnNfc291cmNlXG4gIH1cbiIsImNvbnN0IGdldEZvZyA9IHJlcXVpcmUoICcuL2ZvZy5qcycgKVxuY29uc3QgdmlnbmV0dGUgPSByZXF1aXJlKCAnLi92aWduZXR0ZS5qcycgKVxuY29uc3QgeyBwYXJhbV93cmFwLCBNYXRlcmlhbElEIH0gPSByZXF1aXJlKCAnLi91dGlscy5qcycgKVxuY29uc3QgX19saWdodGluZyA9IHJlcXVpcmUoICcuL2xpZ2h0aW5nLmpzJyApXG5jb25zdCB7IFZhciwgZmxvYXRfdmFyX2dlbiwgdmVjMl92YXJfZ2VuLCB2ZWMzX3Zhcl9nZW4sIHZlYzRfdmFyX2dlbiwgaW50X3Zhcl9nZW4sIFZhckFsbG9jIH0gPSByZXF1aXJlKCcuL3Zhci5qcycpXG5cbmNvbnN0IGdldFNjZW5lID0gZnVuY3Rpb24oIFNERiApIHtcblxuICBTY2VuZSA9IGZ1bmN0aW9uKCBvYmpzLCBjYW52YXMsIHN0ZXBzPTEwMCwgbWluRGlzdGFuY2U9LjAwMSwgbWF4RGlzdGFuY2U9NDAsIHNpemU9Miwgc2hvdWxkQW5pbWF0ZT1mYWxzZSApIHtcbiAgICBjb25zdCBzY2VuZSAgPSBPYmplY3QuY3JlYXRlKCBTY2VuZS5wcm90b3R5cGUgKVxuXG4gICAgTWF0ZXJpYWxJRC5jbGVhcigpXG5cbiAgICBTREYubGlnaHRpbmcubGlnaHRzID0gW11cblxuICAgIHNjZW5lLl9fcHJlcmVuZGVyID0gb2Jqc1xuICAgIGlmKCBvYmpzLmxlbmd0aCA+IDEgKSB7XG4gICAgICAvLyByZWR1Y2Ugb2JqZWN0cyB0byBuZXN0ZWQgVW5pb25zXG4gICAgICBzY2VuZS5fX3ByZXJlbmRlciA9IG9ianMucmVkdWNlKCAoIGN1cnJlbnQsIG5leHQgKSA9PiBTREYuVW5pb24oIGN1cnJlbnQsIG5leHQgKSApXG4gICAgfVxuXG4gICAgT2JqZWN0LmFzc2lnbiggc2NlbmUsIHsgXG4gICAgICBvYmpzLCBcbiAgICAgIGNhbnZhcyxcbiAgICAgIHBvc3Rwcm9jZXNzaW5nOltdLFxuICAgICAgX19zaGFkb3c6OCxcbiAgICAgIF9fZm9sbG93TGlnaHQ6bnVsbFxuICAgIH0pXG5cbiAgICBzY2VuZS5hbmltYXRlKCBzaG91bGRBbmltYXRlIClcbiAgICAgIC5zdGVwcyggc3RlcHMgKVxuICAgICAgLnRocmVzaG9sZCggbWluRGlzdGFuY2UgKVxuICAgICAgLmZhclBsYW5lKCBtYXhEaXN0YW5jZSApXG4gICAgICAucmVzb2x1dGlvbiggMSApXG5cbiAgICBzY2VuZS51c2VRdWFsaXR5ID0gdHJ1ZVxuICAgIHNjZW5lLnVzZVZveGVscyAgPSBmYWxzZVxuXG4gICAgU0RGLl9fc2NlbmUgPSBzY2VuZVxuXG4gICAgcmV0dXJuIHNjZW5lXG4gIH1cblxuICBTY2VuZS5wcm90b3R5cGUgPSB7XG4gICAgYW5pbWF0ZSggdiApIHsgdGhpcy5fX2FuaW1hdGUgPSB2OyByZXR1cm4gdGhpcyB9LCAgXG4gICAgcmVzb2x1dGlvbiggdiApIHsgXG4gICAgICB0aGlzLndpZHRoID0gTWF0aC5mbG9vciggdGhpcy5jYW52YXMud2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aCAqIHYgKVxuICAgICAgdGhpcy5oZWlnaHQgPSBNYXRoLmZsb29yKCB0aGlzLmNhbnZhcy5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgKiB2IClcbiAgICAgIFxuICAgICAgdGhpcy5fX3Jlc29sdXRpb24gPSB2O1xuICAgICAgdGhpcy51c2VRdWFsaXR5ID0gZmFsc2VcbiAgICAgIHJldHVybiB0aGlzIFxuICAgIH0sICBcbiAgICB2b3hlbCggdiA9IC4xICkgeyBcbiAgICAgIHRoaXMudXNlVm94ZWxzID0gdHJ1ZVxuICAgICAgdGhpcy5fX3ZveGVsU2l6ZSA9IHZcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSxcbiAgICB0aHJlc2hvbGQoIHYgKSB7IHRoaXMuX190aHJlc2hvbGQgPSB2OyB0aGlzLnVzZVF1YWxpdHkgPSBmYWxzZTsgcmV0dXJuIHRoaXMgfSwgIFxuICAgIHN0ZXBzKCB2ICkgeyB0aGlzLl9fc3RlcHMgPSB2OyB0aGlzLnVzZVF1YWxpdHkgPSBmYWxzZTsgcmV0dXJuIHRoaXMgfSwgIFxuICAgIGZhclBsYW5lKCB2ICkgeyB0aGlzLl9fZmFyUGxhbmUgPSB2OyB0aGlzLnVzZVF1YWxpdHkgPSBmYWxzZTsgIHJldHVybiB0aGlzIH0sICBcbiAgICBjYW1lcmEoIHg9MCwgeT0wLCB6PTUsIHNwZWVkPTEgKSB7XG4gICAgICBTREYuY2FtZXJhLl9fY2FtZXJhLnBvc2l0aW9uWzBdID0geFxuICAgICAgU0RGLmNhbWVyYS5fX2NhbWVyYS5wb3NpdGlvblsxXSA9IHlcbiAgICAgIFNERi5jYW1lcmEuX19jYW1lcmEucG9zaXRpb25bMl0gPSB6XG4gICAgICBTREYuY2FtZXJhLl9fY2FtZXJhLnJvdGF0aW9uU3BlZWQgPSBzcGVlZCAqIC4wMVxuICAgICAgU0RGLmNhbWVyYS5fX2NhbWVyYS5wb3NpdGlvblNwZWVkID0gc3BlZWQgKiAtLjI1XG4gICAgICBTREYuY2FtZXJhLnVwZGF0ZSgpXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG4gICAgc2hhZG93KCBrPTAgKSB7XG4gICAgICB0aGlzLl9fc2hhZG93ID0gaztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgcXVhbGl0eSggcXVhbGl0eT0xMCApIHtcbiAgICAgIHRoaXMudGhyZXNob2xkKCAuMSAvIChxdWFsaXR5ICogcXVhbGl0eSAqIHF1YWxpdHkgKSApXG4gICAgICB0aGlzLnN0ZXBzKCBxdWFsaXR5ICogMjAgKVxuICAgICAgdGhpcy5mYXJQbGFuZSggcXVhbGl0eSAqIDUgKVxuICAgICAgdGhpcy5yZXNvbHV0aW9uKCBNYXRoLm1pbiggLjIgKiBxdWFsaXR5LCAyICkgKVxuXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG4gICAgZm9sbG93KCBsaWdodCwgZGlzdGFuY2U9MyApIHtcbiAgICAgIHRoaXMuX19mb2xsb3dMaWdodCA9IGxpZ2h0XG4gICAgICBTREYuY2FtZXJhLm9ubW92ZSA9IGZ1bmN0aW9uKCBjYW1lcmEgKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IFNERi5jYW1lcmEub2Zmc2V0KClcbiAgICAgICAgbGlnaHQucG9zLnggPSBTREYuY2FtZXJhLl9fY2FtZXJhLnBvc2l0aW9uWzBdIC0gb2Zmc2V0WzBdXG4gICAgICAgIGxpZ2h0LnBvcy55ID0gU0RGLmNhbWVyYS5fX2NhbWVyYS5wb3NpdGlvblsxXSAtIG9mZnNldFsxXVxuICAgICAgICBsaWdodC5wb3MueiA9IFNERi5jYW1lcmEuX19jYW1lcmEucG9zaXRpb25bMl0gLSBvZmZzZXRbMl1cbiAgICAgICAgbGlnaHQuZGlydHkgPSB0cnVlXG4gICAgICB9XG4gICAgICBTREYubGlnaHRpbmcubGlnaHRzID0gW2xpZ2h0XVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuICAgIGxpZ2h0KCAuLi5saWdodHMgKSB7XG4gICAgICBTREYubGlnaHRpbmcubGlnaHRzID0gU0RGLmxpZ2h0aW5nLmxpZ2h0cy5jb25jYXQoIGxpZ2h0cyApXG4gICAgICBpZiggdGhpcy5fX2ZvbGxvd0xpZ2h0ICE9PSBudWxsICkgU0RGLmxpZ2h0aW5nLmxpZ2h0cy5wdXNoKCB0aGlzLl9fZm9sbG93TGlnaHQgKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuICAgIGZvZzogZ2V0Rm9nKCBTY2VuZSwgU0RGICksXG4gICAgdmlnbmV0dGU6IHZpZ25ldHRlKCBTY2VuZSwgU0RGICksXG4gICAgYmFja2dyb3VuZDogcmVxdWlyZSggJy4vYmFja2dyb3VuZC5qcycgKSggU2NlbmUsIFNERiApLFxuICAgIHByZXNldHM6IHtcbiAgICAgICdmcmFjdGFsLmNsb3NlJzoge1xuICAgICAgICBmYXJQbGFuZToxLFxuICAgICAgICByZXNvbHV0aW9uOjEsXG4gICAgICAgIHN0ZXBzOjE1MCxcbiAgICAgICAgYW5pbWF0ZWQ6dHJ1ZSxcbiAgICAgICAgdGhyZXNob2xkOi4wMDAxMjVcbiAgICAgIH0sXG4gICAgICAnZnJhY3RhbC5raW5kYWNsb3NlJzoge1xuICAgICAgICBmYXJQbGFuZToyLFxuICAgICAgICByZXNvbHV0aW9uOjEsXG4gICAgICAgIHN0ZXBzOjI1MCxcbiAgICAgICAgYW5pbWF0ZWQ6dHJ1ZSxcbiAgICAgICAgdGhyZXNob2xkOi4wMDAxMjUvMlxuICAgICAgfSxcbiAgICAgICdmcmFjdGFsLm1lZCc6IHtcbiAgICAgICAgZmFyUGxhbmU6NSxcbiAgICAgICAgcmVzb2x1dGlvbjouNzUsXG4gICAgICAgIHN0ZXBzOjgwLFxuICAgICAgICBhbmltYXRlZDp0cnVlLFxuICAgICAgICB0aHJlc2hvbGQ6LjAwMSxcbiAgICAgIH0sXG4gICAgICAnZnJhY3RhbC5sb3cnOiB7XG4gICAgICAgIGZhclBsYW5lOjMuMCxcbiAgICAgICAgcmVzb2x1dGlvbjouNSxcbiAgICAgICAgYW5pbWF0ZWQ6dHJ1ZSxcbiAgICAgICAgc3RlcHM6NTAsXG4gICAgICAgIHRocmVzaG9sZDouMDA1LFxuICAgICAgfSxcbiAgICAgICdmcmFjdGFsLmhpZ2gnOiB7XG4gICAgICAgIGZhclBsYW5lOjEwLFxuICAgICAgICByZXNvbHV0aW9uOjEsXG4gICAgICAgIGFuaW1hdGVkOnRydWUsXG4gICAgICAgIHN0ZXBzOjEwMCxcbiAgICAgICAgdGhyZXNob2xkOi4wMDEsXG4gICAgICB9LFxuICAgICAgJ3JlcGVhdC5sb3cnOiB7XG4gICAgICAgIGZhclBsYW5lOjI1LFxuICAgICAgICByZXNvbHV0aW9uOi41LFxuICAgICAgICBhbmltYXRlZDp0cnVlLFxuICAgICAgICBzdGVwczo1MFxuICAgICAgfSxcbiAgICAgICdyZXBlYXQubWVkJzoge1xuICAgICAgICBmYXJQbGFuZTozNSxcbiAgICAgICAgcmVzb2x1dGlvbjoxLFxuICAgICAgICBhbmltYXRlZDp0cnVlLFxuICAgICAgICBzdGVwczo3NVxuICAgICAgfSxcbiAgICAgICdyZXBlYXQuaGlnaCc6IHtcbiAgICAgICAgZmFyUGxhbmU6NDAsXG4gICAgICAgIHJlc29sdXRpb246MSxcbiAgICAgICAgYW5pbWF0ZWQ6dHJ1ZSxcbiAgICAgICAgc3RlcHM6MTAwXG4gICAgICB9LFxuICAgICAgJ3ZveGVsLmhpZ2gnOiB7XG4gICAgICAgIHJlc29sdXRpb246MSxcbiAgICAgICAgYW5pbWF0ZWQ6dHJ1ZSxcbiAgICAgICAgc3RlcHM6MzBcbiAgICAgIH0sXG4gICAgICAndm94ZWwubWVkJzoge1xuICAgICAgICByZXNvbHV0aW9uOjEsXG4gICAgICAgIGFuaW1hdGVkOnRydWUsXG4gICAgICAgIHN0ZXBzOjIwXG4gICAgICB9LFxuICAgICAgJ3ZveGVsLmxvdyc6IHtcbiAgICAgICAgcmVzb2x1dGlvbjouNSxcbiAgICAgICAgYW5pbWF0ZWQ6dHJ1ZSxcbiAgICAgICAgc3RlcHM6MTBcbiAgICAgIH0sXG4gICAgICBsb3c6IHtcbiAgICAgICAgdGhyZXNob2xkOi4wNSxcbiAgICAgICAgc3RlcHM6NDUsXG4gICAgICAgIGZhclBsYW5lOjEyLFxuICAgICAgICByZXNvbHV0aW9uOi40LFxuICAgICAgICBhbmltYXRlZDp0cnVlXG4gICAgICB9LFxuICAgICAgbWVkaXVtOiB7XG4gICAgICAgIHRocmVzaG9sZDouMDEsXG4gICAgICAgIHN0ZXBzOjgwLFxuICAgICAgICBmYXJQbGFuZToxOCxcbiAgICAgICAgcmVzb2x1dGlvbjouNSxcbiAgICAgICAgYW5pbWF0ZWQ6dHJ1ZVxuICAgICAgfSxcbiAgICAgIG1lZDoge1xuICAgICAgICB0aHJlc2hvbGQ6LjAxLFxuICAgICAgICBzdGVwczo4MCxcbiAgICAgICAgZmFyUGxhbmU6MTgsXG4gICAgICAgIHJlc29sdXRpb246LjUsXG4gICAgICAgIGFuaW1hdGVkOnRydWVcbiAgICAgIH0sXG4gICAgICBoaWdoOiB7XG4gICAgICAgIHRocmVzaG9sZDouMDA1LFxuICAgICAgICBzdGVwczo5MCxcbiAgICAgICAgZmFyUGxhbmU6MjAsXG4gICAgICAgIHJlc29sdXRpb246MSxcbiAgICAgICAgYW5pbWF0ZWQ6dHJ1ZVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBhcHBseVByZXNldCggcHJlc2V0TmFtZSApIHtcbiAgICAgIGNvbnN0IHByZXNldCA9IHRoaXMucHJlc2V0c1sgcHJlc2V0TmFtZSBdXG4gICAgICBpZiggcHJlc2V0LmZhclBsYW5lICE9PSB1bmRlZmluZWQgKSB0aGlzLmZhclBsYW5lKCBwcmVzZXQuZmFyUGxhbmUgKVxuICAgICAgdGhpcy5zdGVwcyggcHJlc2V0LnN0ZXBzIClcbiAgICAgIHRoaXMucmVzb2x1dGlvbiggcHJlc2V0LnJlc29sdXRpb24gKVxuICAgICAgdGhpcy50aHJlc2hvbGQoIHByZXNldC50aHJlc2hvbGQgfHwgLjAwMSApXG5cbiAgICAgIHJldHVybiBwcmVzZXQuYW5pbWF0ZWRcbiAgICB9LFxuICAgIHJlbmRlciggcXVhbGl0eT0xMCwgYW5pbWF0ZT1mYWxzZSwgdXNlUXVhbGl0eT10cnVlICkge1xuICAgICAgdGhpcy5iYWNrZ3JvdW5kKCkgLy8gYWRkcyBkZWZhdWx0IGlmIG5vbmUgaGFzIGJlZW4gc3BlY2lmaWVkXG4gICAgICBpZiggdHlwZW9mIHF1YWxpdHkgPT09ICdzdHJpbmcnICkge1xuICAgICAgICBhbmltYXRlID0gdGhpcy5hcHBseVByZXNldCggcXVhbGl0eSApXG4gICAgICB9ZWxzZSBpZiggdGhpcy51c2VRdWFsaXR5ID09PSB0cnVlICkge1xuICAgICAgICB0aGlzLnF1YWxpdHkoIHF1YWxpdHkgKVxuICAgICAgfVxuICAgICAgdGhpcy5hbmltYXRlKCBhbmltYXRlIClcblxuICAgICAgU0RGLmRpc3RhbmNlT3BzLl9fY2xlYXIoKVxuICAgICAgU0RGLnRleHR1cmVzLmNsZWFyKClcbiAgICAgIGNvbnN0IGdlb21ldHJpZXMgPSBTREYucHJpbWl0aXZlcy5lbWl0X2dlb21ldHJpZXMoKVxuXG4gICAgICBsZXQgWyB2YXJpYWJsZXNEZWNsYXJhdGlvbiwgc2NlbmVSZW5kZXJpbmcsIHBvc3Rwcm9jZXNzaW5nIF0gPSBTREYuZ2VuZXJhdGVTREYoIHRoaXMgKVxuXG4gICAgICBjb25zdCBsaWdodGluZyA9IFNERi5saWdodGluZy5nZW4oIHRoaXMuX19zaGFkb3csIGdlb21ldHJpZXMgKVxuICAgICAgdmFyaWFibGVzRGVjbGFyYXRpb24gKz0gU0RGLm1hdGVyaWFscy5lbWl0X2RlY2woKSBcbiAgICAgIHZhcmlhYmxlc0RlY2xhcmF0aW9uICs9IFNERi50ZXh0dXJlcy5lbWl0X2RlY2woKSBcbiAgICAgIHZhcmlhYmxlc0RlY2xhcmF0aW9uICs9IFNERi5saWdodGluZy5lbWl0X2RlY2woKSBcblxuICAgICAgdGhpcy5mcyA9IFNERi5yZW5kZXJGcmFnbWVudFNoYWRlciggXG4gICAgICAgIHZhcmlhYmxlc0RlY2xhcmF0aW9uLCBcbiAgICAgICAgc2NlbmVSZW5kZXJpbmcub3V0LCBcbiAgICAgICAgc2NlbmVSZW5kZXJpbmcucHJlZmFjZSxcbiAgICAgICAgU0RGLnJlcXVpcmVkR2VvbWV0cmllcy5qb2luKCdcXG4nKSArIFNERi5yZXF1aXJlZE9wcy5qb2luKCdcXG4nKSxcbiAgICAgICAgbGlnaHRpbmcsXG4gICAgICAgIHBvc3Rwcm9jZXNzaW5nLCBcbiAgICAgICAgdGhpcy5fX3N0ZXBzLCB0aGlzLl9fdGhyZXNob2xkLCB0aGlzLl9fZmFyUGxhbmUudG9GaXhlZCgxKSxcbiAgICAgICAgU0RGLmRpc3RhbmNlT3BzLl9fZ2V0R0xTTCgpLFxuICAgICAgICB0aGlzLnVzZVZveGVscyA/IHRoaXMuX192b3hlbFNpemUgOiAwXG4gICAgICApXG5cbiAgICAgIFNERi5zdGFydCggdGhpcy5mcywgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHRoaXMuX19hbmltYXRlIClcblxuICAgICAgLy9TREYubWF0ZXJpYWxzLm1hdGVyaWFscy5sZW5ndGggPSAwXG5cbiAgICAgIHRoaXMudXNlUXVhbGl0eSA9IHRydWVcblxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuXG4gIH1cblxuICByZXR1cm4gU2NlbmVcblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldFNjZW5lIFxuIiwiY29uc3QgU2NlbmVOb2RlID0gKCk9PiBPYmplY3QuY3JlYXRlKCBTY2VuZU5vZGUucHJvdG90eXBlIClcbmNvbnN0IE1hdHJpeCA9IHJlcXVpcmUoICcuL2V4dGVybmFsL21hdHJpeC5qcycgKVxuXG5TY2VuZU5vZGUucHJvdG90eXBlID0ge1xuXHRlbWl0KCkgeyByZXR1cm4gXCIjTm90SW1wbGVtZW50ZWQjXCI7IH0sXG5cblx0ZW1pdF9kZWNsKCkgeyByZXR1cm4gXCJcIjsgfSxcblxuXHR1cGRhdGVfbG9jYXRpb24oZ2wsIHByb2dyYW0pIHt9LFxuXG4gIHVwbG9hZF9kYXRhKGdsKSB7fSxcblxuICBnZXRJRCgpIHtcbiAgICBsZXQgaWQgPSB0aGlzLmlkXG5cbiAgICBpZiggaWQgPT09IHVuZGVmaW5lZCAmJiB0aGlzLnNkZiAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgaWQgPSB0aGlzLnNkZi5nZXRJRCgpXG4gICAgfVxuXG4gICAgcmV0dXJuIGlkXG4gIH0sXG5cbiAgZ2V0Q2VudGVyKCkge1xuICAgIGxldCBjZW50ZXIgPSB0aGlzLmNlbnRlclxuXG4gICAgaWYoIGNlbnRlciA9PT0gdW5kZWZpbmVkICYmIHRoaXMuc2RmICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICBpZiggdGhpcy5zZGYuZ2V0Q2VudGVyID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgIGNlbnRlciA9IHRoaXMuc2RmLl9fd3JhcHBlZC5nZXRDZW50ZXIoKVxuICAgICAgfWVsc2V7XG4gICAgICAgIGNlbnRlciA9IHRoaXMuc2RmLmdldENlbnRlcigpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNlbnRlclxuICB9LFxuXG4gIG1vdmUoIC4uLmFyZ3MgKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNsYXRlKCAuLi5hcmdzIClcbiAgfSxcblxuICByb3RhdGUoIGFuZ2xlLCB4LHkseiApIHtcbiAgICB0aGlzLnRyYW5zZm9ybS5yb3RhdGlvbi5hbmdsZSA9IGFuZ2xlXG4gICAgaWYoIHggIT09IHVuZGVmaW5lZCApIHRoaXMudHJhbnNmb3JtLnJvdGF0aW9uLmF4aXMueCA9IHhcbiAgICBpZiggeSAhPT0gdW5kZWZpbmVkICkgdGhpcy50cmFuc2Zvcm0ucm90YXRpb24uYXhpcy55ID0geVxuICAgIGlmKCB6ICE9PSB1bmRlZmluZWQgKSB0aGlzLnRyYW5zZm9ybS5yb3RhdGlvbi5heGlzLnogPSB6XG4gIFxuICAgIHJldHVybiB0aGlzXG4gIH0sXG5cbiAgcm90YXRlQnkoIGFuZ2xlLHgseSx6ICkge1xuICAgIHRoaXMudHJhbnNmb3JtLl9fcm90YXRpb25zLnB1c2goIE1hdHJpeC5yb3RhdGUoIGFuZ2xlLHgseSx6ICkgKVxuICAgIHJldHVybiB0aGlzXG4gIH0sXG5cbiAgdHJhbnNsYXRlKCB4LHkseiApIHtcbiAgICBpZiggeCAhPT0gdW5kZWZpbmVkICYmIHggIT09IG51bGwgKSB0aGlzLnRyYW5zZm9ybS50cmFuc2xhdGlvbi54ID0geFxuICAgIGlmKCB5ICE9PSB1bmRlZmluZWQgJiYgeSAhPT0gbnVsbCApIHRoaXMudHJhbnNmb3JtLnRyYW5zbGF0aW9uLnkgPSB5XG4gICAgaWYoIHogIT09IHVuZGVmaW5lZCAmJiB6ICE9PSBudWxsICkgdGhpcy50cmFuc2Zvcm0udHJhbnNsYXRpb24ueiA9IHpcbiAgXG4gICAgcmV0dXJuIHRoaXNcbiAgfSxcblxuICBzY2FsZSggYW1vdW50ICkge1xuICAgIGlmKCBhbW91bnQgIT09IHVuZGVmaW5lZCApIHRoaXMudHJhbnNmb3JtLnNjYWxlID0gYW1vdW50XG4gICAgcmV0dXJuIHRoaXNcbiAgfSxcblxuICBtYXRlcmlhbCggbWF0ICkge1xuICAgIHRoaXMuX19zZXRNYXRlcmlhbCggbWF0IClcbiAgICByZXR1cm4gdGhpc1xuICB9LFxuXG4gIHRleHR1cmUoIHRleCxwcm9wcyApIHtcbiAgICB0aGlzLl9fc2V0VGV4dHVyZSggdGV4LHByb3BzIClcbiAgICByZXR1cm4gdGhpc1xuICB9LFxuXG4gIGJ1bXAoIHRleCxzdHJlbmd0aCApIHtcbiAgICB0aGlzLl9fc2V0QnVtcCggdGV4LHN0cmVuZ3RoIClcbiAgICByZXR1cm4gdGhpc1xuICB9XG59XG5cbmNvbnN0IG9wcyA9IFsgJ3JlcGVhdCcsICdwb2xhclJlcGVhdCcsICdlbG9uZ2F0aW9uJyBdXG5cbm9wcy5mb3JFYWNoKCBvcCA9PiB7XG4gIGNvbnN0IGNvbnN0cnVjdG9yTmFtZSA9IG9wWzBdLnRvVXBwZXJDYXNlKCkgKyBvcC5zbGljZSgxKVxuICBTY2VuZU5vZGUucHJvdG90eXBlWyBvcCBdID0gZnVuY3Rpb24oIC4uLmFyZ3MgKSB7XG4gICAgdGhpc1sgb3AgXSA9IHRoaXNbIG9wIF0uYmluZCggdGhpcyApXG4gICAgT2JqZWN0LmFzc2lnbiggdGhpc1sgb3AgXSwgU2NlbmVOb2RlLnByb3RvdHlwZSApXG4gICAgdGhpcy5fX3RhcmdldCA9IHRoaXNbIG9wIF1cbiAgICB0aGlzWyAnX18nK29wIF0gPSBNYXJjaGluZ1sgY29uc3RydWN0b3JOYW1lIF0oIHRoaXMsIC4uLmFyZ3MsIHRoaXNbIG9wIF0gKVxuICAgIHRoaXNbIG9wIF0udHJhbnNmb3JtID0gdGhpc1sgJ19fJytvcCBdLnRyYW5zZm9ybVxuICAgIHJldHVybiB0aGlzXG4gIH1cbn0pXG5cbm1vZHVsZS5leHBvcnRzID0gU2NlbmVOb2RlXG4iLCJjb25zdCBTY2VuZU5vZGUgPSByZXF1aXJlKCAnLi9zY2VuZU5vZGUuanMnICksXG4gICAgICBnZXRQaXhlbHMgPSByZXF1aXJlKCAnZ2V0LXBpeGVscycgKSxcbiAgICAgIGNyZWF0ZVRleHR1cmUgPSByZXF1aXJlKCAnZ2wtdGV4dHVyZTJkJyApLFxuICAgICAgeyBwYXJhbV93cmFwLCBNYXRlcmlhbElEIH0gPSByZXF1aXJlKCAnLi91dGlscy5qcycgKSxcbiAgICAgIHsgVmFyLCBmbG9hdF92YXJfZ2VuLCB2ZWMyX3Zhcl9nZW4sIHZlYzNfdmFyX2dlbiwgdmVjNF92YXJfZ2VuLCBpbnRfdmFyX2dlbiwgVmFyQWxsb2MgfSAgPSByZXF1aXJlKCAnLi92YXIuanMnICksIFxuICAgICAgeyBWZWMyLCBWZWMzLCBWZWM0IH0gPSByZXF1aXJlKCAnLi92ZWMuanMnIClcblxuXG5jb25zdCBfX1RleHR1cmVzID0gZnVuY3Rpb24oIFNERiApIHtcbiAgY29uc3QgZ2VucyA9IHsgXG4gICAgaW50OiAgIGludF92YXJfZ2VuLFxuICAgIGZsb2F0OiBmbG9hdF92YXJfZ2VuLFxuICAgIHZlYzI6IHZlYzJfdmFyX2dlbixcbiAgICB2ZWMzOiB2ZWMzX3Zhcl9nZW4sXG4gICAgdmVjNDogdmVjNF92YXJfZ2VuLFxuICB9XG5cbiAgY29uc3QgdmFycyA9IHsgXG4gICAgdmVjMjogVmVjMixcbiAgICB2ZWMzOiBWZWMzLFxuICAgIHZlYzQ6IFZlYzRcbiAgfVxuXG4gIGNvbnN0IFRleHR1cmVzID0ge1xuICAgIHRleHR1cmVzOltdLFxuICAgIF9fdGV4dHVyZXM6W10sXG5cbiAgICBfX3RleHR1cmVQcmVmYWNlczpbXSxcbiAgICBfX3RleHR1cmVCb2RpZXM6ICBbXSxcblxuICAgIF9fdHlwZXM6IHJlcXVpcmUoICcuL3RleHR1cmVEZXNjcmlwdGlvbnMuanMnICksXG4gICAgX193cmFwIDogcmVxdWlyZSggJy4vdGV4dHVyZVdyYXAuanMnICksIFxuICAgIFxuICAgIF9fZW1pdEZ1bmN0aW9uKCkge1xuICAgICAgbGV0IHB1c2hlZFdyYXAgPSBmYWxzZVxuXG4gICAgICBsZXQgZGVjbCA9IGBcbiAgICAgIHZlYzMgZ2V0VGV4dHVyZSggaW50IGlkLCB2ZWMzIHBvcyApIHtcbiAgICAgICAgdmVjMyB0ZXg7XG4gICAgICAgIHZlYzIgcG9zMjtcblxuICAgICAgICBzd2l0Y2goIGlkICkge1xcbmBcbiAgICAgIFxuICAgICAgVGV4dHVyZXMuX190ZXh0dXJlQm9kaWVzLmxlbmd0aCA9IDBcblxuICAgICAgbGV0IGZ1bmNkZWZzID0gJydcbiAgICAgIHRoaXMudGV4dHVyZXMuZm9yRWFjaCggKHQsaSkgPT4ge1xuICAgICAgICBjb25zdCBtb2RlID0gdC5tb2RlICE9PSAnMmQnICYmIHQuZ2xzbCAhPT0gdW5kZWZpbmVkID8gJzNkJyA6ICcyZCdcblxuICAgICAgICAvLyBhZGQgdGV4dHVyZSB3cmFwIGZ1bmN0aW9uIGlmIG5lZWRlZFxuICAgICAgICBpZiggbW9kZSA9PT0gJzJkJyAmJiBwdXNoZWRXcmFwID09PSBmYWxzZSApIHtcbiAgICAgICAgICBUZXh0dXJlcy5fX3RleHR1cmVCb2RpZXMucHVzaCggVGV4dHVyZXMuX193cmFwIClcbiAgICAgICAgICBwdXNoZWRXcmFwID0gdHJ1ZVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZ2xzbCA9IG1vZGUgPT09ICczZCcgPyB0Lmdsc2wgOiB0Lmdsc2wyZCBcbiAgICAgICAgaWYoIFRleHR1cmVzLl9fdGV4dHVyZUJvZGllcy5pbmRleE9mKCBnbHNsICkgPT09IC0xICkgeyBcbiAgICAgICAgICBUZXh0dXJlcy5fX3RleHR1cmVCb2RpZXMucHVzaCggZ2xzbCApXG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBhcmdzID0gdC5wYXJhbWV0ZXJzLm1hcCggcCA9PiB0Ll9fdGFyZ2V0WyBwLm5hbWUgXS5lbWl0KCkgKSBcbiAgICAgICAgY29uc3QgZnVuY3Rpb25OYW1lID0gbW9kZSA9PT0gJzJkJyA/IHQubmFtZSArICcyZCcgOiB0Lm5hbWUgXG5cbiAgICAgICAgLy9kZWNsICs9IGBcbiAgICAgICAgLy8gIGNhc2UgJHtpfTpcbiAgICAgICAgLy8gICAgICAke21vZGUgPT09ICcyZCcgXG4gICAgICAgIC8vICAgICAgPyBgICAgIFxuICAgICAgICAvLyAgICAgIHZlYzMgbiA9IG5vcm1hbGl6ZSggcG9zICk7XG4gICAgICAgIC8vICAgICAgdmVjNCB0ZXh4ID0gIHZlYzQoJHtmdW5jdGlvbk5hbWV9KCAuNSpuLnl6Ky41ICR7IGFyZ3MubGVuZ3RoID4gMCA/ICcsJyArIGFyZ3Muam9pbignLCcpIDogJyd9ICksIDEuKTtcbiAgICAgICAgLy8gICAgICB2ZWM0IHRleHkgPSAgdmVjNCgke2Z1bmN0aW9uTmFtZX0oIC41Km4uengrLjUgJHsgYXJncy5sZW5ndGggPiAwID8gJywnICsgYXJncy5qb2luKCcsJykgOiAnJ30gKSwgMS4pO1xuICAgICAgICAvLyAgICAgIHZlYzQgdGV4eiA9ICB2ZWM0KCR7ZnVuY3Rpb25OYW1lfSggLjUqbi54eSsuNSAkeyBhcmdzLmxlbmd0aCA+IDAgPyAnLCcgKyBhcmdzLmpvaW4oJywnKSA6ICcnfSApLCAxLik7XG4gICAgICAgIC8vICAgICAgdGV4ID0gdHJpcGxhbmFyKCBuLCB0ZXh4LCB0ZXh5LHRleHosZmFsc2UsZmFsc2UgKS54eXo7YFxuICAgICAgICAvLyAgICAgIDogYCBcbiAgICAgICAgLy8gICAgICB0ZXggPSAke2Z1bmN0aW9uTmFtZX0oIHBvcyAkeyBhcmdzLmxlbmd0aCA+IDAgPyAnLCcgKyBhcmdzLmpvaW4oJywnKSA6ICcnfSApO1xuICAgICAgICAvLyAgIGB9XG4gICAgICAgIC8vICAgIGJyZWFrO1xcbmBcblxuXG4gICAgICAgIGRlY2wgKz1gXG4gICAgICAgICAgY2FzZSAke2l9OlxuICAgICAgICAgICAgJHttb2RlID09PSAnMmQnID8gYCAgICAgcG9zMiA9IGdldFVWQ3ViaWMoIHBvcyApO1xcbmAgOiAnJ30gXG4gICAgICAgICAgICB0ZXggPSAke2Z1bmN0aW9uTmFtZX0oICR7bW9kZSA9PT0gJzJkJyA/J3BvczInOidwb3MnfSAkeyBhcmdzLmxlbmd0aCA+IDAgPyAnLCcgKyBhcmdzLmpvaW4oJywnKSA6ICcnfSApO1xuICAgICAgICAgICAgYnJlYWs7XFxuYCAgICAgICAgICAgIFxuXG4gICAgICB9KVxuXG4gICAgICBkZWNsICs9IGBcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGV4ID0gdmVjMygwLik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ZXg7XG4gICAgICB9XG5cbiAgICAgIHZlYzMgZ2V0VGV4dHVyZSggaW50IGlkLCB2ZWMzIHBvcywgdmVjMyBub3IsIFNERiBzZGYsIGJvb2wgdXNlVHJhbnNmb3JtICkge1xuICAgICAgICB2ZWMzIHRleDtcbiAgICAgICAgdmVjMiBwb3MyO1xuICAgICAgICB2ZWMzIHRwb3MgPSBwb3M7XG4gICAgICAgIGlmKCB1c2VUcmFuc2Zvcm0gPT0gdHJ1ZSApIHtcbiAgICAgICAgICBpZiggbGVuZ3RoKHNkZi5yZXBlYXQpICE9IDAuICkge1xuICAgICAgICAgICAgdHBvcyA9IG1vZCggKHZlYzQocG9zLDEuKSAqIHNkZi5yZXBlYXRUcmFuc2Zvcm0pLnh5eiwgc2RmLnJlcGVhdCkgLSAuNSAqIHNkZi5yZXBlYXQ7XG4gICAgICAgICAgICB0cG9zID0gKCB2ZWM0KHRwb3MsIDEuKSAqIHNkZi50cmFuc2Zvcm0pLnh5ejtcbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHRwb3MgPSAodmVjNCh0cG9zLDEuKSAqIHNkZi50cmFuc2Zvcm0pLnh5ejtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0VGV4dHVyZSggaWQsIHRwb3MgKTtcbiAgICAgIH1cbiAgICAgIGBcbiAgICAgXG4gICAgICByZXR1cm4geyBnbHNsZGVmczogVGV4dHVyZXMuX190ZXh0dXJlQm9kaWVzLmpvaW4oICdcXG4nICksIG1haW5mdW5jOmRlY2wgfVxuICAgIH0sXG5cbiAgICBjbGVhcigpIHtcbiAgICAgIFRleHR1cmVzLnRleHR1cmVzLmxlbmd0aCA9IDBcbiAgICB9LFxuXG4gICAgYWRkVGV4dHVyZSggdGV4ICkge1xuICAgICAgLy8gd2UgaGF2ZSB0byBkaXJ0eSB0aGUgdGV4dHVyZSBzbyB0aGF0IGl0cyBkYXRhXG4gICAgICAvLyB3aWxsIGJlIHVwbG9hZGVkIHRvIG5ldyBzaGFkZXJzLCBvdGhlcndpc2UgdGhlXG4gICAgICAvLyB0ZXh0dXJlIHdpbGwgb25seSB3b3JrIHRoZSBmaXJzdCB0aW1lIGl0J3MgdXNlZCwgd2hlblxuICAgICAgLy8gaXQncyBkaXJ0eSBvbiBpbml0aWFsaXphdGlvbi5cbiAgICAgIFRleHR1cmVzLmRpcnR5KCB0ZXggKVxuXG4gICAgICAvLyBpZiB0ZXh0dXJlIHdpdGggc2FtZSBuYW1lIGlzIGFscmVhZHkgZm91bmQsIHJlcGxhY2UgaXQsXG4gICAgICAvLyBvdGhlcndpc2UgcHVzaCB0ZXh0dXJlXG4gICAgICAvL2NvbnN0IG9sZFRleCA9IFRleHR1cmVzLnRleHR1cmVzLmZpbmQoIF9fdGV4ID0+IHRleC5uYW1lID09PSBfX3RleC5uYW1lIClcbiAgICAgIC8vaWYoIG9sZFRleCAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgLy8gIGNvbnN0IGlkeCA9IFRleHR1cmVzLnRleHR1cmVzLmluZGV4T2YoIG9sZFRleCApXG4gICAgICAvLyAgVGV4dHVyZXMudGV4dHVyZXMuc3BsaWNlKCBpZHgsIDEsIHRleCApXG5cbiAgICAgIC8vICB0ZXguaWQgPSBpZHggXG4gICAgICAvL31lbHNle1xuICAgICAgICB0ZXguaWQgPSBUZXh0dXJlcy50ZXh0dXJlcy5sZW5ndGhcbiAgICAgICAgVGV4dHVyZXMudGV4dHVyZXMucHVzaCggdGV4IClcbiAgICAgIC8vfVxuXG4gICAgICByZXR1cm4gdGV4XG4gICAgfSxcblxuICAgIHRleHR1cmUoIHByZXNldE5hbWU9J25vaXNlJywgcHJvcHM9e30sIHRhcmdldD1udWxsICl7XG4gICAgICAvL2NvbnN0IGlzUHJlc2V0ID0gZmlsZW5hbWVPclByZXNldC5pbmRleE9mKCAnLicgKSA9PT0gLTFcbiAgICAgIC8vY29uc3QgZGVmYXVsdHMgPSB7IHdyYXA6U0RGLmdsLk1JUlJPUkVEX1JFUEVBVCB9XG5cbiAgICAgIGlmKCBUZXh0dXJlcy5fX3R5cGVzWyBwcmVzZXROYW1lIF0gPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgY29uc29sZS5sb2coIGB0aGUgdGV4dHVyZSB0eXBlICcke3ByZXNldE5hbWV9JyBkb2VzIG5vdCBleGlzdC5gIClcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRleCA9IE9iamVjdC5hc3NpZ24oIHsgbW9kZTonM2QnIH0sIFRleHR1cmVzLl9fdHlwZXNbIHByZXNldE5hbWUgXSwgcHJvcHMgKVxuXG4gICAgICBpZiggdGFyZ2V0ID09PSBudWxsICkgdGFyZ2V0ID0gdGV4XG4gICAgICB0ZXguX190YXJnZXQgPSB0YXJnZXRcblxuICAgICAgZm9yKCBsZXQgcGFyYW0gb2YgdGV4LnBhcmFtZXRlcnMgKSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZXMgPSBwYXJhbS5kZWZhdWx0XG4gICAgICAgIGNvbnN0IGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KCBkZWZhdWx0VmFsdWVzIClcblxuICAgICAgICBsZXQgY291bnQgPSAwXG4gICAgICAgIGlmKCBpc0FycmF5ICkge1xuICAgICAgICAgIGxldCB2YWwgPSBwcm9wc1sgcGFyYW0ubmFtZSBdLCBfX3ZhclxuXG4gICAgICAgICAgaWYoIHR5cGVvZiB2YWwgPT09ICdudW1iZXInICkge1xuICAgICAgICAgICAgX192YXIgPSBWYXIoIHZhcnNbIHBhcmFtLnR5cGUgXSggdmFsICksIG51bGwsICd2ZWMzJyApXG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBjb25zdCBpbml0dmFsdWVzID0gdmFsICE9PSB1bmRlZmluZWQgPyB2YWwgOiBkZWZhdWx0VmFsdWVzXG4gICAgICAgICAgICBfX3ZhciA9IFZhciggdmFyc1sgcGFyYW0udHlwZSBdKCAuLi5pbml0dmFsdWVzICksIG51bGwsIHBhcmFtLnR5cGUgKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGZvciBhc3NpZ25pbmcgZW50aXJlIG5ldyB2ZWN0b3JzIHRvIHByb3BlcnR5XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCB0YXJnZXQsIHBhcmFtLm5hbWUsIHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTp0cnVlLFxuICAgICAgICAgICAgZ2V0KCkgeyByZXR1cm4gX192YXIgfSxcbiAgICAgICAgICAgIHNldCh2KSB7XG4gICAgICAgICAgICAgIGlmKCB0eXBlb2YgdiA9PT0gJ29iamVjdCcgKSB7XG4gICAgICAgICAgICAgICAgX192YXIuc2V0KCB2IClcbiAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgX192YXIudmFsdWUueCA9IHZcbiAgICAgICAgICAgICAgICBfX3Zhci52YWx1ZS55ID0gdlxuICAgICAgICAgICAgICAgIF9fdmFyLnZhbHVlLnogPSB2XG4gICAgICAgICAgICAgICAgX192YXIudmFsdWUudyA9IHZcbiAgICAgICAgICAgICAgICBfX3Zhci5kaXJ0eSA9IHRydWVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG5cbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgbGV0IF9fdmFyICA9IHBhcmFtX3dyYXAoIFxuICAgICAgICAgICAgcHJvcHNbIHBhcmFtLm5hbWUgXSwgXG4gICAgICAgICAgICBnZW5zWyBwYXJhbS50eXBlIF0oIGRlZmF1bHRWYWx1ZXMgKSBcbiAgICAgICAgICApXG5cbiAgICAgICAgICAvL19fdmFyLnNldCggZGVmYXVsdFZhbHVlcyApXG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCB0YXJnZXQsIHBhcmFtLm5hbWUsIHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTp0cnVlLFxuICAgICAgICAgICAgZ2V0KCkgeyByZXR1cm4gX192YXIgfSxcbiAgICAgICAgICAgIHNldCh2KSB7XG4gICAgICAgICAgICAgIF9fdmFyLnNldCggdiApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiggcHJlc2V0TmFtZSA9PT0gJ2ltYWdlJyApIHtcbiAgICAgICAgaWYoIHByb3BzLmZpbGVuYW1lICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgdGV4LmltYWdlID0gZ2V0UGl4ZWxzKCBwcm9wcy5maWxlbmFtZSwgKGVycixwaXhlbHMpID0+IHtcbiAgICAgICAgICAgIGlmKCBlcnIgIT09IG51bGwgKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoIGVyciApXG4gICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGV4LnBpeGVscyA9IHBpeGVsc1xuICAgICAgICAgICAgdGV4LmdsdGV4dHVyZSA9IGNyZWF0ZVRleHR1cmUoIFNERi5nbCwgcGl4ZWxzIClcbiAgICAgICAgICAgIHRleC5nbHRleHR1cmUud3JhcCA9IHByb3BzLndyYXAgPT09IHVuZGVmaW5lZCA/IE1hcmNoaW5nLmdsLlJFUEVBVCA6IHByb3BzLndyYXBcbiAgICAgICAgICB9KVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICB0ZXguaW1hZ2UgPSBudWxsXG4gICAgICAgICAgY29uc29sZS5lcnJvcignWW91IG11c3Qgc3BlY2lmeSBhIGZpbGVuYW1lIHdoZW4gdXNpbmcgdGhlIGlhbWdlIHByZXNldC4nKVxuICAgICAgICB9XG4gICAgICB9ZWxzZSBpZiggcHJlc2V0TmFtZSA9PT0gJ2NhbnZhcycgKSB7XG4gICAgICAgIGlmKCBwcm9wcy5jYW52YXMgPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgICB0ZXguY2FudmFzID0gdGV4LmltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcbiAgICAgICAgICB0ZXguY3R4ICAgID0gdGV4LmNhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIHRleC5pbWFnZSA9IHByb3BzLmNhbnZhc1xuICAgICAgICB9XG5cbiAgICAgICAgdGV4LnVwZGF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRleC5nbHRleHR1cmUuc2V0UGl4ZWxzKCB0ZXguaW1hZ2UgKVxuICAgICAgICB9XG5cbiAgICAgICAgdGV4LmdsdGV4dHVyZSA9IGNyZWF0ZVRleHR1cmUoIFNERi5nbCwgdGV4LmltYWdlIClcbiAgICAgICAgdGV4LmdsdGV4dHVyZS53cmFwID0gcHJvcHMud3JhcCA9PT0gdW5kZWZpbmVkID8gTWFyY2hpbmcuZ2wuUkVQRUFUIDogcHJvcHMud3JhcFxuXG4gICAgICAgIHRleC51cGRhdGUoKVxuICAgICAgfVxuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGV4LCAnd3JhcCcsIHtcbiAgICAgICAgZ2V0KCkgeyByZXR1cm4gdGhpcy5nbHRleHR1cmUud3JhcCB9LFxuICAgICAgICBzZXQodil7IHRoaXMuZ2x0ZXh0dXJlLndyYXAgPSB2IH1cbiAgICAgIH0pXG5cbiAgICAgIHRleC5uYW1lID0gcHJlc2V0TmFtZVxuXG4gICAgICByZXR1cm4gdGV4IFxuICAgIH0sXG5cbiAgICBkaXJ0eSggdGV4ICkge30sXG4gICBcbiAgICBlbWl0X2RlY2woKSB7XG4gICAgICBpZiggdGhpcy50ZXh0dXJlcy5sZW5ndGggPT09IDAgKSByZXR1cm4gJycgXG5cbiAgICAgIGxldCBkZWNsID0gJydcblxuICAgICAgY29uc3QgbWVtbyA9IFtdXG4gICAgICBsZXQgaW1hZ2VDb3VudCA9IDA7XG4gICAgICB0aGlzLnRleHR1cmVzLmZvckVhY2goICh0ZXgsaSkgPT4ge1xuICAgICAgICBpZiggbWVtby5pbmRleE9mKCB0ZXggKSA9PT0gLTEgKSB7XG4gICAgICAgICAgZm9yKCBsZXQgcGFyYW0gb2YgdGV4LnBhcmFtZXRlcnMgKSB7XG4gICAgICAgICAgICBpZiggcGFyYW0ubmFtZSAhPT0gJ21hdGVyaWFsJyApXG4gICAgICAgICAgICAgIGRlY2wgKz0gdGV4Ll9fdGFyZ2V0WyBwYXJhbS5uYW1lIF0uZW1pdF9kZWNsKClcbiAgICAgICAgICB9XG4gICAgICAgICAgbWVtby5wdXNoKCB0ZXggKVxuICAgICAgICB9XG4gICAgICAgIGlmKCB0ZXgubmFtZSA9PT0gJ2ltYWdlJyB8fCB0ZXgubmFtZSA9PT0gJ2NhbnZhcycgKSB7XG4gICAgICAgICAgaW1hZ2VDb3VudCsrXG5cbiAgICAgICAgICAvLyBmb3Igc29tZSByZWFzb24gY2FuJ3QgaW1tZWRpYXRlbHkgY2FsbCB1cGRhdGUuLi4gXG4gICAgICAgICAgLy8gaGF2ZSB0byB3YWl0IGZvciBzb21lIHR5cGUgb2YgZG9tIGluaXRpYWxpemF0aW9uP1xuICAgICAgICAgIC8vIHNvIGNhbGwgaGVyZVxuICAgICAgICAgIGlmKCB0ZXgudXBkYXRlICkgdGV4LnVwZGF0ZSgpXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIGlmKCBpbWFnZUNvdW50ID4gMCApIHtcbiAgICAgICAgZGVjbCArPSBgXFxuICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdGV4dHVyZXNbJHtpbWFnZUNvdW50fV07XFxuYFxuICAgICAgfVxuICAgICAgcmV0dXJuIGRlY2xcbiAgICB9LFxuICAgIFxuICAgIHVwZGF0ZV9sb2NhdGlvbiggZ2wsIHByb2dyYW0gKSB7XG4gICAgICBpZiggdGhpcy50ZXh0dXJlcy5sZW5ndGggPiAwICkge1xuICAgICAgICB0aGlzLnRleHR1cmVzLmZvckVhY2goICh0ZXgsaSkgPT4ge1xuICAgICAgICAgIGZvciggbGV0IHBhcmFtIG9mIHRleC5wYXJhbWV0ZXJzICkge1xuICAgICAgICAgICAgaWYoIHBhcmFtLnR5cGUgIT09ICdvYmonICkge1xuICAgICAgICAgICAgICBpZiggcGFyYW0ubmFtZSAhPT0gJ21hdGVyaWFsJyApIFxuICAgICAgICAgICAgICAgIHRleC5fX3RhcmdldFsgcGFyYW0ubmFtZSBdLnVwZGF0ZV9sb2NhdGlvbiggZ2wscHJvZ3JhbSApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKCB0ZXgubmFtZSA9PT0gJ2ltYWdlJyB8fCB0ZXgubmFtZSA9PT0gJ2NhbnZhcycgKSB7XG4gICAgICAgICAgICB0ZXgubG9jID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBgdGV4dHVyZXNbJHt0ZXguaWR9XWAgKVxuICAgICAgICAgICAgdGV4LmdsdGV4dHVyZS5iaW5kKCBpIClcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG5cbiAgICAgIC8vaWYoIHRoaXMudGV4dHVyZXMubGVuZ3RoID4gMCApIHtcbiAgICAgIC8vICB0aGlzLnRleHR1cmVzLnNvcnQoIChhLGIpID0+IGEuaWQgPiBiLmlkID8gMSA6IC0xICkgXG5cbiAgICAgIC8vICBmb3IoIGxldCB0ZXggb2YgdGhpcy50ZXh0dXJlcyApIHtcbiAgICAgIC8vICAgIHRleC5sb2MgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sIGB0ZXh0dXJlc1ske3RleC5pZH1dYCApXG4gICAgICAvLyAgICB0ZXguZ2x0ZXh0dXJlLmJpbmQoIHRleC5pZCApXG4gICAgICAvLyAgfVxuXG4gICAgICAvLyAgdGhpcy5fX3RleHR1cmVzID0gdGhpcy50ZXh0dXJlcy5zbGljZSggMCApXG4gICAgICAvLyAgdGhpcy50ZXh0dXJlcy5sZW5ndGggPSAwXG4gICAgICAvL31cbiAgICB9LFxuXG4gICAgdXBsb2FkX2RhdGEoIGdsLCBwcm9ncmFtICkge1xuICAgICAgaWYoIHRoaXMudGV4dHVyZXMubGVuZ3RoID4gMCApIHtcbiAgICAgICAgdGhpcy50ZXh0dXJlcy5mb3JFYWNoKCAodGV4LGkpID0+IHtcbiAgICAgICAgICBmb3IoIGxldCBwYXJhbSBvZiB0ZXgucGFyYW1ldGVycyApIHtcbiAgICAgICAgICAgIGlmKCBwYXJhbS50eXBlICE9PSAnb2JqJyAmJiBwYXJhbS5uYW1lICE9PSAnbWF0ZXJpYWwnIClcbiAgICAgICAgICAgICAgdGV4Ll9fdGFyZ2V0WyBwYXJhbS5uYW1lIF0udXBsb2FkX2RhdGEoIGdsIClcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYoIHRleC5uYW1lID09PSAnaW1hZ2UnIHx8IHRleC5uYW1lID09PSAnY2FudmFzJyApIHtcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xaSggdGV4LmxvYywgaSApXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cblxuICB9XG5cbiAgVGV4dHVyZXMudGV4dHVyZS5jcmVhdGUgPSBmdW5jdGlvbiggcHJvcHMgKSB7XG4gICAgVGV4dHVyZXMuX190eXBlc1sgcHJvcHMubmFtZSBdID0gcHJvcHNcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCBUZXh0dXJlcy50ZXh0dXJlLCB7XG4gICAgJ3JlcGVhdCc6IHsgZ2V0KCkgeyByZXR1cm4gTWFyY2hpbmcuZ2wuUkVQRUFUIH0gfSxcbiAgICAnbWlycm9yJzogeyBnZXQoKSB7IHJldHVybiBNYXJjaGluZy5nbC5NSVJST1JFRF9SRVBFQVQgfSB9LFxuICAgICdjbGFtcCc6IHsgZ2V0KCkgeyByZXR1cm4gTWFyY2hpbmcuZ2wuQ0xBTVBfVE9fRURHRSB9IH0sXG4gIH0pXG5cbiAgY29uc3QgZiA9IHZhbHVlID0+IHZhbHVlICUgMSA9PT0gMCA/IHZhbHVlLnRvRml4ZWQoMSkgOiB2YWx1ZSBcblxuICByZXR1cm4gVGV4dHVyZXNcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfX1RleHR1cmVzXG4iLCJjb25zdCBnbHNsID0gcmVxdWlyZSggJ2dsc2xpZnknIClcblxuY29uc3QgdGV4dHVyZXMgPSB7XG4gIGltYWdlOiB7XG4gICAgbmFtZTonaW1hZ2UnLFxuICAgIGdsc2wyZDpgXG4gICAgICB2ZWMzIGltYWdlMmQoIHZlYzIgdXYsIGZsb2F0IHNjYWxlLCBmbG9hdCBzdHJlbmd0aCApIHtcbiAgICAgICAgcmV0dXJuIHRleHR1cmUoIHRleHR1cmVzWyAwIF0sIHV2KnNjYWxlICkueHl6ICogc3RyZW5ndGg7XG4gICAgICB9XG4gICAgYCxcbiAgICBwYXJhbWV0ZXJzOltcbiAgICAgIHsgbmFtZTonc2NhbGUnLCB0eXBlOidmbG9hdCcsIGRlZmF1bHQ6MSB9LFxuICAgICAgeyBuYW1lOidzdHJlbmd0aCcsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDoxIH0sICAgXG4gICAgXVxuICB9LFxuICBjYW52YXM6IHtcbiAgICBuYW1lOidjYW52YXMnLFxuICAgIGdsc2wyZDpgXG4gICAgICB2ZWMzIGNhbnZhczJkKCB2ZWMyIHV2LCBmbG9hdCBzY2FsZSwgZmxvYXQgc3RyZW5ndGggKSB7XG4gICAgICAgIHJldHVybiB0ZXh0dXJlKCB0ZXh0dXJlc1sgMCBdLCB1dipzY2FsZSApLnh5eiAqIHN0cmVuZ3RoO1xuICAgICAgfVxuICAgIGAsXG4gICAgcGFyYW1ldGVyczpbXG4gICAgICB7IG5hbWU6J3NjYWxlJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjEgfSxcbiAgICAgIHsgbmFtZTonc3RyZW5ndGgnLCB0eXBlOidmbG9hdCcsIGRlZmF1bHQ6MSB9LCAgIFxuICAgIF1cbiAgfSxcbiAgcmFpbmJvdzoge1xuICAgIG5hbWU6J3JhaW5ib3cnLFxuICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgIHsgbmFtZTonc3RyZW5ndGgnLCB0eXBlOidmbG9hdCcsIGRlZmF1bHQ6MSB9LFxuICAgICAgeyBuYW1lOidzaGlmdCcsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDowIH0sXG4gICAgICB7IG5hbWU6J3NjYWxlJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjEgfSxcbiAgICBdLFxuICAgIGdsc2w6YCBcbiAgICB2ZWMzIHJhaW5ib3coIHZlYzMgcG9zLCBmbG9hdCBzdHJlbmd0aCwgZmxvYXQgc2hpZnQsIGZsb2F0IHNjYWxlICkge1xuICAgICAgcG9zID0gcG9zICogc2NhbGU7XG4gICAgICB2ZWMzIGEgPSB2ZWMzKDAuNSwwLjUsMC41KSwgYiA9IHZlYzMoMC41LDAuNSwwLjUpLCBjID0gdmVjMygxLjAsMS4wLDEuMCksZCA9IHZlYzMoMC4wLDAuMzMsMC42Nyk7XG4gICAgICByZXR1cm4gYSArIGIgKiBjb3MoIDYuMjgzODE4ICogKCBjICogbW9kKGxlbmd0aChwb3MpICsgc2hpZnQsIDEuICkgKyBkICkgKSAqIHN0cmVuZ3RoO1xuICAgIH1gIFxuICB9LFxuICBjaGVja2Vyczoge1xuICAgIG5hbWU6J2NoZWNrZXJzJyxcbiAgICBnbHNsOmAgICAgICAgICAgXG4gICAgICAgIHZlYzMgY2hlY2tlcnMoIHZlYzMgcG9zLCBmbG9hdCBzaXplLCB2ZWMzIGNvbG9yMSwgdmVjMyBjb2xvcjIgKSB7XG4gICAgICAgICAgdmVjMyB0ZXg7XG4gICAgICAgICAgcG9zICA9IHBvcyAqIHNpemU7XG4gICAgICAgICAgaWYgKChpbnQoZmxvb3IocG9zLngpICsgZmxvb3IocG9zLnkpICsgZmxvb3IocG9zLnopKSAmIDEpID09IDApIHtcbiAgICAgICAgICAgIHRleCA9IGNvbG9yMTtcbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHRleCA9IGNvbG9yMjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdGV4O1xuICAgICAgICB9YCxcbiAgICBnbHNsMmQ6YFxuICAgICAgICB2ZWMzIGNoZWNrZXJzMmQoIHZlYzIgdXYsIGZsb2F0IHNpemUsIHZlYzMgY29sb3IxLCB2ZWMzIGNvbG9yMiApIHtcbiAgICAgICAgICBmbG9hdCBmbW9kUmVzdWx0ID0gbW9kKGZsb29yKHNpemUgKiB1di54KSArIGZsb29yKHNpemUgKiB1di55KSwgMi4wKTtcbiAgICAgICAgICBmbG9hdCBmaW4gPSBtYXgoc2lnbihmbW9kUmVzdWx0KSwgMC4wKTsgXG5cbiAgICAgICAgICByZXR1cm4gdmVjMyhmaW4pO1xuICAgICAgICB9XG4gICAgYCxcbiAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICB7IG5hbWU6J3NjYWxlJywgIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDo1IH0sXG4gICAgICB7IG5hbWU6J2NvbG9yMScsIHR5cGU6J3ZlYzMnLCBkZWZhdWx0OlsxLDEsMV0gfSxcbiAgICAgIHsgbmFtZTonY29sb3IyJywgdHlwZTondmVjMycsIGRlZmF1bHQ6WzAsMCwwXSB9XG4gICAgXSxcbiAgfSxcbiAgbm9pc2U6IHtcbiAgICBuYW1lOidub2lzZScsXG4gICAgZ2xzbDpnbHNsKFtcIiNkZWZpbmUgR0xTTElGWSAxXFxuICAgICAgICAgIFxcbiAgICAgICAgLy9cXG4vLyBEZXNjcmlwdGlvbiA6IEFycmF5IGFuZCB0ZXh0dXJlbGVzcyBHTFNMIDJELzNELzREIHNpbXBsZXhcXG4vLyAgICAgICAgICAgICAgIG5vaXNlIGZ1bmN0aW9ucy5cXG4vLyAgICAgIEF1dGhvciA6IElhbiBNY0V3YW4sIEFzaGltYSBBcnRzLlxcbi8vICBNYWludGFpbmVyIDogaWptXFxuLy8gICAgIExhc3Rtb2QgOiAyMDExMDgyMiAoaWptKVxcbi8vICAgICBMaWNlbnNlIDogQ29weXJpZ2h0IChDKSAyMDExIEFzaGltYSBBcnRzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxcbi8vICAgICAgICAgICAgICAgRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlLlxcbi8vICAgICAgICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2FzaGltYS93ZWJnbC1ub2lzZVxcbi8vXFxuXFxudmVjNCBtb2QyODkodmVjNCB4KSB7XFxuICByZXR1cm4geCAtIGZsb29yKHggKiAoMS4wIC8gMjg5LjApKSAqIDI4OS4wOyB9XFxuXFxuZmxvYXQgbW9kMjg5KGZsb2F0IHgpIHtcXG4gIHJldHVybiB4IC0gZmxvb3IoeCAqICgxLjAgLyAyODkuMCkpICogMjg5LjA7IH1cXG5cXG52ZWM0IHBlcm11dGUodmVjNCB4KSB7XFxuICAgICByZXR1cm4gbW9kMjg5KCgoeCozNC4wKSsxLjApKngpO1xcbn1cXG5cXG5mbG9hdCBwZXJtdXRlKGZsb2F0IHgpIHtcXG4gICAgIHJldHVybiBtb2QyODkoKCh4KjM0LjApKzEuMCkqeCk7XFxufVxcblxcbnZlYzQgdGF5bG9ySW52U3FydCh2ZWM0IHIpXFxue1xcbiAgcmV0dXJuIDEuNzkyODQyOTE0MDAxNTkgLSAwLjg1MzczNDcyMDk1MzE0ICogcjtcXG59XFxuXFxuZmxvYXQgdGF5bG9ySW52U3FydChmbG9hdCByKVxcbntcXG4gIHJldHVybiAxLjc5Mjg0MjkxNDAwMTU5IC0gMC44NTM3MzQ3MjA5NTMxNCAqIHI7XFxufVxcblxcbnZlYzQgZ3JhZDQoZmxvYXQgaiwgdmVjNCBpcClcXG4gIHtcXG4gIGNvbnN0IHZlYzQgb25lcyA9IHZlYzQoMS4wLCAxLjAsIDEuMCwgLTEuMCk7XFxuICB2ZWM0IHAscztcXG5cXG4gIHAueHl6ID0gZmxvb3IoIGZyYWN0ICh2ZWMzKGopICogaXAueHl6KSAqIDcuMCkgKiBpcC56IC0gMS4wO1xcbiAgcC53ID0gMS41IC0gZG90KGFicyhwLnh5eiksIG9uZXMueHl6KTtcXG4gIHMgPSB2ZWM0KGxlc3NUaGFuKHAsIHZlYzQoMC4wKSkpO1xcbiAgcC54eXogPSBwLnh5eiArIChzLnh5eioyLjAgLSAxLjApICogcy53d3c7XFxuXFxuICByZXR1cm4gcDtcXG4gIH1cXG5cXG4vLyAoc3FydCg1KSAtIDEpLzQgPSBGNCwgdXNlZCBvbmNlIGJlbG93XFxuI2RlZmluZSBGNCAwLjMwOTAxNjk5NDM3NDk0NzQ1MVxcblxcbmZsb2F0IHNub2lzZSh2ZWM0IHYpXFxuICB7XFxuICBjb25zdCB2ZWM0ICBDID0gdmVjNCggMC4xMzgxOTY2MDExMjUwMTEsICAvLyAoNSAtIHNxcnQoNSkpLzIwICBHNFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAuMjc2MzkzMjAyMjUwMDIxLCAgLy8gMiAqIEc0XFxuICAgICAgICAgICAgICAgICAgICAgICAgMC40MTQ1ODk4MDMzNzUwMzIsICAvLyAzICogRzRcXG4gICAgICAgICAgICAgICAgICAgICAgIC0wLjQ0NzIxMzU5NTQ5OTk1OCk7IC8vIC0xICsgNCAqIEc0XFxuXFxuLy8gRmlyc3QgY29ybmVyXFxuICB2ZWM0IGkgID0gZmxvb3IodiArIGRvdCh2LCB2ZWM0KEY0KSkgKTtcXG4gIHZlYzQgeDAgPSB2IC0gICBpICsgZG90KGksIEMueHh4eCk7XFxuXFxuLy8gT3RoZXIgY29ybmVyc1xcblxcbi8vIFJhbmsgc29ydGluZyBvcmlnaW5hbGx5IGNvbnRyaWJ1dGVkIGJ5IEJpbGwgTGljZWEtS2FuZSwgQU1EIChmb3JtZXJseSBBVEkpXFxuICB2ZWM0IGkwO1xcbiAgdmVjMyBpc1ggPSBzdGVwKCB4MC55encsIHgwLnh4eCApO1xcbiAgdmVjMyBpc1laID0gc3RlcCggeDAuend3LCB4MC55eXogKTtcXG4vLyAgaTAueCA9IGRvdCggaXNYLCB2ZWMzKCAxLjAgKSApO1xcbiAgaTAueCA9IGlzWC54ICsgaXNYLnkgKyBpc1guejtcXG4gIGkwLnl6dyA9IDEuMCAtIGlzWDtcXG4vLyAgaTAueSArPSBkb3QoIGlzWVoueHksIHZlYzIoIDEuMCApICk7XFxuICBpMC55ICs9IGlzWVoueCArIGlzWVoueTtcXG4gIGkwLnp3ICs9IDEuMCAtIGlzWVoueHk7XFxuICBpMC56ICs9IGlzWVouejtcXG4gIGkwLncgKz0gMS4wIC0gaXNZWi56O1xcblxcbiAgLy8gaTAgbm93IGNvbnRhaW5zIHRoZSB1bmlxdWUgdmFsdWVzIDAsMSwyLDMgaW4gZWFjaCBjaGFubmVsXFxuICB2ZWM0IGkzID0gY2xhbXAoIGkwLCAwLjAsIDEuMCApO1xcbiAgdmVjNCBpMiA9IGNsYW1wKCBpMC0xLjAsIDAuMCwgMS4wICk7XFxuICB2ZWM0IGkxID0gY2xhbXAoIGkwLTIuMCwgMC4wLCAxLjAgKTtcXG5cXG4gIC8vICB4MCA9IHgwIC0gMC4wICsgMC4wICogQy54eHh4XFxuICAvLyAgeDEgPSB4MCAtIGkxICArIDEuMCAqIEMueHh4eFxcbiAgLy8gIHgyID0geDAgLSBpMiAgKyAyLjAgKiBDLnh4eHhcXG4gIC8vICB4MyA9IHgwIC0gaTMgICsgMy4wICogQy54eHh4XFxuICAvLyAgeDQgPSB4MCAtIDEuMCArIDQuMCAqIEMueHh4eFxcbiAgdmVjNCB4MSA9IHgwIC0gaTEgKyBDLnh4eHg7XFxuICB2ZWM0IHgyID0geDAgLSBpMiArIEMueXl5eTtcXG4gIHZlYzQgeDMgPSB4MCAtIGkzICsgQy56enp6O1xcbiAgdmVjNCB4NCA9IHgwICsgQy53d3d3O1xcblxcbi8vIFBlcm11dGF0aW9uc1xcbiAgaSA9IG1vZDI4OShpKTtcXG4gIGZsb2F0IGowID0gcGVybXV0ZSggcGVybXV0ZSggcGVybXV0ZSggcGVybXV0ZShpLncpICsgaS56KSArIGkueSkgKyBpLngpO1xcbiAgdmVjNCBqMSA9IHBlcm11dGUoIHBlcm11dGUoIHBlcm11dGUoIHBlcm11dGUgKFxcbiAgICAgICAgICAgICBpLncgKyB2ZWM0KGkxLncsIGkyLncsIGkzLncsIDEuMCApKVxcbiAgICAgICAgICAgKyBpLnogKyB2ZWM0KGkxLnosIGkyLnosIGkzLnosIDEuMCApKVxcbiAgICAgICAgICAgKyBpLnkgKyB2ZWM0KGkxLnksIGkyLnksIGkzLnksIDEuMCApKVxcbiAgICAgICAgICAgKyBpLnggKyB2ZWM0KGkxLngsIGkyLngsIGkzLngsIDEuMCApKTtcXG5cXG4vLyBHcmFkaWVudHM6IDd4N3g2IHBvaW50cyBvdmVyIGEgY3ViZSwgbWFwcGVkIG9udG8gYSA0LWNyb3NzIHBvbHl0b3BlXFxuLy8gNyo3KjYgPSAyOTQsIHdoaWNoIGlzIGNsb3NlIHRvIHRoZSByaW5nIHNpemUgMTcqMTcgPSAyODkuXFxuICB2ZWM0IGlwID0gdmVjNCgxLjAvMjk0LjAsIDEuMC80OS4wLCAxLjAvNy4wLCAwLjApIDtcXG5cXG4gIHZlYzQgcDAgPSBncmFkNChqMCwgICBpcCk7XFxuICB2ZWM0IHAxID0gZ3JhZDQoajEueCwgaXApO1xcbiAgdmVjNCBwMiA9IGdyYWQ0KGoxLnksIGlwKTtcXG4gIHZlYzQgcDMgPSBncmFkNChqMS56LCBpcCk7XFxuICB2ZWM0IHA0ID0gZ3JhZDQoajEudywgaXApO1xcblxcbi8vIE5vcm1hbGlzZSBncmFkaWVudHNcXG4gIHZlYzQgbm9ybSA9IHRheWxvckludlNxcnQodmVjNChkb3QocDAscDApLCBkb3QocDEscDEpLCBkb3QocDIsIHAyKSwgZG90KHAzLHAzKSkpO1xcbiAgcDAgKj0gbm9ybS54O1xcbiAgcDEgKj0gbm9ybS55O1xcbiAgcDIgKj0gbm9ybS56O1xcbiAgcDMgKj0gbm9ybS53O1xcbiAgcDQgKj0gdGF5bG9ySW52U3FydChkb3QocDQscDQpKTtcXG5cXG4vLyBNaXggY29udHJpYnV0aW9ucyBmcm9tIHRoZSBmaXZlIGNvcm5lcnNcXG4gIHZlYzMgbTAgPSBtYXgoMC42IC0gdmVjMyhkb3QoeDAseDApLCBkb3QoeDEseDEpLCBkb3QoeDIseDIpKSwgMC4wKTtcXG4gIHZlYzIgbTEgPSBtYXgoMC42IC0gdmVjMihkb3QoeDMseDMpLCBkb3QoeDQseDQpICAgICAgICAgICAgKSwgMC4wKTtcXG4gIG0wID0gbTAgKiBtMDtcXG4gIG0xID0gbTEgKiBtMTtcXG4gIHJldHVybiA0OS4wICogKCBkb3QobTAqbTAsIHZlYzMoIGRvdCggcDAsIHgwICksIGRvdCggcDEsIHgxICksIGRvdCggcDIsIHgyICkpKVxcbiAgICAgICAgICAgICAgICsgZG90KG0xKm0xLCB2ZWMyKCBkb3QoIHAzLCB4MyApLCBkb3QoIHA0LCB4NCApICkgKSApIDtcXG5cXG4gIH1cXG5cXG4gICAgICAgIHZlYzMgbm9pc2UoIHZlYzMgcG9zLCBmbG9hdCBzY2FsZSwgZmxvYXQgc3RyZW5ndGgsIGZsb2F0IHRpbWUgKSB7XFxuICAgICAgICAgIGZsb2F0IG4gPSBzbm9pc2UoIHZlYzQocG9zKnNjYWxlLCB0aW1lKSApO1xcbiAgICAgICAgICByZXR1cm4gdmVjMyggbiApICogc3RyZW5ndGg7XFxuICAgICAgICB9XCIsXCJcIl0pLFxuICAgIGdsc2wyZDpnbHNsKFtcIiNkZWZpbmUgR0xTTElGWSAxXFxuICAgIFxcbiAgICAgICAgLy9cXG4vLyBEZXNjcmlwdGlvbiA6IEFycmF5IGFuZCB0ZXh0dXJlbGVzcyBHTFNMIDJELzNELzREIHNpbXBsZXhcXG4vLyAgICAgICAgICAgICAgIG5vaXNlIGZ1bmN0aW9ucy5cXG4vLyAgICAgIEF1dGhvciA6IElhbiBNY0V3YW4sIEFzaGltYSBBcnRzLlxcbi8vICBNYWludGFpbmVyIDogaWptXFxuLy8gICAgIExhc3Rtb2QgOiAyMDExMDgyMiAoaWptKVxcbi8vICAgICBMaWNlbnNlIDogQ29weXJpZ2h0IChDKSAyMDExIEFzaGltYSBBcnRzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxcbi8vICAgICAgICAgICAgICAgRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlLlxcbi8vICAgICAgICAgICAgICAgaHR0cHM6Ly9naXRodWIuY29tL2FzaGltYS93ZWJnbC1ub2lzZVxcbi8vXFxuXFxudmVjMyBtb2QyODkodmVjMyB4KSB7XFxuICByZXR1cm4geCAtIGZsb29yKHggKiAoMS4wIC8gMjg5LjApKSAqIDI4OS4wO1xcbn1cXG5cXG52ZWM0IG1vZDI4OSh2ZWM0IHgpIHtcXG4gIHJldHVybiB4IC0gZmxvb3IoeCAqICgxLjAgLyAyODkuMCkpICogMjg5LjA7XFxufVxcblxcbnZlYzQgcGVybXV0ZSh2ZWM0IHgpIHtcXG4gICAgIHJldHVybiBtb2QyODkoKCh4KjM0LjApKzEuMCkqeCk7XFxufVxcblxcbnZlYzQgdGF5bG9ySW52U3FydCh2ZWM0IHIpXFxue1xcbiAgcmV0dXJuIDEuNzkyODQyOTE0MDAxNTkgLSAwLjg1MzczNDcyMDk1MzE0ICogcjtcXG59XFxuXFxuZmxvYXQgc25vaXNlKHZlYzMgdilcXG4gIHtcXG4gIGNvbnN0IHZlYzIgIEMgPSB2ZWMyKDEuMC82LjAsIDEuMC8zLjApIDtcXG4gIGNvbnN0IHZlYzQgIEQgPSB2ZWM0KDAuMCwgMC41LCAxLjAsIDIuMCk7XFxuXFxuLy8gRmlyc3QgY29ybmVyXFxuICB2ZWMzIGkgID0gZmxvb3IodiArIGRvdCh2LCBDLnl5eSkgKTtcXG4gIHZlYzMgeDAgPSAgIHYgLSBpICsgZG90KGksIEMueHh4KSA7XFxuXFxuLy8gT3RoZXIgY29ybmVyc1xcbiAgdmVjMyBnID0gc3RlcCh4MC55engsIHgwLnh5eik7XFxuICB2ZWMzIGwgPSAxLjAgLSBnO1xcbiAgdmVjMyBpMSA9IG1pbiggZy54eXosIGwuenh5ICk7XFxuICB2ZWMzIGkyID0gbWF4KCBnLnh5eiwgbC56eHkgKTtcXG5cXG4gIC8vICAgeDAgPSB4MCAtIDAuMCArIDAuMCAqIEMueHh4O1xcbiAgLy8gICB4MSA9IHgwIC0gaTEgICsgMS4wICogQy54eHg7XFxuICAvLyAgIHgyID0geDAgLSBpMiAgKyAyLjAgKiBDLnh4eDtcXG4gIC8vICAgeDMgPSB4MCAtIDEuMCArIDMuMCAqIEMueHh4O1xcbiAgdmVjMyB4MSA9IHgwIC0gaTEgKyBDLnh4eDtcXG4gIHZlYzMgeDIgPSB4MCAtIGkyICsgQy55eXk7IC8vIDIuMCpDLnggPSAxLzMgPSBDLnlcXG4gIHZlYzMgeDMgPSB4MCAtIEQueXl5OyAgICAgIC8vIC0xLjArMy4wKkMueCA9IC0wLjUgPSAtRC55XFxuXFxuLy8gUGVybXV0YXRpb25zXFxuICBpID0gbW9kMjg5KGkpO1xcbiAgdmVjNCBwID0gcGVybXV0ZSggcGVybXV0ZSggcGVybXV0ZShcXG4gICAgICAgICAgICAgaS56ICsgdmVjNCgwLjAsIGkxLnosIGkyLnosIDEuMCApKVxcbiAgICAgICAgICAgKyBpLnkgKyB2ZWM0KDAuMCwgaTEueSwgaTIueSwgMS4wICkpXFxuICAgICAgICAgICArIGkueCArIHZlYzQoMC4wLCBpMS54LCBpMi54LCAxLjAgKSk7XFxuXFxuLy8gR3JhZGllbnRzOiA3eDcgcG9pbnRzIG92ZXIgYSBzcXVhcmUsIG1hcHBlZCBvbnRvIGFuIG9jdGFoZWRyb24uXFxuLy8gVGhlIHJpbmcgc2l6ZSAxNyoxNyA9IDI4OSBpcyBjbG9zZSB0byBhIG11bHRpcGxlIG9mIDQ5ICg0OSo2ID0gMjk0KVxcbiAgZmxvYXQgbl8gPSAwLjE0Mjg1NzE0Mjg1NzsgLy8gMS4wLzcuMFxcbiAgdmVjMyAgbnMgPSBuXyAqIEQud3l6IC0gRC54eng7XFxuXFxuICB2ZWM0IGogPSBwIC0gNDkuMCAqIGZsb29yKHAgKiBucy56ICogbnMueik7ICAvLyAgbW9kKHAsNyo3KVxcblxcbiAgdmVjNCB4XyA9IGZsb29yKGogKiBucy56KTtcXG4gIHZlYzQgeV8gPSBmbG9vcihqIC0gNy4wICogeF8gKTsgICAgLy8gbW9kKGosTilcXG5cXG4gIHZlYzQgeCA9IHhfICpucy54ICsgbnMueXl5eTtcXG4gIHZlYzQgeSA9IHlfICpucy54ICsgbnMueXl5eTtcXG4gIHZlYzQgaCA9IDEuMCAtIGFicyh4KSAtIGFicyh5KTtcXG5cXG4gIHZlYzQgYjAgPSB2ZWM0KCB4Lnh5LCB5Lnh5ICk7XFxuICB2ZWM0IGIxID0gdmVjNCggeC56dywgeS56dyApO1xcblxcbiAgLy92ZWM0IHMwID0gdmVjNChsZXNzVGhhbihiMCwwLjApKSoyLjAgLSAxLjA7XFxuICAvL3ZlYzQgczEgPSB2ZWM0KGxlc3NUaGFuKGIxLDAuMCkpKjIuMCAtIDEuMDtcXG4gIHZlYzQgczAgPSBmbG9vcihiMCkqMi4wICsgMS4wO1xcbiAgdmVjNCBzMSA9IGZsb29yKGIxKSoyLjAgKyAxLjA7XFxuICB2ZWM0IHNoID0gLXN0ZXAoaCwgdmVjNCgwLjApKTtcXG5cXG4gIHZlYzQgYTAgPSBiMC54enl3ICsgczAueHp5dypzaC54eHl5IDtcXG4gIHZlYzQgYTEgPSBiMS54enl3ICsgczEueHp5dypzaC56end3IDtcXG5cXG4gIHZlYzMgcDAgPSB2ZWMzKGEwLnh5LGgueCk7XFxuICB2ZWMzIHAxID0gdmVjMyhhMC56dyxoLnkpO1xcbiAgdmVjMyBwMiA9IHZlYzMoYTEueHksaC56KTtcXG4gIHZlYzMgcDMgPSB2ZWMzKGExLnp3LGgudyk7XFxuXFxuLy9Ob3JtYWxpc2UgZ3JhZGllbnRzXFxuICB2ZWM0IG5vcm0gPSB0YXlsb3JJbnZTcXJ0KHZlYzQoZG90KHAwLHAwKSwgZG90KHAxLHAxKSwgZG90KHAyLCBwMiksIGRvdChwMyxwMykpKTtcXG4gIHAwICo9IG5vcm0ueDtcXG4gIHAxICo9IG5vcm0ueTtcXG4gIHAyICo9IG5vcm0uejtcXG4gIHAzICo9IG5vcm0udztcXG5cXG4vLyBNaXggZmluYWwgbm9pc2UgdmFsdWVcXG4gIHZlYzQgbSA9IG1heCgwLjYgLSB2ZWM0KGRvdCh4MCx4MCksIGRvdCh4MSx4MSksIGRvdCh4Mix4MiksIGRvdCh4Myx4MykpLCAwLjApO1xcbiAgbSA9IG0gKiBtO1xcbiAgcmV0dXJuIDQyLjAgKiBkb3QoIG0qbSwgdmVjNCggZG90KHAwLHgwKSwgZG90KHAxLHgxKSxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvdChwMix4MiksIGRvdChwMyx4MykgKSApO1xcbiAgfVxcblxcbiAgICAgICAgdmVjMyBub2lzZTJkKCB2ZWMyIHN0LCBmbG9hdCBzY2FsZSwgZmxvYXQgc3RyZW5ndGgsIGZsb2F0IHRpbWUgKSB7XFxuICAgICAgICAgIGZsb2F0IGNvbCA9IHNub2lzZSggdmVjMyggc3QsIHRpbWUgKSAqIHNjYWxlICk7XFxuXFxuICAgICAgICAgIHJldHVybiB2ZWMzKGNvbCkgKiBzdHJlbmd0aDtcXG4gICAgICAgIH1cXG5cIixcIlwiXSkgLFxuICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgIHsgbmFtZTonc2NhbGUnLCB0eXBlOidmbG9hdCcsIGRlZmF1bHQ6MiB9LFxuICAgICAgeyBuYW1lOidzdHJlbmd0aCcsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDouMSB9LFxuICAgICAgeyBuYW1lOid0aW1lJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjEgfVxuICAgIF0sXG4gIH0sXG4gIC8vIGFkYXB0ZWQgZnJvbSBodHRwczovL3RoZWJvb2tvZnNoYWRlcnMuY29tLzEwL1xuICB0cnVjaGV0OiB7XG4gICAgbmFtZTondHJ1Y2hldCcsXG4gICAgZ2xzbDJkOmAgICAgXG4gICAgICAgIGZsb2F0IHJhbmRvbV90cnVjaGV0KGluIHZlYzIgX3N0KSB7XG4gICAgICAgICAgcmV0dXJuIGZyYWN0KHNpbihkb3QoX3N0Lnh5LFxuICAgICAgICAgICAgICAgICAgICAgICAgIHZlYzIoMTIuOTg5OCw3OC4yMzMpKSkqXG4gICAgICAgICAgICAgICAgICAgICAgICA0Mzc1OC41NDUzMTIzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZlYzIgdHJ1Y2hldFBhdHRlcm4oaW4gdmVjMiBfc3QsIGluIGZsb2F0IF9pbmRleCl7XG4gICAgICAgICAgICBfaW5kZXggPSBmcmFjdCgoKF9pbmRleC0wLjUpKjIuMCkpO1xuICAgICAgICAgICAgaWYgKF9pbmRleCA+IDAuNzUpIHtcbiAgICAgICAgICAgICAgICBfc3QgPSB2ZWMyKDEuMCkgLSBfc3Q7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKF9pbmRleCA+IDAuNSkge1xuICAgICAgICAgICAgICAgIF9zdCA9IHZlYzIoMS4wLV9zdC54LF9zdC55KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoX2luZGV4ID4gMC4yNSkge1xuICAgICAgICAgICAgICAgIF9zdCA9IDEuMC12ZWMyKDEuMC1fc3QueCxfc3QueSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3N0O1xuICAgICAgICB9XG5cbiAgICAgICAgdmVjMyB0cnVjaGV0MmQoIHZlYzIgc3QsIGZsb2F0IHNjYWxlLCB2ZWMzIGNvbG9yICkge1xuICAgICAgICAgICAgc3QgPSBzdCAqIHNjYWxlO1xuICAgICAgICAgICAgdmVjMiBpcG9zID0gZmxvb3Ioc3QpOyAgLy8gaW50ZWdlclxuICAgICAgICAgICAgdmVjMiBmcG9zID0gZnJhY3Qoc3QpOyAgLy8gZnJhY3Rpb25cblxuICAgICAgICAgICAgdmVjMiB0aWxlID0gdHJ1Y2hldFBhdHRlcm4oZnBvcywgcmFuZG9tX3RydWNoZXQoIGlwb3MgKSk7XG5cbiAgICAgICAgICAgIGZsb2F0IGNvbCA9IHNtb290aHN0ZXAodGlsZS54LTAuMyx0aWxlLngsdGlsZS55KS1zbW9vdGhzdGVwKHRpbGUueCx0aWxlLngrLjMsdGlsZS55KTtcbiAgICAgICAgICAgIHJldHVybiBjb2xvciAqIGNvbDtcbiAgICAgICAgfVxuXG5gICxcbiAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICB7IG5hbWU6J3NjYWxlJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjEwIH0sXG4gICAgICB7IG5hbWU6J2NvbG9yJywgdHlwZTondmVjMycsIGRlZmF1bHQ6WzEsMSwxXSB9XG4gICAgXSxcbiAgfSxcbiAgZG90czoge1xuICAgIG5hbWU6J2RvdHMnLFxuICAgIGdsc2w6YCAgICAgICAgICBcbiAgICAgICAgdmVjMyBkb3RzKCB2ZWMzIHBvcywgZmxvYXQgY291bnQsIGZsb2F0IHJhZGl1cywgdmVjMyBjb2xvciApIHtcbiAgICAgICAgICB2ZWMzIHRleDtcbiAgICAgICAgICB0ZXggPSB2ZWMzKCBjb2xvciAtIHNtb290aHN0ZXAoIHJhZGl1cywgcmFkaXVzKy4wMiwgbGVuZ3RoKGZyYWN0KHBvcyoocm91bmQoY291bnQvMi4pKy41KSkgLS41ICkpICk7XG4gICAgICAgICAgcmV0dXJuIHRleDtcbiAgICAgICAgfWAgLFxuICAgIGdsc2wyZDpgXG4gICAgICB2ZWMyIHRpbGUodmVjMiBfc3QsIGZsb2F0IF96b29tKXtcbiAgICAgICAgX3N0ICo9IF96b29tO1xuICAgICAgICByZXR1cm4gZnJhY3QoX3N0KTtcbiAgICAgIH1cblxuICAgICAgZmxvYXQgY2lyY2xlKHZlYzIgX3N0LCBmbG9hdCBfcmFkaXVzKXtcbiAgICAgICAgdmVjMiBwb3MgPSB2ZWMyKDAuNSktX3N0O1xuICAgICAgICBfcmFkaXVzICo9IDAuNzU7XG4gICAgICAgIHJldHVybiAxLi1zbW9vdGhzdGVwKF9yYWRpdXMtKF9yYWRpdXMqMC4wNSksX3JhZGl1cysoX3JhZGl1cyowLjA1KSxkb3QocG9zLHBvcykqMy4xNCk7XG4gICAgICB9XG4gICAgXG4gICAgICB2ZWMzIGRvdHMyZCggdmVjMiBfc3QsIGZsb2F0IHNjYWxlLCBmbG9hdCByYWRpdXMsIHZlYzMgY29sb3IgKSB7XG4gICAgICAgIHZlYzIgc3QgPSB0aWxlKF9zdCxzY2FsZSk7XG4gICAgICAgIHZlYzMgZmluID0gdmVjMyhjaXJjbGUoc3QsIHJhZGl1cykpICogY29sb3I7XG4gICAgICAgIHJldHVybiBmaW47XG4gICAgICB9XG4gICAgYCxcbiAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICB7IG5hbWU6J3NjYWxlJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjUgfSxcbiAgICAgIHsgbmFtZToncmFkaXVzJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0Oi4zIH0sXG4gICAgICB7IG5hbWU6J2NvbG9yJywgdHlwZTondmVjMycsIGRlZmF1bHQ6WzEsMSwxXSB9XG4gICAgXSxcbiAgfSxcbiAgc3RyaXBlczoge1xuICAgIG5hbWU6J3N0cmlwZXMnLFxuICAgIGdsc2w6YCAgICAgICAgICBcbiAgICAgICAgdmVjMyBzdHJpcGVzKCB2ZWMzIHBvcywgZmxvYXQgc2NhbGUsIHZlYzMgY29sb3IgKSB7XG4gICAgICAgICAgdmVjMyB0ZXg7XG4gICAgICAgICAgdGV4ID0gdmVjMyggY29sb3IgLSBzbW9vdGhzdGVwKDAuMywgMC4zMiwgbGVuZ3RoKGZyYWN0KChwb3MueCtwb3MueStwb3Mueikqc2NhbGUpIC0uNSApKSApO1xuICAgICAgICAgIHJldHVybiB0ZXg7XG4gICAgICAgIH1gICxcbiAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICB7IG5hbWU6J3NjYWxlJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjUgfSxcbiAgICAgIHsgbmFtZTonY29sb3InLCB0eXBlOid2ZWMzJywgZGVmYXVsdDpbMSwxLDFdIH1cbiAgICBdLFxuICB9LFxuICBjZWxsdWxhcjoge1xuICAgIG5hbWU6J2NlbGx1bGFyJyxcbiAgICBnbHNsOmdsc2woW1wiI2RlZmluZSBHTFNMSUZZIDFcXG5cXG4gICAgICAgIC8vIFBlcm11dGF0aW9uIHBvbHlub21pYWw6ICgzNHheMiArIHgpIG1vZCAyODlcXG52ZWMzIHBlcm11dGUodmVjMyB4KSB7XFxuICByZXR1cm4gbW9kKCgzNC4wICogeCArIDEuMCkgKiB4LCAyODkuMCk7XFxufVxcblxcbnZlYzMgZGlzdCh2ZWMzIHgsIHZlYzMgeSwgdmVjMyB6LCAgYm9vbCBtYW5oYXR0YW5EaXN0YW5jZSkge1xcbiAgcmV0dXJuIG1hbmhhdHRhbkRpc3RhbmNlID8gIGFicyh4KSArIGFicyh5KSArIGFicyh6KSA6ICAoeCAqIHggKyB5ICogeSArIHogKiB6KTtcXG59XFxuXFxudmVjMiB3b3JsZXkodmVjMyBQLCBmbG9hdCBqaXR0ZXIsIGJvb2wgbWFuaGF0dGFuRGlzdGFuY2UpIHtcXG5mbG9hdCBLID0gMC4xNDI4NTcxNDI4NTc7IC8vIDEvN1xcbmZsb2F0IEtvID0gMC40Mjg1NzE0Mjg1NzE7IC8vIDEvMi1LLzJcXG5mbG9hdCAgSzIgPSAwLjAyMDQwODE2MzI2NTMwNjsgLy8gMS8oNyo3KVxcbmZsb2F0IEt6ID0gMC4xNjY2NjY2NjY2Njc7IC8vIDEvNlxcbmZsb2F0IEt6byA9IDAuNDE2NjY2NjY2NjY3OyAvLyAxLzItMS82KjJcXG5cXG5cXHR2ZWMzIFBpID0gbW9kKGZsb29yKFApLCAyODkuMCk7XFxuIFxcdHZlYzMgUGYgPSBmcmFjdChQKSAtIDAuNTtcXG5cXG5cXHR2ZWMzIFBmeCA9IFBmLnggKyB2ZWMzKDEuMCwgMC4wLCAtMS4wKTtcXG5cXHR2ZWMzIFBmeSA9IFBmLnkgKyB2ZWMzKDEuMCwgMC4wLCAtMS4wKTtcXG5cXHR2ZWMzIFBmeiA9IFBmLnogKyB2ZWMzKDEuMCwgMC4wLCAtMS4wKTtcXG5cXG5cXHR2ZWMzIHAgPSBwZXJtdXRlKFBpLnggKyB2ZWMzKC0xLjAsIDAuMCwgMS4wKSk7XFxuXFx0dmVjMyBwMSA9IHBlcm11dGUocCArIFBpLnkgLSAxLjApO1xcblxcdHZlYzMgcDIgPSBwZXJtdXRlKHAgKyBQaS55KTtcXG5cXHR2ZWMzIHAzID0gcGVybXV0ZShwICsgUGkueSArIDEuMCk7XFxuXFxuXFx0dmVjMyBwMTEgPSBwZXJtdXRlKHAxICsgUGkueiAtIDEuMCk7XFxuXFx0dmVjMyBwMTIgPSBwZXJtdXRlKHAxICsgUGkueik7XFxuXFx0dmVjMyBwMTMgPSBwZXJtdXRlKHAxICsgUGkueiArIDEuMCk7XFxuXFxuXFx0dmVjMyBwMjEgPSBwZXJtdXRlKHAyICsgUGkueiAtIDEuMCk7XFxuXFx0dmVjMyBwMjIgPSBwZXJtdXRlKHAyICsgUGkueik7XFxuXFx0dmVjMyBwMjMgPSBwZXJtdXRlKHAyICsgUGkueiArIDEuMCk7XFxuXFxuXFx0dmVjMyBwMzEgPSBwZXJtdXRlKHAzICsgUGkueiAtIDEuMCk7XFxuXFx0dmVjMyBwMzIgPSBwZXJtdXRlKHAzICsgUGkueik7XFxuXFx0dmVjMyBwMzMgPSBwZXJtdXRlKHAzICsgUGkueiArIDEuMCk7XFxuXFxuXFx0dmVjMyBveDExID0gZnJhY3QocDExKkspIC0gS287XFxuXFx0dmVjMyBveTExID0gbW9kKGZsb29yKHAxMSpLKSwgNy4wKSpLIC0gS287XFxuXFx0dmVjMyBvejExID0gZmxvb3IocDExKksyKSpLeiAtIEt6bzsgLy8gcDExIDwgMjg5IGd1YXJhbnRlZWRcXG5cXG5cXHR2ZWMzIG94MTIgPSBmcmFjdChwMTIqSykgLSBLbztcXG5cXHR2ZWMzIG95MTIgPSBtb2QoZmxvb3IocDEyKkspLCA3LjApKksgLSBLbztcXG5cXHR2ZWMzIG96MTIgPSBmbG9vcihwMTIqSzIpKkt6IC0gS3pvO1xcblxcblxcdHZlYzMgb3gxMyA9IGZyYWN0KHAxMypLKSAtIEtvO1xcblxcdHZlYzMgb3kxMyA9IG1vZChmbG9vcihwMTMqSyksIDcuMCkqSyAtIEtvO1xcblxcdHZlYzMgb3oxMyA9IGZsb29yKHAxMypLMikqS3ogLSBLem87XFxuXFxuXFx0dmVjMyBveDIxID0gZnJhY3QocDIxKkspIC0gS287XFxuXFx0dmVjMyBveTIxID0gbW9kKGZsb29yKHAyMSpLKSwgNy4wKSpLIC0gS287XFxuXFx0dmVjMyBvejIxID0gZmxvb3IocDIxKksyKSpLeiAtIEt6bztcXG5cXG5cXHR2ZWMzIG94MjIgPSBmcmFjdChwMjIqSykgLSBLbztcXG5cXHR2ZWMzIG95MjIgPSBtb2QoZmxvb3IocDIyKkspLCA3LjApKksgLSBLbztcXG5cXHR2ZWMzIG96MjIgPSBmbG9vcihwMjIqSzIpKkt6IC0gS3pvO1xcblxcblxcdHZlYzMgb3gyMyA9IGZyYWN0KHAyMypLKSAtIEtvO1xcblxcdHZlYzMgb3kyMyA9IG1vZChmbG9vcihwMjMqSyksIDcuMCkqSyAtIEtvO1xcblxcdHZlYzMgb3oyMyA9IGZsb29yKHAyMypLMikqS3ogLSBLem87XFxuXFxuXFx0dmVjMyBveDMxID0gZnJhY3QocDMxKkspIC0gS287XFxuXFx0dmVjMyBveTMxID0gbW9kKGZsb29yKHAzMSpLKSwgNy4wKSpLIC0gS287XFxuXFx0dmVjMyBvejMxID0gZmxvb3IocDMxKksyKSpLeiAtIEt6bztcXG5cXG5cXHR2ZWMzIG94MzIgPSBmcmFjdChwMzIqSykgLSBLbztcXG5cXHR2ZWMzIG95MzIgPSBtb2QoZmxvb3IocDMyKkspLCA3LjApKksgLSBLbztcXG5cXHR2ZWMzIG96MzIgPSBmbG9vcihwMzIqSzIpKkt6IC0gS3pvO1xcblxcblxcdHZlYzMgb3gzMyA9IGZyYWN0KHAzMypLKSAtIEtvO1xcblxcdHZlYzMgb3kzMyA9IG1vZChmbG9vcihwMzMqSyksIDcuMCkqSyAtIEtvO1xcblxcdHZlYzMgb3ozMyA9IGZsb29yKHAzMypLMikqS3ogLSBLem87XFxuXFxuXFx0dmVjMyBkeDExID0gUGZ4ICsgaml0dGVyKm94MTE7XFxuXFx0dmVjMyBkeTExID0gUGZ5LnggKyBqaXR0ZXIqb3kxMTtcXG5cXHR2ZWMzIGR6MTEgPSBQZnoueCArIGppdHRlcipvejExO1xcblxcblxcdHZlYzMgZHgxMiA9IFBmeCArIGppdHRlcipveDEyO1xcblxcdHZlYzMgZHkxMiA9IFBmeS54ICsgaml0dGVyKm95MTI7XFxuXFx0dmVjMyBkejEyID0gUGZ6LnkgKyBqaXR0ZXIqb3oxMjtcXG5cXG5cXHR2ZWMzIGR4MTMgPSBQZnggKyBqaXR0ZXIqb3gxMztcXG5cXHR2ZWMzIGR5MTMgPSBQZnkueCArIGppdHRlcipveTEzO1xcblxcdHZlYzMgZHoxMyA9IFBmei56ICsgaml0dGVyKm96MTM7XFxuXFxuXFx0dmVjMyBkeDIxID0gUGZ4ICsgaml0dGVyKm94MjE7XFxuXFx0dmVjMyBkeTIxID0gUGZ5LnkgKyBqaXR0ZXIqb3kyMTtcXG5cXHR2ZWMzIGR6MjEgPSBQZnoueCArIGppdHRlcipvejIxO1xcblxcblxcdHZlYzMgZHgyMiA9IFBmeCArIGppdHRlcipveDIyO1xcblxcdHZlYzMgZHkyMiA9IFBmeS55ICsgaml0dGVyKm95MjI7XFxuXFx0dmVjMyBkejIyID0gUGZ6LnkgKyBqaXR0ZXIqb3oyMjtcXG5cXG5cXHR2ZWMzIGR4MjMgPSBQZnggKyBqaXR0ZXIqb3gyMztcXG5cXHR2ZWMzIGR5MjMgPSBQZnkueSArIGppdHRlcipveTIzO1xcblxcdHZlYzMgZHoyMyA9IFBmei56ICsgaml0dGVyKm96MjM7XFxuXFxuXFx0dmVjMyBkeDMxID0gUGZ4ICsgaml0dGVyKm94MzE7XFxuXFx0dmVjMyBkeTMxID0gUGZ5LnogKyBqaXR0ZXIqb3kzMTtcXG5cXHR2ZWMzIGR6MzEgPSBQZnoueCArIGppdHRlcipvejMxO1xcblxcblxcdHZlYzMgZHgzMiA9IFBmeCArIGppdHRlcipveDMyO1xcblxcdHZlYzMgZHkzMiA9IFBmeS56ICsgaml0dGVyKm95MzI7XFxuXFx0dmVjMyBkejMyID0gUGZ6LnkgKyBqaXR0ZXIqb3ozMjtcXG5cXG5cXHR2ZWMzIGR4MzMgPSBQZnggKyBqaXR0ZXIqb3gzMztcXG5cXHR2ZWMzIGR5MzMgPSBQZnkueiArIGppdHRlcipveTMzO1xcblxcdHZlYzMgZHozMyA9IFBmei56ICsgaml0dGVyKm96MzM7XFxuXFxuXFx0dmVjMyBkMTEgPSBkaXN0KGR4MTEsIGR5MTEsIGR6MTEsIG1hbmhhdHRhbkRpc3RhbmNlKTtcXG5cXHR2ZWMzIGQxMiA9ZGlzdChkeDEyLCBkeTEyLCBkejEyLCBtYW5oYXR0YW5EaXN0YW5jZSk7XFxuXFx0dmVjMyBkMTMgPSBkaXN0KGR4MTMsIGR5MTMsIGR6MTMsIG1hbmhhdHRhbkRpc3RhbmNlKTtcXG5cXHR2ZWMzIGQyMSA9IGRpc3QoZHgyMSwgZHkyMSwgZHoyMSwgbWFuaGF0dGFuRGlzdGFuY2UpO1xcblxcdHZlYzMgZDIyID0gZGlzdChkeDIyLCBkeTIyLCBkejIyLCBtYW5oYXR0YW5EaXN0YW5jZSk7XFxuXFx0dmVjMyBkMjMgPSBkaXN0KGR4MjMsIGR5MjMsIGR6MjMsIG1hbmhhdHRhbkRpc3RhbmNlKTtcXG5cXHR2ZWMzIGQzMSA9IGRpc3QoZHgzMSwgZHkzMSwgZHozMSwgbWFuaGF0dGFuRGlzdGFuY2UpO1xcblxcdHZlYzMgZDMyID0gZGlzdChkeDMyLCBkeTMyLCBkejMyLCBtYW5oYXR0YW5EaXN0YW5jZSk7XFxuXFx0dmVjMyBkMzMgPSBkaXN0KGR4MzMsIGR5MzMsIGR6MzMsIG1hbmhhdHRhbkRpc3RhbmNlKTtcXG5cXG5cXHR2ZWMzIGQxYSA9IG1pbihkMTEsIGQxMik7XFxuXFx0ZDEyID0gbWF4KGQxMSwgZDEyKTtcXG5cXHRkMTEgPSBtaW4oZDFhLCBkMTMpOyAvLyBTbWFsbGVzdCBub3cgbm90IGluIGQxMiBvciBkMTNcXG5cXHRkMTMgPSBtYXgoZDFhLCBkMTMpO1xcblxcdGQxMiA9IG1pbihkMTIsIGQxMyk7IC8vIDJuZCBzbWFsbGVzdCBub3cgbm90IGluIGQxM1xcblxcdHZlYzMgZDJhID0gbWluKGQyMSwgZDIyKTtcXG5cXHRkMjIgPSBtYXgoZDIxLCBkMjIpO1xcblxcdGQyMSA9IG1pbihkMmEsIGQyMyk7IC8vIFNtYWxsZXN0IG5vdyBub3QgaW4gZDIyIG9yIGQyM1xcblxcdGQyMyA9IG1heChkMmEsIGQyMyk7XFxuXFx0ZDIyID0gbWluKGQyMiwgZDIzKTsgLy8gMm5kIHNtYWxsZXN0IG5vdyBub3QgaW4gZDIzXFxuXFx0dmVjMyBkM2EgPSBtaW4oZDMxLCBkMzIpO1xcblxcdGQzMiA9IG1heChkMzEsIGQzMik7XFxuXFx0ZDMxID0gbWluKGQzYSwgZDMzKTsgLy8gU21hbGxlc3Qgbm93IG5vdCBpbiBkMzIgb3IgZDMzXFxuXFx0ZDMzID0gbWF4KGQzYSwgZDMzKTtcXG5cXHRkMzIgPSBtaW4oZDMyLCBkMzMpOyAvLyAybmQgc21hbGxlc3Qgbm93IG5vdCBpbiBkMzNcXG5cXHR2ZWMzIGRhID0gbWluKGQxMSwgZDIxKTtcXG5cXHRkMjEgPSBtYXgoZDExLCBkMjEpO1xcblxcdGQxMSA9IG1pbihkYSwgZDMxKTsgLy8gU21hbGxlc3Qgbm93IGluIGQxMVxcblxcdGQzMSA9IG1heChkYSwgZDMxKTsgLy8gMm5kIHNtYWxsZXN0IG5vdyBub3QgaW4gZDMxXFxuXFx0ZDExLnh5ID0gKGQxMS54IDwgZDExLnkpID8gZDExLnh5IDogZDExLnl4O1xcblxcdGQxMS54eiA9IChkMTEueCA8IGQxMS56KSA/IGQxMS54eiA6IGQxMS56eDsgLy8gZDExLnggbm93IHNtYWxsZXN0XFxuXFx0ZDEyID0gbWluKGQxMiwgZDIxKTsgLy8gMm5kIHNtYWxsZXN0IG5vdyBub3QgaW4gZDIxXFxuXFx0ZDEyID0gbWluKGQxMiwgZDIyKTsgLy8gbm9yIGluIGQyMlxcblxcdGQxMiA9IG1pbihkMTIsIGQzMSk7IC8vIG5vciBpbiBkMzFcXG5cXHRkMTIgPSBtaW4oZDEyLCBkMzIpOyAvLyBub3IgaW4gZDMyXFxuXFx0ZDExLnl6ID0gbWluKGQxMS55eixkMTIueHkpOyAvLyBub3IgaW4gZDEyLnl6XFxuXFx0ZDExLnkgPSBtaW4oZDExLnksZDEyLnopOyAvLyBPbmx5IHR3byBtb3JlIHRvIGdvXFxuXFx0ZDExLnkgPSBtaW4oZDExLnksZDExLnopOyAvLyBEb25lISAoUGhldyEpXFxuXFx0cmV0dXJuIHNxcnQoZDExLnh5KTsgLy8gRjEsIEYyXFxuXFxufVxcblxcbiAgICAgICAgdmVjMyBjZWxsdWxhciggdmVjMyBwb3MsIGZsb2F0IHNjYWxlLCBmbG9hdCBqaXR0ZXIsIGZsb2F0IG1vZGUsIGZsb2F0IHN0cmVuZ3RoLCBmbG9hdCB0aW1lICkge1xcbiAgICAgICAgICB2ZWMyIHcgPSB3b3JsZXkoIHBvcyAqIHNjYWxlICsgdGltZSwgaml0dGVyLCBmYWxzZSApO1xcbiAgICAgICAgICB2ZWMzIG87XFxuICAgICAgICAgIGlmKCBtb2RlID09IDAuICkge1xcbiAgICAgICAgICAgIG8gPSB2ZWMzKCB3LnggKTtcXG4gICAgICAgICAgfSBlbHNlIGlmICggbW9kZSA9PSAxLiApIHtcXG4gICAgICAgICAgICBvID0gdmVjMyggdy55ICk7XFxuICAgICAgICAgIH0gZWxzZXtcXG4gICAgICAgICAgICBvID0gdmVjMyggdy55IC0gdy54ICk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcmV0dXJuIG8gKiBzdHJlbmd0aDtcXG4gICAgICAgIH1cXG4gICAgXCIsXCJcIl0pLFxuICAgIGdsc2wyZDpnbHNsKFtcIiNkZWZpbmUgR0xTTElGWSAxXFxuXFxuICAgICAgICAvLyBQZXJtdXRhdGlvbiBwb2x5bm9taWFsOiAoMzR4XjIgKyB4KSBtb2QgMjg5XFxudmVjMyBwZXJtdXRlKHZlYzMgeCkge1xcbiAgcmV0dXJuIG1vZCgoMzQuMCAqIHggKyAxLjApICogeCwgMjg5LjApO1xcbn1cXG5cXG52ZWMzIGRpc3QodmVjMyB4LCB2ZWMzIHksIHZlYzMgeiwgIGJvb2wgbWFuaGF0dGFuRGlzdGFuY2UpIHtcXG4gIHJldHVybiBtYW5oYXR0YW5EaXN0YW5jZSA/ICBhYnMoeCkgKyBhYnMoeSkgKyBhYnMoeikgOiAgKHggKiB4ICsgeSAqIHkgKyB6ICogeik7XFxufVxcblxcbnZlYzIgd29ybGV5KHZlYzMgUCwgZmxvYXQgaml0dGVyLCBib29sIG1hbmhhdHRhbkRpc3RhbmNlKSB7XFxuZmxvYXQgSyA9IDAuMTQyODU3MTQyODU3OyAvLyAxLzdcXG5mbG9hdCBLbyA9IDAuNDI4NTcxNDI4NTcxOyAvLyAxLzItSy8yXFxuZmxvYXQgIEsyID0gMC4wMjA0MDgxNjMyNjUzMDY7IC8vIDEvKDcqNylcXG5mbG9hdCBLeiA9IDAuMTY2NjY2NjY2NjY3OyAvLyAxLzZcXG5mbG9hdCBLem8gPSAwLjQxNjY2NjY2NjY2NzsgLy8gMS8yLTEvNioyXFxuXFxuXFx0dmVjMyBQaSA9IG1vZChmbG9vcihQKSwgMjg5LjApO1xcbiBcXHR2ZWMzIFBmID0gZnJhY3QoUCkgLSAwLjU7XFxuXFxuXFx0dmVjMyBQZnggPSBQZi54ICsgdmVjMygxLjAsIDAuMCwgLTEuMCk7XFxuXFx0dmVjMyBQZnkgPSBQZi55ICsgdmVjMygxLjAsIDAuMCwgLTEuMCk7XFxuXFx0dmVjMyBQZnogPSBQZi56ICsgdmVjMygxLjAsIDAuMCwgLTEuMCk7XFxuXFxuXFx0dmVjMyBwID0gcGVybXV0ZShQaS54ICsgdmVjMygtMS4wLCAwLjAsIDEuMCkpO1xcblxcdHZlYzMgcDEgPSBwZXJtdXRlKHAgKyBQaS55IC0gMS4wKTtcXG5cXHR2ZWMzIHAyID0gcGVybXV0ZShwICsgUGkueSk7XFxuXFx0dmVjMyBwMyA9IHBlcm11dGUocCArIFBpLnkgKyAxLjApO1xcblxcblxcdHZlYzMgcDExID0gcGVybXV0ZShwMSArIFBpLnogLSAxLjApO1xcblxcdHZlYzMgcDEyID0gcGVybXV0ZShwMSArIFBpLnopO1xcblxcdHZlYzMgcDEzID0gcGVybXV0ZShwMSArIFBpLnogKyAxLjApO1xcblxcblxcdHZlYzMgcDIxID0gcGVybXV0ZShwMiArIFBpLnogLSAxLjApO1xcblxcdHZlYzMgcDIyID0gcGVybXV0ZShwMiArIFBpLnopO1xcblxcdHZlYzMgcDIzID0gcGVybXV0ZShwMiArIFBpLnogKyAxLjApO1xcblxcblxcdHZlYzMgcDMxID0gcGVybXV0ZShwMyArIFBpLnogLSAxLjApO1xcblxcdHZlYzMgcDMyID0gcGVybXV0ZShwMyArIFBpLnopO1xcblxcdHZlYzMgcDMzID0gcGVybXV0ZShwMyArIFBpLnogKyAxLjApO1xcblxcblxcdHZlYzMgb3gxMSA9IGZyYWN0KHAxMSpLKSAtIEtvO1xcblxcdHZlYzMgb3kxMSA9IG1vZChmbG9vcihwMTEqSyksIDcuMCkqSyAtIEtvO1xcblxcdHZlYzMgb3oxMSA9IGZsb29yKHAxMSpLMikqS3ogLSBLem87IC8vIHAxMSA8IDI4OSBndWFyYW50ZWVkXFxuXFxuXFx0dmVjMyBveDEyID0gZnJhY3QocDEyKkspIC0gS287XFxuXFx0dmVjMyBveTEyID0gbW9kKGZsb29yKHAxMipLKSwgNy4wKSpLIC0gS287XFxuXFx0dmVjMyBvejEyID0gZmxvb3IocDEyKksyKSpLeiAtIEt6bztcXG5cXG5cXHR2ZWMzIG94MTMgPSBmcmFjdChwMTMqSykgLSBLbztcXG5cXHR2ZWMzIG95MTMgPSBtb2QoZmxvb3IocDEzKkspLCA3LjApKksgLSBLbztcXG5cXHR2ZWMzIG96MTMgPSBmbG9vcihwMTMqSzIpKkt6IC0gS3pvO1xcblxcblxcdHZlYzMgb3gyMSA9IGZyYWN0KHAyMSpLKSAtIEtvO1xcblxcdHZlYzMgb3kyMSA9IG1vZChmbG9vcihwMjEqSyksIDcuMCkqSyAtIEtvO1xcblxcdHZlYzMgb3oyMSA9IGZsb29yKHAyMSpLMikqS3ogLSBLem87XFxuXFxuXFx0dmVjMyBveDIyID0gZnJhY3QocDIyKkspIC0gS287XFxuXFx0dmVjMyBveTIyID0gbW9kKGZsb29yKHAyMipLKSwgNy4wKSpLIC0gS287XFxuXFx0dmVjMyBvejIyID0gZmxvb3IocDIyKksyKSpLeiAtIEt6bztcXG5cXG5cXHR2ZWMzIG94MjMgPSBmcmFjdChwMjMqSykgLSBLbztcXG5cXHR2ZWMzIG95MjMgPSBtb2QoZmxvb3IocDIzKkspLCA3LjApKksgLSBLbztcXG5cXHR2ZWMzIG96MjMgPSBmbG9vcihwMjMqSzIpKkt6IC0gS3pvO1xcblxcblxcdHZlYzMgb3gzMSA9IGZyYWN0KHAzMSpLKSAtIEtvO1xcblxcdHZlYzMgb3kzMSA9IG1vZChmbG9vcihwMzEqSyksIDcuMCkqSyAtIEtvO1xcblxcdHZlYzMgb3ozMSA9IGZsb29yKHAzMSpLMikqS3ogLSBLem87XFxuXFxuXFx0dmVjMyBveDMyID0gZnJhY3QocDMyKkspIC0gS287XFxuXFx0dmVjMyBveTMyID0gbW9kKGZsb29yKHAzMipLKSwgNy4wKSpLIC0gS287XFxuXFx0dmVjMyBvejMyID0gZmxvb3IocDMyKksyKSpLeiAtIEt6bztcXG5cXG5cXHR2ZWMzIG94MzMgPSBmcmFjdChwMzMqSykgLSBLbztcXG5cXHR2ZWMzIG95MzMgPSBtb2QoZmxvb3IocDMzKkspLCA3LjApKksgLSBLbztcXG5cXHR2ZWMzIG96MzMgPSBmbG9vcihwMzMqSzIpKkt6IC0gS3pvO1xcblxcblxcdHZlYzMgZHgxMSA9IFBmeCArIGppdHRlcipveDExO1xcblxcdHZlYzMgZHkxMSA9IFBmeS54ICsgaml0dGVyKm95MTE7XFxuXFx0dmVjMyBkejExID0gUGZ6LnggKyBqaXR0ZXIqb3oxMTtcXG5cXG5cXHR2ZWMzIGR4MTIgPSBQZnggKyBqaXR0ZXIqb3gxMjtcXG5cXHR2ZWMzIGR5MTIgPSBQZnkueCArIGppdHRlcipveTEyO1xcblxcdHZlYzMgZHoxMiA9IFBmei55ICsgaml0dGVyKm96MTI7XFxuXFxuXFx0dmVjMyBkeDEzID0gUGZ4ICsgaml0dGVyKm94MTM7XFxuXFx0dmVjMyBkeTEzID0gUGZ5LnggKyBqaXR0ZXIqb3kxMztcXG5cXHR2ZWMzIGR6MTMgPSBQZnoueiArIGppdHRlcipvejEzO1xcblxcblxcdHZlYzMgZHgyMSA9IFBmeCArIGppdHRlcipveDIxO1xcblxcdHZlYzMgZHkyMSA9IFBmeS55ICsgaml0dGVyKm95MjE7XFxuXFx0dmVjMyBkejIxID0gUGZ6LnggKyBqaXR0ZXIqb3oyMTtcXG5cXG5cXHR2ZWMzIGR4MjIgPSBQZnggKyBqaXR0ZXIqb3gyMjtcXG5cXHR2ZWMzIGR5MjIgPSBQZnkueSArIGppdHRlcipveTIyO1xcblxcdHZlYzMgZHoyMiA9IFBmei55ICsgaml0dGVyKm96MjI7XFxuXFxuXFx0dmVjMyBkeDIzID0gUGZ4ICsgaml0dGVyKm94MjM7XFxuXFx0dmVjMyBkeTIzID0gUGZ5LnkgKyBqaXR0ZXIqb3kyMztcXG5cXHR2ZWMzIGR6MjMgPSBQZnoueiArIGppdHRlcipvejIzO1xcblxcblxcdHZlYzMgZHgzMSA9IFBmeCArIGppdHRlcipveDMxO1xcblxcdHZlYzMgZHkzMSA9IFBmeS56ICsgaml0dGVyKm95MzE7XFxuXFx0dmVjMyBkejMxID0gUGZ6LnggKyBqaXR0ZXIqb3ozMTtcXG5cXG5cXHR2ZWMzIGR4MzIgPSBQZnggKyBqaXR0ZXIqb3gzMjtcXG5cXHR2ZWMzIGR5MzIgPSBQZnkueiArIGppdHRlcipveTMyO1xcblxcdHZlYzMgZHozMiA9IFBmei55ICsgaml0dGVyKm96MzI7XFxuXFxuXFx0dmVjMyBkeDMzID0gUGZ4ICsgaml0dGVyKm94MzM7XFxuXFx0dmVjMyBkeTMzID0gUGZ5LnogKyBqaXR0ZXIqb3kzMztcXG5cXHR2ZWMzIGR6MzMgPSBQZnoueiArIGppdHRlcipvejMzO1xcblxcblxcdHZlYzMgZDExID0gZGlzdChkeDExLCBkeTExLCBkejExLCBtYW5oYXR0YW5EaXN0YW5jZSk7XFxuXFx0dmVjMyBkMTIgPWRpc3QoZHgxMiwgZHkxMiwgZHoxMiwgbWFuaGF0dGFuRGlzdGFuY2UpO1xcblxcdHZlYzMgZDEzID0gZGlzdChkeDEzLCBkeTEzLCBkejEzLCBtYW5oYXR0YW5EaXN0YW5jZSk7XFxuXFx0dmVjMyBkMjEgPSBkaXN0KGR4MjEsIGR5MjEsIGR6MjEsIG1hbmhhdHRhbkRpc3RhbmNlKTtcXG5cXHR2ZWMzIGQyMiA9IGRpc3QoZHgyMiwgZHkyMiwgZHoyMiwgbWFuaGF0dGFuRGlzdGFuY2UpO1xcblxcdHZlYzMgZDIzID0gZGlzdChkeDIzLCBkeTIzLCBkejIzLCBtYW5oYXR0YW5EaXN0YW5jZSk7XFxuXFx0dmVjMyBkMzEgPSBkaXN0KGR4MzEsIGR5MzEsIGR6MzEsIG1hbmhhdHRhbkRpc3RhbmNlKTtcXG5cXHR2ZWMzIGQzMiA9IGRpc3QoZHgzMiwgZHkzMiwgZHozMiwgbWFuaGF0dGFuRGlzdGFuY2UpO1xcblxcdHZlYzMgZDMzID0gZGlzdChkeDMzLCBkeTMzLCBkejMzLCBtYW5oYXR0YW5EaXN0YW5jZSk7XFxuXFxuXFx0dmVjMyBkMWEgPSBtaW4oZDExLCBkMTIpO1xcblxcdGQxMiA9IG1heChkMTEsIGQxMik7XFxuXFx0ZDExID0gbWluKGQxYSwgZDEzKTsgLy8gU21hbGxlc3Qgbm93IG5vdCBpbiBkMTIgb3IgZDEzXFxuXFx0ZDEzID0gbWF4KGQxYSwgZDEzKTtcXG5cXHRkMTIgPSBtaW4oZDEyLCBkMTMpOyAvLyAybmQgc21hbGxlc3Qgbm93IG5vdCBpbiBkMTNcXG5cXHR2ZWMzIGQyYSA9IG1pbihkMjEsIGQyMik7XFxuXFx0ZDIyID0gbWF4KGQyMSwgZDIyKTtcXG5cXHRkMjEgPSBtaW4oZDJhLCBkMjMpOyAvLyBTbWFsbGVzdCBub3cgbm90IGluIGQyMiBvciBkMjNcXG5cXHRkMjMgPSBtYXgoZDJhLCBkMjMpO1xcblxcdGQyMiA9IG1pbihkMjIsIGQyMyk7IC8vIDJuZCBzbWFsbGVzdCBub3cgbm90IGluIGQyM1xcblxcdHZlYzMgZDNhID0gbWluKGQzMSwgZDMyKTtcXG5cXHRkMzIgPSBtYXgoZDMxLCBkMzIpO1xcblxcdGQzMSA9IG1pbihkM2EsIGQzMyk7IC8vIFNtYWxsZXN0IG5vdyBub3QgaW4gZDMyIG9yIGQzM1xcblxcdGQzMyA9IG1heChkM2EsIGQzMyk7XFxuXFx0ZDMyID0gbWluKGQzMiwgZDMzKTsgLy8gMm5kIHNtYWxsZXN0IG5vdyBub3QgaW4gZDMzXFxuXFx0dmVjMyBkYSA9IG1pbihkMTEsIGQyMSk7XFxuXFx0ZDIxID0gbWF4KGQxMSwgZDIxKTtcXG5cXHRkMTEgPSBtaW4oZGEsIGQzMSk7IC8vIFNtYWxsZXN0IG5vdyBpbiBkMTFcXG5cXHRkMzEgPSBtYXgoZGEsIGQzMSk7IC8vIDJuZCBzbWFsbGVzdCBub3cgbm90IGluIGQzMVxcblxcdGQxMS54eSA9IChkMTEueCA8IGQxMS55KSA/IGQxMS54eSA6IGQxMS55eDtcXG5cXHRkMTEueHogPSAoZDExLnggPCBkMTEueikgPyBkMTEueHogOiBkMTEueng7IC8vIGQxMS54IG5vdyBzbWFsbGVzdFxcblxcdGQxMiA9IG1pbihkMTIsIGQyMSk7IC8vIDJuZCBzbWFsbGVzdCBub3cgbm90IGluIGQyMVxcblxcdGQxMiA9IG1pbihkMTIsIGQyMik7IC8vIG5vciBpbiBkMjJcXG5cXHRkMTIgPSBtaW4oZDEyLCBkMzEpOyAvLyBub3IgaW4gZDMxXFxuXFx0ZDEyID0gbWluKGQxMiwgZDMyKTsgLy8gbm9yIGluIGQzMlxcblxcdGQxMS55eiA9IG1pbihkMTEueXosZDEyLnh5KTsgLy8gbm9yIGluIGQxMi55elxcblxcdGQxMS55ID0gbWluKGQxMS55LGQxMi56KTsgLy8gT25seSB0d28gbW9yZSB0byBnb1xcblxcdGQxMS55ID0gbWluKGQxMS55LGQxMS56KTsgLy8gRG9uZSEgKFBoZXchKVxcblxcdHJldHVybiBzcXJ0KGQxMS54eSk7IC8vIEYxLCBGMlxcblxcbn1cXG5cXG4gICAgICAgIHZlYzMgY2VsbHVsYXIoIHZlYzMgcG9zLCBmbG9hdCBzY2FsZSwgZmxvYXQgaml0dGVyLCBmbG9hdCBtb2RlLCBmbG9hdCBzdHJlbmd0aCApIHtcXG4gICAgICAgICAgdmVjMiB3ID0gd29ybGV5KCBwb3MsIGppdHRlciwgZmFsc2UgKTtcXG4gICAgICAgICAgdmVjMyBvO1xcbiAgICAgICAgICBpZiggbW9kZSA9PSAwLiApIHtcXG4gICAgICAgICAgICBvID0gdmVjMyggdy54ICk7XFxuICAgICAgICAgIH0gZWxzZSBpZiAoIG1vZGUgPT0gMS4gKSB7XFxuICAgICAgICAgICAgbyA9IHZlYzMoIHcueSApO1xcbiAgICAgICAgICB9IGVsc2V7XFxuICAgICAgICAgICAgbyA9IHZlYzMoIHcueSAtIHcueCApO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHJldHVybiBvICogc3RyZW5ndGg7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB2ZWMzIGNlbGx1bGFyMmQoIHZlYzIgc3QsIGZsb2F0IHNjYWxlLCBmbG9hdCBqaXR0ZXIsIGZsb2F0IG1vZGUsIGZsb2F0IHN0cmVuZ3RoLCBmbG9hdCB0aW1lICkge1xcbiAgICAgICAgICByZXR1cm4gY2VsbHVsYXIoIHZlYzMoc3QgKiBzY2FsZSwgdGltZSksIG5vciwgc2NhbGUsIGppdHRlciwgbW9kZSwgc3RyZW5ndGggKTtcXG4gICAgICAgIH1cXG4gICAgXCIsXCJcIl0pLFxuICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgIHsgbmFtZTonc2NhbGUnLCB0eXBlOidmbG9hdCcsIGRlZmF1bHQ6MSB9LFxuICAgICAgeyBuYW1lOidqaXR0ZXInLCB0eXBlOidmbG9hdCcsIGRlZmF1bHQ6MSB9LFxuICAgICAgeyBuYW1lOid0eXBlJywgIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDogMCB9LFxuICAgICAgeyBuYW1lOidzdHJlbmd0aCcsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDoyIH0sXG4gICAgICB7IG5hbWU6J3RpbWUnLCB0eXBlOidmbG9hdCcsIGRlZmF1bHQ6MSB9XG4gICAgXSwgICAgIFxuICB9LFxuXG4gIHZvcm9ub2k6IHtcbiAgICBuYW1lOid2b3Jvbm9pJyxcbiAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICB7IG5hbWU6J3NjYWxlJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjEgfSxcbiAgICAgIHsgbmFtZToncmVzJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjEwMCB9LFxuICAgICAgeyBuYW1lOid0aW1lJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjEgfSxcbiAgICAgIHsgbmFtZTonbW9kZScsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDowIH1cbiAgICBdLFxuICAgIGdsc2w6YFxuICAgIHZlYzMgdm9yb25vaV9oYXNoKHZlYzMgcCkge1xuICAgICAgcmV0dXJuIGZyYWN0KFxuICAgICAgICAgIHNpbih2ZWMzKGRvdChwLCB2ZWMzKDEuMCwgNTcuMCwgMTEzLjApKSwgZG90KHAsIHZlYzMoNTcuMCwgMTEzLjAsIDEuMCkpLFxuICAgICAgICAgICAgICAgICAgIGRvdChwLCB2ZWMzKDExMy4wLCAxLjAsIDU3LjApKSkpICpcbiAgICAgICAgICA0Mzc1OC41NDUzKTtcbiAgICB9XG5cbiAgICB2ZWMzIHZvcm9ub2lfM2QoY29uc3QgaW4gdmVjMyB4LCBmbG9hdCBfcmVzICkge1xuICAgICAgdmVjMyBwID0gZmxvb3IoeCk7XG4gICAgICB2ZWMzIGYgPSBmcmFjdCh4KTtcblxuICAgICAgZmxvYXQgaWQgPSAwLjA7XG4gICAgICB2ZWMyIHJlcyA9IHZlYzIoIF9yZXMgKTtcbiAgICAgIGZvciAoaW50IGsgPSAtMTsgayA8PSAxOyBrKyspIHtcbiAgICAgICAgZm9yIChpbnQgaiA9IC0xOyBqIDw9IDE7IGorKykge1xuICAgICAgICAgIGZvciAoaW50IGkgPSAtMTsgaSA8PSAxOyBpKyspIHtcbiAgICAgICAgICAgIHZlYzMgYiA9IHZlYzMoZmxvYXQoaSksIGZsb2F0KGopLCBmbG9hdChrKSk7XG4gICAgICAgICAgICB2ZWMzIHIgPSB2ZWMzKGIpIC0gZiArIHZvcm9ub2lfaGFzaChwICsgYik7XG4gICAgICAgICAgICBmbG9hdCBkID0gZG90KHIsIHIpO1xuXG4gICAgICAgICAgICBmbG9hdCBjb25kID0gbWF4KHNpZ24ocmVzLnggLSBkKSwgMC4wKTtcbiAgICAgICAgICAgIGZsb2F0IG5Db25kID0gMS4wIC0gY29uZDtcblxuICAgICAgICAgICAgZmxvYXQgY29uZDIgPSBuQ29uZCAqIG1heChzaWduKHJlcy55IC0gZCksIDAuMCk7XG4gICAgICAgICAgICBmbG9hdCBuQ29uZDIgPSAxLjAgLSBjb25kMjtcblxuICAgICAgICAgICAgaWQgPSAoZG90KHAgKyBiLCB2ZWMzKDEuMCwgNTcuMCwgMTEzLjApKSAqIGNvbmQpICsgKGlkICogbkNvbmQpO1xuICAgICAgICAgICAgcmVzID0gdmVjMihkLCByZXMueCkgKiBjb25kICsgcmVzICogbkNvbmQ7XG5cbiAgICAgICAgICAgIHJlcy55ID0gY29uZDIgKiBkICsgbkNvbmQyICogcmVzLnk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB2ZWMzKHNxcnQocmVzKSwgYWJzKGlkKSk7XG4gICAgfVxuXG4gICAgdmVjMyB2b3Jvbm9pKCB2ZWMzIHBvcywgZmxvYXQgc2NhbGUsIGZsb2F0IHJlcywgZmxvYXQgdGltZSwgZmxvYXQgbW9kZSApIHtcbiAgICAgIHZlYzMgdiA9IHZvcm9ub2lfM2QoIHBvcyAqIHNjYWxlLCByZXMgKTtcbiAgICAgIHZlYzMgZmluO1xuICAgICAgaWYoIG1vZGUgPT0gMC4gKSBmaW4gPSB2ZWMzKHYueCk7XG4gICAgICBpZiggbW9kZSA9PSAxLiApIGZpbiA9IHZlYzModi55KTtcbiAgICAgIGlmKCBtb2RlID09IDIuICkgZmluID0gdmVjMyh2LnkgLSB2LngpOyBcblxuICAgICAgcmV0dXJuIGZpbjtcbiAgICB9XG5gLFxuICAgIGdsc2wyZDpnbHNsKFtcIiNkZWZpbmUgR0xTTElGWSAxXFxuICAgIFxcbiAgICB2ZWMzIHZvcm9ub2lfaGFzaCh2ZWMzIHApIHtcXG4gICAgICByZXR1cm4gZnJhY3QoXFxuICAgICAgICAgIHNpbih2ZWMzKGRvdChwLCB2ZWMzKDEuMCwgNTcuMCwgMTEzLjApKSwgZG90KHAsIHZlYzMoNTcuMCwgMTEzLjAsIDEuMCkpLFxcbiAgICAgICAgICAgICAgICAgICBkb3QocCwgdmVjMygxMTMuMCwgMS4wLCA1Ny4wKSkpKSAqIDQzNzU4LjU0NTMpO1xcbiAgICB9XFxuXFxuICAgIHZlYzMgdm9yb25vaV8zZChjb25zdCBpbiB2ZWMzIHgsIGZsb2F0IF9yZXMgKSB7XFxuICAgICAgdmVjMyBwID0gZmxvb3IoeCk7XFxuICAgICAgdmVjMyBmID0gZnJhY3QoeCk7XFxuXFxuICAgICAgZmxvYXQgaWQgPSAwLjA7XFxuICAgICAgdmVjMiByZXMgPSB2ZWMyKCBfcmVzICk7XFxuICAgICAgZm9yIChpbnQgayA9IC0xOyBrIDw9IDE7IGsrKykge1xcbiAgICAgICAgZm9yIChpbnQgaiA9IC0xOyBqIDw9IDE7IGorKykge1xcbiAgICAgICAgICBmb3IgKGludCBpID0gLTE7IGkgPD0gMTsgaSsrKSB7XFxuICAgICAgICAgICAgdmVjMyBiID0gdmVjMyhmbG9hdChpKSwgZmxvYXQoaiksIGZsb2F0KGspKTtcXG4gICAgICAgICAgICB2ZWMzIHIgPSB2ZWMzKGIpIC0gZiArIHZvcm9ub2lfaGFzaChwICsgYik7XFxuICAgICAgICAgICAgZmxvYXQgZCA9IGRvdChyLCByKTtcXG5cXG4gICAgICAgICAgICBmbG9hdCBjb25kID0gbWF4KHNpZ24ocmVzLnggLSBkKSwgMC4wKTtcXG4gICAgICAgICAgICBmbG9hdCBuQ29uZCA9IDEuMCAtIGNvbmQ7XFxuXFxuICAgICAgICAgICAgZmxvYXQgY29uZDIgPSBuQ29uZCAqIG1heChzaWduKHJlcy55IC0gZCksIDAuMCk7XFxuICAgICAgICAgICAgZmxvYXQgbkNvbmQyID0gMS4wIC0gY29uZDI7XFxuXFxuICAgICAgICAgICAgaWQgPSAoZG90KHAgKyBiLCB2ZWMzKDEuMCwgNTcuMCwgMTEzLjApKSAqIGNvbmQpICsgKGlkICogbkNvbmQpO1xcbiAgICAgICAgICAgIHJlcyA9IHZlYzIoZCwgcmVzLngpICogY29uZCArIHJlcyAqIG5Db25kO1xcblxcbiAgICAgICAgICAgIHJlcy55ID0gY29uZDIgKiBkICsgbkNvbmQyICogcmVzLnk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIHZlYzMoc3FydChyZXMpLCBhYnMoaWQpKTtcXG4gICAgfVxcblxcbiAgICB2ZWMzIHZvcm9ub2kyZCggdmVjMiBzdCwgZmxvYXQgc2NhbGUsIGZsb2F0IHJlcywgZmxvYXQgdGltZSwgZmxvYXQgbW9kZSApIHtcXG4gICAgICB2ZWMzIHYgPSB2b3Jvbm9pXzNkKCB2ZWMzKHN0KiBzY2FsZSwgdGltZSksIHJlcyApO1xcbiAgICAgIHZlYzMgZmluO1xcbiAgICAgIGlmKCBtb2RlID09IDAuICkgZmluID0gdmVjMyh2LngpO1xcbiAgICAgIGlmKCBtb2RlID09IDEuICkgZmluID0gdmVjMyh2LnkpO1xcbiAgICAgIGlmKCBtb2RlID09IDIuICkgZmluID0gdmVjMyh2LnkgLSB2LngpOyBcXG5cXG4gICAgICByZXR1cm4gZmluO1xcbiAgICB9XFxuXFxuXCIsXCJcIl0pICxcbiAgfSxcbiAgLy8gYWRhcHRlZCBmcm9tIGh0dHBzOi8vdGhlYm9va29mc2hhZGVycy5jb20vZWRpdC5waHAjMDkvemlnemFnLmZyYWdcbiAgemlnemFnOiB7XG4gICAgbmFtZTonemlnemFnJyxcbiAgICBnbHNsMmQ6YCAgICBcbiAgICAgICB2ZWMyIG1pcnJvclRpbGUodmVjMiBfc3QsIGZsb2F0IF96b29tKXtcbiAgICAgICAgIF9zdCAqPSBfem9vbTtcbiAgICAgICAgIGlmIChmcmFjdChfc3QueSAqIDAuNSkgPiAwLjUpe1xuICAgICAgICAgICBfc3QueCA9IF9zdC54KzAuNTtcbiAgICAgICAgICAgX3N0LnkgPSAxLjAtX3N0Lnk7XG4gICAgICAgICB9XG4gICAgICAgICByZXR1cm4gZnJhY3QoX3N0KTtcbiAgICAgICB9XG5cbiAgICAgICBmbG9hdCBmaWxsWSh2ZWMyIF9zdCwgZmxvYXQgX3BjdCxmbG9hdCBfYW50aWEpe1xuICAgICAgICAgcmV0dXJuIHNtb290aHN0ZXAoIF9wY3QtX2FudGlhLCBfcGN0LCBfc3QueSk7XG4gICAgICAgfVxuXG4gICAgICAgdmVjMyB6aWd6YWcyZCggdmVjMiBzdCwgZmxvYXQgc2NhbGUsIGZsb2F0IHRpbWUgKSB7XG4gICAgICAgICBzdCA9IG1pcnJvclRpbGUoc3QqdmVjMigxLiwyLiksc2NhbGUpO1xuICAgICAgICAgZmxvYXQgeCA9IHN0LngqMi47XG4gICAgICAgICBmbG9hdCBhID0gZmxvb3IoMS4rc2luKHgqMy4xNCkpO1xuICAgICAgICAgZmxvYXQgYiA9IGZsb29yKDEuK3NpbigoeCsxLikqMy4xNCkpO1xuICAgICAgICAgZmxvYXQgZiA9IGZyYWN0KHgpO1xuXG4gICAgICAgICB2ZWMzIGNvbG9yID0gdmVjMyggZmlsbFkoc3QsbWl4KGEsYixmKSwwLjAxKSApOyBcblxuICAgICAgICAgcmV0dXJuIHZlYzMoY29sb3IpO1xuICAgICAgIH1cbmAgLFxuICAgIHBhcmFtZXRlcnM6IFtcbiAgICAgIHsgbmFtZTonc2NhbGUnLCB0eXBlOidmbG9hdCcsIGRlZmF1bHQ6NSB9LFxuICAgICAgeyBuYW1lOid0aW1lJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjEgfVxuICAgIF0sXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0ZXh0dXJlc1xuIiwibW9kdWxlLmV4cG9ydHMgPSBgXG4gICAgLy8gcCA9IHBvaW50IG9uIHN1cmZhY2UsIHAwID0gb2JqZWN0IGNlbnRlclxuICAgIHZlYzIgZ2V0VVZDdWJpYyh2ZWMzIHAgKXtcbiAgICAgIHZlYzMgYWJzcCA9IGFicyhwKTtcbiAgICAgICAgXG4gICAgICAvLyBGaXJzdCBjb25kaXRpb25hbDogSWYgdGhlIHBvaW50IGlzIGluIG9uZSBvZiB0aGUgc2V4dGFudHMgdG8gdGhlIFxuICAgICAgLy8gbGVmdCBvciByaWdodCBvZiB0aGUgeC1heGlzLCB0aGUgdXYgY29yZGluYXRlIHdpbGwgYmUgKDAuNSpwLnp5KS8ocC54KS5cbiAgICAgIC8vIElmIHlvdSB0cmFjZSBhIGxpbmUgb3V0IHRvIGEgenkgcGxhbmUgdGhhdCBpcyAwLjUgdW5pdHMgZnJvbSB0aGUgemVybyBvcmlnaW4sICBcbiAgICAgIC8vICgwLjUqcC54eXopLyhwLngpIHdpbGwgYmUgdGhlIHJlc3VsdCwgYW5kXG4gICAgICAvLyB0aGUgeXogY29tcG9uZW50cyB3aWxsIGJlIG91ciB1diBjb29yZGluYXRlcywgaGVuY2UgKDAuNSpwLnp5KS8ocC54KS5cblxuICAgICAgdmVjMiB1diA9ICgoYWJzcC54Pj1hYnNwLnkpJiYoYWJzcC54Pj1hYnNwLnopKSBcbiAgICAgICAgPyAoMC41KnAuenkpLyhwLngpIFxuICAgICAgICA6ICgoYWJzcC55Pj1hYnNwLnopJiYoYWJzcC55Pj1hYnNwLngpKSA/ICgwLjUqcC54eikvKHAueSkgOiAoLTAuNSpwLnh5KS8ocC56KTtcblxuICAgICAgLy9XZSBzdGlsbCBuZWVkIHRvIGRldGVybWluZSB3aGljaCBzaWRlIG91ciB1diBjb3JkaW5hdGVzIGFyZSBvbiBzb1xuICAgICAgLy90aGF0IHRoZSB0ZXh0dXJlIG9yaWVudHMgdGhlIHJpZ2h0IHdheS4gTm90ZSB0aGF0IHRoZXJlJ3Mgc29tZSBcbiAgICAgIC8vIHJlZHVuZGFuY3kgdGhlcmUsIHdoaWNoIEknbGwgZml4IGF0IHNvbWUgc3RhZ2UuIEZvciBub3csIGl0IHdvcmtzLCBzbyBJJ20gbm90IHRvdWNoaW5nIGl0LiA6KVxuICAgICAgaWYoICgocC54PDAuKSYmKGFic3AueD49YWJzcC55KSYmKGFic3AueD49YWJzcC56KSkgXG4gICAgICAgfHwgKChwLnk8MC4pJiYoYWJzcC55Pj1hYnNwLnopJiYoYWJzcC55Pj1hYnNwLngpKSBcbiAgICAgICB8fCAoKHAuej4wLikmJihhYnNwLno+PWFic3AueCkmJihhYnNwLno+PWFic3AueSkpICkgdXYueSo9LTEuO1xuICAgICAgICAgICAgIFxuICAgICAgLy8gTWFwcGluZyB0aGUgdXYgcmFuZ2UgZnJvbSBbLTAuNSwgMC41XSB0byBbMC4wLCAxLjBdLlxuICAgICAgcmV0dXJuICh1diswLjUpO1xuICAgIH1cbiAgICB2ZWM0IHRyaXBsYW5hcih2ZWMzIG4sIHZlYzQgdGV4eCwgdmVjNCB0ZXh5LCB2ZWM0IHRleHosIGJvb2wgYWRqdXN0M2QsIGJvb2wgcmVzY2FsZSkge1xuICAgICAgLy9pZiAoZG9mbGlweikgbi56ID0gLW4uejtcbiAgICAgIGlmIChyZXNjYWxlKSB7XG4gICAgICAgIHRleHggPSAyLjAqdGV4eCAtIDEuMDtcbiAgICAgICAgdGV4eSA9IDIuMCp0ZXh5IC0gMS4wO1xuICAgICAgICB0ZXh6ID0gMi4wKnRleHogLSAxLjA7XG4gICAgICB9XG4gICAgICBpZiAoYWRqdXN0M2QpIHtcbiAgICAgICAgdGV4eC54ICo9IHNpZ24obi54KTtcbiAgICAgICAgdGV4eS55ICo9IHNpZ24obi55KTtcbiAgICAgICAgdGV4ei56ICo9IHNpZ24obi56KTtcbiAgICAgIH1cbiAgICAgIC8vaWYgKGp1c3R0ZXh5KSByZXR1cm4gdGV4eTtcbiAgICAgIHZlYzMgd2VpZ2h0cyA9IGFicyhuKTtcbiAgICAgIC8vaWYgKGRvd2VpZ2h0Y29ycmVjdGlvbikgd2VpZ2h0cyAvPSBkb3Qod2VpZ2h0cyx2ZWMzKDEpKTsgLy8gS2VlcCBzcGhlcmljYWwhXG4gICAgICAgIHJldHVybiBtYXQ0KHRleHgsdGV4eSx0ZXh6LHZlYzQoMCkpKnZlYzQod2VpZ2h0cywwKTtcbiAgICB9IFxuICAgIGBcbi8qXG5tb2R1bGUuZXhwb3J0cyA9IGB2ZWMzIHQzKHNhbXBsZXIyRCB0ZXgsIHZlYzMgcCwgdmVjMyBuKVxue1xuICBtYXQzIFIgPSBtYXQzKHZlYzMoY29zKFQpLHNpbihUKSwwKSx2ZWMzKC1zaW4oVCksY29zKFQpLDApLHZlYzMoMCwwLC0xKSk7XG4gIHAgKj0gUi84LjA7XG4gIG4gKj0gUjtcbiAgI2lmZGVmIFNtb290aFxuICByZXR1cm4gICh0ZXh0dXJlKHRleCxwLnh5KS5yZ2Iqbi56Km4uelxuICAgICt0ZXh0dXJlKHRleCxwLnp5KS5yZ2Iqbi54Km4ueFxuICAgICt0ZXh0dXJlKHRleCxwLnh6KS5yZ2Iqbi55Km4ueSk7XG4gICNlbHNlXG4gICAgcmV0dXJuICh0ZXh0dXJlKHRleCxwLnh5KS5yZ2JcbiAgICAgICt0ZXh0dXJlKHRleCxwLnp5KS5yZ2JcbiAgICAgICt0ZXh0dXJlKHRleCxwLnh6KS5yZ2IpLzMuMDtcbiAgICAjZW5kaWZcbiAgICB9YFxuICAgICovXG4iLCJjb25zdCB7IHBhcmFtX3dyYXAsIE1hdGVyaWFsSUQgfSA9IHJlcXVpcmUoICcuL3V0aWxzLmpzJyApXG5jb25zdCB7IFZhciwgZmxvYXRfdmFyX2dlbiwgdmVjMl92YXJfZ2VuLCB2ZWMzX3Zhcl9nZW4sIHZlYzRfdmFyX2dlbiwgaW50X3Zhcl9nZW4sIFZhckFsbG9jIH0gID0gcmVxdWlyZSggJy4vdmFyLmpzJyApXG5jb25zdCBNYXRyaXggPSByZXF1aXJlKCAnLi9leHRlcm5hbC9tYXRyaXguanMnIClcbndpbmRvdy5NYXRyaXggPSBNYXRyaXhcbmNvbnN0IE1hdHJpeFdyYXAgPSBmdW5jdGlvbiAoIHNob3VsZEludmVydCA9IGZhbHNlICkge1xuICBjb25zdCBtID0gT2JqZWN0LmNyZWF0ZSggTWF0cml4V3JhcC5wcm90b3R5cGUgKVxuICBtLmRpcnR5ID0gdHJ1ZVxuICBtLnRyYW5zbGF0aW9uID0ge31cbiAgbS5zY2FsZSA9IHt9XG4gIG0uc2hvdWxkSW52ZXJ0ID0gc2hvdWxkSW52ZXJ0XG4gIG0ucm90YXRpb24gPSB7XG4gICAgYXhpczoge31cbiAgfVxuICBtLnBhcmVudCA9IG51bGxcblxuICBsZXQgdHggPSAwLCB0eSA9IDAsIHR6ID0gMFxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggbS50cmFuc2xhdGlvbiwge1xuICAgIHg6IHtcbiAgICAgIGdldCgpIHsgcmV0dXJuIHR4IH0sXG4gICAgICBzZXQodil7XG4gICAgICAgIHR4ID0gdlxuICAgICAgICAvL20uX19kYXRhID0gbS5fX2RhdGEubXVsdGlwbHkoIE1hdHJpeC50cmFuc2xhdGUoIHR4LCB0eSwgdHogKSApXG4gICAgICAgIG0uZGlydHkgPSB0cnVlXG4gICAgICB9XG4gICAgfSxcbiAgICB5OiB7XG4gICAgICBnZXQoKSB7IHJldHVybiB0eSB9LFxuICAgICAgc2V0KHYpe1xuICAgICAgICB0eSA9IHZcbiAgICAgICAgLy9tLl9fZGF0YSA9IG0uX19kYXRhLm11bHRpcGx5KCBNYXRyaXgudHJhbnNsYXRlKCB0eCwgdHksIHR6ICkgKVxuICAgICAgICBtLmRpcnR5ID0gdHJ1ZVxuICAgICAgfVxuICAgIH0sXG4gICAgejoge1xuICAgICAgZ2V0KCkgeyByZXR1cm4gdHogfSxcbiAgICAgIHNldCh2KXtcbiAgICAgICAgdHogPSB2XG4gICAgICAgIC8vbS5fX2RhdGEgPSBtLl9fZGF0YS5tdWx0aXBseSggTWF0cml4LnRyYW5zbGF0ZSggdHgsIHR5LCB0eiApIClcbiAgICAgICAgbS5kaXJ0eSA9IHRydWVcbiAgICAgIH1cbiAgICB9LFxuICB9KVxuXG4gIC8vIHNjYWxpbmcgbXVzdCBiZSBzZW50IGFzIHNlcGFyYXRlIHVuaWZvcm0gdG8gYXZvaWQgc2RmIG92ZXIgZXN0aW1hdGlvbiBcbiAgbGV0IHNjYWxlID0gMVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIG0sJ3NjYWxlJywge1xuICAgIGdldCgpIHsgcmV0dXJuIHNjYWxlIH0sXG4gICAgc2V0KHYpe1xuICAgICAgc2NhbGUgPSB2XG4gICAgICAvL20uX19kYXRhID0gbS5fX2RhdGEubXVsdGlwbHkoIE1hdHJpeC5yb3RhdGUoIGFuZ2xlLCByeCwgcnksIHJ6ICkgKVxuICAgICAgbS5kaXJ0eSA9IHRydWVcbiAgICB9IFxuICB9KVxuXG4gIC8qIEZPUiBOT04tVU5JRk9STSBTQ0FMSU5HOlxuICAgKlxuICAgKiAxLiBjb21tZW50IG91dCBzY2FsZSBwcm9wZXJ0eSBhYm92ZVxuICAgKiAyLiB1bmNvbW1lbnQgc2NhbGUgcHJvcGVydHkgYmVsb3dcbiAgICogMy4gY2hhbmdlIGVtaXRfZGVjbCB0byB1c2UgYSB2ZWMzIGZvciBzY2FsZVxuICAgKiA0LiBjaGFuZ2UgdXBsb2FkX2RhdGEgdG8gdXBsb2FkIGEgM2ZcbiAgICogNS4gSW4gXCJwcmltaXRpdmVzLmpzXCIsIHJlcGxhY2UgbGluZSAxNTUgKHBhcnQgb2YgZW1pdCkgdG8gdXNlIGNvbXBlbnNhdGVkIHNjYWxpbmdcbiAgICovIFxuXG4gIC8vbGV0IHN4ID0gMSwgc3kgPSAxLCBzeiA9IDFcbiAgLy9PYmplY3QuZGVmaW5lUHJvcGVydGllcyggbS5zY2FsZSwge1xuICAvLyAgeDoge1xuICAvLyAgICBnZXQoKSB7IHJldHVybiBzeCB9LFxuICAvLyAgICBzZXQodil7XG4gIC8vICAgICAgc3ggPSB2XG4gIC8vICAgICAgLy9tLl9fZGF0YSA9IG0uX19kYXRhLm11bHRpcGx5KCBNYXRyaXguc2NhbGUoIHN4LCBzeSwgc3ogKSApXG4gIC8vICAgICAgbS5kaXJ0eSA9IHRydWVcbiAgLy8gICAgfVxuICAvLyAgfSxcbiAgLy8gIHk6IHtcbiAgLy8gICAgZ2V0KCkgeyByZXR1cm4gc3kgfSxcbiAgLy8gICAgc2V0KHYpe1xuICAvLyAgICAgIHN5ID0gdlxuICAvLyAgICAgIC8vbS5fX2RhdGEgPSBtLl9fZGF0YS5tdWx0aXBseSggTWF0cml4LnNjYWxlKCBzeCwgc3ksIHN6ICkgKVxuICAvLyAgICAgIG0uZGlydHkgPSB0cnVlXG4gIC8vICAgIH1cbiAgLy8gIH0sXG4gIC8vICB6OiB7XG4gIC8vICAgIGdldCgpIHsgcmV0dXJuIHN6IH0sXG4gIC8vICAgIHNldCh2KXtcbiAgLy8gICAgICBzeiA9IHZcbiAgLy8gICAgICAvL20uX19kYXRhID0gbS5fX2RhdGEubXVsdGlwbHkoIE1hdHJpeC5zY2FsZSggc3gsIHN5LCBzeiApIClcbiAgLy8gICAgICBtLmRpcnR5ID0gdHJ1ZVxuICAvLyAgICB9XG4gIC8vICB9LFxuICAvL30pXG5cbiAgbGV0IGFuZ2xlID0gMFxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIG0ucm90YXRpb24sICdhbmdsZScsIHtcbiAgICBnZXQoKSB7IHJldHVybiBhbmdsZSB9LFxuICAgIHNldCh2KXtcbiAgICAgIGFuZ2xlID0gdlxuICAgICAgLy9tLl9fZGF0YSA9IG0uX19kYXRhLm11bHRpcGx5KCBNYXRyaXgucm90YXRlKCBhbmdsZSwgcngsIHJ5LCByeiApIClcbiAgICAgIG0uZGlydHkgPSB0cnVlXG4gICAgfSBcbiAgfSlcblxuICBsZXQgcnggPSAwLCByeSA9IDAsIHJ6ID0gMFxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggbS5yb3RhdGlvbi5heGlzLCB7XG4gICAgeDoge1xuICAgICAgZ2V0KCkgeyByZXR1cm4gcnggfSxcbiAgICAgIHNldCh2KXtcbiAgICAgICAgcnggPSB2XG4gICAgICAgIC8vbS5fX2RhdGEgPSBtLl9fZGF0YSA9IE1hdHJpeC5yb3RhdGUoIGFuZ2xlLCByeCwgcnksIHJ6LCBtLl9fZGF0YSApXG4gICAgICAgIG0uZGlydHkgPSB0cnVlXG4gICAgICB9XG4gICAgfSxcbiAgICB5OiB7XG4gICAgICBnZXQoKSB7IHJldHVybiByeSB9LFxuICAgICAgc2V0KHYpe1xuICAgICAgICByeSA9IHZcbiAgICAgICAgLy9tLl9fZGF0YSA9IG0uX19kYXRhID0gTWF0cml4LnJvdGF0ZSggYW5nbGUsIHJ4LCByeSwgcnosIG0uX19kYXRhIClcbiAgICAgICAgbS5kaXJ0eSA9IHRydWVcbiAgICAgIH1cbiAgICB9LFxuICAgIHo6IHtcbiAgICAgIGdldCgpIHsgcmV0dXJuIHJ6IH0sXG4gICAgICBzZXQodil7XG4gICAgICAgIHJ6ID0gdlxuICAgICAgICAvL20uX19kYXRhID0gbS5fX2RhdGEgPSBNYXRyaXgucm90YXRlKCBhbmdsZSwgcngsIHJ5LCByeiwgbS5fX2RhdGEgKVxuICAgICAgICBtLmRpcnR5ID0gdHJ1ZVxuICAgICAgfVxuICAgIH0sXG4gIH0pXG5cbiAgbS5fX3JvdGF0aW9ucyA9IFtdXG4gIG0uX19pZCAgID0gVmFyQWxsb2MuYWxsb2MoKSAgXG4gIG0uX19kaXJ0eSA9IGZ1bmN0aW9uKCkge31cbiAgbS5fX2RhdGEgPSBNYXRyaXguaWRlbnRpdHkoKVxuICBtLl9fTWF0cml4ID0gTWF0cml4XG4gIG0udmFyTmFtZSA9ICd0cmFuc2Zvcm0nICsgbS5fX2lkXG5cbiAgcmV0dXJuIG1cbn1cblxuTWF0cml4V3JhcC5wcm90b3R5cGUgPSB7XG4gIHR5cGU6ICdtYXRyaXgnLFxuXG4gIGVtaXQoKSB7IHJldHVybiB0aGlzLnZhck5hbWUgfSxcblxuICBlbWl0X3NjYWxlKCkgeyByZXR1cm4gdGhpcy52YXJOYW1lICsgJ19zY2FsZScgfSxcblxuICBlbWl0X2RlY2woKSB7IFxuICAgIGNvbnN0IGRlY2wgPSAgYCAgICB1bmlmb3JtIG1hdDQgJHt0aGlzLnZhck5hbWV9O1xuICAgIHVuaWZvcm0gZmxvYXQgJHt0aGlzLnZhck5hbWV9X3NjYWxlO1xuICAgIGAgXG5cbiAgICByZXR1cm4gZGVjbFxuICB9LFxuXG5cdHVwZGF0ZV9sb2NhdGlvbihnbCwgcHJvZ3JhbSkge1xuXHRcdHRoaXMubG9jID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCB0aGlzLnZhck5hbWUgKVxuXHRcdHRoaXMubG9jX3NjYWxlID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCB0aGlzLnZhck5hbWUrJ19zY2FsZScgKVxuXHR9LFx0XG5cblx0dXBsb2FkX2RhdGEoZ2wpIHtcblx0XHRpZiggIXRoaXMuZGlydHkgKSByZXR1cm5cblx0XHRcbiAgICB0aGlzLmludGVybmFsKClcblxuICAgIGlmKCB0aGlzLnNob3VsZEludmVydCA9PT0gdHJ1ZSApIHtcbiAgICAgIGNvbnN0IGludmVyc2UgPSBNYXRyaXguaW52ZXJzZSggdGhpcy5fX2RhdGEgKVxuICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdiggdGhpcy5sb2MsIGZhbHNlLCBpbnZlcnNlLm0gKVxuICAgIH1lbHNle1xuICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdiggdGhpcy5sb2MsIGZhbHNlLCB0aGlzLl9fZGF0YS5tIClcbiAgICB9XG4gICAgLy9nbC51bmlmb3JtM2YodGhpcy5sb2Nfc2NhbGUsIHRoaXMuc2NhbGUueCwgdGhpcy5zY2FsZS55LCB0aGlzLnNjYWxlLnogKVxuICAgIFxuICAgIC8vIHNjYWxpbmcgbXVzdCBiZSBzZW50IGFzIHNlcGFyYXRlIHVuaWZvcm0gdG8gYXZvaWQgc2RmIG92ZXItZXN0aW1hdGlvbiBcbiAgICBnbC51bmlmb3JtMWYodGhpcy5sb2Nfc2NhbGUsIHRoaXMuc2NhbGUgKVxuXG5cdFx0dGhpcy5kaXJ0eSA9IGZhbHNlXG4gIH0sXG5cblxuICBpbnRlcm5hbCgpIHtcbiAgICB0aGlzLl9fZGF0YSA9IE1hdHJpeC5pZGVudGl0eSgpXG4gICAgaWYoIHRoaXMucGFyZW50ICE9IG51bGwgKSB0aGlzLl9fZGF0YSA9IHRoaXMucGFyZW50Ll9fZGF0YVxuXG4gICAgdGhpcy5fX2RhdGEgPSB0aGlzLl9fZGF0YS5tdWx0aXBseSggTWF0cml4LnRyYW5zbGF0ZSggdGhpcy50cmFuc2xhdGlvbi54LCB0aGlzLnRyYW5zbGF0aW9uLnksIHRoaXMudHJhbnNsYXRpb24ueiApICkgXG5cbiAgICAvLyBoYW5kbGUgY3VtdWxhdGl2ZSByb3RhdGlvbnMgdmlhIC5yb3RhdGVCeSgpIG1ldGhvZFxuICAgIHRoaXMuX19yb3RhdGlvbnMuZm9yRWFjaCggciA9PiB0aGlzLl9fZGF0YSA9IHRoaXMuX19kYXRhLm11bHRpcGx5KCByICkgKVxuXG4gICAgLy8gaGFuZGxlIGFic29sdXRlIHJvdGF0aW9ucyB2aWEgLnJvdGF0ZSgpIG1ldGhvZC4uLiBzaG91bGQgdGhpcyBiZSBhbGlhc2VkIHRvIHJvdGF0ZVRvKCkgP1xuICAgIHRoaXMuX19kYXRhID0gdGhpcy5fX2RhdGEubXVsdGlwbHkoIE1hdHJpeC5yb3RhdGUoIHRoaXMucm90YXRpb24uYW5nbGUsIHRoaXMucm90YXRpb24uYXhpcy54LCB0aGlzLnJvdGF0aW9uLmF4aXMueSwgdGhpcy5yb3RhdGlvbi5heGlzLnogKSApXG5cbiAgICB0aGlzLl9fZGF0YSA9IHRoaXMuX19kYXRhLm11bHRpcGx5KCBNYXRyaXguc2NhbGUoIHRoaXMuc2NhbGUsIHRoaXMuc2NhbGUsIHRoaXMuc2NhbGUgKSApXG4gIH0sXG5cbiAgaW52ZXJ0KCBzaG91bGRJbnZlcnQgPSB0cnVlKSB7XG4gICAgdGhpcy5zaG91bGRJbnZlcnQgPSBzaG91bGRJbnZlcnRcbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZVxuICB9LFxuXG4gIGFwcGx5KCB0cmFuc2Zvcm0gPSBudWxsLCBzaG91bGRJbnZlcnQgPSBmYWxzZSApIHtcbiAgICB0aGlzLnBhcmVudCA9IHRyYW5zZm9ybVxuICAgIHRoaXMuZGlydHkgPSB0cnVlXG4gIH0gXG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBNYXRyaXhXcmFwXG4iLCJjb25zdCBWYXIgPSByZXF1aXJlKCcuL3Zhci5qcycpLlZhclxuY29uc3QgeyBWZWMyLCBWZWMzLCBWZWM0IH0gPSByZXF1aXJlKCAnLi92ZWMuanMnIClcblxuLy8gV3JhcHBlclxuZnVuY3Rpb24gcGFyYW1fd3JhcCggdiwgX19kZWZhdWx0LCBuYW1lPW51bGwgKSB7XG5cdGlmKCB2ID09PSB1bmRlZmluZWQgfHwgdiA9PT0gbnVsbCApIHJldHVybiBfX2RlZmF1bHQoKVxuXHRpZiggdi5fX2lzVmFyID09PSB0cnVlICkgcmV0dXJuIHZcblx0XG5cdHJldHVybiBWYXIoIHYsIG5hbWUgKVxufVxuXG5jb25zdCBNYXRlcmlhbElEID0ge1xuXHRjdXJyZW50OiAwLFxuXHRhbGxvYygpIHtcblx0XHRyZXR1cm4gTWF0ZXJpYWxJRC5jdXJyZW50KytcbiAgfSxcbiAgY2xlYXIoKSB7XG4gICAgTWF0ZXJpYWxJRC5jdXJyZW50ID0gMFxuICB9XG59XG5cbmNvbnN0IHByb2Nlc3NWZWMyID0gZnVuY3Rpb24oIHZhbCApIHtcbiAgaWYoIHR5cGVvZiB2YWwgPT09ICdudW1iZXInICkgXG4gICAgdmFsID0gVmVjMiggY29sb3IgKVxuICBlbHNlIGlmKCBBcnJheS5pc0FycmF5KCB2YWwgKSApIFxuICAgIHZhbCA9IFZlYzIoIHZhbFswXSwgdmFsWzFdIClcblxuICByZXR1cm4gdmFsXG59XG5cbmNvbnN0IHByb2Nlc3NWZWMzID0gZnVuY3Rpb24oIHZhbCApIHtcbiAgaWYoIHR5cGVvZiB2YWwgPT09ICdudW1iZXInICkgXG4gICAgdmFsID0gVmVjMyggdmFsIClcbiAgZWxzZSBpZiggQXJyYXkuaXNBcnJheSggdmFsICkgKSBcbiAgICB2YWwgPSBWZWMzKCB2YWxbMF0sIHZhbFsxXSwgdmFsWzJdIClcblxuICByZXR1cm4gdmFsXG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBwYXJhbV93cmFwLCBNYXRlcmlhbElELCBwcm9jZXNzVmVjMiwgcHJvY2Vzc1ZlYzMgfVxuIiwiY29uc3QgeyBWZWMyLCBWZWMzLCBWZWM0IH0gPSByZXF1aXJlKCAnLi92ZWMuanMnIClcbmNvbnN0IGZsb2F0ID0gcmVxdWlyZSggJy4vZmxvYXQuanMnIClcbmNvbnN0IGludCAgID0gcmVxdWlyZSggJy4vaW50LmpzJyApXG5cbi8vIFZhclxuY29uc3QgVmFyQWxsb2MgPSB7XG5cdGN1cnJlbnQ6IDAsXG4gIGNsZWFyKCkge1xuICAgIFZhckFsbG9jLmN1cnJlbnQgPSAwXG4gIH0sXG5cdGFsbG9jKCkge1xuXHRcdHJldHVybiBWYXJBbGxvYy5jdXJyZW50Kytcblx0fVxufVxuXG5jb25zdCBWYXIgPSBmdW5jdGlvbiggdmFsdWUsIGZpeGVkTmFtZSA9IG51bGwsIF9fdHlwZSApIHtcbiAgY29uc3QgdiA9IE9iamVjdC5jcmVhdGUoIFZhci5wcm90b3R5cGUgKVxuXHR2LnZhck5hbWUgPSBmaXhlZE5hbWUgIT09IG51bGwgPyBmaXhlZE5hbWUgOiAndmFyJyArIFZhckFsbG9jLmFsbG9jKClcbiAgdi52YWx1ZSA9IHZhbHVlXG4gIHYudHlwZSA9IHYudmFsdWUudHlwZVxuICBpZiggdi50eXBlID09PSB1bmRlZmluZWQgKSB2LnR5cGUgPSBfX3R5cGUgfHwgJ2Zsb2F0JyBcblxuICB2YWx1ZS52YXIgPSB2XG5cbiAgaWYoIHYudHlwZSAhPT0gJ2Zsb2F0JyAmJiB2LnR5cGUgIT09ICdpbnQnICkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCB2LCB7XG4gICAgICB4OiB7XG4gICAgICAgIGdldCgpIHsgcmV0dXJuIHRoaXMudmFsdWUueCB9LFxuICAgICAgICBzZXQodil7IHRoaXMudmFsdWUueCA9IHY7IHRoaXMuZGlydHkgPSB0cnVlIH1cbiAgICAgIH0sXG4gICAgICB5OiB7XG4gICAgICAgIGdldCgpIHsgcmV0dXJuIHRoaXMudmFsdWUueSB9LFxuICAgICAgICBzZXQodil7IHRoaXMudmFsdWUueSA9IHY7IHRoaXMuZGlydHkgPSB0cnVlIH1cbiAgICAgIH0sXG4gICAgICB6OiB7XG4gICAgICAgIGdldCgpIHsgcmV0dXJuIHRoaXMudmFsdWUueiB9LFxuICAgICAgICBzZXQodil7IHRoaXMudmFsdWUueiA9IHY7IHRoaXMuZGlydHkgPSB0cnVlIH1cbiAgICAgIH0sXG4gICAgICB3OiB7XG4gICAgICAgIGdldCgpIHsgcmV0dXJuIHRoaXMudmFsdWUudyB9LFxuICAgICAgICBzZXQodil7IHRoaXMudmFsdWUudyA9IHY7IHRoaXMuZGlydHkgPSB0cnVlIH1cbiAgICAgIH0sXG4gICAgICByOiB7XG4gICAgICAgIGdldCgpIHsgcmV0dXJuIHRoaXMudmFsdWUueCB9LFxuICAgICAgICBzZXQodil7IHRoaXMudmFsdWUueCA9IHY7IHRoaXMuZGlydHkgPSB0cnVlIH1cbiAgICAgIH0sXG4gICAgICBnOiB7XG4gICAgICAgIGdldCgpIHsgcmV0dXJuIHRoaXMudmFsdWUueSB9LFxuICAgICAgICBzZXQodil7IHRoaXMudmFsdWUueSA9IHY7IHRoaXMuZGlydHkgPSB0cnVlIH1cbiAgICAgIH0sXG4gICAgICBiOiB7XG4gICAgICAgIGdldCgpIHsgcmV0dXJuIHRoaXMudmFsdWUueiB9LFxuICAgICAgICBzZXQodil7IHRoaXMudmFsdWUueiA9IHY7IHRoaXMuZGlydHkgPSB0cnVlIH1cbiAgICAgIH0sXG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiB2XG59XG5cblZhci5oYXJkY29kZSA9IGZhbHNlXG5jb25zdCBlbWl0X2Zsb2F0ID0gZnVuY3Rpb24oIGEgKSB7XG5cdGlmIChhICUgMSA9PT0gMClcblx0XHRyZXR1cm4gYS50b0ZpeGVkKCAxIClcblx0ZWxzZVxuXHRcdHJldHVybiBhXG59XG5cblZhci5wcm90b3R5cGUgPSB7XG5cdGRpcnR5OiB0cnVlLFxuXG5cdGxvYzogLTEsXG5cbiAgZW1pdCgpIHsgXG4gICAgbGV0IG91dFxuICAgIGlmKCB0aGlzLnZhbHVlLmlzR2VuICkge1xuICAgICAgY29uc3QgdmVjT3V0ID0gdGhpcy52YWx1ZS5lbWl0KCkgXG4gICAgICBvdXQgPSB2ZWNPdXQucHJlZmFjZSArIHZlY091dC5vdXRcbiAgICAgICAgXG4gICAgfWVsc2V7XG4gICAgICBvdXQgPSB0aGlzLnZhck5hbWUgXG4gICAgfSBcblxuICAgIHJldHVybiBvdXRcbiAgfSxcblxuICBlbWl0X2RlY2woKSB7IFxuICAgIGxldCBvdXQgPSAnJ1xuICAgIGlmKCB0aGlzLnZhbHVlLmlzR2VuICkge1xuICAgICAgb3V0ID0gdGhpcy52YWx1ZS5lbWl0X2RlY2woKVxuICAgIH1lbHNle1xuICAgICAgaWYoIFZhci5oYXJkY29kZSA9PT0gdHJ1ZSApIHtcblxuICAgICAgICBpZiggdHlwZW9mIHRoaXMudmFsdWUuZW1pdCAhPT0gJ2Z1bmN0aW9uJyApIHtcbiAgICAgICAgICBpZiggdGhpcy50eXBlID09PSAnZmxvYXQnICkge1xuICAgICAgICAgICAgb3V0ID0gYCR7dGhpcy50eXBlfSAke3RoaXMudmFyTmFtZX0gPSAke2VtaXRfZmxvYXQodGhpcy52YWx1ZSl9O1xcbmBcbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIG91dCA9IGAke3RoaXMudHlwZX0gJHt0aGlzLnZhck5hbWV9ID0gJHt0aGlzLnZhbHVlfTtcXG5gXG4gICAgICAgICAgfVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICBsZXQgdmFsID0gdGhpcy52YWx1ZS5lbWl0KClcbiAgICAgICAgICBpZiggdHlwZW9mIHZhbCAhPT0gJ3N0cmluZycgKSB2YWwgPSB2YWwub3V0XG4gICAgICAgICAgb3V0ID0gdmFsICE9PSB1bmRlZmluZWQgPyBgJHt0aGlzLnR5cGV9ICR7dGhpcy52YXJOYW1lfSA9ICR7dmFsfTtcXG5gIDogJydcbiAgICAgICAgfVxuICAgICAgfWVsc2V7XG4gICAgICAgIG91dCA9IGB1bmlmb3JtICR7dGhpcy50eXBlfSAke3RoaXMudmFyTmFtZX07XFxuYFxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0XG4gIH0sXG5cblx0c2V0KHYpIHsgdGhpcy52YWx1ZSA9IHY7IHRoaXMuZGlydHkgPSB0cnVlOyB9LFxuXG5cdHVwZGF0ZV9sb2NhdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgIGlmKCB0aGlzLnZhbHVlLmlzR2VuICkge1xuICAgICAgdGhpcy52YWx1ZS51cGRhdGVfbG9jYXRpb24oIGdsLCBwcm9ncmFtIClcbiAgICAgIHJldHVyblxuICAgIH1cblx0XHR0aGlzLmxvYyA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCB0aGlzLnZhck5hbWUpXG5cdH0sXHRcblxuXHR1cGxvYWRfZGF0YShnbCkge1xuXHRcdGlmKCAhdGhpcy5kaXJ0eSApIHJldHVyblxuXHRcdFxuICAgIGlmKCB0aGlzLnZhbHVlLmlzR2VuICkge1xuICAgICAgdGhpcy52YWx1ZS51cGxvYWRfZGF0YSggZ2wgIClcbiAgICAgIHRoaXMuZGlydHkgPSBmYWxzZVxuICAgICAgcmV0dXJuXG4gICAgfVxuXHRcdGxldCB2ID0gdGhpcy52YWx1ZVxuXHRcdGlmICh0eXBlb2YgdiA9PT0gJ251bWJlcicgKSB7XG5cdFx0XHRnbC51bmlmb3JtMWYoIHRoaXMubG9jLCB2IClcblx0XHR9ZWxzZSBpZiAoIHYgaW5zdGFuY2VvZiBWZWMyICkge1xuXHRcdFx0Z2wudW5pZm9ybTJmKHRoaXMubG9jLCB2LngsIHYueSApXG5cdFx0fSBlbHNlIGlmKCB2IGluc3RhbmNlb2YgVmVjMyApIHtcblx0XHRcdGdsLnVuaWZvcm0zZih0aGlzLmxvYywgdi54LCB2LnksIHYueiApXG5cdFx0fSBlbHNlIGlmKCB2IGluc3RhbmNlb2YgVmVjNCApIHtcblx0XHRcdGdsLnVuaWZvcm00Zih0aGlzLmxvYywgdi54LCB2LnksIHYueiwgdi53IClcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZm9yIGNvbG9yIHZhcmlhYmxlc1xuICAgICAgaWYoIHRoaXMudHlwZSA9PT0gJ2Zsb2F0JyApIHtcbiAgICAgICAgZ2wudW5pZm9ybTFmKCB0aGlzLmxvYywgdi54IClcbiAgICAgIH1lbHNle1xuICAgICAgICBnbC51bmlmb3JtMWkoIHRoaXMubG9jLCB2LnggKVxuICAgICAgfVxuICAgIH1cblxuXHRcdHRoaXMuZGlydHkgPSBmYWxzZVxuXHR9XG59XG5cblxuZnVuY3Rpb24gaW50X3Zhcl9nZW4oeCxuYW1lPW51bGwpIHsgXG4gIGxldCBvdXRwdXQgPSAoKT0+IHtcbiAgICBsZXQgb3V0ID0gVmFyKCBpbnQoeCksIG5hbWUsICdpbnQnICkgXG4gICAgcmV0dXJuIG91dFxuICB9XG5cbiAgcmV0dXJuIG91dHB1dFxufVxuZnVuY3Rpb24gZmxvYXRfdmFyX2dlbih4LG5hbWU9bnVsbCkgeyByZXR1cm4gKCk9PiB7IHJldHVybiBWYXIoIGZsb2F0KHgpLCBuYW1lLCAnZmxvYXQnICkgfSB9XG5cbmZ1bmN0aW9uIHZlYzJfdmFyX2dlbih4LCB5LG5hbWU9bnVsbCkgeyBcbiAgcmV0dXJuICgpPT4gVmFyKCBWZWMyKHgsIHkpLCBuYW1lICApIFxufVxuXG5mdW5jdGlvbiB2ZWMzX3Zhcl9nZW4oeD0wLCB5LCB6LG5hbWU9bnVsbCkgeyBcbiAgcmV0dXJuICgpPT4gVmFyKCBWZWMzKHgsIHksIHopLCBuYW1lICkgXG59XG5cbmZ1bmN0aW9uIHZlYzRfdmFyX2dlbiggeCwgeSwgeiwgdywgbmFtZT1udWxsICkgeyBcbiAgcmV0dXJuIFZhciggVmVjNCggeCwgeSwgeiwgdyApLCBuYW1lICkgXG59XG4vL2Z1bmN0aW9uIGZsb2F0X3Zhcl9nZW4oeCxuYW1lPW51bGwpIHsgcmV0dXJuICgpPT4geyByZXR1cm4gVmFyKCBmbG9hdCh4KSwgbmFtZSwgJ2Zsb2F0JyApIH0gfVxuXG4vL2Z1bmN0aW9uIHZlYzJfdmFyX2dlbih4LCB5LG5hbWU9bnVsbCkgeyByZXR1cm4gKCk9PiBWYXIoIFZlYzIoeCwgeSksIG5hbWUgICkgfVxuXG4vL2Z1bmN0aW9uIHZlYzNfdmFyX2dlbih4LCB5LCB6LG5hbWU9bnVsbCkgeyByZXR1cm4gKCk9PiBWYXIoIFZlYzMoeCwgeSwgeiksIG5hbWUgKSB9XG5cbi8vZnVuY3Rpb24gdmVjNF92YXJfZ2VuKCB4LCB5LCB6LCB3LCBuYW1lPW51bGwgKSB7IHJldHVybiBWYXIoIFZlYzQoIHgsIHksIHosIHcgKSwgbmFtZSApIH1cblxubW9kdWxlLmV4cG9ydHMgPSB7IFZhciwgZmxvYXRfdmFyX2dlbiwgdmVjMl92YXJfZ2VuLCB2ZWMzX3Zhcl9nZW4sIHZlYzRfdmFyX2dlbiwgaW50X3Zhcl9nZW4sIFZhckFsbG9jIH1cblxuLypmdW5jdGlvbiBmbG9hdF92YXJfZ2VuKHgsbmFtZT1udWxsKSB7IHJldHVybiAoKT0+IHsgcmV0dXJuIFZhciggZmxvYXQoeCksIG5hbWUsICdmbG9hdCcgKSB9IH1cblxuZnVuY3Rpb24gdmVjMl92YXJfZ2VuKHgsIHksbmFtZT1udWxsKSB7IFxuICBpZiggeSA9PT0gdW5kZWZpbmVkICkgeSA9IHhcbiAgcmV0dXJuICgpPT4gVmFyKCBWZWMyKHgsIHkpLCBuYW1lICApIFxufVxuXG5mdW5jdGlvbiB2ZWMzX3Zhcl9nZW4oeCwgeSwgeixuYW1lPW51bGwpIHsgXG4gIGlmKCB5ID09PSB1bmRlZmluZWQgKSB5ID0geFxuICBpZiggeiA9PT0gdW5kZWZpbmVkICkgeiA9IHhcbiAgcmV0dXJuICgpPT4gVmFyKCBWZWMzKHgsIHksIHopLCBuYW1lICkgXG59XG5cbmZ1bmN0aW9uIHZlYzRfdmFyX2dlbiggeCwgeSwgeiwgdywgbmFtZT1udWxsICkgeyBcbiAgaWYoIHkgPT09IHVuZGVmaW5lZCApIHkgPSB4XG4gIGlmKCB6ID09PSB1bmRlZmluZWQgKSB6ID0geFxuICBpZiggdyA9PT0gdW5kZWZpbmVkICkgdyA9IHhcbiAgcmV0dXJuIFZhciggVmVjNCggeCwgeSwgeiwgdyApLCBuYW1lICkgXG59XG4qL1xuIiwiY29uc3QgVmVjMiA9IGZ1bmN0aW9uICh4PTAsIHk9MCkge1xuICBpZiggeC50eXBlID09PSAndmVjMicgKSByZXR1cm4geCAgXG4gIGNvbnN0IHYgPSBPYmplY3QuY3JlYXRlKCBWZWMyLnByb3RvdHlwZSApXG4gIGlmKCBBcnJheS5pc0FycmF5KCB4ICkgKSB7XG4gICAgdi54ID0geFswXTsgdi55ID0geFsxXTsgXG4gIH0gZWxzZSBpZiggeSA9PT0gdW5kZWZpbmVkICkge1xuICAgIHYueCA9IHYueSA9IHhcbiAgfWVsc2V7XG4gICAgdi54ID0geDsgdi55ID0geTsgXG4gIH1cblxuICByZXR1cm4gdlxufVxuXG5WZWMyLnByb3RvdHlwZSA9IHtcbiAgdHlwZTogJ3ZlYzInLFxuXHRlbWl0KCkgeyByZXR1cm4gXCJ2ZWMyKFwiICsgdGhpcy54ICsgXCIsXCIgKyB0aGlzLnkgKyBcIilcIiB9LFxuICBlbWl0X2RlY2woKSB7IHJldHVybiBcIlwiOyB9LFxuICBjb3B5KCkge1xuICAgIHJldHVybiBWZWMyKCB0aGlzLngsIHRoaXMueSApXG4gIH1cbn1cblxuY29uc3QgVmVjMyA9IGZ1bmN0aW9uICh4PTAsIHksIHopIHtcbiAgaWYoIHgudHlwZSA9PT0gJ3ZlYzMnICkgcmV0dXJuIHggIFxuICBjb25zdCB2ID0gT2JqZWN0LmNyZWF0ZSggVmVjMy5wcm90b3R5cGUgKVxuICBsZXQgdnggPTAsdnk9MCx2ej0wXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCB2LCB7XG4gICAgeDoge1xuICAgICAgZ2V0KCkgIHsgcmV0dXJuIHZ4IH0sXG4gICAgICBzZXQodikgeyB2eCA9IHY7IHRoaXMuZGlydHkgPSB0cnVlOyB9XG4gICAgfSxcblxuICAgIHk6IHtcbiAgICAgIGdldCgpICB7IHJldHVybiB2eSB9LFxuICAgICAgc2V0KHYpIHsgdnkgPSB2OyB0aGlzLmRpcnR5ID0gdHJ1ZTsgfVxuICAgIH0sXG5cbiAgICB6OiB7XG4gICAgICBnZXQoKSAgeyByZXR1cm4gdnogfSxcbiAgICAgIHNldCh2KSB7IHZ6ID0gdjsgdGhpcy5kaXJ0eSA9IHRydWU7IH1cbiAgICB9LFxuICAgIHI6IHtcbiAgICAgIGdldCgpICB7IHJldHVybiB2eCB9LFxuICAgICAgc2V0KHYpIHsgdnggPSB2OyB0aGlzLmRpcnR5ID0gdHJ1ZTsgfVxuICAgIH0sXG5cbiAgICBnOiB7XG4gICAgICBnZXQoKSAgeyByZXR1cm4gdnkgfSxcbiAgICAgIHNldCh2KSB7IHZ5ID0gdjsgdGhpcy5kaXJ0eSA9IHRydWU7IH1cbiAgICB9LFxuXG4gICAgYjoge1xuICAgICAgZ2V0KCkgIHsgcmV0dXJuIHZ6IH0sXG4gICAgICBzZXQodikgeyB2eiA9IHY7IHRoaXMuZGlydHkgPSB0cnVlOyB9XG4gICAgfSxcblxuICB9KVxuXG4gIGlmKCBBcnJheS5pc0FycmF5KCB4ICkgKSB7XG4gICAgdi54ID0geFswXTsgdi55ID0geFsxXTsgdi56ID0geFsyXTsgXG4gIH0gZWxzZSBpZiggeSA9PT0gdW5kZWZpbmVkICYmIHogPT09IHVuZGVmaW5lZCkge1xuICAgIHYueCA9IHYueSA9IHYueiA9IHhcbiAgfWVsc2V7XG4gICAgdi54ID0geDsgdi55ID0geTsgdi56ID0gejtcbiAgfVxuIFxuICB2LmlzR2VuID0gdi54LnR5cGUgPT09ICdzdHJpbmcnIHx8IHYueS50eXBlID09PSAnc3RyaW5nJyB8fCB2LnoudHlwZSA9PT0gJ3N0cmluZydcbiAgcmV0dXJuIHZcbn07XG5cblZlYzMucHJvdG90eXBlID0ge1xuICB0eXBlOiAndmVjMycsXG4gIGVtaXQoKSB7IFxuICAgIGxldCBvdXQgPSBgdmVjMyhgXG4gICAgbGV0IHByZWZhY2UgPSAnJ1xuXG4gICAgaWYoIHRoaXMueC50eXBlID09PSAnc3RyaW5nJyApIHtcbiAgICAgIGNvbnN0IHhvdXQgPSB0aGlzLnguZW1pdCgpXG4gICAgICBvdXQgKz0geG91dC5vdXQgKyAnLCdcbiAgICB9ZWxzZXtcbiAgICAgIG91dCArPSB0aGlzLnggKyAnLCdcbiAgICB9XG5cbiAgICBpZiggdGhpcy55LnR5cGUgPT09ICdzdHJpbmcnICkge1xuICAgICAgY29uc3QgeW91dCA9IHRoaXMueS5lbWl0KClcbiAgICAgIG91dCArPSB5b3V0Lm91dCArICcsJyBcbiAgICB9ZWxzZXtcbiAgICAgIG91dCArPSB0aGlzLnkgKyAnLCdcbiAgICB9XG4gICAgaWYoIHRoaXMuei50eXBlID09PSAnc3RyaW5nJyApIHtcbiAgICAgIGNvbnN0IHpvdXQgPSB0aGlzLnouZW1pdCgpXG4gICAgICBvdXQgKz0gem91dC5vdXRcbiAgICB9ZWxzZXtcbiAgICAgIG91dCArPSB0aGlzLnogXG4gICAgfVxuXG4gICAgb3V0ICs9ICcpJ1xuXG4gICAgcmV0dXJuIHsgb3V0LCBwcmVmYWNlIH1cbiAgfSxcbiAgZW1pdF9kZWNsKCkgeyBcbiAgICBsZXQgb3V0ID0gJydcbiAgICBpZiggdGhpcy54LnR5cGUgPT09ICdzdHJpbmcnICkge1xuICAgICAgb3V0ICs9IHRoaXMueC5lbWl0X2RlY2woKVxuICAgIH0gXG4gICAgaWYoIHRoaXMueS50eXBlID09PSAnc3RyaW5nJyAmJiB0aGlzLnggIT09IHRoaXMueSAgKSB7XG4gICAgICBvdXQgKz0gdGhpcy55LmVtaXRfZGVjbCgpXG4gICAgfSBcbiAgICBpZiggdGhpcy56LnR5cGUgPT09ICdzdHJpbmcnICYmIHRoaXMueiAhPT0gdGhpcy55ICYmIHRoaXMueiAhPT0gdGhpcy54ICkge1xuICAgICAgb3V0ICs9IHRoaXMuei5lbWl0X2RlY2woKVxuICAgIH0gXG4gICAgcmV0dXJuIG91dFxuICB9LFxuXG5cdHVwZGF0ZV9sb2NhdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgIGlmKCB0aGlzLmlzR2VuICkge1xuICAgICAgaWYoIHRoaXMueC50eXBlID09PSAnc3RyaW5nJyApIHtcbiAgICAgICAgdGhpcy54LnVwZGF0ZV9sb2NhdGlvbihnbCxwcm9ncmFtKVxuICAgICAgfSBcbiAgICAgIGlmKCB0aGlzLnkudHlwZSA9PT0gJ3N0cmluZycgJiYgdGhpcy54ICE9PSB0aGlzLnkgICkge1xuICAgICAgICB0aGlzLnkudXBkYXRlX2xvY2F0aW9uKGdsLHByb2dyYW0pXG4gICAgICB9IFxuICAgICAgaWYoIHRoaXMuei50eXBlID09PSAnc3RyaW5nJyAmJiB0aGlzLnogIT09IHRoaXMueSAmJiB0aGlzLnogIT09IHRoaXMueCApIHtcbiAgICAgICAgdGhpcy56LnVwZGF0ZV9sb2NhdGlvbihnbCxwcm9ncmFtKVxuICAgICAgfSAgICAgIFxuICAgIH1cbiAgfSxcbiAgXG4gIHVwbG9hZF9kYXRhKGdsKSB7XG4gICAgaWYoIHRoaXMuaXNHZW4gKSB7XG4gICAgICBpZiggdGhpcy54LnR5cGUgPT09ICdzdHJpbmcnICkge1xuICAgICAgICB0aGlzLngudXBsb2FkX2RhdGEoZ2wpXG4gICAgICB9IFxuICAgICAgaWYoIHRoaXMueS50eXBlID09PSAnc3RyaW5nJyAmJiB0aGlzLnggIT09IHRoaXMueSAgKSB7XG4gICAgICAgIHRoaXMueS51cGxvYWRfZGF0YShnbClcbiAgICAgIH0gXG4gICAgICBpZiggdGhpcy56LnR5cGUgPT09ICdzdHJpbmcnICYmIHRoaXMueiAhPT0gdGhpcy55ICYmIHRoaXMueiAhPT0gdGhpcy54ICkge1xuICAgICAgICB0aGlzLnoudXBsb2FkX2RhdGEoZ2wpXG4gICAgICB9ICAgICAgXG4gICAgfVxuICB9LFxuXG4gIGNvcHkoKSB7XG4gICAgcmV0dXJuIFZlYzMoIHRoaXMueCwgdGhpcy55LCB0aGlzLnogKVxuICB9XG5cbn1cblxuY29uc3QgVmVjNCA9IGZ1bmN0aW9uICh4PTAsIHksIHosIHcpIHtcbiAgaWYoIHgudHlwZSA9PT0gJ3ZlYzQnICkgcmV0dXJuIHhcbiAgY29uc3QgdiA9IE9iamVjdC5jcmVhdGUoIFZlYzQucHJvdG90eXBlIClcblxuICBpZiggQXJyYXkuaXNBcnJheSggeCApICkge1xuICAgIHYueCA9IHhbMF07IHYueSA9IHhbMV07IHYueiA9IHhbMl07IHYudyA9IHhbM10gXG4gIH0gZWxzZSBpZiggeSA9PT0gdW5kZWZpbmVkICYmIHogPT09IHVuZGVmaW5lZCkge1xuICAgIHYueCA9IHYueSA9IHYueiA9IHYudyA9IHhcbiAgfWVsc2V7XG4gICAgdi54ID0geDsgdi55ID0geTsgdi56ID0gejsgdi53ID0gdzs7XG4gIH1cblxuICB2LmlzR2VuID0gdi54LnR5cGUgPT09ICdzdHJpbmcnIHx8IHYueS50eXBlID09PSAnc3RyaW5nJyB8fCB2LnoudHlwZSA9PT0gJ3N0cmluZydcblxuICByZXR1cm4gdlxufTtcblxuVmVjNC5wcm90b3R5cGUgPSB7XG4gIHR5cGU6ICd2ZWM0JyxcbiAgZW1pdCgpIHsgXG4gICAgbGV0IG91dCA9IGB2ZWM0KGBcbiAgICBsZXQgcHJlZmFjZSA9ICcnXG5cbiAgICBpZiggdGhpcy54LnR5cGUgPT09ICdzdHJpbmcnICkge1xuICAgICAgY29uc3QgeG91dCA9IHRoaXMueC5lbWl0KClcbiAgICAgIG91dCArPSB4b3V0Lm91dCArICcsJ1xuICAgIH1lbHNle1xuICAgICAgb3V0ICs9IHRoaXMueCArICcsJ1xuICAgIH1cblxuICAgIGlmKCB0aGlzLnkudHlwZSA9PT0gJ3N0cmluZycgKSB7XG4gICAgICBjb25zdCB5b3V0ID0gdGhpcy55LmVtaXQoKVxuICAgICAgb3V0ICs9IHlvdXQub3V0ICsgJywnIFxuICAgIH1lbHNle1xuICAgICAgb3V0ICs9IHRoaXMueSArICcsJ1xuICAgIH1cblxuICAgIGlmKCB0aGlzLnoudHlwZSA9PT0gJ3N0cmluZycgKSB7XG4gICAgICBjb25zdCB6b3V0ID0gdGhpcy56LmVtaXQoKVxuICAgICAgb3V0ICs9IHpvdXQub3V0XG4gICAgfWVsc2V7XG4gICAgICBvdXQgKz0gdGhpcy56IFxuICAgIH1cbiAgICBcbiAgICBpZiggdGhpcy53LnR5cGUgPT09ICdzdHJpbmcnICkge1xuICAgICAgY29uc3Qgd291dCA9IHRoaXMudy5lbWl0KClcbiAgICAgIG91dCArPSB3b3V0Lm91dFxuICAgIH1lbHNle1xuICAgICAgb3V0ICs9IHRoaXMudyBcbiAgICB9XG5cbiAgICBvdXQgKz0gJyknXG5cbiAgICByZXR1cm4geyBvdXQsIHByZWZhY2UgfVxuICB9LFxuICBlbWl0X2RlY2woKSB7IFxuICAgIGxldCBvdXQgPSAnJ1xuICAgIGlmKCB0aGlzLngudHlwZSA9PT0gJ3N0cmluZycgKSB7XG4gICAgICBvdXQgKz0gdGhpcy54LmVtaXRfZGVjbCgpXG4gICAgfSBcbiAgICBpZiggdGhpcy55LnR5cGUgPT09ICdzdHJpbmcnICYmIHRoaXMueCAhPT0gdGhpcy55ICApIHtcbiAgICAgIG91dCArPSB0aGlzLnkuZW1pdF9kZWNsKClcbiAgICB9IFxuICAgIGlmKCB0aGlzLnoudHlwZSA9PT0gJ3N0cmluZycgJiYgdGhpcy56ICE9PSB0aGlzLnkgJiYgdGhpcy56ICE9PSB0aGlzLnggKSB7XG4gICAgICBvdXQgKz0gdGhpcy56LmVtaXRfZGVjbCgpXG4gICAgfSBcbiAgICBpZiggdGhpcy53LnR5cGUgPT09ICdzdHJpbmcnICYmIHRoaXMudyAhPT0gdGhpcy55ICYmIHRoaXMudyAhPT0gdGhpcy54ICYmIHRoaXMudyAhPT0gdGhpcy56ICkge1xuICAgICAgb3V0ICs9IHRoaXMudy5lbWl0X2RlY2woKVxuICAgIH1cbiAgICByZXR1cm4gb3V0XG4gIH0sXG5cblx0dXBkYXRlX2xvY2F0aW9uKGdsLCBwcm9ncmFtKSB7XG4gICAgaWYoIHRoaXMuaXNHZW4gKSB7XG4gICAgICBpZiggdGhpcy54LnR5cGUgPT09ICdzdHJpbmcnICkge1xuICAgICAgICB0aGlzLngudXBkYXRlX2xvY2F0aW9uKGdsLHByb2dyYW0pXG4gICAgICB9IFxuICAgICAgaWYoIHRoaXMueS50eXBlID09PSAnc3RyaW5nJyAmJiB0aGlzLnggIT09IHRoaXMueSAgKSB7XG4gICAgICAgIHRoaXMueS51cGRhdGVfbG9jYXRpb24oZ2wscHJvZ3JhbSlcbiAgICAgIH0gXG4gICAgICBpZiggdGhpcy56LnR5cGUgPT09ICdzdHJpbmcnICYmIHRoaXMueiAhPT0gdGhpcy55ICYmIHRoaXMueiAhPT0gdGhpcy54ICkge1xuICAgICAgICB0aGlzLnoudXBkYXRlX2xvY2F0aW9uKGdsLHByb2dyYW0pXG4gICAgICB9ICAgICAgXG4gICAgICBpZiggdGhpcy53LnR5cGUgPT09ICdzdHJpbmcnICYmIHRoaXMudyAhPT0gdGhpcy55ICYmIHRoaXMudyAhPT0gdGhpcy54ICYmIHRoaXMudyAhPT0gdGhpcy56ICkge1xuICAgICAgICB0aGlzLncudXBkYXRlX2xvY2F0aW9uKGdsLHByb2dyYW0pXG4gICAgICB9ICBcbiAgICB9XG4gIH0sXG4gIFxuICB1cGxvYWRfZGF0YShnbCkge1xuICAgIGlmKCB0aGlzLmlzR2VuICkge1xuICAgICAgaWYoIHRoaXMueC50eXBlID09PSAnc3RyaW5nJyApIHtcbiAgICAgICAgdGhpcy54LnVwbG9hZF9kYXRhKGdsKVxuICAgICAgfSBcbiAgICAgIGlmKCB0aGlzLnkudHlwZSA9PT0gJ3N0cmluZycgJiYgdGhpcy54ICE9PSB0aGlzLnkgICkge1xuICAgICAgICB0aGlzLnkudXBsb2FkX2RhdGEoZ2wpXG4gICAgICB9IFxuICAgICAgaWYoIHRoaXMuei50eXBlID09PSAnc3RyaW5nJyAmJiB0aGlzLnogIT09IHRoaXMueSAmJiB0aGlzLnogIT09IHRoaXMueCApIHtcbiAgICAgICAgdGhpcy56LnVwbG9hZF9kYXRhKGdsKVxuICAgICAgfSBcbiAgICAgIGlmKCB0aGlzLncudHlwZSA9PT0gJ3N0cmluZycgJiYgdGhpcy53ICE9PSB0aGlzLnkgJiYgdGhpcy53ICE9PSB0aGlzLnggJiYgdGhpcy53ICE9PSB0aGlzLnogKSB7XG4gICAgICAgIHRoaXMudy51cGxvYWRfZGF0YShnbClcbiAgICAgIH0gICAgICBcbiAgICB9XG4gIH0sXG5cbiAgY29weSgpIHtcbiAgICByZXR1cm4gVmVjNCggdGhpcy54LCB0aGlzLnksIHRoaXMueiwgdGhpcy53IClcbiAgfVxufVxuLy8gVmVjNFxuXG4vL2xldCBWZWM0ID0gZnVuY3Rpb24gKHgsIHksIHosIHcpIHtcbi8vICBjb25zdCB2ID0gT2JqZWN0LmNyZWF0ZSggVmVjNC5wcm90b3R5cGUgKVxuLy8gIHYueCA9IHg7IHYueSA9IHk7IHYueiA9IHo7IHYudyA9IHdcblxuLy8gIHJldHVybiB2XG4vL307XG5cbi8vVmVjNC5wcm90b3R5cGUgPSB7XG4vLyAgdHlwZTogJ3ZlYzQnLFxuLy8gIGVtaXQoKSB7IHJldHVybiBcInZlYzQoXCIgKyB0aGlzLnggKyBcIixcIiArIHRoaXMueSArIFwiLFwiICsgdGhpcy56ICsgXCIsXCIgKyB0aGlzLncgKyBcIilcIjsgfSxcbi8vICBlbWl0X2RlY2woKSB7IHJldHVybiBcIlwiOyB9XG4vL31cblxuXG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgVmVjMiwgVmVjMywgVmVjNCB9IFxuIiwiY29uc3QgU2NlbmVOb2RlID0gcmVxdWlyZSggJy4vc2NlbmVOb2RlLmpzJyApLFxuICAgICAgeyBwYXJhbV93cmFwLCBNYXRlcmlhbElEIH0gPSByZXF1aXJlKCAnLi91dGlscy5qcycgKSxcbiAgICAgIHsgVmFyLCBmbG9hdF92YXJfZ2VuLCB2ZWMyX3Zhcl9nZW4sIHZlYzNfdmFyX2dlbiwgdmVjNF92YXJfZ2VuLCBpbnRfdmFyX2dlbiwgVmFyQWxsb2MgfSA9IHJlcXVpcmUoICcuL3Zhci5qcycgKVxuXG5jb25zdCBWaWduZXR0ZSA9IGZ1bmN0aW9uKCBTY2VuZSwgU0RGICkge1xuXG4gIGNvbnN0IFZnbiA9IGZ1bmN0aW9uKCByYWRpdXM9MC4xLCBzbW9vdGhuZXNzPS4xICkge1xuICAgIGNvbnN0IHZnbiA9IE9iamVjdC5jcmVhdGUoIFZnbi5wcm90b3R5cGUgKVxuICAgIGNvbnN0IF9fcmFkaXVzID0gcGFyYW1fd3JhcCggcmFkaXVzLCBmbG9hdF92YXJfZ2VuKCByYWRpdXMgKSApICBcbiAgICBcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHZnbiwgJ3JhZGl1cycsIHtcbiAgICAgIGdldCgpIHsgcmV0dXJuIF9fcmFkaXVzIH0sXG4gICAgICBzZXQoIHYgKSB7XG4gICAgICAgIF9fcmFkaXVzLnNldCggdiApXG4gICAgICB9XG4gICAgfSlcblxuICAgIGNvbnN0IF9fc21vb3RobmVzcyA9IHBhcmFtX3dyYXAoIHNtb290aG5lc3MsIGZsb2F0X3Zhcl9nZW4oIHNtb290aG5lc3MgKSApICBcbiAgICBcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHZnbiwgJ3Ntb290aG5lc3MnLCB7XG4gICAgICBnZXQoKSB7IHJldHVybiBfX3Ntb290aG5lc3MgfSxcbiAgICAgIHNldCggdiApIHtcbiAgICAgICAgX19zbW9vdGhuZXNzLnNldCggdiApXG4gICAgICB9XG4gICAgfSlcbiAgICBcbiAgICAvLyB0aGlzIHJlZmVycyB0byB0aGUgY3VycmVudCBzY2VuZSB2aWEgaW1wbGljaXQgYmluZGluZyBpbiBzY2VuZS5qc1xuICAgIHRoaXMucG9zdHByb2Nlc3NpbmcucHVzaCggdmduIClcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBWZ24ucHJvdG90eXBlID0gU2NlbmVOb2RlKClcbiBcbiAgT2JqZWN0LmFzc2lnbiggVmduLnByb3RvdHlwZSwge1xuICAgIGVtaXQoKSB7XG4gICAgICByZXR1cm4gYCAgY29sb3IgKj0gdmlnbmV0dGUoIHZfdXYsICR7dGhpcy5yYWRpdXMuZW1pdCgpfSwgJHt0aGlzLnNtb290aG5lc3MuZW1pdCgpfSApO2BcbiAgICB9LFxuICAgXG4gICAgZW1pdF9kZWNsKCkge1xuICAgICAgbGV0IHN0ciA9IHRoaXMucmFkaXVzLmVtaXRfZGVjbCgpICsgdGhpcy5zbW9vdGhuZXNzLmVtaXRfZGVjbCgpXG4gICAgICAvLyB0YWtlbiBmcm9tIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3ItbHllaC1hcmNoaXZlZC8xNzBiNTNmY2RjMGUxN2FmY2YxNVxuICAgICAgLy8gb3JpZ2luYWxseSBpcVxuICAgICAgY29uc3QgcHJlZmFjZSA9IGAgIGZsb2F0IHZpZ25ldHRlKHZlYzIgdXYsIGZsb2F0IHJhZGl1cywgZmxvYXQgc21vb3RobmVzcykge1xuICAgICAgICByZXR1cm4gcmFkaXVzICsgMC41KjE2LjAqdXYueCp1di55KigxLjAtdXYueCkqKDEuMC11di55KTsgXG4gICAgICB9XG4gIGBcbiAgICAgIGlmKCBTREYubWVtby52Z24gPT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgc3RyID0gc3RyICsgcHJlZmFjZVxuICAgICAgICBTREYubWVtby52Z24gPSB0cnVlXG4gICAgICB9ZWxzZXtcbiAgICAgICAgc3RyID0gJydcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0clxuICAgIH0sXG5cbiAgICB1cGRhdGVfbG9jYXRpb24oIGdsLCBwcm9ncmFtICkge1xuICAgICAgdGhpcy5yYWRpdXMudXBkYXRlX2xvY2F0aW9uKCBnbCwgcHJvZ3JhbSApXG4gICAgICB0aGlzLnNtb290aG5lc3MudXBkYXRlX2xvY2F0aW9uKCBnbCwgcHJvZ3JhbSApXG4gICAgfSxcblxuICAgIHVwbG9hZF9kYXRhKCBnbCApIHtcbiAgICAgIHRoaXMucmFkaXVzLnVwbG9hZF9kYXRhKCBnbCApXG4gICAgICB0aGlzLnNtb290aG5lc3MudXBsb2FkX2RhdGEoIGdsIClcbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIFZnblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFZpZ25ldHRlIFxuIiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgdmFyIGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8XG4gICAgICByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPVxuICAgICAgKCh1aW50OFtpXSA8PCAxNikgJiAweEZGMDAwMCkgK1xuICAgICAgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweEZGMDApICtcbiAgICAgICh1aW50OFtpICsgMl0gJiAweEZGKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKFxuICAgICAgdWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKVxuICAgICkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcbiAgICAgICc9PSdcbiAgICApXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcbiAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXG4gICAgICAnPSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiIsIi8qKlxuICogQml0IHR3aWRkbGluZyBoYWNrcyBmb3IgSmF2YVNjcmlwdC5cbiAqXG4gKiBBdXRob3I6IE1pa29sYSBMeXNlbmtvXG4gKlxuICogUG9ydGVkIGZyb20gU3RhbmZvcmQgYml0IHR3aWRkbGluZyBoYWNrIGxpYnJhcnk6XG4gKiAgICBodHRwOi8vZ3JhcGhpY3Muc3RhbmZvcmQuZWR1L35zZWFuZGVyL2JpdGhhY2tzLmh0bWxcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjsgXCJ1c2UgcmVzdHJpY3RcIjtcblxuLy9OdW1iZXIgb2YgYml0cyBpbiBhbiBpbnRlZ2VyXG52YXIgSU5UX0JJVFMgPSAzMjtcblxuLy9Db25zdGFudHNcbmV4cG9ydHMuSU5UX0JJVFMgID0gSU5UX0JJVFM7XG5leHBvcnRzLklOVF9NQVggICA9ICAweDdmZmZmZmZmO1xuZXhwb3J0cy5JTlRfTUlOICAgPSAtMTw8KElOVF9CSVRTLTEpO1xuXG4vL1JldHVybnMgLTEsIDAsICsxIGRlcGVuZGluZyBvbiBzaWduIG9mIHhcbmV4cG9ydHMuc2lnbiA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuICh2ID4gMCkgLSAodiA8IDApO1xufVxuXG4vL0NvbXB1dGVzIGFic29sdXRlIHZhbHVlIG9mIGludGVnZXJcbmV4cG9ydHMuYWJzID0gZnVuY3Rpb24odikge1xuICB2YXIgbWFzayA9IHYgPj4gKElOVF9CSVRTLTEpO1xuICByZXR1cm4gKHYgXiBtYXNrKSAtIG1hc2s7XG59XG5cbi8vQ29tcHV0ZXMgbWluaW11bSBvZiBpbnRlZ2VycyB4IGFuZCB5XG5leHBvcnRzLm1pbiA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgcmV0dXJuIHkgXiAoKHggXiB5KSAmIC0oeCA8IHkpKTtcbn1cblxuLy9Db21wdXRlcyBtYXhpbXVtIG9mIGludGVnZXJzIHggYW5kIHlcbmV4cG9ydHMubWF4ID0gZnVuY3Rpb24oeCwgeSkge1xuICByZXR1cm4geCBeICgoeCBeIHkpICYgLSh4IDwgeSkpO1xufVxuXG4vL0NoZWNrcyBpZiBhIG51bWJlciBpcyBhIHBvd2VyIG9mIHR3b1xuZXhwb3J0cy5pc1BvdzIgPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiAhKHYgJiAodi0xKSkgJiYgKCEhdik7XG59XG5cbi8vQ29tcHV0ZXMgbG9nIGJhc2UgMiBvZiB2XG5leHBvcnRzLmxvZzIgPSBmdW5jdGlvbih2KSB7XG4gIHZhciByLCBzaGlmdDtcbiAgciA9ICAgICAodiA+IDB4RkZGRikgPDwgNDsgdiA+Pj49IHI7XG4gIHNoaWZ0ID0gKHYgPiAweEZGICApIDw8IDM7IHYgPj4+PSBzaGlmdDsgciB8PSBzaGlmdDtcbiAgc2hpZnQgPSAodiA+IDB4RiAgICkgPDwgMjsgdiA+Pj49IHNoaWZ0OyByIHw9IHNoaWZ0O1xuICBzaGlmdCA9ICh2ID4gMHgzICAgKSA8PCAxOyB2ID4+Pj0gc2hpZnQ7IHIgfD0gc2hpZnQ7XG4gIHJldHVybiByIHwgKHYgPj4gMSk7XG59XG5cbi8vQ29tcHV0ZXMgbG9nIGJhc2UgMTAgb2YgdlxuZXhwb3J0cy5sb2cxMCA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuICAodiA+PSAxMDAwMDAwMDAwKSA/IDkgOiAodiA+PSAxMDAwMDAwMDApID8gOCA6ICh2ID49IDEwMDAwMDAwKSA/IDcgOlxuICAgICAgICAgICh2ID49IDEwMDAwMDApID8gNiA6ICh2ID49IDEwMDAwMCkgPyA1IDogKHYgPj0gMTAwMDApID8gNCA6XG4gICAgICAgICAgKHYgPj0gMTAwMCkgPyAzIDogKHYgPj0gMTAwKSA/IDIgOiAodiA+PSAxMCkgPyAxIDogMDtcbn1cblxuLy9Db3VudHMgbnVtYmVyIG9mIGJpdHNcbmV4cG9ydHMucG9wQ291bnQgPSBmdW5jdGlvbih2KSB7XG4gIHYgPSB2IC0gKCh2ID4+PiAxKSAmIDB4NTU1NTU1NTUpO1xuICB2ID0gKHYgJiAweDMzMzMzMzMzKSArICgodiA+Pj4gMikgJiAweDMzMzMzMzMzKTtcbiAgcmV0dXJuICgodiArICh2ID4+PiA0KSAmIDB4RjBGMEYwRikgKiAweDEwMTAxMDEpID4+PiAyNDtcbn1cblxuLy9Db3VudHMgbnVtYmVyIG9mIHRyYWlsaW5nIHplcm9zXG5mdW5jdGlvbiBjb3VudFRyYWlsaW5nWmVyb3Modikge1xuICB2YXIgYyA9IDMyO1xuICB2ICY9IC12O1xuICBpZiAodikgYy0tO1xuICBpZiAodiAmIDB4MDAwMEZGRkYpIGMgLT0gMTY7XG4gIGlmICh2ICYgMHgwMEZGMDBGRikgYyAtPSA4O1xuICBpZiAodiAmIDB4MEYwRjBGMEYpIGMgLT0gNDtcbiAgaWYgKHYgJiAweDMzMzMzMzMzKSBjIC09IDI7XG4gIGlmICh2ICYgMHg1NTU1NTU1NSkgYyAtPSAxO1xuICByZXR1cm4gYztcbn1cbmV4cG9ydHMuY291bnRUcmFpbGluZ1plcm9zID0gY291bnRUcmFpbGluZ1plcm9zO1xuXG4vL1JvdW5kcyB0byBuZXh0IHBvd2VyIG9mIDJcbmV4cG9ydHMubmV4dFBvdzIgPSBmdW5jdGlvbih2KSB7XG4gIHYgKz0gdiA9PT0gMDtcbiAgLS12O1xuICB2IHw9IHYgPj4+IDE7XG4gIHYgfD0gdiA+Pj4gMjtcbiAgdiB8PSB2ID4+PiA0O1xuICB2IHw9IHYgPj4+IDg7XG4gIHYgfD0gdiA+Pj4gMTY7XG4gIHJldHVybiB2ICsgMTtcbn1cblxuLy9Sb3VuZHMgZG93biB0byBwcmV2aW91cyBwb3dlciBvZiAyXG5leHBvcnRzLnByZXZQb3cyID0gZnVuY3Rpb24odikge1xuICB2IHw9IHYgPj4+IDE7XG4gIHYgfD0gdiA+Pj4gMjtcbiAgdiB8PSB2ID4+PiA0O1xuICB2IHw9IHYgPj4+IDg7XG4gIHYgfD0gdiA+Pj4gMTY7XG4gIHJldHVybiB2IC0gKHY+Pj4xKTtcbn1cblxuLy9Db21wdXRlcyBwYXJpdHkgb2Ygd29yZFxuZXhwb3J0cy5wYXJpdHkgPSBmdW5jdGlvbih2KSB7XG4gIHYgXj0gdiA+Pj4gMTY7XG4gIHYgXj0gdiA+Pj4gODtcbiAgdiBePSB2ID4+PiA0O1xuICB2ICY9IDB4ZjtcbiAgcmV0dXJuICgweDY5OTYgPj4+IHYpICYgMTtcbn1cblxudmFyIFJFVkVSU0VfVEFCTEUgPSBuZXcgQXJyYXkoMjU2KTtcblxuKGZ1bmN0aW9uKHRhYikge1xuICBmb3IodmFyIGk9MDsgaTwyNTY7ICsraSkge1xuICAgIHZhciB2ID0gaSwgciA9IGksIHMgPSA3O1xuICAgIGZvciAodiA+Pj49IDE7IHY7IHYgPj4+PSAxKSB7XG4gICAgICByIDw8PSAxO1xuICAgICAgciB8PSB2ICYgMTtcbiAgICAgIC0tcztcbiAgICB9XG4gICAgdGFiW2ldID0gKHIgPDwgcykgJiAweGZmO1xuICB9XG59KShSRVZFUlNFX1RBQkxFKTtcblxuLy9SZXZlcnNlIGJpdHMgaW4gYSAzMiBiaXQgd29yZFxuZXhwb3J0cy5yZXZlcnNlID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gIChSRVZFUlNFX1RBQkxFWyB2ICAgICAgICAgJiAweGZmXSA8PCAyNCkgfFxuICAgICAgICAgIChSRVZFUlNFX1RBQkxFWyh2ID4+PiA4KSAgJiAweGZmXSA8PCAxNikgfFxuICAgICAgICAgIChSRVZFUlNFX1RBQkxFWyh2ID4+PiAxNikgJiAweGZmXSA8PCA4KSAgfFxuICAgICAgICAgICBSRVZFUlNFX1RBQkxFWyh2ID4+PiAyNCkgJiAweGZmXTtcbn1cblxuLy9JbnRlcmxlYXZlIGJpdHMgb2YgMiBjb29yZGluYXRlcyB3aXRoIDE2IGJpdHMuICBVc2VmdWwgZm9yIGZhc3QgcXVhZHRyZWUgY29kZXNcbmV4cG9ydHMuaW50ZXJsZWF2ZTIgPSBmdW5jdGlvbih4LCB5KSB7XG4gIHggJj0gMHhGRkZGO1xuICB4ID0gKHggfCAoeCA8PCA4KSkgJiAweDAwRkYwMEZGO1xuICB4ID0gKHggfCAoeCA8PCA0KSkgJiAweDBGMEYwRjBGO1xuICB4ID0gKHggfCAoeCA8PCAyKSkgJiAweDMzMzMzMzMzO1xuICB4ID0gKHggfCAoeCA8PCAxKSkgJiAweDU1NTU1NTU1O1xuXG4gIHkgJj0gMHhGRkZGO1xuICB5ID0gKHkgfCAoeSA8PCA4KSkgJiAweDAwRkYwMEZGO1xuICB5ID0gKHkgfCAoeSA8PCA0KSkgJiAweDBGMEYwRjBGO1xuICB5ID0gKHkgfCAoeSA8PCAyKSkgJiAweDMzMzMzMzMzO1xuICB5ID0gKHkgfCAoeSA8PCAxKSkgJiAweDU1NTU1NTU1O1xuXG4gIHJldHVybiB4IHwgKHkgPDwgMSk7XG59XG5cbi8vRXh0cmFjdHMgdGhlIG50aCBpbnRlcmxlYXZlZCBjb21wb25lbnRcbmV4cG9ydHMuZGVpbnRlcmxlYXZlMiA9IGZ1bmN0aW9uKHYsIG4pIHtcbiAgdiA9ICh2ID4+PiBuKSAmIDB4NTU1NTU1NTU7XG4gIHYgPSAodiB8ICh2ID4+PiAxKSkgICYgMHgzMzMzMzMzMztcbiAgdiA9ICh2IHwgKHYgPj4+IDIpKSAgJiAweDBGMEYwRjBGO1xuICB2ID0gKHYgfCAodiA+Pj4gNCkpICAmIDB4MDBGRjAwRkY7XG4gIHYgPSAodiB8ICh2ID4+PiAxNikpICYgMHgwMDBGRkZGO1xuICByZXR1cm4gKHYgPDwgMTYpID4+IDE2O1xufVxuXG5cbi8vSW50ZXJsZWF2ZSBiaXRzIG9mIDMgY29vcmRpbmF0ZXMsIGVhY2ggd2l0aCAxMCBiaXRzLiAgVXNlZnVsIGZvciBmYXN0IG9jdHJlZSBjb2Rlc1xuZXhwb3J0cy5pbnRlcmxlYXZlMyA9IGZ1bmN0aW9uKHgsIHksIHopIHtcbiAgeCAmPSAweDNGRjtcbiAgeCAgPSAoeCB8ICh4PDwxNikpICYgNDI3ODE5MDMzNTtcbiAgeCAgPSAoeCB8ICh4PDw4KSkgICYgMjUxNzE5Njk1O1xuICB4ICA9ICh4IHwgKHg8PDQpKSAgJiAzMjcyMzU2MDM1O1xuICB4ICA9ICh4IHwgKHg8PDIpKSAgJiAxMjI3MTMzNTEzO1xuXG4gIHkgJj0gMHgzRkY7XG4gIHkgID0gKHkgfCAoeTw8MTYpKSAmIDQyNzgxOTAzMzU7XG4gIHkgID0gKHkgfCAoeTw8OCkpICAmIDI1MTcxOTY5NTtcbiAgeSAgPSAoeSB8ICh5PDw0KSkgICYgMzI3MjM1NjAzNTtcbiAgeSAgPSAoeSB8ICh5PDwyKSkgICYgMTIyNzEzMzUxMztcbiAgeCB8PSAoeSA8PCAxKTtcbiAgXG4gIHogJj0gMHgzRkY7XG4gIHogID0gKHogfCAoejw8MTYpKSAmIDQyNzgxOTAzMzU7XG4gIHogID0gKHogfCAoejw8OCkpICAmIDI1MTcxOTY5NTtcbiAgeiAgPSAoeiB8ICh6PDw0KSkgICYgMzI3MjM1NjAzNTtcbiAgeiAgPSAoeiB8ICh6PDwyKSkgICYgMTIyNzEzMzUxMztcbiAgXG4gIHJldHVybiB4IHwgKHogPDwgMik7XG59XG5cbi8vRXh0cmFjdHMgbnRoIGludGVybGVhdmVkIGNvbXBvbmVudCBvZiBhIDMtdHVwbGVcbmV4cG9ydHMuZGVpbnRlcmxlYXZlMyA9IGZ1bmN0aW9uKHYsIG4pIHtcbiAgdiA9ICh2ID4+PiBuKSAgICAgICAmIDEyMjcxMzM1MTM7XG4gIHYgPSAodiB8ICh2Pj4+MikpICAgJiAzMjcyMzU2MDM1O1xuICB2ID0gKHYgfCAodj4+PjQpKSAgICYgMjUxNzE5Njk1O1xuICB2ID0gKHYgfCAodj4+PjgpKSAgICYgNDI3ODE5MDMzNTtcbiAgdiA9ICh2IHwgKHY+Pj4xNikpICAmIDB4M0ZGO1xuICByZXR1cm4gKHY8PDIyKT4+MjI7XG59XG5cbi8vQ29tcHV0ZXMgbmV4dCBjb21iaW5hdGlvbiBpbiBjb2xleGljb2dyYXBoaWMgb3JkZXIgKHRoaXMgaXMgbWlzdGFrZW5seSBjYWxsZWQgbmV4dFBlcm11dGF0aW9uIG9uIHRoZSBiaXQgdHdpZGRsaW5nIGhhY2tzIHBhZ2UpXG5leHBvcnRzLm5leHRDb21iaW5hdGlvbiA9IGZ1bmN0aW9uKHYpIHtcbiAgdmFyIHQgPSB2IHwgKHYgLSAxKTtcbiAgcmV0dXJuICh0ICsgMSkgfCAoKCh+dCAmIC1+dCkgLSAxKSA+Pj4gKGNvdW50VHJhaWxpbmdaZXJvcyh2KSArIDEpKTtcbn1cblxuIiwiIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxudmFyIGN1c3RvbUluc3BlY3RTeW1ib2wgPVxuICAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sLmZvciA9PT0gJ2Z1bmN0aW9uJylcbiAgICA/IFN5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJylcbiAgICA6IG51bGxcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG52YXIgS19NQVhfTEVOR1RIID0gMHg3ZmZmZmZmZlxuZXhwb3J0cy5rTWF4TGVuZ3RoID0gS19NQVhfTEVOR1RIXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFByaW50IHdhcm5pbmcgYW5kIHJlY29tbWVuZCB1c2luZyBgYnVmZmVyYCB2NC54IHdoaWNoIGhhcyBhbiBPYmplY3RcbiAqICAgICAgICAgICAgICAgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIFdlIHJlcG9ydCB0aGF0IHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGlmIHRoZSBhcmUgbm90IHN1YmNsYXNzYWJsZVxuICogdXNpbmcgX19wcm90b19fLiBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YFxuICogKFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4KS4gSUUgMTAgbGFja3Mgc3VwcG9ydFxuICogZm9yIF9fcHJvdG9fXyBhbmQgaGFzIGEgYnVnZ3kgdHlwZWQgYXJyYXkgaW1wbGVtZW50YXRpb24uXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gdHlwZWRBcnJheVN1cHBvcnQoKVxuXG5pZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gIGNvbnNvbGUuZXJyb3IoXG4gICAgJ1RoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSAnICtcbiAgICAnYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC4nXG4gIClcbn1cblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICAvLyBDYW4gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWQ/XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgdmFyIHByb3RvID0geyBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH0gfVxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihwcm90bywgVWludDhBcnJheS5wcm90b3R5cGUpXG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGFyciwgcHJvdG8pXG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDJcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAncGFyZW50Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ1ZmZlclxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ29mZnNldCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5ieXRlT2Zmc2V0XG4gIH1cbn0pXG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAobGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIGxlbmd0aCArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlci5wcm90b3R5cGUpXG4gIHJldHVybiBidWZcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG5mdW5jdGlvbiBmcm9tICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHZhbHVlKVxuICB9XG5cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICAgIClcbiAgfVxuXG4gIGlmIChpc0luc3RhbmNlKHZhbHVlLCBBcnJheUJ1ZmZlcikgfHxcbiAgICAgICh2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgQXJyYXlCdWZmZXIpKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAoaXNJbnN0YW5jZSh2YWx1ZSwgU2hhcmVkQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIFNoYXJlZEFycmF5QnVmZmVyKSkpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgIClcbiAgfVxuXG4gIHZhciB2YWx1ZU9mID0gdmFsdWUudmFsdWVPZiAmJiB2YWx1ZS52YWx1ZU9mKClcbiAgaWYgKHZhbHVlT2YgIT0gbnVsbCAmJiB2YWx1ZU9mICE9PSB2YWx1ZSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZU9mLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICB2YXIgYiA9IGZyb21PYmplY3QodmFsdWUpXG4gIGlmIChiKSByZXR1cm4gYlxuXG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9QcmltaXRpdmUgIT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oXG4gICAgICB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdKCdzdHJpbmcnKSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoXG4gICAgKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICApXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gTm90ZTogQ2hhbmdlIHByb3RvdHlwZSAqYWZ0ZXIqIEJ1ZmZlci5mcm9tIGlzIGRlZmluZWQgdG8gd29ya2Fyb3VuZCBDaHJvbWUgYnVnOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC8xNDhcbk9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIucHJvdG90eXBlLCBVaW50OEFycmF5LnByb3RvdHlwZSlcbk9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIsIFVpbnQ4QXJyYXkpXG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBzaXplICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAoc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IGJ1Zi53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wib2Zmc2V0XCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJsZW5ndGhcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgdmFyIGJ1ZlxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1ZiwgQnVmZmVyLnByb3RvdHlwZSlcblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbilcblxuICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnVmXG4gICAgfVxuXG4gICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgbnVtYmVySXNOYU4ob2JqLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoMClcbiAgICB9XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKVxuICB9XG5cbiAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iai5kYXRhKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBLX01BWF9MRU5HVEhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIEtfTUFYX0xFTkdUSC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gdHJ1ZSAmJlxuICAgIGIgIT09IEJ1ZmZlci5wcm90b3R5cGUgLy8gc28gQnVmZmVyLmlzQnVmZmVyKEJ1ZmZlci5wcm90b3R5cGUpIHdpbGwgYmUgZmFsc2Vcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmIChpc0luc3RhbmNlKGEsIFVpbnQ4QXJyYXkpKSBhID0gQnVmZmVyLmZyb20oYSwgYS5vZmZzZXQsIGEuYnl0ZUxlbmd0aClcbiAgaWYgKGlzSW5zdGFuY2UoYiwgVWludDhBcnJheSkpIGIgPSBCdWZmZXIuZnJvbShiLCBiLm9mZnNldCwgYi5ieXRlTGVuZ3RoKVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJidWYxXCIsIFwiYnVmMlwiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5J1xuICAgIClcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmIChpc0luc3RhbmNlKGJ1ZiwgVWludDhBcnJheSkpIHtcbiAgICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGJ1ZilcbiAgICB9XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgaXNJbnN0YW5jZShzdHJpbmcsIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBzdHJpbmdcbiAgICApXG4gIH1cblxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbXVzdE1hdGNoID0gKGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSA9PT0gdHJ1ZSlcbiAgaWYgKCFtdXN0TWF0Y2ggJiYgbGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB7XG4gICAgICAgICAgcmV0dXJuIG11c3RNYXRjaCA/IC0xIDogdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCAoYW5kIHRoZSBgaXMtYnVmZmVyYCBucG0gcGFja2FnZSlcbi8vIHRvIGRldGVjdCBhIEJ1ZmZlciBpbnN0YW5jZS4gSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGBpbnN0YW5jZW9mIEJ1ZmZlcmBcbi8vIHJlbGlhYmx5IGluIGEgYnJvd3NlcmlmeSBjb250ZXh0IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50XG4vLyBjb3BpZXMgb2YgdGhlICdidWZmZXInIHBhY2thZ2UgaW4gdXNlLiBUaGlzIG1ldGhvZCB3b3JrcyBldmVuIGZvciBCdWZmZXJcbi8vIGluc3RhbmNlcyB0aGF0IHdlcmUgY3JlYXRlZCBmcm9tIGFub3RoZXIgY29weSBvZiB0aGUgYGJ1ZmZlcmAgcGFja2FnZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE1NFxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgdmFyIGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyA9IEJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmdcblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICB2YXIgc3RyID0gJydcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5yZXBsYWNlKC8oLnsyfSkvZywgJyQxICcpLnRyaW0oKVxuICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5pZiAoY3VzdG9tSW5zcGVjdFN5bWJvbCkge1xuICBCdWZmZXIucHJvdG90eXBlW2N1c3RvbUluc3BlY3RTeW1ib2xdID0gQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmIChpc0luc3RhbmNlKHRhcmdldCwgVWludDhBcnJheSkpIHtcbiAgICB0YXJnZXQgPSBCdWZmZXIuZnJvbSh0YXJnZXQsIHRhcmdldC5vZmZzZXQsIHRhcmdldC5ieXRlTGVuZ3RoKVxuICB9XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInRhcmdldFwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdGFyZ2V0KVxuICAgIClcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICB2YXIgeSA9IGVuZCAtIHN0YXJ0XG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIHZhciB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKG51bWJlcklzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgW3ZhbF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIHZhciBpbmRleFNpemUgPSAxXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIHZhciBpXG4gIGlmIChkaXIpIHtcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIHZhciByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChudW1iZXJJc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA+Pj4gMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSBoZXhTbGljZUxvb2t1cFRhYmxlW2J1ZltpXV1cbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgKGJ5dGVzW2kgKyAxXSAqIDI1NikpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG5ld0J1ZiwgQnVmZmVyLnByb3RvdHlwZSlcblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aFxuICB2YXIgbXVsID0gMVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IDBcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgc2hvdWxkIGJlIGEgQnVmZmVyJylcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBVc2UgYnVpbHQtaW4gd2hlbiBhdmFpbGFibGUsIG1pc3NpbmcgZnJvbSBJRTExXG4gICAgdGhpcy5jb3B5V2l0aGluKHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKVxuICB9IGVsc2UgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yICh2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoKGVuY29kaW5nID09PSAndXRmOCcgJiYgY29kZSA8IDEyOCkgfHxcbiAgICAgICAgICBlbmNvZGluZyA9PT0gJ2xhdGluMScpIHtcbiAgICAgICAgLy8gRmFzdCBwYXRoOiBJZiBgdmFsYCBmaXRzIGludG8gYSBzaW5nbGUgYnl0ZSwgdXNlIHRoYXQgbnVtZXJpYyB2YWx1ZS5cbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdib29sZWFuJykge1xuICAgIHZhbCA9IE51bWJlcih2YWwpXG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFwiJyArIHZhbCArXG4gICAgICAgICdcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHRha2VzIGVxdWFsIHNpZ25zIGFzIGVuZCBvZiB0aGUgQmFzZTY0IGVuY29kaW5nXG4gIHN0ciA9IHN0ci5zcGxpdCgnPScpWzBdXG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbi8vIEFycmF5QnVmZmVyIG9yIFVpbnQ4QXJyYXkgb2JqZWN0cyBmcm9tIG90aGVyIGNvbnRleHRzIChpLmUuIGlmcmFtZXMpIGRvIG5vdCBwYXNzXG4vLyB0aGUgYGluc3RhbmNlb2ZgIGNoZWNrIGJ1dCB0aGV5IHNob3VsZCBiZSB0cmVhdGVkIGFzIG9mIHRoYXQgdHlwZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE2NlxuZnVuY3Rpb24gaXNJbnN0YW5jZSAob2JqLCB0eXBlKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiB0eXBlIHx8XG4gICAgKG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvciAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lICE9IG51bGwgJiZcbiAgICAgIG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSB0eXBlLm5hbWUpXG59XG5mdW5jdGlvbiBudW1iZXJJc05hTiAob2JqKSB7XG4gIC8vIEZvciBJRTExIHN1cHBvcnRcbiAgcmV0dXJuIG9iaiAhPT0gb2JqIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG5cbi8vIENyZWF0ZSBsb29rdXAgdGFibGUgZm9yIGB0b1N0cmluZygnaGV4JylgXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8yMTlcbnZhciBoZXhTbGljZUxvb2t1cFRhYmxlID0gKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFscGhhYmV0ID0gJzAxMjM0NTY3ODlhYmNkZWYnXG4gIHZhciB0YWJsZSA9IG5ldyBBcnJheSgyNTYpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgIHZhciBpMTYgPSBpICogMTZcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IDE2OyArK2opIHtcbiAgICAgIHRhYmxlW2kxNiArIGpdID0gYWxwaGFiZXRbaV0gKyBhbHBoYWJldFtqXVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGFibGVcbn0pKClcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuXG5mdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICBpZiAoQXJyYXkuaXNBcnJheSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFyZyk7XG4gIH1cbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSBCdWZmZXIuaXNCdWZmZXI7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiXG5cbnZhciBjcmVhdGVUaHVuayA9IHJlcXVpcmUoXCIuL2xpYi90aHVuay5qc1wiKVxuXG5mdW5jdGlvbiBQcm9jZWR1cmUoKSB7XG4gIHRoaXMuYXJnVHlwZXMgPSBbXVxuICB0aGlzLnNoaW1BcmdzID0gW11cbiAgdGhpcy5hcnJheUFyZ3MgPSBbXVxuICB0aGlzLmFycmF5QmxvY2tJbmRpY2VzID0gW11cbiAgdGhpcy5zY2FsYXJBcmdzID0gW11cbiAgdGhpcy5vZmZzZXRBcmdzID0gW11cbiAgdGhpcy5vZmZzZXRBcmdJbmRleCA9IFtdXG4gIHRoaXMuaW5kZXhBcmdzID0gW11cbiAgdGhpcy5zaGFwZUFyZ3MgPSBbXVxuICB0aGlzLmZ1bmNOYW1lID0gXCJcIlxuICB0aGlzLnByZSA9IG51bGxcbiAgdGhpcy5ib2R5ID0gbnVsbFxuICB0aGlzLnBvc3QgPSBudWxsXG4gIHRoaXMuZGVidWcgPSBmYWxzZVxufVxuXG5mdW5jdGlvbiBjb21waWxlQ3dpc2UodXNlcl9hcmdzKSB7XG4gIC8vQ3JlYXRlIHByb2NlZHVyZVxuICB2YXIgcHJvYyA9IG5ldyBQcm9jZWR1cmUoKVxuICBcbiAgLy9QYXJzZSBibG9ja3NcbiAgcHJvYy5wcmUgICAgPSB1c2VyX2FyZ3MucHJlXG4gIHByb2MuYm9keSAgID0gdXNlcl9hcmdzLmJvZHlcbiAgcHJvYy5wb3N0ICAgPSB1c2VyX2FyZ3MucG9zdFxuXG4gIC8vUGFyc2UgYXJndW1lbnRzXG4gIHZhciBwcm9jX2FyZ3MgPSB1c2VyX2FyZ3MuYXJncy5zbGljZSgwKVxuICBwcm9jLmFyZ1R5cGVzID0gcHJvY19hcmdzXG4gIGZvcih2YXIgaT0wOyBpPHByb2NfYXJncy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBhcmdfdHlwZSA9IHByb2NfYXJnc1tpXVxuICAgIGlmKGFyZ190eXBlID09PSBcImFycmF5XCIgfHwgKHR5cGVvZiBhcmdfdHlwZSA9PT0gXCJvYmplY3RcIiAmJiBhcmdfdHlwZS5ibG9ja0luZGljZXMpKSB7XG4gICAgICBwcm9jLmFyZ1R5cGVzW2ldID0gXCJhcnJheVwiXG4gICAgICBwcm9jLmFycmF5QXJncy5wdXNoKGkpXG4gICAgICBwcm9jLmFycmF5QmxvY2tJbmRpY2VzLnB1c2goYXJnX3R5cGUuYmxvY2tJbmRpY2VzID8gYXJnX3R5cGUuYmxvY2tJbmRpY2VzIDogMClcbiAgICAgIHByb2Muc2hpbUFyZ3MucHVzaChcImFycmF5XCIgKyBpKVxuICAgICAgaWYoaSA8IHByb2MucHJlLmFyZ3MubGVuZ3RoICYmIHByb2MucHJlLmFyZ3NbaV0uY291bnQ+MCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogcHJlKCkgYmxvY2sgbWF5IG5vdCByZWZlcmVuY2UgYXJyYXkgYXJnc1wiKVxuICAgICAgfVxuICAgICAgaWYoaSA8IHByb2MucG9zdC5hcmdzLmxlbmd0aCAmJiBwcm9jLnBvc3QuYXJnc1tpXS5jb3VudD4wKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBwb3N0KCkgYmxvY2sgbWF5IG5vdCByZWZlcmVuY2UgYXJyYXkgYXJnc1wiKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZihhcmdfdHlwZSA9PT0gXCJzY2FsYXJcIikge1xuICAgICAgcHJvYy5zY2FsYXJBcmdzLnB1c2goaSlcbiAgICAgIHByb2Muc2hpbUFyZ3MucHVzaChcInNjYWxhclwiICsgaSlcbiAgICB9IGVsc2UgaWYoYXJnX3R5cGUgPT09IFwiaW5kZXhcIikge1xuICAgICAgcHJvYy5pbmRleEFyZ3MucHVzaChpKVxuICAgICAgaWYoaSA8IHByb2MucHJlLmFyZ3MubGVuZ3RoICYmIHByb2MucHJlLmFyZ3NbaV0uY291bnQgPiAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBwcmUoKSBibG9jayBtYXkgbm90IHJlZmVyZW5jZSBhcnJheSBpbmRleFwiKVxuICAgICAgfVxuICAgICAgaWYoaSA8IHByb2MuYm9keS5hcmdzLmxlbmd0aCAmJiBwcm9jLmJvZHkuYXJnc1tpXS5sdmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IGJvZHkoKSBibG9jayBtYXkgbm90IHdyaXRlIHRvIGFycmF5IGluZGV4XCIpXG4gICAgICB9XG4gICAgICBpZihpIDwgcHJvYy5wb3N0LmFyZ3MubGVuZ3RoICYmIHByb2MucG9zdC5hcmdzW2ldLmNvdW50ID4gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogcG9zdCgpIGJsb2NrIG1heSBub3QgcmVmZXJlbmNlIGFycmF5IGluZGV4XCIpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmKGFyZ190eXBlID09PSBcInNoYXBlXCIpIHtcbiAgICAgIHByb2Muc2hhcGVBcmdzLnB1c2goaSlcbiAgICAgIGlmKGkgPCBwcm9jLnByZS5hcmdzLmxlbmd0aCAmJiBwcm9jLnByZS5hcmdzW2ldLmx2YWx1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogcHJlKCkgYmxvY2sgbWF5IG5vdCB3cml0ZSB0byBhcnJheSBzaGFwZVwiKVxuICAgICAgfVxuICAgICAgaWYoaSA8IHByb2MuYm9keS5hcmdzLmxlbmd0aCAmJiBwcm9jLmJvZHkuYXJnc1tpXS5sdmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IGJvZHkoKSBibG9jayBtYXkgbm90IHdyaXRlIHRvIGFycmF5IHNoYXBlXCIpXG4gICAgICB9XG4gICAgICBpZihpIDwgcHJvYy5wb3N0LmFyZ3MubGVuZ3RoICYmIHByb2MucG9zdC5hcmdzW2ldLmx2YWx1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogcG9zdCgpIGJsb2NrIG1heSBub3Qgd3JpdGUgdG8gYXJyYXkgc2hhcGVcIilcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYodHlwZW9mIGFyZ190eXBlID09PSBcIm9iamVjdFwiICYmIGFyZ190eXBlLm9mZnNldCkge1xuICAgICAgcHJvYy5hcmdUeXBlc1tpXSA9IFwib2Zmc2V0XCJcbiAgICAgIHByb2Mub2Zmc2V0QXJncy5wdXNoKHsgYXJyYXk6IGFyZ190eXBlLmFycmF5LCBvZmZzZXQ6YXJnX3R5cGUub2Zmc2V0IH0pXG4gICAgICBwcm9jLm9mZnNldEFyZ0luZGV4LnB1c2goaSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IFVua25vd24gYXJndW1lbnQgdHlwZSBcIiArIHByb2NfYXJnc1tpXSlcbiAgICB9XG4gIH1cbiAgXG4gIC8vTWFrZSBzdXJlIGF0IGxlYXN0IG9uZSBhcnJheSBhcmd1bWVudCB3YXMgc3BlY2lmaWVkXG4gIGlmKHByb2MuYXJyYXlBcmdzLmxlbmd0aCA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IE5vIGFycmF5IGFyZ3VtZW50cyBzcGVjaWZpZWRcIilcbiAgfVxuICBcbiAgLy9NYWtlIHN1cmUgYXJndW1lbnRzIGFyZSBjb3JyZWN0XG4gIGlmKHByb2MucHJlLmFyZ3MubGVuZ3RoID4gcHJvY19hcmdzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBUb28gbWFueSBhcmd1bWVudHMgaW4gcHJlKCkgYmxvY2tcIilcbiAgfVxuICBpZihwcm9jLmJvZHkuYXJncy5sZW5ndGggPiBwcm9jX2FyZ3MubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IFRvbyBtYW55IGFyZ3VtZW50cyBpbiBib2R5KCkgYmxvY2tcIilcbiAgfVxuICBpZihwcm9jLnBvc3QuYXJncy5sZW5ndGggPiBwcm9jX2FyZ3MubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IFRvbyBtYW55IGFyZ3VtZW50cyBpbiBwb3N0KCkgYmxvY2tcIilcbiAgfVxuXG4gIC8vQ2hlY2sgZGVidWcgZmxhZ1xuICBwcm9jLmRlYnVnID0gISF1c2VyX2FyZ3MucHJpbnRDb2RlIHx8ICEhdXNlcl9hcmdzLmRlYnVnXG4gIFxuICAvL1JldHJpZXZlIG5hbWVcbiAgcHJvYy5mdW5jTmFtZSA9IHVzZXJfYXJncy5mdW5jTmFtZSB8fCBcImN3aXNlXCJcbiAgXG4gIC8vUmVhZCBpbiBibG9jayBzaXplXG4gIHByb2MuYmxvY2tTaXplID0gdXNlcl9hcmdzLmJsb2NrU2l6ZSB8fCA2NFxuXG4gIHJldHVybiBjcmVhdGVUaHVuayhwcm9jKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBpbGVDd2lzZVxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIHVuaXEgPSByZXF1aXJlKFwidW5pcVwiKVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGdlbmVyYXRlcyB2ZXJ5IHNpbXBsZSBsb29wcyBhbmFsb2dvdXMgdG8gaG93IHlvdSB0eXBpY2FsbHkgdHJhdmVyc2UgYXJyYXlzICh0aGUgb3V0ZXJtb3N0IGxvb3AgY29ycmVzcG9uZHMgdG8gdGhlIHNsb3dlc3QgY2hhbmdpbmcgaW5kZXgsIHRoZSBpbm5lcm1vc3QgbG9vcCB0byB0aGUgZmFzdGVzdCBjaGFuZ2luZyBpbmRleClcbi8vIFRPRE86IElmIHR3byBhcnJheXMgaGF2ZSB0aGUgc2FtZSBzdHJpZGVzIChhbmQgb2Zmc2V0cykgdGhlcmUgaXMgcG90ZW50aWFsIGZvciBkZWNyZWFzaW5nIHRoZSBudW1iZXIgb2YgXCJwb2ludGVyc1wiIGFuZCByZWxhdGVkIHZhcmlhYmxlcy4gVGhlIGRyYXdiYWNrIGlzIHRoYXQgdGhlIHR5cGUgc2lnbmF0dXJlIHdvdWxkIGJlY29tZSBtb3JlIHNwZWNpZmljIGFuZCB0aGF0IHRoZXJlIHdvdWxkIHRodXMgYmUgbGVzcyBwb3RlbnRpYWwgZm9yIGNhY2hpbmcsIGJ1dCBpdCBtaWdodCBzdGlsbCBiZSB3b3J0aCBpdCwgZXNwZWNpYWxseSB3aGVuIGRlYWxpbmcgd2l0aCBsYXJnZSBudW1iZXJzIG9mIGFyZ3VtZW50cy5cbmZ1bmN0aW9uIGlubmVyRmlsbChvcmRlciwgcHJvYywgYm9keSkge1xuICB2YXIgZGltZW5zaW9uID0gb3JkZXIubGVuZ3RoXG4gICAgLCBuYXJncyA9IHByb2MuYXJyYXlBcmdzLmxlbmd0aFxuICAgICwgaGFzX2luZGV4ID0gcHJvYy5pbmRleEFyZ3MubGVuZ3RoPjBcbiAgICAsIGNvZGUgPSBbXVxuICAgICwgdmFycyA9IFtdXG4gICAgLCBpZHg9MCwgcGlkeD0wLCBpLCBqXG4gIGZvcihpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHsgLy8gSXRlcmF0aW9uIHZhcmlhYmxlc1xuICAgIHZhcnMucHVzaChbXCJpXCIsaSxcIj0wXCJdLmpvaW4oXCJcIikpXG4gIH1cbiAgLy9Db21wdXRlIHNjYW4gZGVsdGFzXG4gIGZvcihqPTA7IGo8bmFyZ3M7ICsraikge1xuICAgIGZvcihpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICAgIHBpZHggPSBpZHhcbiAgICAgIGlkeCA9IG9yZGVyW2ldXG4gICAgICBpZihpID09PSAwKSB7IC8vIFRoZSBpbm5lcm1vc3QvZmFzdGVzdCBkaW1lbnNpb24ncyBkZWx0YSBpcyBzaW1wbHkgaXRzIHN0cmlkZVxuICAgICAgICB2YXJzLnB1c2goW1wiZFwiLGosXCJzXCIsaSxcIj10XCIsaixcInBcIixpZHhdLmpvaW4oXCJcIikpXG4gICAgICB9IGVsc2UgeyAvLyBGb3Igb3RoZXIgZGltZW5zaW9ucyB0aGUgZGVsdGEgaXMgYmFzaWNhbGx5IHRoZSBzdHJpZGUgbWludXMgc29tZXRoaW5nIHdoaWNoIGVzc2VudGlhbGx5IFwicmV3aW5kc1wiIHRoZSBwcmV2aW91cyAobW9yZSBpbm5lcikgZGltZW5zaW9uXG4gICAgICAgIHZhcnMucHVzaChbXCJkXCIsaixcInNcIixpLFwiPSh0XCIsaixcInBcIixpZHgsXCItc1wiLHBpZHgsXCIqdFwiLGosXCJwXCIscGlkeCxcIilcIl0uam9pbihcIlwiKSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHZhcnMubGVuZ3RoID4gMCkge1xuICAgIGNvZGUucHVzaChcInZhciBcIiArIHZhcnMuam9pbihcIixcIikpXG4gIH0gIFxuICAvL1NjYW4gbG9vcFxuICBmb3IoaT1kaW1lbnNpb24tMTsgaT49MDsgLS1pKSB7IC8vIFN0YXJ0IGF0IGxhcmdlc3Qgc3RyaWRlIGFuZCB3b3JrIHlvdXIgd2F5IGlud2FyZHNcbiAgICBpZHggPSBvcmRlcltpXVxuICAgIGNvZGUucHVzaChbXCJmb3IoaVwiLGksXCI9MDtpXCIsaSxcIjxzXCIsaWR4LFwiOysraVwiLGksXCIpe1wiXS5qb2luKFwiXCIpKVxuICB9XG4gIC8vUHVzaCBib2R5IG9mIGlubmVyIGxvb3BcbiAgY29kZS5wdXNoKGJvZHkpXG4gIC8vQWR2YW5jZSBzY2FuIHBvaW50ZXJzXG4gIGZvcihpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICBwaWR4ID0gaWR4XG4gICAgaWR4ID0gb3JkZXJbaV1cbiAgICBmb3Ioaj0wOyBqPG5hcmdzOyArK2opIHtcbiAgICAgIGNvZGUucHVzaChbXCJwXCIsaixcIis9ZFwiLGosXCJzXCIsaV0uam9pbihcIlwiKSlcbiAgICB9XG4gICAgaWYoaGFzX2luZGV4KSB7XG4gICAgICBpZihpID4gMCkge1xuICAgICAgICBjb2RlLnB1c2goW1wiaW5kZXhbXCIscGlkeCxcIl0tPXNcIixwaWR4XS5qb2luKFwiXCIpKVxuICAgICAgfVxuICAgICAgY29kZS5wdXNoKFtcIisraW5kZXhbXCIsaWR4LFwiXVwiXS5qb2luKFwiXCIpKVxuICAgIH1cbiAgICBjb2RlLnB1c2goXCJ9XCIpXG4gIH1cbiAgcmV0dXJuIGNvZGUuam9pbihcIlxcblwiKVxufVxuXG4vLyBHZW5lcmF0ZSBcIm91dGVyXCIgbG9vcHMgdGhhdCBsb29wIG92ZXIgYmxvY2tzIG9mIGRhdGEsIGFwcGx5aW5nIFwiaW5uZXJcIiBsb29wcyB0byB0aGUgYmxvY2tzIGJ5IG1hbmlwdWxhdGluZyB0aGUgbG9jYWwgdmFyaWFibGVzIGluIHN1Y2ggYSB3YXkgdGhhdCB0aGUgaW5uZXIgbG9vcCBvbmx5IFwic2Vlc1wiIHRoZSBjdXJyZW50IGJsb2NrLlxuLy8gVE9ETzogSWYgdGhpcyBpcyB1c2VkLCB0aGVuIHRoZSBwcmV2aW91cyBkZWNsYXJhdGlvbiAoZG9uZSBieSBnZW5lcmF0ZUN3aXNlT3ApIG9mIHMqIGlzIGVzc2VudGlhbGx5IHVubmVjZXNzYXJ5LlxuLy8gICAgICAgSSBiZWxpZXZlIHRoZSBzKiBhcmUgbm90IHVzZWQgZWxzZXdoZXJlIChpbiBwYXJ0aWN1bGFyLCBJIGRvbid0IHRoaW5rIHRoZXkncmUgdXNlZCBpbiB0aGUgcHJlL3Bvc3QgcGFydHMgYW5kIFwic2hhcGVcIiBpcyBkZWZpbmVkIGluZGVwZW5kZW50bHkpLCBzbyBpdCB3b3VsZCBiZSBwb3NzaWJsZSB0byBtYWtlIGRlZmluaW5nIHRoZSBzKiBkZXBlbmRlbnQgb24gd2hhdCBsb29wIG1ldGhvZCBpcyBiZWluZyB1c2VkLlxuZnVuY3Rpb24gb3V0ZXJGaWxsKG1hdGNoZWQsIG9yZGVyLCBwcm9jLCBib2R5KSB7XG4gIHZhciBkaW1lbnNpb24gPSBvcmRlci5sZW5ndGhcbiAgICAsIG5hcmdzID0gcHJvYy5hcnJheUFyZ3MubGVuZ3RoXG4gICAgLCBibG9ja1NpemUgPSBwcm9jLmJsb2NrU2l6ZVxuICAgICwgaGFzX2luZGV4ID0gcHJvYy5pbmRleEFyZ3MubGVuZ3RoID4gMFxuICAgICwgY29kZSA9IFtdXG4gIGZvcih2YXIgaT0wOyBpPG5hcmdzOyArK2kpIHtcbiAgICBjb2RlLnB1c2goW1widmFyIG9mZnNldFwiLGksXCI9cFwiLGldLmpvaW4oXCJcIikpXG4gIH1cbiAgLy9HZW5lcmF0ZSBsb29wcyBmb3IgdW5tYXRjaGVkIGRpbWVuc2lvbnNcbiAgLy8gVGhlIG9yZGVyIGluIHdoaWNoIHRoZXNlIGRpbWVuc2lvbnMgYXJlIHRyYXZlcnNlZCBpcyBmYWlybHkgYXJiaXRyYXJ5IChmcm9tIHNtYWxsIHN0cmlkZSB0byBsYXJnZSBzdHJpZGUsIGZvciB0aGUgZmlyc3QgYXJndW1lbnQpXG4gIC8vIFRPRE86IEl0IHdvdWxkIGJlIG5pY2UgaWYgdGhlIG9yZGVyIGluIHdoaWNoIHRoZXNlIGxvb3BzIGFyZSBwbGFjZWQgd291bGQgYWxzbyBiZSBzb21laG93IFwib3B0aW1hbFwiIChhdCB0aGUgdmVyeSBsZWFzdCB3ZSBzaG91bGQgY2hlY2sgdGhhdCBpdCByZWFsbHkgZG9lc24ndCBodXJ0IHVzIGlmIHRoZXkncmUgbm90KS5cbiAgZm9yKHZhciBpPW1hdGNoZWQ7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICBjb2RlLnB1c2goW1wiZm9yKHZhciBqXCIraStcIj1TU1tcIiwgb3JkZXJbaV0sIFwiXXwwO2pcIiwgaSwgXCI+MDspe1wiXS5qb2luKFwiXCIpKSAvLyBJdGVyYXRlIGJhY2sgdG8gZnJvbnRcbiAgICBjb2RlLnB1c2goW1wiaWYoalwiLGksXCI8XCIsYmxvY2tTaXplLFwiKXtcIl0uam9pbihcIlwiKSkgLy8gRWl0aGVyIGRlY3JlYXNlIGogYnkgYmxvY2tTaXplIChzID0gYmxvY2tTaXplKSwgb3Igc2V0IGl0IHRvIHplcm8gKGFmdGVyIHNldHRpbmcgcyA9IGopLlxuICAgIGNvZGUucHVzaChbXCJzXCIsb3JkZXJbaV0sXCI9alwiLGldLmpvaW4oXCJcIikpXG4gICAgY29kZS5wdXNoKFtcImpcIixpLFwiPTBcIl0uam9pbihcIlwiKSlcbiAgICBjb2RlLnB1c2goW1wifWVsc2V7c1wiLG9yZGVyW2ldLFwiPVwiLGJsb2NrU2l6ZV0uam9pbihcIlwiKSlcbiAgICBjb2RlLnB1c2goW1wialwiLGksXCItPVwiLGJsb2NrU2l6ZSxcIn1cIl0uam9pbihcIlwiKSlcbiAgICBpZihoYXNfaW5kZXgpIHtcbiAgICAgIGNvZGUucHVzaChbXCJpbmRleFtcIixvcmRlcltpXSxcIl09alwiLGldLmpvaW4oXCJcIikpXG4gICAgfVxuICB9XG4gIGZvcih2YXIgaT0wOyBpPG5hcmdzOyArK2kpIHtcbiAgICB2YXIgaW5kZXhTdHIgPSBbXCJvZmZzZXRcIitpXVxuICAgIGZvcih2YXIgaj1tYXRjaGVkOyBqPGRpbWVuc2lvbjsgKytqKSB7XG4gICAgICBpbmRleFN0ci5wdXNoKFtcImpcIixqLFwiKnRcIixpLFwicFwiLG9yZGVyW2pdXS5qb2luKFwiXCIpKVxuICAgIH1cbiAgICBjb2RlLnB1c2goW1wicFwiLGksXCI9KFwiLGluZGV4U3RyLmpvaW4oXCIrXCIpLFwiKVwiXS5qb2luKFwiXCIpKVxuICB9XG4gIGNvZGUucHVzaChpbm5lckZpbGwob3JkZXIsIHByb2MsIGJvZHkpKVxuICBmb3IodmFyIGk9bWF0Y2hlZDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIGNvZGUucHVzaChcIn1cIilcbiAgfVxuICByZXR1cm4gY29kZS5qb2luKFwiXFxuXCIpXG59XG5cbi8vQ291bnQgdGhlIG51bWJlciBvZiBjb21wYXRpYmxlIGlubmVyIG9yZGVyc1xuLy8gVGhpcyBpcyB0aGUgbGVuZ3RoIG9mIHRoZSBsb25nZXN0IGNvbW1vbiBwcmVmaXggb2YgdGhlIGFycmF5cyBpbiBvcmRlcnMuXG4vLyBFYWNoIGFycmF5IGluIG9yZGVycyBsaXN0cyB0aGUgZGltZW5zaW9ucyBvZiB0aGUgY29ycmVzcG9uZCBuZGFycmF5IGluIG9yZGVyIG9mIGluY3JlYXNpbmcgc3RyaWRlLlxuLy8gVGhpcyBpcyB0aHVzIHRoZSBtYXhpbXVtIG51bWJlciBvZiBkaW1lbnNpb25zIHRoYXQgY2FuIGJlIGVmZmljaWVudGx5IHRyYXZlcnNlZCBieSBzaW1wbGUgbmVzdGVkIGxvb3BzIGZvciBhbGwgYXJyYXlzLlxuZnVuY3Rpb24gY291bnRNYXRjaGVzKG9yZGVycykge1xuICB2YXIgbWF0Y2hlZCA9IDAsIGRpbWVuc2lvbiA9IG9yZGVyc1swXS5sZW5ndGhcbiAgd2hpbGUobWF0Y2hlZCA8IGRpbWVuc2lvbikge1xuICAgIGZvcih2YXIgaj0xOyBqPG9yZGVycy5sZW5ndGg7ICsraikge1xuICAgICAgaWYob3JkZXJzW2pdW21hdGNoZWRdICE9PSBvcmRlcnNbMF1bbWF0Y2hlZF0pIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZWRcbiAgICAgIH1cbiAgICB9XG4gICAgKyttYXRjaGVkXG4gIH1cbiAgcmV0dXJuIG1hdGNoZWRcbn1cblxuLy9Qcm9jZXNzZXMgYSBibG9jayBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIGRhdGEgdHlwZXNcbi8vIFJlcGxhY2VzIHZhcmlhYmxlIG5hbWVzIGJ5IGRpZmZlcmVudCBvbmVzLCBlaXRoZXIgXCJsb2NhbFwiIG9uZXMgKHRoYXQgYXJlIHRoZW4gZmVycmllZCBpbiBhbmQgb3V0IG9mIHRoZSBnaXZlbiBhcnJheSkgb3Igb25lcyBtYXRjaGluZyB0aGUgYXJndW1lbnRzIHRoYXQgdGhlIGZ1bmN0aW9uIHBlcmZvcm1pbmcgdGhlIHVsdGltYXRlIGxvb3Agd2lsbCBhY2NlcHQuXG5mdW5jdGlvbiBwcm9jZXNzQmxvY2soYmxvY2ssIHByb2MsIGR0eXBlcykge1xuICB2YXIgY29kZSA9IGJsb2NrLmJvZHlcbiAgdmFyIHByZSA9IFtdXG4gIHZhciBwb3N0ID0gW11cbiAgZm9yKHZhciBpPTA7IGk8YmxvY2suYXJncy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBjYXJnID0gYmxvY2suYXJnc1tpXVxuICAgIGlmKGNhcmcuY291bnQgPD0gMCkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgdmFyIHJlID0gbmV3IFJlZ0V4cChjYXJnLm5hbWUsIFwiZ1wiKVxuICAgIHZhciBwdHJTdHIgPSBcIlwiXG4gICAgdmFyIGFyck51bSA9IHByb2MuYXJyYXlBcmdzLmluZGV4T2YoaSlcbiAgICBzd2l0Y2gocHJvYy5hcmdUeXBlc1tpXSkge1xuICAgICAgY2FzZSBcIm9mZnNldFwiOlxuICAgICAgICB2YXIgb2ZmQXJnSW5kZXggPSBwcm9jLm9mZnNldEFyZ0luZGV4LmluZGV4T2YoaSlcbiAgICAgICAgdmFyIG9mZkFyZyA9IHByb2Mub2Zmc2V0QXJnc1tvZmZBcmdJbmRleF1cbiAgICAgICAgYXJyTnVtID0gb2ZmQXJnLmFycmF5XG4gICAgICAgIHB0clN0ciA9IFwiK3FcIiArIG9mZkFyZ0luZGV4IC8vIEFkZHMgb2Zmc2V0IHRvIHRoZSBcInBvaW50ZXJcIiBpbiB0aGUgYXJyYXlcbiAgICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgICBwdHJTdHIgPSBcInBcIiArIGFyck51bSArIHB0clN0clxuICAgICAgICB2YXIgbG9jYWxTdHIgPSBcImxcIiArIGlcbiAgICAgICAgdmFyIGFyclN0ciA9IFwiYVwiICsgYXJyTnVtXG4gICAgICAgIGlmIChwcm9jLmFycmF5QmxvY2tJbmRpY2VzW2Fyck51bV0gPT09IDApIHsgLy8gQXJndW1lbnQgdG8gYm9keSBpcyBqdXN0IGEgc2luZ2xlIHZhbHVlIGZyb20gdGhpcyBhcnJheVxuICAgICAgICAgIGlmKGNhcmcuY291bnQgPT09IDEpIHsgLy8gQXJndW1lbnQvYXJyYXkgdXNlZCBvbmx5IG9uY2UoPylcbiAgICAgICAgICAgIGlmKGR0eXBlc1thcnJOdW1dID09PSBcImdlbmVyaWNcIikge1xuICAgICAgICAgICAgICBpZihjYXJnLmx2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHByZS5wdXNoKFtcInZhciBcIiwgbG9jYWxTdHIsIFwiPVwiLCBhcnJTdHIsIFwiLmdldChcIiwgcHRyU3RyLCBcIilcIl0uam9pbihcIlwiKSkgLy8gSXMgdGhpcyBuZWNlc3NhcnkgaWYgdGhlIGFyZ3VtZW50IGlzIE9OTFkgdXNlZCBhcyBhbiBsdmFsdWU/IChrZWVwIGluIG1pbmQgdGhhdCB3ZSBjYW4gaGF2ZSBhICs9IHNvbWV0aGluZywgc28gd2Ugd291bGQgYWN0dWFsbHkgbmVlZCB0byBjaGVjayBjYXJnLnJ2YWx1ZSlcbiAgICAgICAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBsb2NhbFN0cilcbiAgICAgICAgICAgICAgICBwb3N0LnB1c2goW2FyclN0ciwgXCIuc2V0KFwiLCBwdHJTdHIsIFwiLFwiLCBsb2NhbFN0cixcIilcIl0uam9pbihcIlwiKSlcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBbYXJyU3RyLCBcIi5nZXQoXCIsIHB0clN0ciwgXCIpXCJdLmpvaW4oXCJcIikpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIFthcnJTdHIsIFwiW1wiLCBwdHJTdHIsIFwiXVwiXS5qb2luKFwiXCIpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZihkdHlwZXNbYXJyTnVtXSA9PT0gXCJnZW5lcmljXCIpIHtcbiAgICAgICAgICAgIHByZS5wdXNoKFtcInZhciBcIiwgbG9jYWxTdHIsIFwiPVwiLCBhcnJTdHIsIFwiLmdldChcIiwgcHRyU3RyLCBcIilcIl0uam9pbihcIlwiKSkgLy8gVE9ETzogQ291bGQgd2Ugb3B0aW1pemUgYnkgY2hlY2tpbmcgZm9yIGNhcmcucnZhbHVlP1xuICAgICAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgbG9jYWxTdHIpXG4gICAgICAgICAgICBpZihjYXJnLmx2YWx1ZSkge1xuICAgICAgICAgICAgICBwb3N0LnB1c2goW2FyclN0ciwgXCIuc2V0KFwiLCBwdHJTdHIsIFwiLFwiLCBsb2NhbFN0cixcIilcIl0uam9pbihcIlwiKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJlLnB1c2goW1widmFyIFwiLCBsb2NhbFN0ciwgXCI9XCIsIGFyclN0ciwgXCJbXCIsIHB0clN0ciwgXCJdXCJdLmpvaW4oXCJcIikpIC8vIFRPRE86IENvdWxkIHdlIG9wdGltaXplIGJ5IGNoZWNraW5nIGZvciBjYXJnLnJ2YWx1ZT9cbiAgICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIGxvY2FsU3RyKVxuICAgICAgICAgICAgaWYoY2FyZy5sdmFsdWUpIHtcbiAgICAgICAgICAgICAgcG9zdC5wdXNoKFthcnJTdHIsIFwiW1wiLCBwdHJTdHIsIFwiXT1cIiwgbG9jYWxTdHJdLmpvaW4oXCJcIikpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgeyAvLyBBcmd1bWVudCB0byBib2R5IGlzIGEgXCJibG9ja1wiXG4gICAgICAgICAgdmFyIHJlU3RyQXJyID0gW2NhcmcubmFtZV0sIHB0clN0ckFyciA9IFtwdHJTdHJdXG4gICAgICAgICAgZm9yKHZhciBqPTA7IGo8TWF0aC5hYnMocHJvYy5hcnJheUJsb2NrSW5kaWNlc1thcnJOdW1dKTsgaisrKSB7XG4gICAgICAgICAgICByZVN0ckFyci5wdXNoKFwiXFxcXHMqXFxcXFsoW15cXFxcXV0rKVxcXFxdXCIpXG4gICAgICAgICAgICBwdHJTdHJBcnIucHVzaChcIiRcIiArIChqKzEpICsgXCIqdFwiICsgYXJyTnVtICsgXCJiXCIgKyBqKSAvLyBNYXRjaGVkIGluZGV4IHRpbWVzIHN0cmlkZVxuICAgICAgICAgIH1cbiAgICAgICAgICByZSA9IG5ldyBSZWdFeHAocmVTdHJBcnIuam9pbihcIlwiKSwgXCJnXCIpXG4gICAgICAgICAgcHRyU3RyID0gcHRyU3RyQXJyLmpvaW4oXCIrXCIpXG4gICAgICAgICAgaWYoZHR5cGVzW2Fyck51bV0gPT09IFwiZ2VuZXJpY1wiKSB7XG4gICAgICAgICAgICAvKmlmKGNhcmcubHZhbHVlKSB7XG4gICAgICAgICAgICAgIHByZS5wdXNoKFtcInZhciBcIiwgbG9jYWxTdHIsIFwiPVwiLCBhcnJTdHIsIFwiLmdldChcIiwgcHRyU3RyLCBcIilcIl0uam9pbihcIlwiKSkgLy8gSXMgdGhpcyBuZWNlc3NhcnkgaWYgdGhlIGFyZ3VtZW50IGlzIE9OTFkgdXNlZCBhcyBhbiBsdmFsdWU/IChrZWVwIGluIG1pbmQgdGhhdCB3ZSBjYW4gaGF2ZSBhICs9IHNvbWV0aGluZywgc28gd2Ugd291bGQgYWN0dWFsbHkgbmVlZCB0byBjaGVjayBjYXJnLnJ2YWx1ZSlcbiAgICAgICAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgbG9jYWxTdHIpXG4gICAgICAgICAgICAgIHBvc3QucHVzaChbYXJyU3RyLCBcIi5zZXQoXCIsIHB0clN0ciwgXCIsXCIsIGxvY2FsU3RyLFwiKVwiXS5qb2luKFwiXCIpKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgW2FyclN0ciwgXCIuZ2V0KFwiLCBwdHJTdHIsIFwiKVwiXS5qb2luKFwiXCIpKVxuICAgICAgICAgICAgfSovXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogR2VuZXJpYyBhcnJheXMgbm90IHN1cHBvcnRlZCBpbiBjb21iaW5hdGlvbiB3aXRoIGJsb2NrcyFcIilcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVGhpcyBkb2VzIG5vdCBwcm9kdWNlIGFueSBsb2NhbCB2YXJpYWJsZXMsIGV2ZW4gaWYgdmFyaWFibGVzIGFyZSB1c2VkIG11bHRpcGxlIHRpbWVzLiBJdCB3b3VsZCBiZSBwb3NzaWJsZSB0byBkbyBzbywgYnV0IGl0IHdvdWxkIGNvbXBsaWNhdGUgdGhpbmdzIHF1aXRlIGEgYml0LlxuICAgICAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgW2FyclN0ciwgXCJbXCIsIHB0clN0ciwgXCJdXCJdLmpvaW4oXCJcIikpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBicmVha1xuICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBcIllcIiArIHByb2Muc2NhbGFyQXJncy5pbmRleE9mKGkpKVxuICAgICAgYnJlYWtcbiAgICAgIGNhc2UgXCJpbmRleFwiOlxuICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBcImluZGV4XCIpXG4gICAgICBicmVha1xuICAgICAgY2FzZSBcInNoYXBlXCI6XG4gICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIFwic2hhcGVcIilcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG4gIHJldHVybiBbcHJlLmpvaW4oXCJcXG5cIiksIGNvZGUsIHBvc3Quam9pbihcIlxcblwiKV0uam9pbihcIlxcblwiKS50cmltKClcbn1cblxuZnVuY3Rpb24gdHlwZVN1bW1hcnkoZHR5cGVzKSB7XG4gIHZhciBzdW1tYXJ5ID0gbmV3IEFycmF5KGR0eXBlcy5sZW5ndGgpXG4gIHZhciBhbGxFcXVhbCA9IHRydWVcbiAgZm9yKHZhciBpPTA7IGk8ZHR5cGVzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHQgPSBkdHlwZXNbaV1cbiAgICB2YXIgZGlnaXRzID0gdC5tYXRjaCgvXFxkKy8pXG4gICAgaWYoIWRpZ2l0cykge1xuICAgICAgZGlnaXRzID0gXCJcIlxuICAgIH0gZWxzZSB7XG4gICAgICBkaWdpdHMgPSBkaWdpdHNbMF1cbiAgICB9XG4gICAgaWYodC5jaGFyQXQoMCkgPT09IDApIHtcbiAgICAgIHN1bW1hcnlbaV0gPSBcInVcIiArIHQuY2hhckF0KDEpICsgZGlnaXRzXG4gICAgfSBlbHNlIHtcbiAgICAgIHN1bW1hcnlbaV0gPSB0LmNoYXJBdCgwKSArIGRpZ2l0c1xuICAgIH1cbiAgICBpZihpID4gMCkge1xuICAgICAgYWxsRXF1YWwgPSBhbGxFcXVhbCAmJiBzdW1tYXJ5W2ldID09PSBzdW1tYXJ5W2ktMV1cbiAgICB9XG4gIH1cbiAgaWYoYWxsRXF1YWwpIHtcbiAgICByZXR1cm4gc3VtbWFyeVswXVxuICB9XG4gIHJldHVybiBzdW1tYXJ5LmpvaW4oXCJcIilcbn1cblxuLy9HZW5lcmF0ZXMgYSBjd2lzZSBvcGVyYXRvclxuZnVuY3Rpb24gZ2VuZXJhdGVDV2lzZU9wKHByb2MsIHR5cGVzaWcpIHtcblxuICAvL0NvbXB1dGUgZGltZW5zaW9uXG4gIC8vIEFycmF5cyBnZXQgcHV0IGZpcnN0IGluIHR5cGVzaWcsIGFuZCB0aGVyZSBhcmUgdHdvIGVudHJpZXMgcGVyIGFycmF5IChkdHlwZSBhbmQgb3JkZXIpLCBzbyB0aGlzIGdldHMgdGhlIG51bWJlciBvZiBkaW1lbnNpb25zIGluIHRoZSBmaXJzdCBhcnJheSBhcmcuXG4gIHZhciBkaW1lbnNpb24gPSAodHlwZXNpZ1sxXS5sZW5ndGggLSBNYXRoLmFicyhwcm9jLmFycmF5QmxvY2tJbmRpY2VzWzBdKSl8MFxuICB2YXIgb3JkZXJzID0gbmV3IEFycmF5KHByb2MuYXJyYXlBcmdzLmxlbmd0aClcbiAgdmFyIGR0eXBlcyA9IG5ldyBBcnJheShwcm9jLmFycmF5QXJncy5sZW5ndGgpXG4gIGZvcih2YXIgaT0wOyBpPHByb2MuYXJyYXlBcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgZHR5cGVzW2ldID0gdHlwZXNpZ1syKmldXG4gICAgb3JkZXJzW2ldID0gdHlwZXNpZ1syKmkrMV1cbiAgfVxuICBcbiAgLy9EZXRlcm1pbmUgd2hlcmUgYmxvY2sgYW5kIGxvb3AgaW5kaWNlcyBzdGFydCBhbmQgZW5kXG4gIHZhciBibG9ja0JlZ2luID0gW10sIGJsb2NrRW5kID0gW10gLy8gVGhlc2UgaW5kaWNlcyBhcmUgZXhwb3NlZCBhcyBibG9ja3NcbiAgdmFyIGxvb3BCZWdpbiA9IFtdLCBsb29wRW5kID0gW10gLy8gVGhlc2UgaW5kaWNlcyBhcmUgaXRlcmF0ZWQgb3ZlclxuICB2YXIgbG9vcE9yZGVycyA9IFtdIC8vIG9yZGVycyByZXN0cmljdGVkIHRvIHRoZSBsb29wIGluZGljZXNcbiAgZm9yKHZhciBpPTA7IGk8cHJvYy5hcnJheUFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAocHJvYy5hcnJheUJsb2NrSW5kaWNlc1tpXTwwKSB7XG4gICAgICBsb29wQmVnaW4ucHVzaCgwKVxuICAgICAgbG9vcEVuZC5wdXNoKGRpbWVuc2lvbilcbiAgICAgIGJsb2NrQmVnaW4ucHVzaChkaW1lbnNpb24pXG4gICAgICBibG9ja0VuZC5wdXNoKGRpbWVuc2lvbitwcm9jLmFycmF5QmxvY2tJbmRpY2VzW2ldKVxuICAgIH0gZWxzZSB7XG4gICAgICBsb29wQmVnaW4ucHVzaChwcm9jLmFycmF5QmxvY2tJbmRpY2VzW2ldKSAvLyBOb24tbmVnYXRpdmVcbiAgICAgIGxvb3BFbmQucHVzaChwcm9jLmFycmF5QmxvY2tJbmRpY2VzW2ldK2RpbWVuc2lvbilcbiAgICAgIGJsb2NrQmVnaW4ucHVzaCgwKVxuICAgICAgYmxvY2tFbmQucHVzaChwcm9jLmFycmF5QmxvY2tJbmRpY2VzW2ldKVxuICAgIH1cbiAgICB2YXIgbmV3T3JkZXIgPSBbXVxuICAgIGZvcih2YXIgaj0wOyBqPG9yZGVyc1tpXS5sZW5ndGg7IGorKykge1xuICAgICAgaWYgKGxvb3BCZWdpbltpXTw9b3JkZXJzW2ldW2pdICYmIG9yZGVyc1tpXVtqXTxsb29wRW5kW2ldKSB7XG4gICAgICAgIG5ld09yZGVyLnB1c2gob3JkZXJzW2ldW2pdLWxvb3BCZWdpbltpXSkgLy8gSWYgdGhpcyBpcyBhIGxvb3AgaW5kZXgsIHB1dCBpdCBpbiBuZXdPcmRlciwgc3VidHJhY3RpbmcgbG9vcEJlZ2luLCB0byBtYWtlIHN1cmUgdGhhdCBhbGwgbG9vcE9yZGVycyBhcmUgdXNpbmcgYSBjb21tb24gc2V0IG9mIGluZGljZXMuXG4gICAgICB9XG4gICAgfVxuICAgIGxvb3BPcmRlcnMucHVzaChuZXdPcmRlcilcbiAgfVxuXG4gIC8vRmlyc3QgY3JlYXRlIGFyZ3VtZW50cyBmb3IgcHJvY2VkdXJlXG4gIHZhciBhcmdsaXN0ID0gW1wiU1NcIl0gLy8gU1MgaXMgdGhlIG92ZXJhbGwgc2hhcGUgb3ZlciB3aGljaCB3ZSBpdGVyYXRlXG4gIHZhciBjb2RlID0gW1wiJ3VzZSBzdHJpY3QnXCJdXG4gIHZhciB2YXJzID0gW11cbiAgXG4gIGZvcih2YXIgaj0wOyBqPGRpbWVuc2lvbjsgKytqKSB7XG4gICAgdmFycy5wdXNoKFtcInNcIiwgaiwgXCI9U1NbXCIsIGosIFwiXVwiXS5qb2luKFwiXCIpKSAvLyBUaGUgbGltaXRzIGZvciBlYWNoIGRpbWVuc2lvbi5cbiAgfVxuICBmb3IodmFyIGk9MDsgaTxwcm9jLmFycmF5QXJncy5sZW5ndGg7ICsraSkge1xuICAgIGFyZ2xpc3QucHVzaChcImFcIitpKSAvLyBBY3R1YWwgZGF0YSBhcnJheVxuICAgIGFyZ2xpc3QucHVzaChcInRcIitpKSAvLyBTdHJpZGVzXG4gICAgYXJnbGlzdC5wdXNoKFwicFwiK2kpIC8vIE9mZnNldCBpbiB0aGUgYXJyYXkgYXQgd2hpY2ggdGhlIGRhdGEgc3RhcnRzIChhbHNvIHVzZWQgZm9yIGl0ZXJhdGluZyBvdmVyIHRoZSBkYXRhKVxuICAgIFxuICAgIGZvcih2YXIgaj0wOyBqPGRpbWVuc2lvbjsgKytqKSB7IC8vIFVucGFjayB0aGUgc3RyaWRlcyBpbnRvIHZhcnMgZm9yIGxvb3BpbmdcbiAgICAgIHZhcnMucHVzaChbXCJ0XCIsaSxcInBcIixqLFwiPXRcIixpLFwiW1wiLGxvb3BCZWdpbltpXStqLFwiXVwiXS5qb2luKFwiXCIpKVxuICAgIH1cbiAgICBcbiAgICBmb3IodmFyIGo9MDsgajxNYXRoLmFicyhwcm9jLmFycmF5QmxvY2tJbmRpY2VzW2ldKTsgKytqKSB7IC8vIFVucGFjayB0aGUgc3RyaWRlcyBpbnRvIHZhcnMgZm9yIGJsb2NrIGl0ZXJhdGlvblxuICAgICAgdmFycy5wdXNoKFtcInRcIixpLFwiYlwiLGosXCI9dFwiLGksXCJbXCIsYmxvY2tCZWdpbltpXStqLFwiXVwiXS5qb2luKFwiXCIpKVxuICAgIH1cbiAgfVxuICBmb3IodmFyIGk9MDsgaTxwcm9jLnNjYWxhckFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICBhcmdsaXN0LnB1c2goXCJZXCIgKyBpKVxuICB9XG4gIGlmKHByb2Muc2hhcGVBcmdzLmxlbmd0aCA+IDApIHtcbiAgICB2YXJzLnB1c2goXCJzaGFwZT1TUy5zbGljZSgwKVwiKSAvLyBNYWtlcyB0aGUgc2hhcGUgb3ZlciB3aGljaCB3ZSBpdGVyYXRlIGF2YWlsYWJsZSB0byB0aGUgdXNlciBkZWZpbmVkIGZ1bmN0aW9ucyAoc28geW91IGNhbiB1c2Ugd2lkdGgvaGVpZ2h0IGZvciBleGFtcGxlKVxuICB9XG4gIGlmKHByb2MuaW5kZXhBcmdzLmxlbmd0aCA+IDApIHtcbiAgICAvLyBQcmVwYXJlIGFuIGFycmF5IHRvIGtlZXAgdHJhY2sgb2YgdGhlIChsb2dpY2FsKSBpbmRpY2VzLCBpbml0aWFsaXplZCB0byBkaW1lbnNpb24gemVyb2VzLlxuICAgIHZhciB6ZXJvcyA9IG5ldyBBcnJheShkaW1lbnNpb24pXG4gICAgZm9yKHZhciBpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICAgIHplcm9zW2ldID0gXCIwXCJcbiAgICB9XG4gICAgdmFycy5wdXNoKFtcImluZGV4PVtcIiwgemVyb3Muam9pbihcIixcIiksIFwiXVwiXS5qb2luKFwiXCIpKVxuICB9XG4gIGZvcih2YXIgaT0wOyBpPHByb2Mub2Zmc2V0QXJncy5sZW5ndGg7ICsraSkgeyAvLyBPZmZzZXQgYXJndW1lbnRzIHVzZWQgZm9yIHN0ZW5jaWwgb3BlcmF0aW9uc1xuICAgIHZhciBvZmZfYXJnID0gcHJvYy5vZmZzZXRBcmdzW2ldXG4gICAgdmFyIGluaXRfc3RyaW5nID0gW11cbiAgICBmb3IodmFyIGo9MDsgajxvZmZfYXJnLm9mZnNldC5sZW5ndGg7ICsraikge1xuICAgICAgaWYob2ZmX2FyZy5vZmZzZXRbal0gPT09IDApIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH0gZWxzZSBpZihvZmZfYXJnLm9mZnNldFtqXSA9PT0gMSkge1xuICAgICAgICBpbml0X3N0cmluZy5wdXNoKFtcInRcIiwgb2ZmX2FyZy5hcnJheSwgXCJwXCIsIGpdLmpvaW4oXCJcIikpICAgICAgXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbml0X3N0cmluZy5wdXNoKFtvZmZfYXJnLm9mZnNldFtqXSwgXCIqdFwiLCBvZmZfYXJnLmFycmF5LCBcInBcIiwgal0uam9pbihcIlwiKSlcbiAgICAgIH1cbiAgICB9XG4gICAgaWYoaW5pdF9zdHJpbmcubGVuZ3RoID09PSAwKSB7XG4gICAgICB2YXJzLnB1c2goXCJxXCIgKyBpICsgXCI9MFwiKVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXJzLnB1c2goW1wicVwiLCBpLCBcIj1cIiwgaW5pdF9zdHJpbmcuam9pbihcIitcIildLmpvaW4oXCJcIikpXG4gICAgfVxuICB9XG5cbiAgLy9QcmVwYXJlIHRoaXMgdmFyaWFibGVzXG4gIHZhciB0aGlzVmFycyA9IHVuaXEoW10uY29uY2F0KHByb2MucHJlLnRoaXNWYXJzKVxuICAgICAgICAgICAgICAgICAgICAgIC5jb25jYXQocHJvYy5ib2R5LnRoaXNWYXJzKVxuICAgICAgICAgICAgICAgICAgICAgIC5jb25jYXQocHJvYy5wb3N0LnRoaXNWYXJzKSlcbiAgdmFycyA9IHZhcnMuY29uY2F0KHRoaXNWYXJzKVxuICBpZiAodmFycy5sZW5ndGggPiAwKSB7XG4gICAgY29kZS5wdXNoKFwidmFyIFwiICsgdmFycy5qb2luKFwiLFwiKSlcbiAgfVxuICBmb3IodmFyIGk9MDsgaTxwcm9jLmFycmF5QXJncy5sZW5ndGg7ICsraSkge1xuICAgIGNvZGUucHVzaChcInBcIitpK1wifD0wXCIpXG4gIH1cbiAgXG4gIC8vSW5saW5lIHByZWx1ZGVcbiAgaWYocHJvYy5wcmUuYm9keS5sZW5ndGggPiAzKSB7XG4gICAgY29kZS5wdXNoKHByb2Nlc3NCbG9jayhwcm9jLnByZSwgcHJvYywgZHR5cGVzKSlcbiAgfVxuXG4gIC8vUHJvY2VzcyBib2R5XG4gIHZhciBib2R5ID0gcHJvY2Vzc0Jsb2NrKHByb2MuYm9keSwgcHJvYywgZHR5cGVzKVxuICB2YXIgbWF0Y2hlZCA9IGNvdW50TWF0Y2hlcyhsb29wT3JkZXJzKVxuICBpZihtYXRjaGVkIDwgZGltZW5zaW9uKSB7XG4gICAgY29kZS5wdXNoKG91dGVyRmlsbChtYXRjaGVkLCBsb29wT3JkZXJzWzBdLCBwcm9jLCBib2R5KSkgLy8gVE9ETzogUmF0aGVyIHRoYW4gcGFzc2luZyBsb29wT3JkZXJzWzBdLCBpdCBtaWdodCBiZSBpbnRlcmVzdGluZyB0byBsb29rIGF0IHBhc3NpbmcgYW4gb3JkZXIgdGhhdCByZXByZXNlbnRzIHRoZSBtYWpvcml0eSBvZiB0aGUgYXJndW1lbnRzIGZvciBleGFtcGxlLlxuICB9IGVsc2Uge1xuICAgIGNvZGUucHVzaChpbm5lckZpbGwobG9vcE9yZGVyc1swXSwgcHJvYywgYm9keSkpXG4gIH1cblxuICAvL0lubGluZSBlcGlsb2dcbiAgaWYocHJvYy5wb3N0LmJvZHkubGVuZ3RoID4gMykge1xuICAgIGNvZGUucHVzaChwcm9jZXNzQmxvY2socHJvYy5wb3N0LCBwcm9jLCBkdHlwZXMpKVxuICB9XG4gIFxuICBpZihwcm9jLmRlYnVnKSB7XG4gICAgY29uc29sZS5sb2coXCItLS0tLUdlbmVyYXRlZCBjd2lzZSByb3V0aW5lIGZvciBcIiwgdHlwZXNpZywgXCI6XFxuXCIgKyBjb2RlLmpvaW4oXCJcXG5cIikgKyBcIlxcbi0tLS0tLS0tLS1cIilcbiAgfVxuICBcbiAgdmFyIGxvb3BOYW1lID0gWyhwcm9jLmZ1bmNOYW1lfHxcInVubmFtZWRcIiksIFwiX2N3aXNlX2xvb3BfXCIsIG9yZGVyc1swXS5qb2luKFwic1wiKSxcIm1cIixtYXRjaGVkLHR5cGVTdW1tYXJ5KGR0eXBlcyldLmpvaW4oXCJcIilcbiAgdmFyIGYgPSBuZXcgRnVuY3Rpb24oW1wiZnVuY3Rpb24gXCIsbG9vcE5hbWUsXCIoXCIsIGFyZ2xpc3Quam9pbihcIixcIiksXCIpe1wiLCBjb2RlLmpvaW4oXCJcXG5cIiksXCJ9IHJldHVybiBcIiwgbG9vcE5hbWVdLmpvaW4oXCJcIikpXG4gIHJldHVybiBmKClcbn1cbm1vZHVsZS5leHBvcnRzID0gZ2VuZXJhdGVDV2lzZU9wXG4iLCJcInVzZSBzdHJpY3RcIlxuXG4vLyBUaGUgZnVuY3Rpb24gYmVsb3cgaXMgY2FsbGVkIHdoZW4gY29uc3RydWN0aW5nIGEgY3dpc2UgZnVuY3Rpb24gb2JqZWN0LCBhbmQgZG9lcyB0aGUgZm9sbG93aW5nOlxuLy8gQSBmdW5jdGlvbiBvYmplY3QgaXMgY29uc3RydWN0ZWQgd2hpY2ggYWNjZXB0cyBhcyBhcmd1bWVudCBhIGNvbXBpbGF0aW9uIGZ1bmN0aW9uIGFuZCByZXR1cm5zIGFub3RoZXIgZnVuY3Rpb24uXG4vLyBJdCBpcyB0aGlzIG90aGVyIGZ1bmN0aW9uIHRoYXQgaXMgZXZlbnR1YWxseSByZXR1cm5lZCBieSBjcmVhdGVUaHVuaywgYW5kIHRoaXMgZnVuY3Rpb24gaXMgdGhlIG9uZSB0aGF0IGFjdHVhbGx5XG4vLyBjaGVja3Mgd2hldGhlciBhIGNlcnRhaW4gcGF0dGVybiBvZiBhcmd1bWVudHMgaGFzIGFscmVhZHkgYmVlbiB1c2VkIGJlZm9yZSBhbmQgY29tcGlsZXMgbmV3IGxvb3BzIGFzIG5lZWRlZC5cbi8vIFRoZSBjb21waWxhdGlvbiBwYXNzZWQgdG8gdGhlIGZpcnN0IGZ1bmN0aW9uIG9iamVjdCBpcyB1c2VkIGZvciBjb21waWxpbmcgbmV3IGZ1bmN0aW9ucy5cbi8vIE9uY2UgdGhpcyBmdW5jdGlvbiBvYmplY3QgaXMgY3JlYXRlZCwgaXQgaXMgY2FsbGVkIHdpdGggY29tcGlsZSBhcyBhcmd1bWVudCwgd2hlcmUgdGhlIGZpcnN0IGFyZ3VtZW50IG9mIGNvbXBpbGVcbi8vIGlzIGJvdW5kIHRvIFwicHJvY1wiIChlc3NlbnRpYWxseSBjb250YWluaW5nIGEgcHJlcHJvY2Vzc2VkIHZlcnNpb24gb2YgdGhlIHVzZXIgYXJndW1lbnRzIHRvIGN3aXNlKS5cbi8vIFNvIGNyZWF0ZVRodW5rIHJvdWdobHkgd29ya3MgbGlrZSB0aGlzOlxuLy8gZnVuY3Rpb24gY3JlYXRlVGh1bmsocHJvYykge1xuLy8gICB2YXIgdGh1bmsgPSBmdW5jdGlvbihjb21waWxlQm91bmQpIHtcbi8vICAgICB2YXIgQ0FDSEVEID0ge31cbi8vICAgICByZXR1cm4gZnVuY3Rpb24oYXJyYXlzIGFuZCBzY2FsYXJzKSB7XG4vLyAgICAgICBpZiAoZHR5cGUgYW5kIG9yZGVyIG9mIGFycmF5cyBpbiBDQUNIRUQpIHtcbi8vICAgICAgICAgdmFyIGZ1bmMgPSBDQUNIRURbZHR5cGUgYW5kIG9yZGVyIG9mIGFycmF5c11cbi8vICAgICAgIH0gZWxzZSB7XG4vLyAgICAgICAgIHZhciBmdW5jID0gQ0FDSEVEW2R0eXBlIGFuZCBvcmRlciBvZiBhcnJheXNdID0gY29tcGlsZUJvdW5kKGR0eXBlIGFuZCBvcmRlciBvZiBhcnJheXMpXG4vLyAgICAgICB9XG4vLyAgICAgICByZXR1cm4gZnVuYyhhcnJheXMgYW5kIHNjYWxhcnMpXG4vLyAgICAgfVxuLy8gICB9XG4vLyAgIHJldHVybiB0aHVuayhjb21waWxlLmJpbmQxKHByb2MpKVxuLy8gfVxuXG52YXIgY29tcGlsZSA9IHJlcXVpcmUoXCIuL2NvbXBpbGUuanNcIilcblxuZnVuY3Rpb24gY3JlYXRlVGh1bmsocHJvYykge1xuICB2YXIgY29kZSA9IFtcIid1c2Ugc3RyaWN0J1wiLCBcInZhciBDQUNIRUQ9e31cIl1cbiAgdmFyIHZhcnMgPSBbXVxuICB2YXIgdGh1bmtOYW1lID0gcHJvYy5mdW5jTmFtZSArIFwiX2N3aXNlX3RodW5rXCJcbiAgXG4gIC8vQnVpbGQgdGh1bmtcbiAgY29kZS5wdXNoKFtcInJldHVybiBmdW5jdGlvbiBcIiwgdGh1bmtOYW1lLCBcIihcIiwgcHJvYy5zaGltQXJncy5qb2luKFwiLFwiKSwgXCIpe1wiXS5qb2luKFwiXCIpKVxuICB2YXIgdHlwZXNpZyA9IFtdXG4gIHZhciBzdHJpbmdfdHlwZXNpZyA9IFtdXG4gIHZhciBwcm9jX2FyZ3MgPSBbW1wiYXJyYXlcIixwcm9jLmFycmF5QXJnc1swXSxcIi5zaGFwZS5zbGljZShcIiwgLy8gU2xpY2Ugc2hhcGUgc28gdGhhdCB3ZSBvbmx5IHJldGFpbiB0aGUgc2hhcGUgb3ZlciB3aGljaCB3ZSBpdGVyYXRlICh3aGljaCBnZXRzIHBhc3NlZCB0byB0aGUgY3dpc2Ugb3BlcmF0b3IgYXMgU1MpLlxuICAgICAgICAgICAgICAgICAgICBNYXRoLm1heCgwLHByb2MuYXJyYXlCbG9ja0luZGljZXNbMF0pLHByb2MuYXJyYXlCbG9ja0luZGljZXNbMF08MD8oXCIsXCIrcHJvYy5hcnJheUJsb2NrSW5kaWNlc1swXStcIilcIik6XCIpXCJdLmpvaW4oXCJcIildXG4gIHZhciBzaGFwZUxlbmd0aENvbmRpdGlvbnMgPSBbXSwgc2hhcGVDb25kaXRpb25zID0gW11cbiAgLy8gUHJvY2VzcyBhcnJheSBhcmd1bWVudHNcbiAgZm9yKHZhciBpPTA7IGk8cHJvYy5hcnJheUFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgaiA9IHByb2MuYXJyYXlBcmdzW2ldXG4gICAgdmFycy5wdXNoKFtcInRcIiwgaiwgXCI9YXJyYXlcIiwgaiwgXCIuZHR5cGUsXCIsXG4gICAgICAgICAgICAgICBcInJcIiwgaiwgXCI9YXJyYXlcIiwgaiwgXCIub3JkZXJcIl0uam9pbihcIlwiKSlcbiAgICB0eXBlc2lnLnB1c2goXCJ0XCIgKyBqKVxuICAgIHR5cGVzaWcucHVzaChcInJcIiArIGopXG4gICAgc3RyaW5nX3R5cGVzaWcucHVzaChcInRcIitqKVxuICAgIHN0cmluZ190eXBlc2lnLnB1c2goXCJyXCIraitcIi5qb2luKClcIilcbiAgICBwcm9jX2FyZ3MucHVzaChcImFycmF5XCIgKyBqICsgXCIuZGF0YVwiKVxuICAgIHByb2NfYXJncy5wdXNoKFwiYXJyYXlcIiArIGogKyBcIi5zdHJpZGVcIilcbiAgICBwcm9jX2FyZ3MucHVzaChcImFycmF5XCIgKyBqICsgXCIub2Zmc2V0fDBcIilcbiAgICBpZiAoaT4wKSB7IC8vIEdhdGhlciBjb25kaXRpb25zIHRvIGNoZWNrIGZvciBzaGFwZSBlcXVhbGl0eSAoaWdub3JpbmcgYmxvY2sgaW5kaWNlcylcbiAgICAgIHNoYXBlTGVuZ3RoQ29uZGl0aW9ucy5wdXNoKFwiYXJyYXlcIiArIHByb2MuYXJyYXlBcmdzWzBdICsgXCIuc2hhcGUubGVuZ3RoPT09YXJyYXlcIiArIGogKyBcIi5zaGFwZS5sZW5ndGgrXCIgKyAoTWF0aC5hYnMocHJvYy5hcnJheUJsb2NrSW5kaWNlc1swXSktTWF0aC5hYnMocHJvYy5hcnJheUJsb2NrSW5kaWNlc1tpXSkpKVxuICAgICAgc2hhcGVDb25kaXRpb25zLnB1c2goXCJhcnJheVwiICsgcHJvYy5hcnJheUFyZ3NbMF0gKyBcIi5zaGFwZVtzaGFwZUluZGV4K1wiICsgTWF0aC5tYXgoMCxwcm9jLmFycmF5QmxvY2tJbmRpY2VzWzBdKSArIFwiXT09PWFycmF5XCIgKyBqICsgXCIuc2hhcGVbc2hhcGVJbmRleCtcIiArIE1hdGgubWF4KDAscHJvYy5hcnJheUJsb2NrSW5kaWNlc1tpXSkgKyBcIl1cIilcbiAgICB9XG4gIH1cbiAgLy8gQ2hlY2sgZm9yIHNoYXBlIGVxdWFsaXR5XG4gIGlmIChwcm9jLmFycmF5QXJncy5sZW5ndGggPiAxKSB7XG4gICAgY29kZS5wdXNoKFwiaWYgKCEoXCIgKyBzaGFwZUxlbmd0aENvbmRpdGlvbnMuam9pbihcIiAmJiBcIikgKyBcIikpIHRocm93IG5ldyBFcnJvcignY3dpc2U6IEFycmF5cyBkbyBub3QgYWxsIGhhdmUgdGhlIHNhbWUgZGltZW5zaW9uYWxpdHkhJylcIilcbiAgICBjb2RlLnB1c2goXCJmb3IodmFyIHNoYXBlSW5kZXg9YXJyYXlcIiArIHByb2MuYXJyYXlBcmdzWzBdICsgXCIuc2hhcGUubGVuZ3RoLVwiICsgTWF0aC5hYnMocHJvYy5hcnJheUJsb2NrSW5kaWNlc1swXSkgKyBcIjsgc2hhcGVJbmRleC0tPjA7KSB7XCIpXG4gICAgY29kZS5wdXNoKFwiaWYgKCEoXCIgKyBzaGFwZUNvbmRpdGlvbnMuam9pbihcIiAmJiBcIikgKyBcIikpIHRocm93IG5ldyBFcnJvcignY3dpc2U6IEFycmF5cyBkbyBub3QgYWxsIGhhdmUgdGhlIHNhbWUgc2hhcGUhJylcIilcbiAgICBjb2RlLnB1c2goXCJ9XCIpXG4gIH1cbiAgLy8gUHJvY2VzcyBzY2FsYXIgYXJndW1lbnRzXG4gIGZvcih2YXIgaT0wOyBpPHByb2Muc2NhbGFyQXJncy5sZW5ndGg7ICsraSkge1xuICAgIHByb2NfYXJncy5wdXNoKFwic2NhbGFyXCIgKyBwcm9jLnNjYWxhckFyZ3NbaV0pXG4gIH1cbiAgLy8gQ2hlY2sgZm9yIGNhY2hlZCBmdW5jdGlvbiAoYW5kIGlmIG5vdCBwcmVzZW50LCBnZW5lcmF0ZSBpdClcbiAgdmFycy5wdXNoKFtcInR5cGU9W1wiLCBzdHJpbmdfdHlwZXNpZy5qb2luKFwiLFwiKSwgXCJdLmpvaW4oKVwiXS5qb2luKFwiXCIpKVxuICB2YXJzLnB1c2goXCJwcm9jPUNBQ0hFRFt0eXBlXVwiKVxuICBjb2RlLnB1c2goXCJ2YXIgXCIgKyB2YXJzLmpvaW4oXCIsXCIpKVxuICBcbiAgY29kZS5wdXNoKFtcImlmKCFwcm9jKXtcIixcbiAgICAgICAgICAgICBcIkNBQ0hFRFt0eXBlXT1wcm9jPWNvbXBpbGUoW1wiLCB0eXBlc2lnLmpvaW4oXCIsXCIpLCBcIl0pfVwiLFxuICAgICAgICAgICAgIFwicmV0dXJuIHByb2MoXCIsIHByb2NfYXJncy5qb2luKFwiLFwiKSwgXCIpfVwiXS5qb2luKFwiXCIpKVxuXG4gIGlmKHByb2MuZGVidWcpIHtcbiAgICBjb25zb2xlLmxvZyhcIi0tLS0tR2VuZXJhdGVkIHRodW5rOlxcblwiICsgY29kZS5qb2luKFwiXFxuXCIpICsgXCJcXG4tLS0tLS0tLS0tXCIpXG4gIH1cbiAgXG4gIC8vQ29tcGlsZSB0aHVua1xuICB2YXIgdGh1bmsgPSBuZXcgRnVuY3Rpb24oXCJjb21waWxlXCIsIGNvZGUuam9pbihcIlxcblwiKSlcbiAgcmV0dXJuIHRodW5rKGNvbXBpbGUuYmluZCh1bmRlZmluZWQsIHByb2MpKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVRodW5rXG4iLCJcbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBkYXRhVXJpVG9CdWZmZXI7XG5cbi8qKlxuICogUmV0dXJucyBhIGBCdWZmZXJgIGluc3RhbmNlIGZyb20gdGhlIGdpdmVuIGRhdGEgVVJJIGB1cmlgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmkgRGF0YSBVUkkgdG8gdHVybiBpbnRvIGEgQnVmZmVyIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtCdWZmZXJ9IEJ1ZmZlciBpbnN0YW5jZSBmcm9tIERhdGEgVVJJXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRhdGFVcmlUb0J1ZmZlciAodXJpKSB7XG4gIGlmICghL15kYXRhXFw6L2kudGVzdCh1cmkpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYHVyaWAgZG9lcyBub3QgYXBwZWFyIHRvIGJlIGEgRGF0YSBVUkkgKG11c3QgYmVnaW4gd2l0aCBcImRhdGE6XCIpJyk7XG4gIH1cblxuICAvLyBzdHJpcCBuZXdsaW5lc1xuICB1cmkgPSB1cmkucmVwbGFjZSgvXFxyP1xcbi9nLCAnJyk7XG5cbiAgLy8gc3BsaXQgdGhlIFVSSSB1cCBpbnRvIHRoZSBcIm1ldGFkYXRhXCIgYW5kIHRoZSBcImRhdGFcIiBwb3J0aW9uc1xuICB2YXIgZmlyc3RDb21tYSA9IHVyaS5pbmRleE9mKCcsJyk7XG4gIGlmICgtMSA9PT0gZmlyc3RDb21tYSB8fCBmaXJzdENvbW1hIDw9IDQpIHRocm93IG5ldyBUeXBlRXJyb3IoJ21hbGZvcm1lZCBkYXRhOiBVUkknKTtcblxuICAvLyByZW1vdmUgdGhlIFwiZGF0YTpcIiBzY2hlbWUgYW5kIHBhcnNlIHRoZSBtZXRhZGF0YVxuICB2YXIgbWV0YSA9IHVyaS5zdWJzdHJpbmcoNSwgZmlyc3RDb21tYSkuc3BsaXQoJzsnKTtcblxuICB2YXIgYmFzZTY0ID0gZmFsc2U7XG4gIHZhciBjaGFyc2V0ID0gJ1VTLUFTQ0lJJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCdiYXNlNjQnID09IG1ldGFbaV0pIHtcbiAgICAgIGJhc2U2NCA9IHRydWU7XG4gICAgfSBlbHNlIGlmICgwID09IG1ldGFbaV0uaW5kZXhPZignY2hhcnNldD0nKSkge1xuICAgICAgY2hhcnNldCA9IG1ldGFbaV0uc3Vic3RyaW5nKDgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGdldCB0aGUgZW5jb2RlZCBkYXRhIHBvcnRpb24gYW5kIGRlY29kZSBVUkktZW5jb2RlZCBjaGFyc1xuICB2YXIgZGF0YSA9IHVuZXNjYXBlKHVyaS5zdWJzdHJpbmcoZmlyc3RDb21tYSArIDEpKTtcblxuICB2YXIgZW5jb2RpbmcgPSBiYXNlNjQgPyAnYmFzZTY0JyA6ICdhc2NpaSc7XG4gIHZhciBidWZmZXIgPSBuZXcgQnVmZmVyKGRhdGEsIGVuY29kaW5nKTtcblxuICAvLyBzZXQgYC50eXBlYCBwcm9wZXJ0eSB0byBNSU1FIHR5cGVcbiAgYnVmZmVyLnR5cGUgPSBtZXRhWzBdIHx8ICd0ZXh0L3BsYWluJztcblxuICAvLyBzZXQgdGhlIGAuY2hhcnNldGAgcHJvcGVydHlcbiAgYnVmZmVyLmNoYXJzZXQgPSBjaGFyc2V0O1xuXG4gIHJldHVybiBidWZmZXI7XG59XG4iLCJcInVzZSBzdHJpY3RcIlxuXG5mdW5jdGlvbiBkdXBlX2FycmF5KGNvdW50LCB2YWx1ZSwgaSkge1xuICB2YXIgYyA9IGNvdW50W2ldfDBcbiAgaWYoYyA8PSAwKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cbiAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShjKSwgalxuICBpZihpID09PSBjb3VudC5sZW5ndGgtMSkge1xuICAgIGZvcihqPTA7IGo8YzsgKytqKSB7XG4gICAgICByZXN1bHRbal0gPSB2YWx1ZVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3Ioaj0wOyBqPGM7ICsraikge1xuICAgICAgcmVzdWx0W2pdID0gZHVwZV9hcnJheShjb3VudCwgdmFsdWUsIGkrMSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBkdXBlX251bWJlcihjb3VudCwgdmFsdWUpIHtcbiAgdmFyIHJlc3VsdCwgaVxuICByZXN1bHQgPSBuZXcgQXJyYXkoY291bnQpXG4gIGZvcihpPTA7IGk8Y291bnQ7ICsraSkge1xuICAgIHJlc3VsdFtpXSA9IHZhbHVlXG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBkdXBlKGNvdW50LCB2YWx1ZSkge1xuICBpZih0eXBlb2YgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB2YWx1ZSA9IDBcbiAgfVxuICBzd2l0Y2godHlwZW9mIGNvdW50KSB7XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgaWYoY291bnQgPiAwKSB7XG4gICAgICAgIHJldHVybiBkdXBlX251bWJlcihjb3VudHwwLCB2YWx1ZSlcbiAgICAgIH1cbiAgICBicmVha1xuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgIGlmKHR5cGVvZiAoY291bnQubGVuZ3RoKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gZHVwZV9hcnJheShjb3VudCwgdmFsdWUsIDApXG4gICAgICB9XG4gICAgYnJlYWtcbiAgfVxuICByZXR1cm4gW11cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkdXBlIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzID0gdW5kZWZpbmVkO1xuXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcbi8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG5FdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycyA9IDEwO1xuXG4vLyBPYnZpb3VzbHkgbm90IGFsbCBFbWl0dGVycyBzaG91bGQgYmUgbGltaXRlZCB0byAxMC4gVGhpcyBmdW5jdGlvbiBhbGxvd3Ncbi8vIHRoYXQgdG8gYmUgaW5jcmVhc2VkLiBTZXQgdG8gemVybyBmb3IgdW5saW1pdGVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XG4gIGlmICghaXNOdW1iZXIobikgfHwgbiA8IDAgfHwgaXNOYU4obikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCduIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBlciwgaGFuZGxlciwgbGVuLCBhcmdzLCBpLCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XG4gICAgICAgIChpc09iamVjdCh0aGlzLl9ldmVudHMuZXJyb3IpICYmICF0aGlzLl9ldmVudHMuZXJyb3IubGVuZ3RoKSkge1xuICAgICAgZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICAgICAgdmFyIGVyciA9IG5ldyBFcnJvcignVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudC4gKCcgKyBlciArICcpJyk7XG4gICAgICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc1VuZGVmaW5lZChoYW5kbGVyKSlcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGlzRnVuY3Rpb24oaGFuZGxlcikpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIGZhc3QgY2FzZXNcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIHNsb3dlclxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICAgIGhhbmRsZXIuYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGhhbmRsZXIpKSB7XG4gICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xuICAgIGxlbiA9IGxpc3RlbmVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIG07XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgaWYgKHRoaXMuX2V2ZW50cy5uZXdMaXN0ZW5lcilcbiAgICB0aGlzLmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihsaXN0ZW5lci5saXN0ZW5lcikgP1xuICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAvLyBPcHRpbWl6ZSB0aGUgY2FzZSBvZiBvbmUgbGlzdGVuZXIuIERvbid0IG5lZWQgdGhlIGV4dHJhIGFycmF5IG9iamVjdC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgZWxzZSBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IGdvdCBhbiBhcnJheSwganVzdCBhcHBlbmQuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlXG4gICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gW3RoaXMuX2V2ZW50c1t0eXBlXSwgbGlzdGVuZXJdO1xuXG4gIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pICYmICF0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkKSB7XG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XG4gICAgICBtID0gdGhpcy5fbWF4TGlzdGVuZXJzO1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gICAgfVxuXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcbiAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQgPSB0cnVlO1xuICAgICAgY29uc29sZS5lcnJvcignKG5vZGUpIHdhcm5pbmc6IHBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgJyArXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnVXNlIGVtaXR0ZXIuc2V0TWF4TGlzdGVuZXJzKCkgdG8gaW5jcmVhc2UgbGltaXQuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gbm90IHN1cHBvcnRlZCBpbiBJRSAxMFxuICAgICAgICBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIHZhciBmaXJlZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGcoKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBnKTtcblxuICAgIGlmICghZmlyZWQpIHtcbiAgICAgIGZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICB9XG5cbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICB0aGlzLm9uKHR5cGUsIGcpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbGlzdCwgcG9zaXRpb24sIGxlbmd0aCwgaTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXR1cm4gdGhpcztcblxuICBsaXN0ID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuICBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgcG9zaXRpb24gPSAtMTtcblxuICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHxcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG5cbiAgfSBlbHNlIGlmIChpc09iamVjdChsaXN0KSkge1xuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcbiAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fFxuICAgICAgICAgIChsaXN0W2ldLmxpc3RlbmVyICYmIGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xuICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IDApXG4gICAgICByZXR1cm4gdGhpcztcblxuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgbGlzdC5sZW5ndGggPSAwO1xuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGtleSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIG5vdCBsaXN0ZW5pbmcgZm9yIHJlbW92ZUxpc3RlbmVyLCBubyBuZWVkIHRvIGVtaXRcbiAgaWYgKCF0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcbiAgICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIGVsc2UgaWYgKHRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoa2V5KTtcbiAgICB9XG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzRnVuY3Rpb24obGlzdGVuZXJzKSkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgfSBlbHNlIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAvLyBMSUZPIG9yZGVyXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tsaXN0ZW5lcnMubGVuZ3RoIC0gMV0pO1xuICB9XG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIHJldDtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1t0eXBlXSlcbiAgICByZXQgPSBbXTtcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIHJldCA9IFt0aGlzLl9ldmVudHNbdHlwZV1dO1xuICBlbHNlXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIGlmICh0aGlzLl9ldmVudHMpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICAgIGlmIChpc0Z1bmN0aW9uKGV2bGlzdGVuZXIpKVxuICAgICAgcmV0dXJuIDE7XG4gICAgZWxzZSBpZiAoZXZsaXN0ZW5lcilcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gMDtcbn07XG5cbkV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24oZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xufTtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuIiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBwYXRoICAgICAgICAgID0gcmVxdWlyZSgncGF0aCcpXG52YXIgbmRhcnJheSAgICAgICA9IHJlcXVpcmUoJ25kYXJyYXknKVxudmFyIEdpZlJlYWRlciAgICAgPSByZXF1aXJlKCdvbWdnaWYnKS5HaWZSZWFkZXJcbnZhciBwYWNrICAgICAgICAgID0gcmVxdWlyZSgnbmRhcnJheS1wYWNrJylcbnZhciB0aHJvdWdoICAgICAgID0gcmVxdWlyZSgndGhyb3VnaCcpXG52YXIgcGFyc2VEYXRhVVJJICA9IHJlcXVpcmUoJ2RhdGEtdXJpLXRvLWJ1ZmZlcicpXG5cbmZ1bmN0aW9uIGRlZmF1bHRJbWFnZSh1cmwsIGNiKSB7XG4gIHZhciBpbWcgPSBuZXcgSW1hZ2UoKVxuICBpbWcuY3Jvc3NPcmlnaW4gPSBcIkFub255bW91c1wiXG4gIGltZy5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJylcbiAgICBjYW52YXMud2lkdGggPSBpbWcud2lkdGhcbiAgICBjYW52YXMuaGVpZ2h0ID0gaW1nLmhlaWdodFxuICAgIHZhciBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJylcbiAgICBjb250ZXh0LmRyYXdJbWFnZShpbWcsIDAsIDApXG4gICAgdmFyIHBpeGVscyA9IGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGltZy53aWR0aCwgaW1nLmhlaWdodClcbiAgICBjYihudWxsLCBuZGFycmF5KG5ldyBVaW50OEFycmF5KHBpeGVscy5kYXRhKSwgW2ltZy53aWR0aCwgaW1nLmhlaWdodCwgNF0sIFs0LCA0KmltZy53aWR0aCwgMV0sIDApKVxuICB9XG4gIGltZy5vbmVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgY2IoZXJyKVxuICB9XG4gIGltZy5zcmMgPSB1cmxcbn1cblxuLy9BbmltYXRlZCBnaWYgbG9hZGluZ1xuZnVuY3Rpb24gaGFuZGxlR2lmKGRhdGEsIGNiKSB7XG4gIHZhciByZWFkZXJcbiAgdHJ5IHtcbiAgICByZWFkZXIgPSBuZXcgR2lmUmVhZGVyKGRhdGEpXG4gIH0gY2F0Y2goZXJyKSB7XG4gICAgY2IoZXJyKVxuICAgIHJldHVyblxuICB9XG4gIGlmKHJlYWRlci5udW1GcmFtZXMoKSA+IDApIHtcbiAgICB2YXIgbnNoYXBlID0gW3JlYWRlci5udW1GcmFtZXMoKSwgcmVhZGVyLmhlaWdodCwgcmVhZGVyLndpZHRoLCA0XVxuICAgIHZhciBuZGF0YSA9IG5ldyBVaW50OEFycmF5KG5zaGFwZVswXSAqIG5zaGFwZVsxXSAqIG5zaGFwZVsyXSAqIG5zaGFwZVszXSlcbiAgICB2YXIgcmVzdWx0ID0gbmRhcnJheShuZGF0YSwgbnNoYXBlKVxuICAgIHRyeSB7XG4gICAgICBmb3IodmFyIGk9MDsgaTxyZWFkZXIubnVtRnJhbWVzKCk7ICsraSkge1xuICAgICAgICByZWFkZXIuZGVjb2RlQW5kQmxpdEZyYW1lUkdCQShpLCBuZGF0YS5zdWJhcnJheShcbiAgICAgICAgICByZXN1bHQuaW5kZXgoaSwgMCwgMCwgMCksXG4gICAgICAgICAgcmVzdWx0LmluZGV4KGkrMSwgMCwgMCwgMCkpKVxuICAgICAgfVxuICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICBjYihlcnIpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY2IobnVsbCwgcmVzdWx0LnRyYW5zcG9zZSgwLDIsMSkpXG4gIH0gZWxzZSB7XG4gICAgdmFyIG5zaGFwZSA9IFtyZWFkZXIuaGVpZ2h0LCByZWFkZXIud2lkdGgsIDRdXG4gICAgdmFyIG5kYXRhID0gbmV3IFVpbnQ4QXJyYXkobnNoYXBlWzBdICogbnNoYXBlWzFdICogbnNoYXBlWzJdKVxuICAgIHZhciByZXN1bHQgPSBuZGFycmF5KG5kYXRhLCBuc2hhcGUpXG4gICAgdHJ5IHtcbiAgICAgIHJlYWRlci5kZWNvZGVBbmRCbGl0RnJhbWVSR0JBKDAsIG5kYXRhKVxuICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICBjYihlcnIpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY2IobnVsbCwgcmVzdWx0LnRyYW5zcG9zZSgxLDApKVxuICB9XG59XG5cbmZ1bmN0aW9uIGh0dHBHaWYodXJsLCBjYikge1xuICB2YXIgeGhyICAgICAgICAgID0gbmV3IFhNTEh0dHBSZXF1ZXN0KClcbiAgeGhyLm9wZW4oJ0dFVCcsIHVybCwgdHJ1ZSlcbiAgeGhyLnJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcidcbiAgaWYoeGhyLm92ZXJyaWRlTWltZVR5cGUpe1xuICAgIHhoci5vdmVycmlkZU1pbWVUeXBlKCdhcHBsaWNhdGlvbi9iaW5hcnknKVxuICB9XG4gIHhoci5vbmVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgY2IoZXJyKVxuICB9XG4gIHhoci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICBpZih4aHIucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhciBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoeGhyLnJlc3BvbnNlKVxuICAgIGhhbmRsZUdpZihkYXRhLCBjYilcbiAgICByZXR1cm5cbiAgfVxuICB4aHIuc2VuZCgpXG59XG5cbmZ1bmN0aW9uIGNvcHlCdWZmZXIoYnVmZmVyKSB7XG4gIGlmKGJ1ZmZlclswXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIG4gPSBidWZmZXIubGVuZ3RoXG4gICAgdmFyIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KG4pXG4gICAgZm9yKHZhciBpPTA7IGk8bjsgKytpKSB7XG4gICAgICByZXN1bHRbaV0gPSBidWZmZXIuZ2V0KGkpXG4gICAgfVxuICAgIHJldHVybiByZXN1bHRcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKVxuICB9XG59XG5cbmZ1bmN0aW9uIGRhdGFHaWYodXJsLCBjYikge1xuICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICB2YXIgYnVmZmVyID0gcGFyc2VEYXRhVVJJKHVybClcbiAgICAgIGlmKGJ1ZmZlcikge1xuICAgICAgICBoYW5kbGVHaWYoY29weUJ1ZmZlcihidWZmZXIpLCBjYilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNiKG5ldyBFcnJvcignRXJyb3IgcGFyc2luZyBkYXRhIFVSSScpKVxuICAgICAgfVxuICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICBjYihlcnIpXG4gICAgfVxuICB9KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGdldFBpeGVscyh1cmwsIHR5cGUsIGNiKSB7XG4gIGlmKCFjYikge1xuICAgIGNiID0gdHlwZVxuICAgIHR5cGUgPSAnJ1xuICB9XG4gIHZhciBleHQgPSBwYXRoLmV4dG5hbWUodXJsKVxuICBzd2l0Y2godHlwZSB8fCBleHQudG9VcHBlckNhc2UoKSkge1xuICAgIGNhc2UgJy5HSUYnOlxuICAgICAgaHR0cEdpZih1cmwsIGNiKVxuICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIGlmKEJ1ZmZlci5pc0J1ZmZlcih1cmwpKSB7XG4gICAgICAgIHVybCA9ICdkYXRhOicgKyB0eXBlICsgJztiYXNlNjQsJyArIHVybC50b1N0cmluZygnYmFzZTY0JylcbiAgICAgIH1cbiAgICAgIGlmKHVybC5pbmRleE9mKCdkYXRhOmltYWdlL2dpZjsnKSA9PT0gMCkge1xuICAgICAgICBkYXRhR2lmKHVybCwgY2IpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWZhdWx0SW1hZ2UodXJsLCBjYilcbiAgICAgIH1cbiAgfVxufSIsIm1vZHVsZS5leHBvcnRzID0gYWRqb2ludDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBhZGp1Z2F0ZSBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIGFkam9pbnQob3V0LCBhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV07XG5cbiAgICBvdXRbMF0gID0gIChhMTEgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMSAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpICsgYTMxICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikpO1xuICAgIG91dFsxXSAgPSAtKGEwMSAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIxICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzEgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSk7XG4gICAgb3V0WzJdICA9ICAoYTAxICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgLSBhMTEgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMSAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgICBvdXRbM10gID0gLShhMDEgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSAtIGExMSAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpICsgYTIxICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xuICAgIG91dFs0XSAgPSAtKGExMCAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIwICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgKyBhMzAgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSk7XG4gICAgb3V0WzVdICA9ICAoYTAwICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjAgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMCAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpKTtcbiAgICBvdXRbNl0gID0gLShhMDAgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSAtIGExMCAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMwICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xuICAgIG91dFs3XSAgPSAgKGEwMCAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpIC0gYTEwICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikgKyBhMjAgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XG4gICAgb3V0WzhdICA9ICAoYTEwICogKGEyMSAqIGEzMyAtIGEyMyAqIGEzMSkgLSBhMjAgKiAoYTExICogYTMzIC0gYTEzICogYTMxKSArIGEzMCAqIChhMTEgKiBhMjMgLSBhMTMgKiBhMjEpKTtcbiAgICBvdXRbOV0gID0gLShhMDAgKiAoYTIxICogYTMzIC0gYTIzICogYTMxKSAtIGEyMCAqIChhMDEgKiBhMzMgLSBhMDMgKiBhMzEpICsgYTMwICogKGEwMSAqIGEyMyAtIGEwMyAqIGEyMSkpO1xuICAgIG91dFsxMF0gPSAgKGEwMCAqIChhMTEgKiBhMzMgLSBhMTMgKiBhMzEpIC0gYTEwICogKGEwMSAqIGEzMyAtIGEwMyAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTEzIC0gYTAzICogYTExKSk7XG4gICAgb3V0WzExXSA9IC0oYTAwICogKGExMSAqIGEyMyAtIGExMyAqIGEyMSkgLSBhMTAgKiAoYTAxICogYTIzIC0gYTAzICogYTIxKSArIGEyMCAqIChhMDEgKiBhMTMgLSBhMDMgKiBhMTEpKTtcbiAgICBvdXRbMTJdID0gLShhMTAgKiAoYTIxICogYTMyIC0gYTIyICogYTMxKSAtIGEyMCAqIChhMTEgKiBhMzIgLSBhMTIgKiBhMzEpICsgYTMwICogKGExMSAqIGEyMiAtIGExMiAqIGEyMSkpO1xuICAgIG91dFsxM10gPSAgKGEwMCAqIChhMjEgKiBhMzIgLSBhMjIgKiBhMzEpIC0gYTIwICogKGEwMSAqIGEzMiAtIGEwMiAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTIyIC0gYTAyICogYTIxKSk7XG4gICAgb3V0WzE0XSA9IC0oYTAwICogKGExMSAqIGEzMiAtIGExMiAqIGEzMSkgLSBhMTAgKiAoYTAxICogYTMyIC0gYTAyICogYTMxKSArIGEzMCAqIChhMDEgKiBhMTIgLSBhMDIgKiBhMTEpKTtcbiAgICBvdXRbMTVdID0gIChhMDAgKiAoYTExICogYTIyIC0gYTEyICogYTIxKSAtIGExMCAqIChhMDEgKiBhMjIgLSBhMDIgKiBhMjEpICsgYTIwICogKGEwMSAqIGExMiAtIGEwMiAqIGExMSkpO1xuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gY2xvbmU7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBtYXQ0IGluaXRpYWxpemVkIHdpdGggdmFsdWVzIGZyb20gYW4gZXhpc3RpbmcgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQ0fSBhIG1hdHJpeCB0byBjbG9uZVxuICogQHJldHVybnMge21hdDR9IGEgbmV3IDR4NCBtYXRyaXhcbiAqL1xuZnVuY3Rpb24gY2xvbmUoYSkge1xuICAgIHZhciBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICBvdXRbNl0gPSBhWzZdO1xuICAgIG91dFs3XSA9IGFbN107XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgICBvdXRbOV0gPSBhWzldO1xuICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICBvdXRbMTFdID0gYVsxMV07XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gY29weTtcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgbWF0NCB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF07XG4gICAgb3V0WzFdID0gYVsxXTtcbiAgICBvdXRbMl0gPSBhWzJdO1xuICAgIG91dFszXSA9IGFbM107XG4gICAgb3V0WzRdID0gYVs0XTtcbiAgICBvdXRbNV0gPSBhWzVdO1xuICAgIG91dFs2XSA9IGFbNl07XG4gICAgb3V0WzddID0gYVs3XTtcbiAgICBvdXRbOF0gPSBhWzhdO1xuICAgIG91dFs5XSA9IGFbOV07XG4gICAgb3V0WzEwXSA9IGFbMTBdO1xuICAgIG91dFsxMV0gPSBhWzExXTtcbiAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgcmV0dXJuIG91dDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBjcmVhdGU7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpZGVudGl0eSBtYXQ0XG4gKlxuICogQHJldHVybnMge21hdDR9IGEgbmV3IDR4NCBtYXRyaXhcbiAqL1xuZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgIHZhciBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcbiAgICBvdXRbMF0gPSAxO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gMTtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSAxO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZGV0ZXJtaW5hbnQ7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZGV0ZXJtaW5hbnQgb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkZXRlcm1pbmFudCBvZiBhXG4gKi9cbmZ1bmN0aW9uIGRldGVybWluYW50KGEpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdLFxuICAgICAgICBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XSxcblxuICAgICAgICBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTAsXG4gICAgICAgIGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMCxcbiAgICAgICAgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwLFxuICAgICAgICBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTEsXG4gICAgICAgIGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMSxcbiAgICAgICAgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyLFxuICAgICAgICBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzAsXG4gICAgICAgIGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMCxcbiAgICAgICAgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwLFxuICAgICAgICBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzEsXG4gICAgICAgIGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMSxcbiAgICAgICAgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICAgIHJldHVybiBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnJvbVF1YXQ7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgcXVhdGVybmlvbiByb3RhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXQ0fSBxIFJvdGF0aW9uIHF1YXRlcm5pb25cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gZnJvbVF1YXQob3V0LCBxKSB7XG4gICAgdmFyIHggPSBxWzBdLCB5ID0gcVsxXSwgeiA9IHFbMl0sIHcgPSBxWzNdLFxuICAgICAgICB4MiA9IHggKyB4LFxuICAgICAgICB5MiA9IHkgKyB5LFxuICAgICAgICB6MiA9IHogKyB6LFxuXG4gICAgICAgIHh4ID0geCAqIHgyLFxuICAgICAgICB5eCA9IHkgKiB4MixcbiAgICAgICAgeXkgPSB5ICogeTIsXG4gICAgICAgIHp4ID0geiAqIHgyLFxuICAgICAgICB6eSA9IHogKiB5MixcbiAgICAgICAgenogPSB6ICogejIsXG4gICAgICAgIHd4ID0gdyAqIHgyLFxuICAgICAgICB3eSA9IHcgKiB5MixcbiAgICAgICAgd3ogPSB3ICogejI7XG5cbiAgICBvdXRbMF0gPSAxIC0geXkgLSB6ejtcbiAgICBvdXRbMV0gPSB5eCArIHd6O1xuICAgIG91dFsyXSA9IHp4IC0gd3k7XG4gICAgb3V0WzNdID0gMDtcblxuICAgIG91dFs0XSA9IHl4IC0gd3o7XG4gICAgb3V0WzVdID0gMSAtIHh4IC0geno7XG4gICAgb3V0WzZdID0genkgKyB3eDtcbiAgICBvdXRbN10gPSAwO1xuXG4gICAgb3V0WzhdID0genggKyB3eTtcbiAgICBvdXRbOV0gPSB6eSAtIHd4O1xuICAgIG91dFsxMF0gPSAxIC0geHggLSB5eTtcbiAgICBvdXRbMTFdID0gMDtcblxuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAwO1xuICAgIG91dFsxNV0gPSAxO1xuXG4gICAgcmV0dXJuIG91dDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmcm9tUm90YXRpb25cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBnaXZlbiBhbmdsZSBhcm91bmQgYSBnaXZlbiBheGlzXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KVxuICogICAgIG1hdDQucm90YXRlKGRlc3QsIGRlc3QsIHJhZCwgYXhpcylcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHBhcmFtIHt2ZWMzfSBheGlzIHRoZSBheGlzIHRvIHJvdGF0ZSBhcm91bmRcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gZnJvbVJvdGF0aW9uKG91dCwgcmFkLCBheGlzKSB7XG4gIHZhciBzLCBjLCB0XG4gIHZhciB4ID0gYXhpc1swXVxuICB2YXIgeSA9IGF4aXNbMV1cbiAgdmFyIHogPSBheGlzWzJdXG4gIHZhciBsZW4gPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSArIHogKiB6KVxuXG4gIGlmIChNYXRoLmFicyhsZW4pIDwgMC4wMDAwMDEpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgbGVuID0gMSAvIGxlblxuICB4ICo9IGxlblxuICB5ICo9IGxlblxuICB6ICo9IGxlblxuXG4gIHMgPSBNYXRoLnNpbihyYWQpXG4gIGMgPSBNYXRoLmNvcyhyYWQpXG4gIHQgPSAxIC0gY1xuXG4gIC8vIFBlcmZvcm0gcm90YXRpb24tc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gIG91dFswXSA9IHggKiB4ICogdCArIGNcbiAgb3V0WzFdID0geSAqIHggKiB0ICsgeiAqIHNcbiAgb3V0WzJdID0geiAqIHggKiB0IC0geSAqIHNcbiAgb3V0WzNdID0gMFxuICBvdXRbNF0gPSB4ICogeSAqIHQgLSB6ICogc1xuICBvdXRbNV0gPSB5ICogeSAqIHQgKyBjXG4gIG91dFs2XSA9IHogKiB5ICogdCArIHggKiBzXG4gIG91dFs3XSA9IDBcbiAgb3V0WzhdID0geCAqIHogKiB0ICsgeSAqIHNcbiAgb3V0WzldID0geSAqIHogKiB0IC0geCAqIHNcbiAgb3V0WzEwXSA9IHogKiB6ICogdCArIGNcbiAgb3V0WzExXSA9IDBcbiAgb3V0WzEyXSA9IDBcbiAgb3V0WzEzXSA9IDBcbiAgb3V0WzE0XSA9IDBcbiAgb3V0WzE1XSA9IDFcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmcm9tUm90YXRpb25UcmFuc2xhdGlvbjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSBxdWF0ZXJuaW9uIHJvdGF0aW9uIGFuZCB2ZWN0b3IgdHJhbnNsYXRpb25cbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpO1xuICogICAgIG1hdDQudHJhbnNsYXRlKGRlc3QsIHZlYyk7XG4gKiAgICAgdmFyIHF1YXRNYXQgPSBtYXQ0LmNyZWF0ZSgpO1xuICogICAgIHF1YXQ0LnRvTWF0NChxdWF0LCBxdWF0TWF0KTtcbiAqICAgICBtYXQ0Lm11bHRpcGx5KGRlc3QsIHF1YXRNYXQpO1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7cXVhdDR9IHEgUm90YXRpb24gcXVhdGVybmlvblxuICogQHBhcmFtIHt2ZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiBmcm9tUm90YXRpb25UcmFuc2xhdGlvbihvdXQsIHEsIHYpIHtcbiAgICAvLyBRdWF0ZXJuaW9uIG1hdGhcbiAgICB2YXIgeCA9IHFbMF0sIHkgPSBxWzFdLCB6ID0gcVsyXSwgdyA9IHFbM10sXG4gICAgICAgIHgyID0geCArIHgsXG4gICAgICAgIHkyID0geSArIHksXG4gICAgICAgIHoyID0geiArIHosXG5cbiAgICAgICAgeHggPSB4ICogeDIsXG4gICAgICAgIHh5ID0geCAqIHkyLFxuICAgICAgICB4eiA9IHggKiB6MixcbiAgICAgICAgeXkgPSB5ICogeTIsXG4gICAgICAgIHl6ID0geSAqIHoyLFxuICAgICAgICB6eiA9IHogKiB6MixcbiAgICAgICAgd3ggPSB3ICogeDIsXG4gICAgICAgIHd5ID0gdyAqIHkyLFxuICAgICAgICB3eiA9IHcgKiB6MjtcblxuICAgIG91dFswXSA9IDEgLSAoeXkgKyB6eik7XG4gICAgb3V0WzFdID0geHkgKyB3ejtcbiAgICBvdXRbMl0gPSB4eiAtIHd5O1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0geHkgLSB3ejtcbiAgICBvdXRbNV0gPSAxIC0gKHh4ICsgenopO1xuICAgIG91dFs2XSA9IHl6ICsgd3g7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSB4eiArIHd5O1xuICAgIG91dFs5XSA9IHl6IC0gd3g7XG4gICAgb3V0WzEwXSA9IDEgLSAoeHggKyB5eSk7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IHZbMF07XG4gICAgb3V0WzEzXSA9IHZbMV07XG4gICAgb3V0WzE0XSA9IHZbMl07XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgXG4gICAgcmV0dXJuIG91dDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBmcm9tU2NhbGluZ1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciBzY2FsaW5nXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KVxuICogICAgIG1hdDQuc2NhbGUoZGVzdCwgZGVzdCwgdmVjKVxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7dmVjM30gdiBTY2FsaW5nIHZlY3RvclxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiBmcm9tU2NhbGluZyhvdXQsIHYpIHtcbiAgb3V0WzBdID0gdlswXVxuICBvdXRbMV0gPSAwXG4gIG91dFsyXSA9IDBcbiAgb3V0WzNdID0gMFxuICBvdXRbNF0gPSAwXG4gIG91dFs1XSA9IHZbMV1cbiAgb3V0WzZdID0gMFxuICBvdXRbN10gPSAwXG4gIG91dFs4XSA9IDBcbiAgb3V0WzldID0gMFxuICBvdXRbMTBdID0gdlsyXVxuICBvdXRbMTFdID0gMFxuICBvdXRbMTJdID0gMFxuICBvdXRbMTNdID0gMFxuICBvdXRbMTRdID0gMFxuICBvdXRbMTVdID0gMVxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZyb21UcmFuc2xhdGlvblxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHZlY3RvciB0cmFuc2xhdGlvblxuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdClcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCBkZXN0LCB2ZWMpXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHt2ZWMzfSB2IFRyYW5zbGF0aW9uIHZlY3RvclxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiBmcm9tVHJhbnNsYXRpb24ob3V0LCB2KSB7XG4gIG91dFswXSA9IDFcbiAgb3V0WzFdID0gMFxuICBvdXRbMl0gPSAwXG4gIG91dFszXSA9IDBcbiAgb3V0WzRdID0gMFxuICBvdXRbNV0gPSAxXG4gIG91dFs2XSA9IDBcbiAgb3V0WzddID0gMFxuICBvdXRbOF0gPSAwXG4gIG91dFs5XSA9IDBcbiAgb3V0WzEwXSA9IDFcbiAgb3V0WzExXSA9IDBcbiAgb3V0WzEyXSA9IHZbMF1cbiAgb3V0WzEzXSA9IHZbMV1cbiAgb3V0WzE0XSA9IHZbMl1cbiAgb3V0WzE1XSA9IDFcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmcm9tWFJvdGF0aW9uXG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFggYXhpc1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdClcbiAqICAgICBtYXQ0LnJvdGF0ZVgoZGVzdCwgZGVzdCwgcmFkKVxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIGZyb21YUm90YXRpb24ob3V0LCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpXG5cbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzBdID0gMVxuICAgIG91dFsxXSA9IDBcbiAgICBvdXRbMl0gPSAwXG4gICAgb3V0WzNdID0gMFxuICAgIG91dFs0XSA9IDBcbiAgICBvdXRbNV0gPSBjXG4gICAgb3V0WzZdID0gc1xuICAgIG91dFs3XSA9IDBcbiAgICBvdXRbOF0gPSAwXG4gICAgb3V0WzldID0gLXNcbiAgICBvdXRbMTBdID0gY1xuICAgIG91dFsxMV0gPSAwXG4gICAgb3V0WzEyXSA9IDBcbiAgICBvdXRbMTNdID0gMFxuICAgIG91dFsxNF0gPSAwXG4gICAgb3V0WzE1XSA9IDFcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBmcm9tWVJvdGF0aW9uXG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFkgYXhpc1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdClcbiAqICAgICBtYXQ0LnJvdGF0ZVkoZGVzdCwgZGVzdCwgcmFkKVxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIGZyb21ZUm90YXRpb24ob3V0LCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpXG5cbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzBdID0gY1xuICAgIG91dFsxXSA9IDBcbiAgICBvdXRbMl0gPSAtc1xuICAgIG91dFszXSA9IDBcbiAgICBvdXRbNF0gPSAwXG4gICAgb3V0WzVdID0gMVxuICAgIG91dFs2XSA9IDBcbiAgICBvdXRbN10gPSAwXG4gICAgb3V0WzhdID0gc1xuICAgIG91dFs5XSA9IDBcbiAgICBvdXRbMTBdID0gY1xuICAgIG91dFsxMV0gPSAwXG4gICAgb3V0WzEyXSA9IDBcbiAgICBvdXRbMTNdID0gMFxuICAgIG91dFsxNF0gPSAwXG4gICAgb3V0WzE1XSA9IDFcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBmcm9tWlJvdGF0aW9uXG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFogYXhpc1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdClcbiAqICAgICBtYXQ0LnJvdGF0ZVooZGVzdCwgZGVzdCwgcmFkKVxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIGZyb21aUm90YXRpb24ob3V0LCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpXG5cbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzBdID0gY1xuICAgIG91dFsxXSA9IHNcbiAgICBvdXRbMl0gPSAwXG4gICAgb3V0WzNdID0gMFxuICAgIG91dFs0XSA9IC1zXG4gICAgb3V0WzVdID0gY1xuICAgIG91dFs2XSA9IDBcbiAgICBvdXRbN10gPSAwXG4gICAgb3V0WzhdID0gMFxuICAgIG91dFs5XSA9IDBcbiAgICBvdXRbMTBdID0gMVxuICAgIG91dFsxMV0gPSAwXG4gICAgb3V0WzEyXSA9IDBcbiAgICBvdXRbMTNdID0gMFxuICAgIG91dFsxNF0gPSAwXG4gICAgb3V0WzE1XSA9IDFcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBmcnVzdHVtO1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGZydXN0dW0gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7TnVtYmVyfSBsZWZ0IExlZnQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSByaWdodCBSaWdodCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IGJvdHRvbSBCb3R0b20gYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSB0b3AgVG9wIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gbmVhciBOZWFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gZmFyIEZhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiBmcnVzdHVtKG91dCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpIHtcbiAgICB2YXIgcmwgPSAxIC8gKHJpZ2h0IC0gbGVmdCksXG4gICAgICAgIHRiID0gMSAvICh0b3AgLSBib3R0b20pLFxuICAgICAgICBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzBdID0gKG5lYXIgKiAyKSAqIHJsO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gKG5lYXIgKiAyKSAqIHRiO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAocmlnaHQgKyBsZWZ0KSAqIHJsO1xuICAgIG91dFs5XSA9ICh0b3AgKyBib3R0b20pICogdGI7XG4gICAgb3V0WzEwXSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuICAgIG91dFsxMV0gPSAtMTtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gKGZhciAqIG5lYXIgKiAyKSAqIG5mO1xuICAgIG91dFsxNV0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gaWRlbnRpdHk7XG5cbi8qKlxuICogU2V0IGEgbWF0NCB0byB0aGUgaWRlbnRpdHkgbWF0cml4XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gaWRlbnRpdHkob3V0KSB7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDE7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gMTtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgY3JlYXRlOiByZXF1aXJlKCcuL2NyZWF0ZScpXG4gICwgY2xvbmU6IHJlcXVpcmUoJy4vY2xvbmUnKVxuICAsIGNvcHk6IHJlcXVpcmUoJy4vY29weScpXG4gICwgaWRlbnRpdHk6IHJlcXVpcmUoJy4vaWRlbnRpdHknKVxuICAsIHRyYW5zcG9zZTogcmVxdWlyZSgnLi90cmFuc3Bvc2UnKVxuICAsIGludmVydDogcmVxdWlyZSgnLi9pbnZlcnQnKVxuICAsIGFkam9pbnQ6IHJlcXVpcmUoJy4vYWRqb2ludCcpXG4gICwgZGV0ZXJtaW5hbnQ6IHJlcXVpcmUoJy4vZGV0ZXJtaW5hbnQnKVxuICAsIG11bHRpcGx5OiByZXF1aXJlKCcuL211bHRpcGx5JylcbiAgLCB0cmFuc2xhdGU6IHJlcXVpcmUoJy4vdHJhbnNsYXRlJylcbiAgLCBzY2FsZTogcmVxdWlyZSgnLi9zY2FsZScpXG4gICwgcm90YXRlOiByZXF1aXJlKCcuL3JvdGF0ZScpXG4gICwgcm90YXRlWDogcmVxdWlyZSgnLi9yb3RhdGVYJylcbiAgLCByb3RhdGVZOiByZXF1aXJlKCcuL3JvdGF0ZVknKVxuICAsIHJvdGF0ZVo6IHJlcXVpcmUoJy4vcm90YXRlWicpXG4gICwgZnJvbVJvdGF0aW9uOiByZXF1aXJlKCcuL2Zyb21Sb3RhdGlvbicpXG4gICwgZnJvbVJvdGF0aW9uVHJhbnNsYXRpb246IHJlcXVpcmUoJy4vZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24nKVxuICAsIGZyb21TY2FsaW5nOiByZXF1aXJlKCcuL2Zyb21TY2FsaW5nJylcbiAgLCBmcm9tVHJhbnNsYXRpb246IHJlcXVpcmUoJy4vZnJvbVRyYW5zbGF0aW9uJylcbiAgLCBmcm9tWFJvdGF0aW9uOiByZXF1aXJlKCcuL2Zyb21YUm90YXRpb24nKVxuICAsIGZyb21ZUm90YXRpb246IHJlcXVpcmUoJy4vZnJvbVlSb3RhdGlvbicpXG4gICwgZnJvbVpSb3RhdGlvbjogcmVxdWlyZSgnLi9mcm9tWlJvdGF0aW9uJylcbiAgLCBmcm9tUXVhdDogcmVxdWlyZSgnLi9mcm9tUXVhdCcpXG4gICwgZnJ1c3R1bTogcmVxdWlyZSgnLi9mcnVzdHVtJylcbiAgLCBwZXJzcGVjdGl2ZTogcmVxdWlyZSgnLi9wZXJzcGVjdGl2ZScpXG4gICwgcGVyc3BlY3RpdmVGcm9tRmllbGRPZlZpZXc6IHJlcXVpcmUoJy4vcGVyc3BlY3RpdmVGcm9tRmllbGRPZlZpZXcnKVxuICAsIG9ydGhvOiByZXF1aXJlKCcuL29ydGhvJylcbiAgLCBsb29rQXQ6IHJlcXVpcmUoJy4vbG9va0F0JylcbiAgLCBzdHI6IHJlcXVpcmUoJy4vc3RyJylcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gaW52ZXJ0O1xuXG4vKipcbiAqIEludmVydHMgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiBpbnZlcnQob3V0LCBhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV0sXG5cbiAgICAgICAgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwLFxuICAgICAgICBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTAsXG4gICAgICAgIGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMCxcbiAgICAgICAgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExLFxuICAgICAgICBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTEsXG4gICAgICAgIGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMixcbiAgICAgICAgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwLFxuICAgICAgICBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzAsXG4gICAgICAgIGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMCxcbiAgICAgICAgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxLFxuICAgICAgICBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzEsXG4gICAgICAgIGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMixcblxuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGRldGVybWluYW50XG4gICAgICAgIGRldCA9IGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcblxuICAgIGlmICghZGV0KSB7IFxuICAgICAgICByZXR1cm4gbnVsbDsgXG4gICAgfVxuICAgIGRldCA9IDEuMCAvIGRldDtcblxuICAgIG91dFswXSA9IChhMTEgKiBiMTEgLSBhMTIgKiBiMTAgKyBhMTMgKiBiMDkpICogZGV0O1xuICAgIG91dFsxXSA9IChhMDIgKiBiMTAgLSBhMDEgKiBiMTEgLSBhMDMgKiBiMDkpICogZGV0O1xuICAgIG91dFsyXSA9IChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0O1xuICAgIG91dFszXSA9IChhMjIgKiBiMDQgLSBhMjEgKiBiMDUgLSBhMjMgKiBiMDMpICogZGV0O1xuICAgIG91dFs0XSA9IChhMTIgKiBiMDggLSBhMTAgKiBiMTEgLSBhMTMgKiBiMDcpICogZGV0O1xuICAgIG91dFs1XSA9IChhMDAgKiBiMTEgLSBhMDIgKiBiMDggKyBhMDMgKiBiMDcpICogZGV0O1xuICAgIG91dFs2XSA9IChhMzIgKiBiMDIgLSBhMzAgKiBiMDUgLSBhMzMgKiBiMDEpICogZGV0O1xuICAgIG91dFs3XSA9IChhMjAgKiBiMDUgLSBhMjIgKiBiMDIgKyBhMjMgKiBiMDEpICogZGV0O1xuICAgIG91dFs4XSA9IChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0O1xuICAgIG91dFs5XSA9IChhMDEgKiBiMDggLSBhMDAgKiBiMTAgLSBhMDMgKiBiMDYpICogZGV0O1xuICAgIG91dFsxMF0gPSAoYTMwICogYjA0IC0gYTMxICogYjAyICsgYTMzICogYjAwKSAqIGRldDtcbiAgICBvdXRbMTFdID0gKGEyMSAqIGIwMiAtIGEyMCAqIGIwNCAtIGEyMyAqIGIwMCkgKiBkZXQ7XG4gICAgb3V0WzEyXSA9IChhMTEgKiBiMDcgLSBhMTAgKiBiMDkgLSBhMTIgKiBiMDYpICogZGV0O1xuICAgIG91dFsxM10gPSAoYTAwICogYjA5IC0gYTAxICogYjA3ICsgYTAyICogYjA2KSAqIGRldDtcbiAgICBvdXRbMTRdID0gKGEzMSAqIGIwMSAtIGEzMCAqIGIwMyAtIGEzMiAqIGIwMCkgKiBkZXQ7XG4gICAgb3V0WzE1XSA9IChhMjAgKiBiMDMgLSBhMjEgKiBiMDEgKyBhMjIgKiBiMDApICogZGV0O1xuXG4gICAgcmV0dXJuIG91dDtcbn07IiwidmFyIGlkZW50aXR5ID0gcmVxdWlyZSgnLi9pZGVudGl0eScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGxvb2tBdDtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBsb29rLWF0IG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBleWUgcG9zaXRpb24sIGZvY2FsIHBvaW50LCBhbmQgdXAgYXhpc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7dmVjM30gZXllIFBvc2l0aW9uIG9mIHRoZSB2aWV3ZXJcbiAqIEBwYXJhbSB7dmVjM30gY2VudGVyIFBvaW50IHRoZSB2aWV3ZXIgaXMgbG9va2luZyBhdFxuICogQHBhcmFtIHt2ZWMzfSB1cCB2ZWMzIHBvaW50aW5nIHVwXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIGxvb2tBdChvdXQsIGV5ZSwgY2VudGVyLCB1cCkge1xuICAgIHZhciB4MCwgeDEsIHgyLCB5MCwgeTEsIHkyLCB6MCwgejEsIHoyLCBsZW4sXG4gICAgICAgIGV5ZXggPSBleWVbMF0sXG4gICAgICAgIGV5ZXkgPSBleWVbMV0sXG4gICAgICAgIGV5ZXogPSBleWVbMl0sXG4gICAgICAgIHVweCA9IHVwWzBdLFxuICAgICAgICB1cHkgPSB1cFsxXSxcbiAgICAgICAgdXB6ID0gdXBbMl0sXG4gICAgICAgIGNlbnRlcnggPSBjZW50ZXJbMF0sXG4gICAgICAgIGNlbnRlcnkgPSBjZW50ZXJbMV0sXG4gICAgICAgIGNlbnRlcnogPSBjZW50ZXJbMl07XG5cbiAgICBpZiAoTWF0aC5hYnMoZXlleCAtIGNlbnRlcngpIDwgMC4wMDAwMDEgJiZcbiAgICAgICAgTWF0aC5hYnMoZXlleSAtIGNlbnRlcnkpIDwgMC4wMDAwMDEgJiZcbiAgICAgICAgTWF0aC5hYnMoZXlleiAtIGNlbnRlcnopIDwgMC4wMDAwMDEpIHtcbiAgICAgICAgcmV0dXJuIGlkZW50aXR5KG91dCk7XG4gICAgfVxuXG4gICAgejAgPSBleWV4IC0gY2VudGVyeDtcbiAgICB6MSA9IGV5ZXkgLSBjZW50ZXJ5O1xuICAgIHoyID0gZXlleiAtIGNlbnRlcno7XG5cbiAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KHowICogejAgKyB6MSAqIHoxICsgejIgKiB6Mik7XG4gICAgejAgKj0gbGVuO1xuICAgIHoxICo9IGxlbjtcbiAgICB6MiAqPSBsZW47XG5cbiAgICB4MCA9IHVweSAqIHoyIC0gdXB6ICogejE7XG4gICAgeDEgPSB1cHogKiB6MCAtIHVweCAqIHoyO1xuICAgIHgyID0gdXB4ICogejEgLSB1cHkgKiB6MDtcbiAgICBsZW4gPSBNYXRoLnNxcnQoeDAgKiB4MCArIHgxICogeDEgKyB4MiAqIHgyKTtcbiAgICBpZiAoIWxlbikge1xuICAgICAgICB4MCA9IDA7XG4gICAgICAgIHgxID0gMDtcbiAgICAgICAgeDIgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxlbiA9IDEgLyBsZW47XG4gICAgICAgIHgwICo9IGxlbjtcbiAgICAgICAgeDEgKj0gbGVuO1xuICAgICAgICB4MiAqPSBsZW47XG4gICAgfVxuXG4gICAgeTAgPSB6MSAqIHgyIC0gejIgKiB4MTtcbiAgICB5MSA9IHoyICogeDAgLSB6MCAqIHgyO1xuICAgIHkyID0gejAgKiB4MSAtIHoxICogeDA7XG5cbiAgICBsZW4gPSBNYXRoLnNxcnQoeTAgKiB5MCArIHkxICogeTEgKyB5MiAqIHkyKTtcbiAgICBpZiAoIWxlbikge1xuICAgICAgICB5MCA9IDA7XG4gICAgICAgIHkxID0gMDtcbiAgICAgICAgeTIgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGxlbiA9IDEgLyBsZW47XG4gICAgICAgIHkwICo9IGxlbjtcbiAgICAgICAgeTEgKj0gbGVuO1xuICAgICAgICB5MiAqPSBsZW47XG4gICAgfVxuXG4gICAgb3V0WzBdID0geDA7XG4gICAgb3V0WzFdID0geTA7XG4gICAgb3V0WzJdID0gejA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSB4MTtcbiAgICBvdXRbNV0gPSB5MTtcbiAgICBvdXRbNl0gPSB6MTtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IHgyO1xuICAgIG91dFs5XSA9IHkyO1xuICAgIG91dFsxMF0gPSB6MjtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gLSh4MCAqIGV5ZXggKyB4MSAqIGV5ZXkgKyB4MiAqIGV5ZXopO1xuICAgIG91dFsxM10gPSAtKHkwICogZXlleCArIHkxICogZXlleSArIHkyICogZXlleik7XG4gICAgb3V0WzE0XSA9IC0oejAgKiBleWV4ICsgejEgKiBleWV5ICsgejIgKiBleWV6KTtcbiAgICBvdXRbMTVdID0gMTtcblxuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gbXVsdGlwbHk7XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gbWF0NCdzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHttYXQ0fSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdLFxuICAgICAgICBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XTtcblxuICAgIC8vIENhY2hlIG9ubHkgdGhlIGN1cnJlbnQgbGluZSBvZiB0aGUgc2Vjb25kIG1hdHJpeFxuICAgIHZhciBiMCAgPSBiWzBdLCBiMSA9IGJbMV0sIGIyID0gYlsyXSwgYjMgPSBiWzNdOyAgXG4gICAgb3V0WzBdID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICAgIG91dFsxXSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgICBvdXRbMl0gPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gICAgb3V0WzNdID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuXG4gICAgYjAgPSBiWzRdOyBiMSA9IGJbNV07IGIyID0gYls2XTsgYjMgPSBiWzddO1xuICAgIG91dFs0XSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBvdXRbNV0gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0WzZdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIG91dFs3XSA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcblxuICAgIGIwID0gYls4XTsgYjEgPSBiWzldOyBiMiA9IGJbMTBdOyBiMyA9IGJbMTFdO1xuICAgIG91dFs4XSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBvdXRbOV0gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0WzEwXSA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBvdXRbMTFdID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuXG4gICAgYjAgPSBiWzEyXTsgYjEgPSBiWzEzXTsgYjIgPSBiWzE0XTsgYjMgPSBiWzE1XTtcbiAgICBvdXRbMTJdID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICAgIG91dFsxM10gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0WzE0XSA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBvdXRbMTVdID0gYjAqYTAzICsgYjEqYTEzICsgYjIqYTIzICsgYjMqYTMzO1xuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gb3J0aG87XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgb3J0aG9nb25hbCBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge251bWJlcn0gbGVmdCBMZWZ0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gcmlnaHQgUmlnaHQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBib3R0b20gQm90dG9tIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gdG9wIFRvcCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gb3J0aG8ob3V0LCBsZWZ0LCByaWdodCwgYm90dG9tLCB0b3AsIG5lYXIsIGZhcikge1xuICAgIHZhciBsciA9IDEgLyAobGVmdCAtIHJpZ2h0KSxcbiAgICAgICAgYnQgPSAxIC8gKGJvdHRvbSAtIHRvcCksXG4gICAgICAgIG5mID0gMSAvIChuZWFyIC0gZmFyKTtcbiAgICBvdXRbMF0gPSAtMiAqIGxyO1xuICAgIG91dFsxXSA9IDA7XG4gICAgb3V0WzJdID0gMDtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IDA7XG4gICAgb3V0WzVdID0gLTIgKiBidDtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gMDtcbiAgICBvdXRbOV0gPSAwO1xuICAgIG91dFsxMF0gPSAyICogbmY7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IChsZWZ0ICsgcmlnaHQpICogbHI7XG4gICAgb3V0WzEzXSA9ICh0b3AgKyBib3R0b20pICogYnQ7XG4gICAgb3V0WzE0XSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gcGVyc3BlY3RpdmU7XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtudW1iZXJ9IGZvdnkgVmVydGljYWwgZmllbGQgb2YgdmlldyBpbiByYWRpYW5zXG4gKiBAcGFyYW0ge251bWJlcn0gYXNwZWN0IEFzcGVjdCByYXRpby4gdHlwaWNhbGx5IHZpZXdwb3J0IHdpZHRoL2hlaWdodFxuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gcGVyc3BlY3RpdmUob3V0LCBmb3Z5LCBhc3BlY3QsIG5lYXIsIGZhcikge1xuICAgIHZhciBmID0gMS4wIC8gTWF0aC50YW4oZm92eSAvIDIpLFxuICAgICAgICBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzBdID0gZiAvIGFzcGVjdDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IGY7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gKGZhciArIG5lYXIpICogbmY7XG4gICAgb3V0WzExXSA9IC0xO1xuICAgIG91dFsxMl0gPSAwO1xuICAgIG91dFsxM10gPSAwO1xuICAgIG91dFsxNF0gPSAoMiAqIGZhciAqIG5lYXIpICogbmY7XG4gICAgb3V0WzE1XSA9IDA7XG4gICAgcmV0dXJuIG91dDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSBwZXJzcGVjdGl2ZUZyb21GaWVsZE9mVmlldztcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBwZXJzcGVjdGl2ZSBwcm9qZWN0aW9uIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBmaWVsZCBvZiB2aWV3LlxuICogVGhpcyBpcyBwcmltYXJpbHkgdXNlZnVsIGZvciBnZW5lcmF0aW5nIHByb2plY3Rpb24gbWF0cmljZXMgdG8gYmUgdXNlZFxuICogd2l0aCB0aGUgc3RpbGwgZXhwZXJpZW1lbnRhbCBXZWJWUiBBUEkuXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtudW1iZXJ9IGZvdiBPYmplY3QgY29udGFpbmluZyB0aGUgZm9sbG93aW5nIHZhbHVlczogdXBEZWdyZWVzLCBkb3duRGVncmVlcywgbGVmdERlZ3JlZXMsIHJpZ2h0RGVncmVlc1xuICogQHBhcmFtIHtudW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gcGVyc3BlY3RpdmVGcm9tRmllbGRPZlZpZXcob3V0LCBmb3YsIG5lYXIsIGZhcikge1xuICAgIHZhciB1cFRhbiA9IE1hdGgudGFuKGZvdi51cERlZ3JlZXMgKiBNYXRoLlBJLzE4MC4wKSxcbiAgICAgICAgZG93blRhbiA9IE1hdGgudGFuKGZvdi5kb3duRGVncmVlcyAqIE1hdGguUEkvMTgwLjApLFxuICAgICAgICBsZWZ0VGFuID0gTWF0aC50YW4oZm92LmxlZnREZWdyZWVzICogTWF0aC5QSS8xODAuMCksXG4gICAgICAgIHJpZ2h0VGFuID0gTWF0aC50YW4oZm92LnJpZ2h0RGVncmVlcyAqIE1hdGguUEkvMTgwLjApLFxuICAgICAgICB4U2NhbGUgPSAyLjAgLyAobGVmdFRhbiArIHJpZ2h0VGFuKSxcbiAgICAgICAgeVNjYWxlID0gMi4wIC8gKHVwVGFuICsgZG93blRhbik7XG5cbiAgICBvdXRbMF0gPSB4U2NhbGU7XG4gICAgb3V0WzFdID0gMC4wO1xuICAgIG91dFsyXSA9IDAuMDtcbiAgICBvdXRbM10gPSAwLjA7XG4gICAgb3V0WzRdID0gMC4wO1xuICAgIG91dFs1XSA9IHlTY2FsZTtcbiAgICBvdXRbNl0gPSAwLjA7XG4gICAgb3V0WzddID0gMC4wO1xuICAgIG91dFs4XSA9IC0oKGxlZnRUYW4gLSByaWdodFRhbikgKiB4U2NhbGUgKiAwLjUpO1xuICAgIG91dFs5XSA9ICgodXBUYW4gLSBkb3duVGFuKSAqIHlTY2FsZSAqIDAuNSk7XG4gICAgb3V0WzEwXSA9IGZhciAvIChuZWFyIC0gZmFyKTtcbiAgICBvdXRbMTFdID0gLTEuMDtcbiAgICBvdXRbMTJdID0gMC4wO1xuICAgIG91dFsxM10gPSAwLjA7XG4gICAgb3V0WzE0XSA9IChmYXIgKiBuZWFyKSAvIChuZWFyIC0gZmFyKTtcbiAgICBvdXRbMTVdID0gMC4wO1xuICAgIHJldHVybiBvdXQ7XG59XG5cbiIsIm1vZHVsZS5leHBvcnRzID0gcm90YXRlO1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXQ0IGJ5IHRoZSBnaXZlbiBhbmdsZVxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcGFyYW0ge3ZlYzN9IGF4aXMgdGhlIGF4aXMgdG8gcm90YXRlIGFyb3VuZFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiByb3RhdGUob3V0LCBhLCByYWQsIGF4aXMpIHtcbiAgICB2YXIgeCA9IGF4aXNbMF0sIHkgPSBheGlzWzFdLCB6ID0gYXhpc1syXSxcbiAgICAgICAgbGVuID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeiksXG4gICAgICAgIHMsIGMsIHQsXG4gICAgICAgIGEwMCwgYTAxLCBhMDIsIGEwMyxcbiAgICAgICAgYTEwLCBhMTEsIGExMiwgYTEzLFxuICAgICAgICBhMjAsIGEyMSwgYTIyLCBhMjMsXG4gICAgICAgIGIwMCwgYjAxLCBiMDIsXG4gICAgICAgIGIxMCwgYjExLCBiMTIsXG4gICAgICAgIGIyMCwgYjIxLCBiMjI7XG5cbiAgICBpZiAoTWF0aC5hYnMobGVuKSA8IDAuMDAwMDAxKSB7IHJldHVybiBudWxsOyB9XG4gICAgXG4gICAgbGVuID0gMSAvIGxlbjtcbiAgICB4ICo9IGxlbjtcbiAgICB5ICo9IGxlbjtcbiAgICB6ICo9IGxlbjtcblxuICAgIHMgPSBNYXRoLnNpbihyYWQpO1xuICAgIGMgPSBNYXRoLmNvcyhyYWQpO1xuICAgIHQgPSAxIC0gYztcblxuICAgIGEwMCA9IGFbMF07IGEwMSA9IGFbMV07IGEwMiA9IGFbMl07IGEwMyA9IGFbM107XG4gICAgYTEwID0gYVs0XTsgYTExID0gYVs1XTsgYTEyID0gYVs2XTsgYTEzID0gYVs3XTtcbiAgICBhMjAgPSBhWzhdOyBhMjEgPSBhWzldOyBhMjIgPSBhWzEwXTsgYTIzID0gYVsxMV07XG5cbiAgICAvLyBDb25zdHJ1Y3QgdGhlIGVsZW1lbnRzIG9mIHRoZSByb3RhdGlvbiBtYXRyaXhcbiAgICBiMDAgPSB4ICogeCAqIHQgKyBjOyBiMDEgPSB5ICogeCAqIHQgKyB6ICogczsgYjAyID0geiAqIHggKiB0IC0geSAqIHM7XG4gICAgYjEwID0geCAqIHkgKiB0IC0geiAqIHM7IGIxMSA9IHkgKiB5ICogdCArIGM7IGIxMiA9IHogKiB5ICogdCArIHggKiBzO1xuICAgIGIyMCA9IHggKiB6ICogdCArIHkgKiBzOyBiMjEgPSB5ICogeiAqIHQgLSB4ICogczsgYjIyID0geiAqIHogKiB0ICsgYztcblxuICAgIC8vIFBlcmZvcm0gcm90YXRpb24tc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzBdID0gYTAwICogYjAwICsgYTEwICogYjAxICsgYTIwICogYjAyO1xuICAgIG91dFsxXSA9IGEwMSAqIGIwMCArIGExMSAqIGIwMSArIGEyMSAqIGIwMjtcbiAgICBvdXRbMl0gPSBhMDIgKiBiMDAgKyBhMTIgKiBiMDEgKyBhMjIgKiBiMDI7XG4gICAgb3V0WzNdID0gYTAzICogYjAwICsgYTEzICogYjAxICsgYTIzICogYjAyO1xuICAgIG91dFs0XSA9IGEwMCAqIGIxMCArIGExMCAqIGIxMSArIGEyMCAqIGIxMjtcbiAgICBvdXRbNV0gPSBhMDEgKiBiMTAgKyBhMTEgKiBiMTEgKyBhMjEgKiBiMTI7XG4gICAgb3V0WzZdID0gYTAyICogYjEwICsgYTEyICogYjExICsgYTIyICogYjEyO1xuICAgIG91dFs3XSA9IGEwMyAqIGIxMCArIGExMyAqIGIxMSArIGEyMyAqIGIxMjtcbiAgICBvdXRbOF0gPSBhMDAgKiBiMjAgKyBhMTAgKiBiMjEgKyBhMjAgKiBiMjI7XG4gICAgb3V0WzldID0gYTAxICogYjIwICsgYTExICogYjIxICsgYTIxICogYjIyO1xuICAgIG91dFsxMF0gPSBhMDIgKiBiMjAgKyBhMTIgKiBiMjEgKyBhMjIgKiBiMjI7XG4gICAgb3V0WzExXSA9IGEwMyAqIGIyMCArIGExMyAqIGIyMSArIGEyMyAqIGIyMjtcblxuICAgIGlmIChhICE9PSBvdXQpIHsgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgbGFzdCByb3dcbiAgICAgICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJvdGF0ZVg7XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBYIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiByb3RhdGVYKG91dCwgYSwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKSxcbiAgICAgICAgYTEwID0gYVs0XSxcbiAgICAgICAgYTExID0gYVs1XSxcbiAgICAgICAgYTEyID0gYVs2XSxcbiAgICAgICAgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSxcbiAgICAgICAgYTIxID0gYVs5XSxcbiAgICAgICAgYTIyID0gYVsxMF0sXG4gICAgICAgIGEyMyA9IGFbMTFdO1xuXG4gICAgaWYgKGEgIT09IG91dCkgeyAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCByb3dzXG4gICAgICAgIG91dFswXSAgPSBhWzBdO1xuICAgICAgICBvdXRbMV0gID0gYVsxXTtcbiAgICAgICAgb3V0WzJdICA9IGFbMl07XG4gICAgICAgIG91dFszXSAgPSBhWzNdO1xuICAgICAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgfVxuXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFs0XSA9IGExMCAqIGMgKyBhMjAgKiBzO1xuICAgIG91dFs1XSA9IGExMSAqIGMgKyBhMjEgKiBzO1xuICAgIG91dFs2XSA9IGExMiAqIGMgKyBhMjIgKiBzO1xuICAgIG91dFs3XSA9IGExMyAqIGMgKyBhMjMgKiBzO1xuICAgIG91dFs4XSA9IGEyMCAqIGMgLSBhMTAgKiBzO1xuICAgIG91dFs5XSA9IGEyMSAqIGMgLSBhMTEgKiBzO1xuICAgIG91dFsxMF0gPSBhMjIgKiBjIC0gYTEyICogcztcbiAgICBvdXRbMTFdID0gYTIzICogYyAtIGExMyAqIHM7XG4gICAgcmV0dXJuIG91dDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSByb3RhdGVZO1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWSBheGlzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gcm90YXRlWShvdXQsIGEsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCksXG4gICAgICAgIGEwMCA9IGFbMF0sXG4gICAgICAgIGEwMSA9IGFbMV0sXG4gICAgICAgIGEwMiA9IGFbMl0sXG4gICAgICAgIGEwMyA9IGFbM10sXG4gICAgICAgIGEyMCA9IGFbOF0sXG4gICAgICAgIGEyMSA9IGFbOV0sXG4gICAgICAgIGEyMiA9IGFbMTBdLFxuICAgICAgICBhMjMgPSBhWzExXTtcblxuICAgIGlmIChhICE9PSBvdXQpIHsgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgcm93c1xuICAgICAgICBvdXRbNF0gID0gYVs0XTtcbiAgICAgICAgb3V0WzVdICA9IGFbNV07XG4gICAgICAgIG91dFs2XSAgPSBhWzZdO1xuICAgICAgICBvdXRbN10gID0gYVs3XTtcbiAgICAgICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cblxuICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbMF0gPSBhMDAgKiBjIC0gYTIwICogcztcbiAgICBvdXRbMV0gPSBhMDEgKiBjIC0gYTIxICogcztcbiAgICBvdXRbMl0gPSBhMDIgKiBjIC0gYTIyICogcztcbiAgICBvdXRbM10gPSBhMDMgKiBjIC0gYTIzICogcztcbiAgICBvdXRbOF0gPSBhMDAgKiBzICsgYTIwICogYztcbiAgICBvdXRbOV0gPSBhMDEgKiBzICsgYTIxICogYztcbiAgICBvdXRbMTBdID0gYTAyICogcyArIGEyMiAqIGM7XG4gICAgb3V0WzExXSA9IGEwMyAqIHMgKyBhMjMgKiBjO1xuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gcm90YXRlWjtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFogYXhpc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIHJvdGF0ZVoob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpLFxuICAgICAgICBhMDAgPSBhWzBdLFxuICAgICAgICBhMDEgPSBhWzFdLFxuICAgICAgICBhMDIgPSBhWzJdLFxuICAgICAgICBhMDMgPSBhWzNdLFxuICAgICAgICBhMTAgPSBhWzRdLFxuICAgICAgICBhMTEgPSBhWzVdLFxuICAgICAgICBhMTIgPSBhWzZdLFxuICAgICAgICBhMTMgPSBhWzddO1xuXG4gICAgaWYgKGEgIT09IG91dCkgeyAvLyBJZiB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiBkaWZmZXIsIGNvcHkgdGhlIHVuY2hhbmdlZCBsYXN0IHJvd1xuICAgICAgICBvdXRbOF0gID0gYVs4XTtcbiAgICAgICAgb3V0WzldICA9IGFbOV07XG4gICAgICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICAgICAgb3V0WzExXSA9IGFbMTFdO1xuICAgICAgICBvdXRbMTJdID0gYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgfVxuXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFswXSA9IGEwMCAqIGMgKyBhMTAgKiBzO1xuICAgIG91dFsxXSA9IGEwMSAqIGMgKyBhMTEgKiBzO1xuICAgIG91dFsyXSA9IGEwMiAqIGMgKyBhMTIgKiBzO1xuICAgIG91dFszXSA9IGEwMyAqIGMgKyBhMTMgKiBzO1xuICAgIG91dFs0XSA9IGExMCAqIGMgLSBhMDAgKiBzO1xuICAgIG91dFs1XSA9IGExMSAqIGMgLSBhMDEgKiBzO1xuICAgIG91dFs2XSA9IGExMiAqIGMgLSBhMDIgKiBzO1xuICAgIG91dFs3XSA9IGExMyAqIGMgLSBhMDMgKiBzO1xuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gc2NhbGU7XG5cbi8qKlxuICogU2NhbGVzIHRoZSBtYXQ0IGJ5IHRoZSBkaW1lbnNpb25zIGluIHRoZSBnaXZlbiB2ZWMzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHNjYWxlXG4gKiBAcGFyYW0ge3ZlYzN9IHYgdGhlIHZlYzMgdG8gc2NhbGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICoqL1xuZnVuY3Rpb24gc2NhbGUob3V0LCBhLCB2KSB7XG4gICAgdmFyIHggPSB2WzBdLCB5ID0gdlsxXSwgeiA9IHZbMl07XG5cbiAgICBvdXRbMF0gPSBhWzBdICogeDtcbiAgICBvdXRbMV0gPSBhWzFdICogeDtcbiAgICBvdXRbMl0gPSBhWzJdICogeDtcbiAgICBvdXRbM10gPSBhWzNdICogeDtcbiAgICBvdXRbNF0gPSBhWzRdICogeTtcbiAgICBvdXRbNV0gPSBhWzVdICogeTtcbiAgICBvdXRbNl0gPSBhWzZdICogeTtcbiAgICBvdXRbN10gPSBhWzddICogeTtcbiAgICBvdXRbOF0gPSBhWzhdICogejtcbiAgICBvdXRbOV0gPSBhWzldICogejtcbiAgICBvdXRbMTBdID0gYVsxMF0gKiB6O1xuICAgIG91dFsxMV0gPSBhWzExXSAqIHo7XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gc3RyO1xuXG4vKipcbiAqIFJldHVybnMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBtYXQgbWF0cml4IHRvIHJlcHJlc2VudCBhcyBhIHN0cmluZ1xuICogQHJldHVybnMge1N0cmluZ30gc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBtYXRyaXhcbiAqL1xuZnVuY3Rpb24gc3RyKGEpIHtcbiAgICByZXR1cm4gJ21hdDQoJyArIGFbMF0gKyAnLCAnICsgYVsxXSArICcsICcgKyBhWzJdICsgJywgJyArIGFbM10gKyAnLCAnICtcbiAgICAgICAgICAgICAgICAgICAgYVs0XSArICcsICcgKyBhWzVdICsgJywgJyArIGFbNl0gKyAnLCAnICsgYVs3XSArICcsICcgK1xuICAgICAgICAgICAgICAgICAgICBhWzhdICsgJywgJyArIGFbOV0gKyAnLCAnICsgYVsxMF0gKyAnLCAnICsgYVsxMV0gKyAnLCAnICsgXG4gICAgICAgICAgICAgICAgICAgIGFbMTJdICsgJywgJyArIGFbMTNdICsgJywgJyArIGFbMTRdICsgJywgJyArIGFbMTVdICsgJyknO1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHRyYW5zbGF0ZTtcblxuLyoqXG4gKiBUcmFuc2xhdGUgYSBtYXQ0IGJ5IHRoZSBnaXZlbiB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gdHJhbnNsYXRlXG4gKiBAcGFyYW0ge3ZlYzN9IHYgdmVjdG9yIHRvIHRyYW5zbGF0ZSBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiB0cmFuc2xhdGUob3V0LCBhLCB2KSB7XG4gICAgdmFyIHggPSB2WzBdLCB5ID0gdlsxXSwgeiA9IHZbMl0sXG4gICAgICAgIGEwMCwgYTAxLCBhMDIsIGEwMyxcbiAgICAgICAgYTEwLCBhMTEsIGExMiwgYTEzLFxuICAgICAgICBhMjAsIGEyMSwgYTIyLCBhMjM7XG5cbiAgICBpZiAoYSA9PT0gb3V0KSB7XG4gICAgICAgIG91dFsxMl0gPSBhWzBdICogeCArIGFbNF0gKiB5ICsgYVs4XSAqIHogKyBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMV0gKiB4ICsgYVs1XSAqIHkgKyBhWzldICogeiArIGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsyXSAqIHggKyBhWzZdICogeSArIGFbMTBdICogeiArIGFbMTRdO1xuICAgICAgICBvdXRbMTVdID0gYVszXSAqIHggKyBhWzddICogeSArIGFbMTFdICogeiArIGFbMTVdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGEwMCA9IGFbMF07IGEwMSA9IGFbMV07IGEwMiA9IGFbMl07IGEwMyA9IGFbM107XG4gICAgICAgIGExMCA9IGFbNF07IGExMSA9IGFbNV07IGExMiA9IGFbNl07IGExMyA9IGFbN107XG4gICAgICAgIGEyMCA9IGFbOF07IGEyMSA9IGFbOV07IGEyMiA9IGFbMTBdOyBhMjMgPSBhWzExXTtcblxuICAgICAgICBvdXRbMF0gPSBhMDA7IG91dFsxXSA9IGEwMTsgb3V0WzJdID0gYTAyOyBvdXRbM10gPSBhMDM7XG4gICAgICAgIG91dFs0XSA9IGExMDsgb3V0WzVdID0gYTExOyBvdXRbNl0gPSBhMTI7IG91dFs3XSA9IGExMztcbiAgICAgICAgb3V0WzhdID0gYTIwOyBvdXRbOV0gPSBhMjE7IG91dFsxMF0gPSBhMjI7IG91dFsxMV0gPSBhMjM7XG5cbiAgICAgICAgb3V0WzEyXSA9IGEwMCAqIHggKyBhMTAgKiB5ICsgYTIwICogeiArIGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYTAxICogeCArIGExMSAqIHkgKyBhMjEgKiB6ICsgYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhMDIgKiB4ICsgYTEyICogeSArIGEyMiAqIHogKyBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGEwMyAqIHggKyBhMTMgKiB5ICsgYTIzICogeiArIGFbMTVdO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gdHJhbnNwb3NlO1xuXG4vKipcbiAqIFRyYW5zcG9zZSB0aGUgdmFsdWVzIG9mIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gdHJhbnNwb3NlKG91dCwgYSkge1xuICAgIC8vIElmIHdlIGFyZSB0cmFuc3Bvc2luZyBvdXJzZWx2ZXMgd2UgY2FuIHNraXAgYSBmZXcgc3RlcHMgYnV0IGhhdmUgdG8gY2FjaGUgc29tZSB2YWx1ZXNcbiAgICBpZiAob3V0ID09PSBhKSB7XG4gICAgICAgIHZhciBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgICAgICAgICAgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgICAgIGEyMyA9IGFbMTFdO1xuXG4gICAgICAgIG91dFsxXSA9IGFbNF07XG4gICAgICAgIG91dFsyXSA9IGFbOF07XG4gICAgICAgIG91dFszXSA9IGFbMTJdO1xuICAgICAgICBvdXRbNF0gPSBhMDE7XG4gICAgICAgIG91dFs2XSA9IGFbOV07XG4gICAgICAgIG91dFs3XSA9IGFbMTNdO1xuICAgICAgICBvdXRbOF0gPSBhMDI7XG4gICAgICAgIG91dFs5XSA9IGExMjtcbiAgICAgICAgb3V0WzExXSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTJdID0gYTAzO1xuICAgICAgICBvdXRbMTNdID0gYTEzO1xuICAgICAgICBvdXRbMTRdID0gYTIzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG91dFswXSA9IGFbMF07XG4gICAgICAgIG91dFsxXSA9IGFbNF07XG4gICAgICAgIG91dFsyXSA9IGFbOF07XG4gICAgICAgIG91dFszXSA9IGFbMTJdO1xuICAgICAgICBvdXRbNF0gPSBhWzFdO1xuICAgICAgICBvdXRbNV0gPSBhWzVdO1xuICAgICAgICBvdXRbNl0gPSBhWzldO1xuICAgICAgICBvdXRbN10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzhdID0gYVsyXTtcbiAgICAgICAgb3V0WzldID0gYVs2XTtcbiAgICAgICAgb3V0WzEwXSA9IGFbMTBdO1xuICAgICAgICBvdXRbMTFdID0gYVsxNF07XG4gICAgICAgIG91dFsxMl0gPSBhWzNdO1xuICAgICAgICBvdXRbMTNdID0gYVs3XTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMTFdO1xuICAgICAgICBvdXRbMTVdID0gYVsxNV07XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBvdXQ7XG59OyIsIid1c2Ugc3RyaWN0J1xuXG52YXIgbmRhcnJheSA9IHJlcXVpcmUoJ25kYXJyYXknKVxudmFyIG9wcyAgICAgPSByZXF1aXJlKCduZGFycmF5LW9wcycpXG52YXIgcG9vbCAgICA9IHJlcXVpcmUoJ3R5cGVkYXJyYXktcG9vbCcpXG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlVGV4dHVyZTJEXG5cbnZhciBsaW5lYXJUeXBlcyA9IG51bGxcbnZhciBmaWx0ZXJUeXBlcyA9IG51bGxcbnZhciB3cmFwVHlwZXMgICA9IG51bGxcblxuZnVuY3Rpb24gbGF6eUluaXRMaW5lYXJUeXBlcyhnbCkge1xuICBsaW5lYXJUeXBlcyA9IFtcbiAgICBnbC5MSU5FQVIsXG4gICAgZ2wuTkVBUkVTVF9NSVBNQVBfTElORUFSLFxuICAgIGdsLkxJTkVBUl9NSVBNQVBfTkVBUkVTVCxcbiAgICBnbC5MSU5FQVJfTUlQTUFQX05FQVJFU1RcbiAgXVxuICBmaWx0ZXJUeXBlcyA9IFtcbiAgICBnbC5ORUFSRVNULFxuICAgIGdsLkxJTkVBUixcbiAgICBnbC5ORUFSRVNUX01JUE1BUF9ORUFSRVNULFxuICAgIGdsLk5FQVJFU1RfTUlQTUFQX0xJTkVBUixcbiAgICBnbC5MSU5FQVJfTUlQTUFQX05FQVJFU1QsXG4gICAgZ2wuTElORUFSX01JUE1BUF9MSU5FQVJcbiAgXVxuICB3cmFwVHlwZXMgPSBbXG4gICAgZ2wuUkVQRUFULFxuICAgIGdsLkNMQU1QX1RPX0VER0UsXG4gICAgZ2wuTUlSUk9SRURfUkVQRUFUXG4gIF1cbn1cblxuZnVuY3Rpb24gYWNjZXB0VGV4dHVyZURPTSAob2JqKSB7XG4gIHJldHVybiAoXG4gICAgKCd1bmRlZmluZWQnICE9IHR5cGVvZiBIVE1MQ2FudmFzRWxlbWVudCAmJiBvYmogaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCkgfHxcbiAgICAoJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIEhUTUxJbWFnZUVsZW1lbnQgJiYgb2JqIGluc3RhbmNlb2YgSFRNTEltYWdlRWxlbWVudCkgfHxcbiAgICAoJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIEhUTUxWaWRlb0VsZW1lbnQgJiYgb2JqIGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCkgfHxcbiAgICAoJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIEltYWdlRGF0YSAmJiBvYmogaW5zdGFuY2VvZiBJbWFnZURhdGEpKVxufVxuXG52YXIgY29udmVydEZsb2F0VG9VaW50OCA9IGZ1bmN0aW9uKG91dCwgaW5wKSB7XG4gIG9wcy5tdWxzKG91dCwgaW5wLCAyNTUuMClcbn1cblxuZnVuY3Rpb24gcmVzaGFwZVRleHR1cmUodGV4LCB3LCBoKSB7XG4gIHZhciBnbCA9IHRleC5nbFxuICB2YXIgbWF4U2l6ZSA9IGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVEVYVFVSRV9TSVpFKVxuICBpZih3IDwgMCB8fCB3ID4gbWF4U2l6ZSB8fCBoIDwgMCB8fCBoID4gbWF4U2l6ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignZ2wtdGV4dHVyZTJkOiBJbnZhbGlkIHRleHR1cmUgc2l6ZScpXG4gIH1cbiAgdGV4Ll9zaGFwZSA9IFt3LCBoXVxuICB0ZXguYmluZCgpXG4gIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgdGV4LmZvcm1hdCwgdywgaCwgMCwgdGV4LmZvcm1hdCwgdGV4LnR5cGUsIG51bGwpXG4gIHRleC5fbWlwTGV2ZWxzID0gWzBdXG4gIHJldHVybiB0ZXhcbn1cblxuZnVuY3Rpb24gVGV4dHVyZTJEKGdsLCBoYW5kbGUsIHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZSkge1xuICB0aGlzLmdsID0gZ2xcbiAgdGhpcy5oYW5kbGUgPSBoYW5kbGVcbiAgdGhpcy5mb3JtYXQgPSBmb3JtYXRcbiAgdGhpcy50eXBlID0gdHlwZVxuICB0aGlzLl9zaGFwZSA9IFt3aWR0aCwgaGVpZ2h0XVxuICB0aGlzLl9taXBMZXZlbHMgPSBbMF1cbiAgdGhpcy5fbWFnRmlsdGVyID0gZ2wuTkVBUkVTVFxuICB0aGlzLl9taW5GaWx0ZXIgPSBnbC5ORUFSRVNUXG4gIHRoaXMuX3dyYXBTID0gZ2wuQ0xBTVBfVE9fRURHRVxuICB0aGlzLl93cmFwVCA9IGdsLkNMQU1QX1RPX0VER0VcbiAgdGhpcy5fYW5pc29TYW1wbGVzID0gMVxuXG4gIHZhciBwYXJlbnQgPSB0aGlzXG4gIHZhciB3cmFwVmVjdG9yID0gW3RoaXMuX3dyYXBTLCB0aGlzLl93cmFwVF1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMod3JhcFZlY3RvciwgW1xuICAgIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBwYXJlbnQuX3dyYXBTXG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgIHJldHVybiBwYXJlbnQud3JhcFMgPSB2XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcGFyZW50Ll93cmFwVFxuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICByZXR1cm4gcGFyZW50LndyYXBUID0gdlxuICAgICAgfVxuICAgIH1cbiAgXSlcbiAgdGhpcy5fd3JhcFZlY3RvciA9IHdyYXBWZWN0b3JcblxuICB2YXIgc2hhcGVWZWN0b3IgPSBbdGhpcy5fc2hhcGVbMF0sIHRoaXMuX3NoYXBlWzFdXVxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhzaGFwZVZlY3RvciwgW1xuICAgIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBwYXJlbnQuX3NoYXBlWzBdXG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICAgIHJldHVybiBwYXJlbnQud2lkdGggPSB2XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcGFyZW50Ll9zaGFwZVsxXVxuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICByZXR1cm4gcGFyZW50LmhlaWdodCA9IHZcbiAgICAgIH1cbiAgICB9XG4gIF0pXG4gIHRoaXMuX3NoYXBlVmVjdG9yID0gc2hhcGVWZWN0b3Jcbn1cblxudmFyIHByb3RvID0gVGV4dHVyZTJELnByb3RvdHlwZVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhwcm90bywge1xuICBtaW5GaWx0ZXI6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21pbkZpbHRlclxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICB0aGlzLmJpbmQoKVxuICAgICAgdmFyIGdsID0gdGhpcy5nbFxuICAgICAgaWYodGhpcy50eXBlID09PSBnbC5GTE9BVCAmJiBsaW5lYXJUeXBlcy5pbmRleE9mKHYpID49IDApIHtcbiAgICAgICAgaWYoIWdsLmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJykpIHtcbiAgICAgICAgICB2ID0gZ2wuTkVBUkVTVFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZihmaWx0ZXJUeXBlcy5pbmRleE9mKHYpIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXRleHR1cmUyZDogVW5rbm93biBmaWx0ZXIgbW9kZSAnICsgdilcbiAgICAgIH1cbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCB2KVxuICAgICAgcmV0dXJuIHRoaXMuX21pbkZpbHRlciA9IHZcbiAgICB9XG4gIH0sXG4gIG1hZ0ZpbHRlcjoge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWFnRmlsdGVyXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHRoaXMuYmluZCgpXG4gICAgICB2YXIgZ2wgPSB0aGlzLmdsXG4gICAgICBpZih0aGlzLnR5cGUgPT09IGdsLkZMT0FUICYmIGxpbmVhclR5cGVzLmluZGV4T2YodikgPj0gMCkge1xuICAgICAgICBpZighZ2wuZ2V0RXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9mbG9hdF9saW5lYXInKSkge1xuICAgICAgICAgIHYgPSBnbC5ORUFSRVNUXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmKGZpbHRlclR5cGVzLmluZGV4T2YodikgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZ2wtdGV4dHVyZTJkOiBVbmtub3duIGZpbHRlciBtb2RlICcgKyB2KVxuICAgICAgfVxuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIHYpXG4gICAgICByZXR1cm4gdGhpcy5fbWFnRmlsdGVyID0gdlxuICAgIH1cbiAgfSxcbiAgbWlwU2FtcGxlczoge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYW5pc29TYW1wbGVzXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKGkpIHtcbiAgICAgIHZhciBwc2FtcGxlcyA9IHRoaXMuX2FuaXNvU2FtcGxlc1xuICAgICAgdGhpcy5fYW5pc29TYW1wbGVzID0gTWF0aC5tYXgoaSwgMSl8MFxuICAgICAgaWYocHNhbXBsZXMgIT09IHRoaXMuX2FuaXNvU2FtcGxlcykge1xuICAgICAgICB2YXIgZXh0ID0gdGhpcy5nbC5nZXRFeHRlbnNpb24oJ0VYVF90ZXh0dXJlX2ZpbHRlcl9hbmlzb3Ryb3BpYycpXG4gICAgICAgIGlmKGV4dCkge1xuICAgICAgICAgIHRoaXMuZ2wudGV4UGFyYW1ldGVyZih0aGlzLmdsLlRFWFRVUkVfMkQsIGV4dC5URVhUVVJFX01BWF9BTklTT1RST1BZX0VYVCwgdGhpcy5fYW5pc29TYW1wbGVzKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fYW5pc29TYW1wbGVzXG4gICAgfVxuICB9LFxuICB3cmFwUzoge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fd3JhcFNcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgdGhpcy5iaW5kKClcbiAgICAgIGlmKHdyYXBUeXBlcy5pbmRleE9mKHYpIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXRleHR1cmUyZDogVW5rbm93biB3cmFwIG1vZGUgJyArIHYpXG4gICAgICB9XG4gICAgICB0aGlzLmdsLnRleFBhcmFtZXRlcmkodGhpcy5nbC5URVhUVVJFXzJELCB0aGlzLmdsLlRFWFRVUkVfV1JBUF9TLCB2KVxuICAgICAgcmV0dXJuIHRoaXMuX3dyYXBTID0gdlxuICAgIH1cbiAgfSxcbiAgd3JhcFQ6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3dyYXBUXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHRoaXMuYmluZCgpXG4gICAgICBpZih3cmFwVHlwZXMuaW5kZXhPZih2KSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnbC10ZXh0dXJlMmQ6IFVua25vd24gd3JhcCBtb2RlICcgKyB2KVxuICAgICAgfVxuICAgICAgdGhpcy5nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuZ2wuVEVYVFVSRV8yRCwgdGhpcy5nbC5URVhUVVJFX1dSQVBfVCwgdilcbiAgICAgIHJldHVybiB0aGlzLl93cmFwVCA9IHZcbiAgICB9XG4gIH0sXG4gIHdyYXA6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3dyYXBWZWN0b3JcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgaWYoIUFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgdiA9IFt2LHZdXG4gICAgICB9XG4gICAgICBpZih2Lmxlbmd0aCAhPT0gMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXRleHR1cmUyZDogTXVzdCBzcGVjaWZ5IHdyYXAgbW9kZSBmb3Igcm93cyBhbmQgY29sdW1ucycpXG4gICAgICB9XG4gICAgICBmb3IodmFyIGk9MDsgaTwyOyArK2kpIHtcbiAgICAgICAgaWYod3JhcFR5cGVzLmluZGV4T2YodltpXSkgPCAwKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnbC10ZXh0dXJlMmQ6IFVua25vd24gd3JhcCBtb2RlICcgKyB2KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl93cmFwUyA9IHZbMF1cbiAgICAgIHRoaXMuX3dyYXBUID0gdlsxXVxuXG4gICAgICB2YXIgZ2wgPSB0aGlzLmdsXG4gICAgICB0aGlzLmJpbmQoKVxuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgdGhpcy5fd3JhcFMpXG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9ULCB0aGlzLl93cmFwVClcblxuICAgICAgcmV0dXJuIHZcbiAgICB9XG4gIH0sXG4gIHNoYXBlOiB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zaGFwZVZlY3RvclxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih4KSB7XG4gICAgICBpZighQXJyYXkuaXNBcnJheSh4KSkge1xuICAgICAgICB4ID0gW3h8MCx4fDBdXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZih4Lmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZ2wtdGV4dHVyZTJkOiBJbnZhbGlkIHRleHR1cmUgc2hhcGUnKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXNoYXBlVGV4dHVyZSh0aGlzLCB4WzBdfDAsIHhbMV18MClcbiAgICAgIHJldHVybiBbeFswXXwwLCB4WzFdfDBdXG4gICAgfVxuICB9LFxuICB3aWR0aDoge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2hhcGVbMF1cbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odykge1xuICAgICAgdyA9IHd8MFxuICAgICAgcmVzaGFwZVRleHR1cmUodGhpcywgdywgdGhpcy5fc2hhcGVbMV0pXG4gICAgICByZXR1cm4gd1xuICAgIH1cbiAgfSxcbiAgaGVpZ2h0OiB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zaGFwZVsxXVxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbihoKSB7XG4gICAgICBoID0gaHwwXG4gICAgICByZXNoYXBlVGV4dHVyZSh0aGlzLCB0aGlzLl9zaGFwZVswXSwgaClcbiAgICAgIHJldHVybiBoXG4gICAgfVxuICB9XG59KVxuXG5wcm90by5iaW5kID0gZnVuY3Rpb24odW5pdCkge1xuICB2YXIgZ2wgPSB0aGlzLmdsXG4gIGlmKHVuaXQgIT09IHVuZGVmaW5lZCkge1xuICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTAgKyAodW5pdHwwKSlcbiAgfVxuICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLmhhbmRsZSlcbiAgaWYodW5pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuICh1bml0fDApXG4gIH1cbiAgcmV0dXJuIGdsLmdldFBhcmFtZXRlcihnbC5BQ1RJVkVfVEVYVFVSRSkgLSBnbC5URVhUVVJFMFxufVxuXG5wcm90by5kaXNwb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZ2wuZGVsZXRlVGV4dHVyZSh0aGlzLmhhbmRsZSlcbn1cblxucHJvdG8uZ2VuZXJhdGVNaXBtYXAgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5iaW5kKClcbiAgdGhpcy5nbC5nZW5lcmF0ZU1pcG1hcCh0aGlzLmdsLlRFWFRVUkVfMkQpXG5cbiAgLy9VcGRhdGUgbWlwIGxldmVsc1xuICB2YXIgbCA9IE1hdGgubWluKHRoaXMuX3NoYXBlWzBdLCB0aGlzLl9zaGFwZVsxXSlcbiAgZm9yKHZhciBpPTA7IGw+MDsgKytpLCBsPj4+PTEpIHtcbiAgICBpZih0aGlzLl9taXBMZXZlbHMuaW5kZXhPZihpKSA8IDApIHtcbiAgICAgIHRoaXMuX21pcExldmVscy5wdXNoKGkpXG4gICAgfVxuICB9XG59XG5cbnByb3RvLnNldFBpeGVscyA9IGZ1bmN0aW9uKGRhdGEsIHhfb2ZmLCB5X29mZiwgbWlwX2xldmVsKSB7XG4gIHZhciBnbCA9IHRoaXMuZ2xcbiAgdGhpcy5iaW5kKClcbiAgaWYoQXJyYXkuaXNBcnJheSh4X29mZikpIHtcbiAgICBtaXBfbGV2ZWwgPSB5X29mZlxuICAgIHlfb2ZmID0geF9vZmZbMV18MFxuICAgIHhfb2ZmID0geF9vZmZbMF18MFxuICB9IGVsc2Uge1xuICAgIHhfb2ZmID0geF9vZmYgfHwgMFxuICAgIHlfb2ZmID0geV9vZmYgfHwgMFxuICB9XG4gIG1pcF9sZXZlbCA9IG1pcF9sZXZlbCB8fCAwXG4gIHZhciBkaXJlY3REYXRhID0gYWNjZXB0VGV4dHVyZURPTShkYXRhKSA/IGRhdGEgOiBkYXRhLnJhd1xuICBpZihkaXJlY3REYXRhKSB7XG4gICAgdmFyIG5lZWRzTWlwID0gdGhpcy5fbWlwTGV2ZWxzLmluZGV4T2YobWlwX2xldmVsKSA8IDBcbiAgICBpZihuZWVkc01pcCkge1xuICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCB0aGlzLmZvcm1hdCwgdGhpcy5mb3JtYXQsIHRoaXMudHlwZSwgZGlyZWN0RGF0YSlcbiAgICAgIHRoaXMuX21pcExldmVscy5wdXNoKG1pcF9sZXZlbClcbiAgICB9IGVsc2Uge1xuICAgICAgZ2wudGV4U3ViSW1hZ2UyRChnbC5URVhUVVJFXzJELCBtaXBfbGV2ZWwsIHhfb2ZmLCB5X29mZiwgdGhpcy5mb3JtYXQsIHRoaXMudHlwZSwgZGlyZWN0RGF0YSlcbiAgICB9XG4gIH0gZWxzZSBpZihkYXRhLnNoYXBlICYmIGRhdGEuc3RyaWRlICYmIGRhdGEuZGF0YSkge1xuICAgIGlmKGRhdGEuc2hhcGUubGVuZ3RoIDwgMiB8fFxuICAgICAgIHhfb2ZmICsgZGF0YS5zaGFwZVsxXSA+IHRoaXMuX3NoYXBlWzFdPj4+bWlwX2xldmVsIHx8XG4gICAgICAgeV9vZmYgKyBkYXRhLnNoYXBlWzBdID4gdGhpcy5fc2hhcGVbMF0+Pj5taXBfbGV2ZWwgfHxcbiAgICAgICB4X29mZiA8IDAgfHxcbiAgICAgICB5X29mZiA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZ2wtdGV4dHVyZTJkOiBUZXh0dXJlIGRpbWVuc2lvbnMgYXJlIG91dCBvZiBib3VuZHMnKVxuICAgIH1cbiAgICB0ZXhTdWJJbWFnZUFycmF5KGdsLCB4X29mZiwgeV9vZmYsIG1pcF9sZXZlbCwgdGhpcy5mb3JtYXQsIHRoaXMudHlwZSwgdGhpcy5fbWlwTGV2ZWxzLCBkYXRhKVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignZ2wtdGV4dHVyZTJkOiBVbnN1cHBvcnRlZCBkYXRhIHR5cGUnKVxuICB9XG59XG5cblxuZnVuY3Rpb24gaXNQYWNrZWQoc2hhcGUsIHN0cmlkZSkge1xuICBpZihzaGFwZS5sZW5ndGggPT09IDMpIHtcbiAgICByZXR1cm4gIChzdHJpZGVbMl0gPT09IDEpICYmXG4gICAgICAgICAgICAoc3RyaWRlWzFdID09PSBzaGFwZVswXSpzaGFwZVsyXSkgJiZcbiAgICAgICAgICAgIChzdHJpZGVbMF0gPT09IHNoYXBlWzJdKVxuICB9XG4gIHJldHVybiAgKHN0cmlkZVswXSA9PT0gMSkgJiZcbiAgICAgICAgICAoc3RyaWRlWzFdID09PSBzaGFwZVswXSlcbn1cblxuZnVuY3Rpb24gdGV4U3ViSW1hZ2VBcnJheShnbCwgeF9vZmYsIHlfb2ZmLCBtaXBfbGV2ZWwsIGNmb3JtYXQsIGN0eXBlLCBtaXBMZXZlbHMsIGFycmF5KSB7XG4gIHZhciBkdHlwZSA9IGFycmF5LmR0eXBlXG4gIHZhciBzaGFwZSA9IGFycmF5LnNoYXBlLnNsaWNlKClcbiAgaWYoc2hhcGUubGVuZ3RoIDwgMiB8fCBzaGFwZS5sZW5ndGggPiAzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdnbC10ZXh0dXJlMmQ6IEludmFsaWQgbmRhcnJheSwgbXVzdCBiZSAyZCBvciAzZCcpXG4gIH1cbiAgdmFyIHR5cGUgPSAwLCBmb3JtYXQgPSAwXG4gIHZhciBwYWNrZWQgPSBpc1BhY2tlZChzaGFwZSwgYXJyYXkuc3RyaWRlLnNsaWNlKCkpXG4gIGlmKGR0eXBlID09PSAnZmxvYXQzMicpIHtcbiAgICB0eXBlID0gZ2wuRkxPQVRcbiAgfSBlbHNlIGlmKGR0eXBlID09PSAnZmxvYXQ2NCcpIHtcbiAgICB0eXBlID0gZ2wuRkxPQVRcbiAgICBwYWNrZWQgPSBmYWxzZVxuICAgIGR0eXBlID0gJ2Zsb2F0MzInXG4gIH0gZWxzZSBpZihkdHlwZSA9PT0gJ3VpbnQ4Jykge1xuICAgIHR5cGUgPSBnbC5VTlNJR05FRF9CWVRFXG4gIH0gZWxzZSB7XG4gICAgdHlwZSA9IGdsLlVOU0lHTkVEX0JZVEVcbiAgICBwYWNrZWQgPSBmYWxzZVxuICAgIGR0eXBlID0gJ3VpbnQ4J1xuICB9XG4gIHZhciBjaGFubmVscyA9IDFcbiAgaWYoc2hhcGUubGVuZ3RoID09PSAyKSB7XG4gICAgZm9ybWF0ID0gZ2wuTFVNSU5BTkNFXG4gICAgc2hhcGUgPSBbc2hhcGVbMF0sIHNoYXBlWzFdLCAxXVxuICAgIGFycmF5ID0gbmRhcnJheShhcnJheS5kYXRhLCBzaGFwZSwgW2FycmF5LnN0cmlkZVswXSwgYXJyYXkuc3RyaWRlWzFdLCAxXSwgYXJyYXkub2Zmc2V0KVxuICB9IGVsc2UgaWYoc2hhcGUubGVuZ3RoID09PSAzKSB7XG4gICAgaWYoc2hhcGVbMl0gPT09IDEpIHtcbiAgICAgIGZvcm1hdCA9IGdsLkFMUEhBXG4gICAgfSBlbHNlIGlmKHNoYXBlWzJdID09PSAyKSB7XG4gICAgICBmb3JtYXQgPSBnbC5MVU1JTkFOQ0VfQUxQSEFcbiAgICB9IGVsc2UgaWYoc2hhcGVbMl0gPT09IDMpIHtcbiAgICAgIGZvcm1hdCA9IGdsLlJHQlxuICAgIH0gZWxzZSBpZihzaGFwZVsyXSA9PT0gNCkge1xuICAgICAgZm9ybWF0ID0gZ2wuUkdCQVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXRleHR1cmUyZDogSW52YWxpZCBzaGFwZSBmb3IgcGl4ZWwgY29vcmRzJylcbiAgICB9XG4gICAgY2hhbm5lbHMgPSBzaGFwZVsyXVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcignZ2wtdGV4dHVyZTJkOiBJbnZhbGlkIHNoYXBlIGZvciB0ZXh0dXJlJylcbiAgfVxuICAvL0ZvciAxLWNoYW5uZWwgdGV4dHVyZXMgYWxsb3cgY29udmVyc2lvbiBiZXR3ZWVuIGZvcm1hdHNcbiAgaWYoKGZvcm1hdCAgPT09IGdsLkxVTUlOQU5DRSB8fCBmb3JtYXQgID09PSBnbC5BTFBIQSkgJiZcbiAgICAgKGNmb3JtYXQgPT09IGdsLkxVTUlOQU5DRSB8fCBjZm9ybWF0ID09PSBnbC5BTFBIQSkpIHtcbiAgICBmb3JtYXQgPSBjZm9ybWF0XG4gIH1cbiAgaWYoZm9ybWF0ICE9PSBjZm9ybWF0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdnbC10ZXh0dXJlMmQ6IEluY29tcGF0aWJsZSB0ZXh0dXJlIGZvcm1hdCBmb3Igc2V0UGl4ZWxzJylcbiAgfVxuICB2YXIgc2l6ZSA9IGFycmF5LnNpemVcbiAgdmFyIG5lZWRzTWlwID0gbWlwTGV2ZWxzLmluZGV4T2YobWlwX2xldmVsKSA8IDBcbiAgaWYobmVlZHNNaXApIHtcbiAgICBtaXBMZXZlbHMucHVzaChtaXBfbGV2ZWwpXG4gIH1cbiAgaWYodHlwZSA9PT0gY3R5cGUgJiYgcGFja2VkKSB7XG4gICAgLy9BcnJheSBkYXRhIHR5cGVzIGFyZSBjb21wYXRpYmxlLCBjYW4gZGlyZWN0bHkgY29weSBpbnRvIHRleHR1cmVcbiAgICBpZihhcnJheS5vZmZzZXQgPT09IDAgJiYgYXJyYXkuZGF0YS5sZW5ndGggPT09IHNpemUpIHtcbiAgICAgIGlmKG5lZWRzTWlwKSB7XG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgbWlwX2xldmVsLCBjZm9ybWF0LCBzaGFwZVswXSwgc2hhcGVbMV0sIDAsIGNmb3JtYXQsIGN0eXBlLCBhcnJheS5kYXRhKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2wudGV4U3ViSW1hZ2UyRChnbC5URVhUVVJFXzJELCBtaXBfbGV2ZWwsIHhfb2ZmLCB5X29mZiwgc2hhcGVbMF0sIHNoYXBlWzFdLCBjZm9ybWF0LCBjdHlwZSwgYXJyYXkuZGF0YSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYobmVlZHNNaXApIHtcbiAgICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCBtaXBfbGV2ZWwsIGNmb3JtYXQsIHNoYXBlWzBdLCBzaGFwZVsxXSwgMCwgY2Zvcm1hdCwgY3R5cGUsIGFycmF5LmRhdGEuc3ViYXJyYXkoYXJyYXkub2Zmc2V0LCBhcnJheS5vZmZzZXQrc2l6ZSkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnbC50ZXhTdWJJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIG1pcF9sZXZlbCwgeF9vZmYsIHlfb2ZmLCBzaGFwZVswXSwgc2hhcGVbMV0sIGNmb3JtYXQsIGN0eXBlLCBhcnJheS5kYXRhLnN1YmFycmF5KGFycmF5Lm9mZnNldCwgYXJyYXkub2Zmc2V0K3NpemUpKVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvL05lZWQgdG8gZG8gdHlwZSBjb252ZXJzaW9uIHRvIHBhY2sgZGF0YSBpbnRvIGJ1ZmZlclxuICAgIHZhciBwYWNrX2J1ZmZlclxuICAgIGlmKGN0eXBlID09PSBnbC5GTE9BVCkge1xuICAgICAgcGFja19idWZmZXIgPSBwb29sLm1hbGxvY0Zsb2F0MzIoc2l6ZSlcbiAgICB9IGVsc2Uge1xuICAgICAgcGFja19idWZmZXIgPSBwb29sLm1hbGxvY1VpbnQ4KHNpemUpXG4gICAgfVxuICAgIHZhciBwYWNrX3ZpZXcgPSBuZGFycmF5KHBhY2tfYnVmZmVyLCBzaGFwZSwgW3NoYXBlWzJdLCBzaGFwZVsyXSpzaGFwZVswXSwgMV0pXG4gICAgaWYodHlwZSA9PT0gZ2wuRkxPQVQgJiYgY3R5cGUgPT09IGdsLlVOU0lHTkVEX0JZVEUpIHtcbiAgICAgIGNvbnZlcnRGbG9hdFRvVWludDgocGFja192aWV3LCBhcnJheSlcbiAgICB9IGVsc2Uge1xuICAgICAgb3BzLmFzc2lnbihwYWNrX3ZpZXcsIGFycmF5KVxuICAgIH1cbiAgICBpZihuZWVkc01pcCkge1xuICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCBtaXBfbGV2ZWwsIGNmb3JtYXQsIHNoYXBlWzBdLCBzaGFwZVsxXSwgMCwgY2Zvcm1hdCwgY3R5cGUsIHBhY2tfYnVmZmVyLnN1YmFycmF5KDAsIHNpemUpKVxuICAgIH0gZWxzZSB7XG4gICAgICBnbC50ZXhTdWJJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIG1pcF9sZXZlbCwgeF9vZmYsIHlfb2ZmLCBzaGFwZVswXSwgc2hhcGVbMV0sIGNmb3JtYXQsIGN0eXBlLCBwYWNrX2J1ZmZlci5zdWJhcnJheSgwLCBzaXplKSlcbiAgICB9XG4gICAgaWYoY3R5cGUgPT09IGdsLkZMT0FUKSB7XG4gICAgICBwb29sLmZyZWVGbG9hdDMyKHBhY2tfYnVmZmVyKVxuICAgIH0gZWxzZSB7XG4gICAgICBwb29sLmZyZWVVaW50OChwYWNrX2J1ZmZlcilcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFRleHR1cmUoZ2wpIHtcbiAgdmFyIHRleCA9IGdsLmNyZWF0ZVRleHR1cmUoKVxuICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXgpXG4gIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCBnbC5ORUFSRVNUKVxuICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZ2wuTkVBUkVTVClcbiAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSlcbiAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSlcbiAgcmV0dXJuIHRleFxufVxuXG5mdW5jdGlvbiBjcmVhdGVUZXh0dXJlU2hhcGUoZ2wsIHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZSkge1xuICB2YXIgbWF4VGV4dHVyZVNpemUgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1RFWFRVUkVfU0laRSlcbiAgaWYod2lkdGggPCAwIHx8IHdpZHRoID4gbWF4VGV4dHVyZVNpemUgfHwgaGVpZ2h0IDwgMCB8fCBoZWlnaHQgID4gbWF4VGV4dHVyZVNpemUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXRleHR1cmUyZDogSW52YWxpZCB0ZXh0dXJlIHNoYXBlJylcbiAgfVxuICBpZih0eXBlID09PSBnbC5GTE9BVCAmJiAhZ2wuZ2V0RXh0ZW5zaW9uKCdPRVNfdGV4dHVyZV9mbG9hdCcpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdnbC10ZXh0dXJlMmQ6IEZsb2F0aW5nIHBvaW50IHRleHR1cmVzIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBwbGF0Zm9ybScpXG4gIH1cbiAgdmFyIHRleCA9IGluaXRUZXh0dXJlKGdsKVxuICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGZvcm1hdCwgd2lkdGgsIGhlaWdodCwgMCwgZm9ybWF0LCB0eXBlLCBudWxsKVxuICByZXR1cm4gbmV3IFRleHR1cmUyRChnbCwgdGV4LCB3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIHR5cGUpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHR1cmVET00oZ2wsIGRpcmVjdERhdGEsIHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZSkge1xuICB2YXIgdGV4ID0gaW5pdFRleHR1cmUoZ2wpXG4gIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZm9ybWF0LCBmb3JtYXQsIHR5cGUsIGRpcmVjdERhdGEpXG4gIHJldHVybiBuZXcgVGV4dHVyZTJEKGdsLCB0ZXgsIHdpZHRoLCBoZWlnaHQsIGZvcm1hdCwgdHlwZSlcbn1cblxuLy9DcmVhdGVzIGEgdGV4dHVyZSBmcm9tIGFuIG5kYXJyYXlcbmZ1bmN0aW9uIGNyZWF0ZVRleHR1cmVBcnJheShnbCwgYXJyYXkpIHtcbiAgdmFyIGR0eXBlID0gYXJyYXkuZHR5cGVcbiAgdmFyIHNoYXBlID0gYXJyYXkuc2hhcGUuc2xpY2UoKVxuICB2YXIgbWF4U2l6ZSA9IGdsLmdldFBhcmFtZXRlcihnbC5NQVhfVEVYVFVSRV9TSVpFKVxuICBpZihzaGFwZVswXSA8IDAgfHwgc2hhcGVbMF0gPiBtYXhTaXplIHx8IHNoYXBlWzFdIDwgMCB8fCBzaGFwZVsxXSA+IG1heFNpemUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXRleHR1cmUyZDogSW52YWxpZCB0ZXh0dXJlIHNpemUnKVxuICB9XG4gIHZhciBwYWNrZWQgPSBpc1BhY2tlZChzaGFwZSwgYXJyYXkuc3RyaWRlLnNsaWNlKCkpXG4gIHZhciB0eXBlID0gMFxuICBpZihkdHlwZSA9PT0gJ2Zsb2F0MzInKSB7XG4gICAgdHlwZSA9IGdsLkZMT0FUXG4gIH0gZWxzZSBpZihkdHlwZSA9PT0gJ2Zsb2F0NjQnKSB7XG4gICAgdHlwZSA9IGdsLkZMT0FUXG4gICAgcGFja2VkID0gZmFsc2VcbiAgICBkdHlwZSA9ICdmbG9hdDMyJ1xuICB9IGVsc2UgaWYoZHR5cGUgPT09ICd1aW50OCcpIHtcbiAgICB0eXBlID0gZ2wuVU5TSUdORURfQllURVxuICB9IGVsc2Uge1xuICAgIHR5cGUgPSBnbC5VTlNJR05FRF9CWVRFXG4gICAgcGFja2VkID0gZmFsc2VcbiAgICBkdHlwZSA9ICd1aW50OCdcbiAgfVxuICB2YXIgZm9ybWF0ID0gMFxuICBpZihzaGFwZS5sZW5ndGggPT09IDIpIHtcbiAgICBmb3JtYXQgPSBnbC5MVU1JTkFOQ0VcbiAgICBzaGFwZSA9IFtzaGFwZVswXSwgc2hhcGVbMV0sIDFdXG4gICAgYXJyYXkgPSBuZGFycmF5KGFycmF5LmRhdGEsIHNoYXBlLCBbYXJyYXkuc3RyaWRlWzBdLCBhcnJheS5zdHJpZGVbMV0sIDFdLCBhcnJheS5vZmZzZXQpXG4gIH0gZWxzZSBpZihzaGFwZS5sZW5ndGggPT09IDMpIHtcbiAgICBpZihzaGFwZVsyXSA9PT0gMSkge1xuICAgICAgZm9ybWF0ID0gZ2wuQUxQSEFcbiAgICB9IGVsc2UgaWYoc2hhcGVbMl0gPT09IDIpIHtcbiAgICAgIGZvcm1hdCA9IGdsLkxVTUlOQU5DRV9BTFBIQVxuICAgIH0gZWxzZSBpZihzaGFwZVsyXSA9PT0gMykge1xuICAgICAgZm9ybWF0ID0gZ2wuUkdCXG4gICAgfSBlbHNlIGlmKHNoYXBlWzJdID09PSA0KSB7XG4gICAgICBmb3JtYXQgPSBnbC5SR0JBXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZ2wtdGV4dHVyZTJkOiBJbnZhbGlkIHNoYXBlIGZvciBwaXhlbCBjb29yZHMnKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXRleHR1cmUyZDogSW52YWxpZCBzaGFwZSBmb3IgdGV4dHVyZScpXG4gIH1cbiAgaWYodHlwZSA9PT0gZ2wuRkxPQVQgJiYgIWdsLmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXQnKSkge1xuICAgIHR5cGUgPSBnbC5VTlNJR05FRF9CWVRFXG4gICAgcGFja2VkID0gZmFsc2VcbiAgfVxuICB2YXIgYnVmZmVyLCBidWZfc3RvcmVcbiAgdmFyIHNpemUgPSBhcnJheS5zaXplXG4gIGlmKCFwYWNrZWQpIHtcbiAgICB2YXIgc3RyaWRlID0gW3NoYXBlWzJdLCBzaGFwZVsyXSpzaGFwZVswXSwgMV1cbiAgICBidWZfc3RvcmUgPSBwb29sLm1hbGxvYyhzaXplLCBkdHlwZSlcbiAgICB2YXIgYnVmX2FycmF5ID0gbmRhcnJheShidWZfc3RvcmUsIHNoYXBlLCBzdHJpZGUsIDApXG4gICAgaWYoKGR0eXBlID09PSAnZmxvYXQzMicgfHwgZHR5cGUgPT09ICdmbG9hdDY0JykgJiYgdHlwZSA9PT0gZ2wuVU5TSUdORURfQllURSkge1xuICAgICAgY29udmVydEZsb2F0VG9VaW50OChidWZfYXJyYXksIGFycmF5KVxuICAgIH0gZWxzZSB7XG4gICAgICBvcHMuYXNzaWduKGJ1Zl9hcnJheSwgYXJyYXkpXG4gICAgfVxuICAgIGJ1ZmZlciA9IGJ1Zl9zdG9yZS5zdWJhcnJheSgwLCBzaXplKVxuICB9IGVsc2UgaWYgKGFycmF5Lm9mZnNldCA9PT0gMCAmJiBhcnJheS5kYXRhLmxlbmd0aCA9PT0gc2l6ZSkge1xuICAgIGJ1ZmZlciA9IGFycmF5LmRhdGFcbiAgfSBlbHNlIHtcbiAgICBidWZmZXIgPSBhcnJheS5kYXRhLnN1YmFycmF5KGFycmF5Lm9mZnNldCwgYXJyYXkub2Zmc2V0ICsgc2l6ZSlcbiAgfVxuICB2YXIgdGV4ID0gaW5pdFRleHR1cmUoZ2wpXG4gIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZm9ybWF0LCBzaGFwZVswXSwgc2hhcGVbMV0sIDAsIGZvcm1hdCwgdHlwZSwgYnVmZmVyKVxuICBpZighcGFja2VkKSB7XG4gICAgcG9vbC5mcmVlKGJ1Zl9zdG9yZSlcbiAgfVxuICByZXR1cm4gbmV3IFRleHR1cmUyRChnbCwgdGV4LCBzaGFwZVswXSwgc2hhcGVbMV0sIGZvcm1hdCwgdHlwZSlcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGV4dHVyZTJEKGdsKSB7XG4gIGlmKGFyZ3VtZW50cy5sZW5ndGggPD0gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcignZ2wtdGV4dHVyZTJkOiBNaXNzaW5nIGFyZ3VtZW50cyBmb3IgdGV4dHVyZTJkIGNvbnN0cnVjdG9yJylcbiAgfVxuICBpZighbGluZWFyVHlwZXMpIHtcbiAgICBsYXp5SW5pdExpbmVhclR5cGVzKGdsKVxuICB9XG4gIGlmKHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVRleHR1cmVTaGFwZShnbCwgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0sIGFyZ3VtZW50c1szXXx8Z2wuUkdCQSwgYXJndW1lbnRzWzRdfHxnbC5VTlNJR05FRF9CWVRFKVxuICB9XG4gIGlmKEFycmF5LmlzQXJyYXkoYXJndW1lbnRzWzFdKSkge1xuICAgIHJldHVybiBjcmVhdGVUZXh0dXJlU2hhcGUoZ2wsIGFyZ3VtZW50c1sxXVswXXwwLCBhcmd1bWVudHNbMV1bMV18MCwgYXJndW1lbnRzWzJdfHxnbC5SR0JBLCBhcmd1bWVudHNbM118fGdsLlVOU0lHTkVEX0JZVEUpXG4gIH1cbiAgaWYodHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgb2JqID0gYXJndW1lbnRzWzFdXG4gICAgdmFyIGRpcmVjdERhdGEgPSBhY2NlcHRUZXh0dXJlRE9NKG9iaikgPyBvYmogOiBvYmoucmF3XG4gICAgaWYgKGRpcmVjdERhdGEpIHtcbiAgICAgIHJldHVybiBjcmVhdGVUZXh0dXJlRE9NKGdsLCBkaXJlY3REYXRhLCBvYmoud2lkdGh8MCwgb2JqLmhlaWdodHwwLCBhcmd1bWVudHNbMl18fGdsLlJHQkEsIGFyZ3VtZW50c1szXXx8Z2wuVU5TSUdORURfQllURSlcbiAgICB9IGVsc2UgaWYob2JqLnNoYXBlICYmIG9iai5kYXRhICYmIG9iai5zdHJpZGUpIHtcbiAgICAgIHJldHVybiBjcmVhdGVUZXh0dXJlQXJyYXkoZ2wsIG9iailcbiAgICB9XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdnbC10ZXh0dXJlMmQ6IEludmFsaWQgYXJndW1lbnRzIGZvciB0ZXh0dXJlMmQgY29uc3RydWN0b3InKVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBhZGQ7XG5cbi8qKlxuICogQWRkcyB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBhZGQob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSArIGJbMF1cbiAgICBvdXRbMV0gPSBhWzFdICsgYlsxXVxuICAgIG91dFsyXSA9IGFbMl0gKyBiWzJdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gYW5nbGVcblxudmFyIGZyb21WYWx1ZXMgPSByZXF1aXJlKCcuL2Zyb21WYWx1ZXMnKVxudmFyIG5vcm1hbGl6ZSA9IHJlcXVpcmUoJy4vbm9ybWFsaXplJylcbnZhciBkb3QgPSByZXF1aXJlKCcuL2RvdCcpXG5cbi8qKlxuICogR2V0IHRoZSBhbmdsZSBiZXR3ZWVuIHR3byAzRCB2ZWN0b3JzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBhbmdsZSBpbiByYWRpYW5zXG4gKi9cbmZ1bmN0aW9uIGFuZ2xlKGEsIGIpIHtcbiAgICB2YXIgdGVtcEEgPSBmcm9tVmFsdWVzKGFbMF0sIGFbMV0sIGFbMl0pXG4gICAgdmFyIHRlbXBCID0gZnJvbVZhbHVlcyhiWzBdLCBiWzFdLCBiWzJdKVxuIFxuICAgIG5vcm1hbGl6ZSh0ZW1wQSwgdGVtcEEpXG4gICAgbm9ybWFsaXplKHRlbXBCLCB0ZW1wQilcbiBcbiAgICB2YXIgY29zaW5lID0gZG90KHRlbXBBLCB0ZW1wQilcblxuICAgIGlmKGNvc2luZSA+IDEuMCl7XG4gICAgICAgIHJldHVybiAwXG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE1hdGguYWNvcyhjb3NpbmUpXG4gICAgfSAgICAgXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGNlaWxcblxuLyoqXG4gKiBNYXRoLmNlaWwgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gY2VpbFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBjZWlsKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmNlaWwoYVswXSlcbiAgb3V0WzFdID0gTWF0aC5jZWlsKGFbMV0pXG4gIG91dFsyXSA9IE1hdGguY2VpbChhWzJdKVxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGNsb25lO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMyBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIHZlY3RvclxuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gY2xvbmVcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xuZnVuY3Rpb24gY2xvbmUoYSkge1xuICAgIHZhciBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDMpXG4gICAgb3V0WzBdID0gYVswXVxuICAgIG91dFsxXSA9IGFbMV1cbiAgICBvdXRbMl0gPSBhWzJdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gY29weTtcblxuLyoqXG4gKiBDb3B5IHRoZSB2YWx1ZXMgZnJvbSBvbmUgdmVjMyB0byBhbm90aGVyXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgc291cmNlIHZlY3RvclxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBjb3B5KG91dCwgYSkge1xuICAgIG91dFswXSA9IGFbMF1cbiAgICBvdXRbMV0gPSBhWzFdXG4gICAgb3V0WzJdID0gYVsyXVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3LCBlbXB0eSB2ZWMzXG4gKlxuICogQHJldHVybnMge3ZlYzN9IGEgbmV3IDNEIHZlY3RvclxuICovXG5mdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgdmFyIG91dCA9IG5ldyBGbG9hdDMyQXJyYXkoMylcbiAgICBvdXRbMF0gPSAwXG4gICAgb3V0WzFdID0gMFxuICAgIG91dFsyXSA9IDBcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBjcm9zcztcblxuLyoqXG4gKiBDb21wdXRlcyB0aGUgY3Jvc3MgcHJvZHVjdCBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBjcm9zcyhvdXQsIGEsIGIpIHtcbiAgICB2YXIgYXggPSBhWzBdLCBheSA9IGFbMV0sIGF6ID0gYVsyXSxcbiAgICAgICAgYnggPSBiWzBdLCBieSA9IGJbMV0sIGJ6ID0gYlsyXVxuXG4gICAgb3V0WzBdID0gYXkgKiBieiAtIGF6ICogYnlcbiAgICBvdXRbMV0gPSBheiAqIGJ4IC0gYXggKiBielxuICAgIG91dFsyXSA9IGF4ICogYnkgLSBheSAqIGJ4XG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kaXN0YW5jZScpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGRpc3RhbmNlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGV1Y2xpZGlhbiBkaXN0YW5jZSBiZXR3ZWVuIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG5mdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG4gICAgdmFyIHggPSBiWzBdIC0gYVswXSxcbiAgICAgICAgeSA9IGJbMV0gLSBhWzFdLFxuICAgICAgICB6ID0gYlsyXSAtIGFbMl1cbiAgICByZXR1cm4gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeilcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGl2aWRlJylcbiIsIm1vZHVsZS5leHBvcnRzID0gZGl2aWRlO1xuXG4vKipcbiAqIERpdmlkZXMgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gZGl2aWRlKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLyBiWzBdXG4gICAgb3V0WzFdID0gYVsxXSAvIGJbMV1cbiAgICBvdXRbMl0gPSBhWzJdIC8gYlsyXVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGRvdDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkb3QgcHJvZHVjdCBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkb3QgcHJvZHVjdCBvZiBhIGFuZCBiXG4gKi9cbmZ1bmN0aW9uIGRvdChhLCBiKSB7XG4gICAgcmV0dXJuIGFbMF0gKiBiWzBdICsgYVsxXSAqIGJbMV0gKyBhWzJdICogYlsyXVxufSIsIm1vZHVsZS5leHBvcnRzID0gMC4wMDAwMDFcbiIsIm1vZHVsZS5leHBvcnRzID0gZXF1YWxzXG5cbnZhciBFUFNJTE9OID0gcmVxdWlyZSgnLi9lcHNpbG9uJylcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGhhdmUgYXBwcm94aW1hdGVseSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbi5cbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIGZpcnN0IHZlY3Rvci5cbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBlcXVhbHMoYSwgYikge1xuICB2YXIgYTAgPSBhWzBdXG4gIHZhciBhMSA9IGFbMV1cbiAgdmFyIGEyID0gYVsyXVxuICB2YXIgYjAgPSBiWzBdXG4gIHZhciBiMSA9IGJbMV1cbiAgdmFyIGIyID0gYlsyXVxuICByZXR1cm4gKE1hdGguYWJzKGEwIC0gYjApIDw9IEVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEwKSwgTWF0aC5hYnMoYjApKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGExIC0gYjEpIDw9IEVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGExKSwgTWF0aC5hYnMoYjEpKSAmJlxuICAgICAgICAgIE1hdGguYWJzKGEyIC0gYjIpIDw9IEVQU0lMT04gKiBNYXRoLm1heCgxLjAsIE1hdGguYWJzKGEyKSwgTWF0aC5hYnMoYjIpKSlcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZXhhY3RFcXVhbHNcblxuLyoqXG4gKiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSB2ZWN0b3JzIGV4YWN0bHkgaGF2ZSB0aGUgc2FtZSBlbGVtZW50cyBpbiB0aGUgc2FtZSBwb3NpdGlvbiAod2hlbiBjb21wYXJlZCB3aXRoID09PSlcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIGZpcnN0IHZlY3Rvci5cbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgc2Vjb25kIHZlY3Rvci5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmIHRoZSB2ZWN0b3JzIGFyZSBlcXVhbCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5mdW5jdGlvbiBleGFjdEVxdWFscyhhLCBiKSB7XG4gIHJldHVybiBhWzBdID09PSBiWzBdICYmIGFbMV0gPT09IGJbMV0gJiYgYVsyXSA9PT0gYlsyXVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmbG9vclxuXG4vKipcbiAqIE1hdGguZmxvb3IgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gZmxvb3JcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gZmxvb3Iob3V0LCBhKSB7XG4gIG91dFswXSA9IE1hdGguZmxvb3IoYVswXSlcbiAgb3V0WzFdID0gTWF0aC5mbG9vcihhWzFdKVxuICBvdXRbMl0gPSBNYXRoLmZsb29yKGFbMl0pXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZm9yRWFjaDtcblxudmFyIHZlYyA9IHJlcXVpcmUoJy4vY3JlYXRlJykoKVxuXG4vKipcbiAqIFBlcmZvcm0gc29tZSBvcGVyYXRpb24gb3ZlciBhbiBhcnJheSBvZiB2ZWMzcy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhIHRoZSBhcnJheSBvZiB2ZWN0b3JzIHRvIGl0ZXJhdGUgb3ZlclxuICogQHBhcmFtIHtOdW1iZXJ9IHN0cmlkZSBOdW1iZXIgb2YgZWxlbWVudHMgYmV0d2VlbiB0aGUgc3RhcnQgb2YgZWFjaCB2ZWMzLiBJZiAwIGFzc3VtZXMgdGlnaHRseSBwYWNrZWRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgTnVtYmVyIG9mIGVsZW1lbnRzIHRvIHNraXAgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudCBOdW1iZXIgb2YgdmVjM3MgdG8gaXRlcmF0ZSBvdmVyLiBJZiAwIGl0ZXJhdGVzIG92ZXIgZW50aXJlIGFycmF5XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHZlY3RvciBpbiB0aGUgYXJyYXlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbYXJnXSBhZGRpdGlvbmFsIGFyZ3VtZW50IHRvIHBhc3MgdG8gZm5cbiAqIEByZXR1cm5zIHtBcnJheX0gYVxuICogQGZ1bmN0aW9uXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2goYSwgc3RyaWRlLCBvZmZzZXQsIGNvdW50LCBmbiwgYXJnKSB7XG4gICAgICAgIHZhciBpLCBsXG4gICAgICAgIGlmKCFzdHJpZGUpIHtcbiAgICAgICAgICAgIHN0cmlkZSA9IDNcbiAgICAgICAgfVxuXG4gICAgICAgIGlmKCFvZmZzZXQpIHtcbiAgICAgICAgICAgIG9mZnNldCA9IDBcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYoY291bnQpIHtcbiAgICAgICAgICAgIGwgPSBNYXRoLm1pbigoY291bnQgKiBzdHJpZGUpICsgb2Zmc2V0LCBhLmxlbmd0aClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGwgPSBhLmxlbmd0aFxuICAgICAgICB9XG5cbiAgICAgICAgZm9yKGkgPSBvZmZzZXQ7IGkgPCBsOyBpICs9IHN0cmlkZSkge1xuICAgICAgICAgICAgdmVjWzBdID0gYVtpXSBcbiAgICAgICAgICAgIHZlY1sxXSA9IGFbaSsxXSBcbiAgICAgICAgICAgIHZlY1syXSA9IGFbaSsyXVxuICAgICAgICAgICAgZm4odmVjLCB2ZWMsIGFyZylcbiAgICAgICAgICAgIGFbaV0gPSB2ZWNbMF0gXG4gICAgICAgICAgICBhW2krMV0gPSB2ZWNbMV0gXG4gICAgICAgICAgICBhW2krMl0gPSB2ZWNbMl1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGFcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGZyb21WYWx1ZXM7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyB2ZWMzIGluaXRpYWxpemVkIHdpdGggdGhlIGdpdmVuIHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xuZnVuY3Rpb24gZnJvbVZhbHVlcyh4LCB5LCB6KSB7XG4gICAgdmFyIG91dCA9IG5ldyBGbG9hdDMyQXJyYXkoMylcbiAgICBvdXRbMF0gPSB4XG4gICAgb3V0WzFdID0geVxuICAgIG91dFsyXSA9IHpcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIEVQU0lMT046IHJlcXVpcmUoJy4vZXBzaWxvbicpXG4gICwgY3JlYXRlOiByZXF1aXJlKCcuL2NyZWF0ZScpXG4gICwgY2xvbmU6IHJlcXVpcmUoJy4vY2xvbmUnKVxuICAsIGFuZ2xlOiByZXF1aXJlKCcuL2FuZ2xlJylcbiAgLCBmcm9tVmFsdWVzOiByZXF1aXJlKCcuL2Zyb21WYWx1ZXMnKVxuICAsIGNvcHk6IHJlcXVpcmUoJy4vY29weScpXG4gICwgc2V0OiByZXF1aXJlKCcuL3NldCcpXG4gICwgZXF1YWxzOiByZXF1aXJlKCcuL2VxdWFscycpXG4gICwgZXhhY3RFcXVhbHM6IHJlcXVpcmUoJy4vZXhhY3RFcXVhbHMnKVxuICAsIGFkZDogcmVxdWlyZSgnLi9hZGQnKVxuICAsIHN1YnRyYWN0OiByZXF1aXJlKCcuL3N1YnRyYWN0JylcbiAgLCBzdWI6IHJlcXVpcmUoJy4vc3ViJylcbiAgLCBtdWx0aXBseTogcmVxdWlyZSgnLi9tdWx0aXBseScpXG4gICwgbXVsOiByZXF1aXJlKCcuL211bCcpXG4gICwgZGl2aWRlOiByZXF1aXJlKCcuL2RpdmlkZScpXG4gICwgZGl2OiByZXF1aXJlKCcuL2RpdicpXG4gICwgbWluOiByZXF1aXJlKCcuL21pbicpXG4gICwgbWF4OiByZXF1aXJlKCcuL21heCcpXG4gICwgZmxvb3I6IHJlcXVpcmUoJy4vZmxvb3InKVxuICAsIGNlaWw6IHJlcXVpcmUoJy4vY2VpbCcpXG4gICwgcm91bmQ6IHJlcXVpcmUoJy4vcm91bmQnKVxuICAsIHNjYWxlOiByZXF1aXJlKCcuL3NjYWxlJylcbiAgLCBzY2FsZUFuZEFkZDogcmVxdWlyZSgnLi9zY2FsZUFuZEFkZCcpXG4gICwgZGlzdGFuY2U6IHJlcXVpcmUoJy4vZGlzdGFuY2UnKVxuICAsIGRpc3Q6IHJlcXVpcmUoJy4vZGlzdCcpXG4gICwgc3F1YXJlZERpc3RhbmNlOiByZXF1aXJlKCcuL3NxdWFyZWREaXN0YW5jZScpXG4gICwgc3FyRGlzdDogcmVxdWlyZSgnLi9zcXJEaXN0JylcbiAgLCBsZW5ndGg6IHJlcXVpcmUoJy4vbGVuZ3RoJylcbiAgLCBsZW46IHJlcXVpcmUoJy4vbGVuJylcbiAgLCBzcXVhcmVkTGVuZ3RoOiByZXF1aXJlKCcuL3NxdWFyZWRMZW5ndGgnKVxuICAsIHNxckxlbjogcmVxdWlyZSgnLi9zcXJMZW4nKVxuICAsIG5lZ2F0ZTogcmVxdWlyZSgnLi9uZWdhdGUnKVxuICAsIGludmVyc2U6IHJlcXVpcmUoJy4vaW52ZXJzZScpXG4gICwgbm9ybWFsaXplOiByZXF1aXJlKCcuL25vcm1hbGl6ZScpXG4gICwgZG90OiByZXF1aXJlKCcuL2RvdCcpXG4gICwgY3Jvc3M6IHJlcXVpcmUoJy4vY3Jvc3MnKVxuICAsIGxlcnA6IHJlcXVpcmUoJy4vbGVycCcpXG4gICwgcmFuZG9tOiByZXF1aXJlKCcuL3JhbmRvbScpXG4gICwgdHJhbnNmb3JtTWF0NDogcmVxdWlyZSgnLi90cmFuc2Zvcm1NYXQ0JylcbiAgLCB0cmFuc2Zvcm1NYXQzOiByZXF1aXJlKCcuL3RyYW5zZm9ybU1hdDMnKVxuICAsIHRyYW5zZm9ybVF1YXQ6IHJlcXVpcmUoJy4vdHJhbnNmb3JtUXVhdCcpXG4gICwgcm90YXRlWDogcmVxdWlyZSgnLi9yb3RhdGVYJylcbiAgLCByb3RhdGVZOiByZXF1aXJlKCcuL3JvdGF0ZVknKVxuICAsIHJvdGF0ZVo6IHJlcXVpcmUoJy4vcm90YXRlWicpXG4gICwgZm9yRWFjaDogcmVxdWlyZSgnLi9mb3JFYWNoJylcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gaW52ZXJzZTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbnZlcnNlIG9mIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGludmVydFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBpbnZlcnNlKG91dCwgYSkge1xuICBvdXRbMF0gPSAxLjAgLyBhWzBdXG4gIG91dFsxXSA9IDEuMCAvIGFbMV1cbiAgb3V0WzJdID0gMS4wIC8gYVsyXVxuICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xlbmd0aCcpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGxlbmd0aDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBsZW5ndGggb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgbGVuZ3RoIG9mXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBsZW5ndGggb2YgYVxuICovXG5mdW5jdGlvbiBsZW5ndGgoYSkge1xuICAgIHZhciB4ID0gYVswXSxcbiAgICAgICAgeSA9IGFbMV0sXG4gICAgICAgIHogPSBhWzJdXG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkgKyB6KnopXG59IiwibW9kdWxlLmV4cG9ydHMgPSBsZXJwO1xuXG4vKipcbiAqIFBlcmZvcm1zIGEgbGluZWFyIGludGVycG9sYXRpb24gYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHQgaW50ZXJwb2xhdGlvbiBhbW91bnQgYmV0d2VlbiB0aGUgdHdvIGlucHV0c1xuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBsZXJwKG91dCwgYSwgYiwgdCkge1xuICAgIHZhciBheCA9IGFbMF0sXG4gICAgICAgIGF5ID0gYVsxXSxcbiAgICAgICAgYXogPSBhWzJdXG4gICAgb3V0WzBdID0gYXggKyB0ICogKGJbMF0gLSBheClcbiAgICBvdXRbMV0gPSBheSArIHQgKiAoYlsxXSAtIGF5KVxuICAgIG91dFsyXSA9IGF6ICsgdCAqIChiWzJdIC0gYXopXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gbWF4O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1heGltdW0gb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gbWF4KG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IE1hdGgubWF4KGFbMF0sIGJbMF0pXG4gICAgb3V0WzFdID0gTWF0aC5tYXgoYVsxXSwgYlsxXSlcbiAgICBvdXRbMl0gPSBNYXRoLm1heChhWzJdLCBiWzJdKVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IG1pbjtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtaW5pbXVtIG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIG1pbihvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1pbihhWzBdLCBiWzBdKVxuICAgIG91dFsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pXG4gICAgb3V0WzJdID0gTWF0aC5taW4oYVsyXSwgYlsyXSlcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL211bHRpcGx5JylcbiIsIm1vZHVsZS5leHBvcnRzID0gbXVsdGlwbHk7XG5cbi8qKlxuICogTXVsdGlwbGllcyB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBtdWx0aXBseShvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYlswXVxuICAgIG91dFsxXSA9IGFbMV0gKiBiWzFdXG4gICAgb3V0WzJdID0gYVsyXSAqIGJbMl1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBuZWdhdGU7XG5cbi8qKlxuICogTmVnYXRlcyB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBuZWdhdGVcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gbmVnYXRlKG91dCwgYSkge1xuICAgIG91dFswXSA9IC1hWzBdXG4gICAgb3V0WzFdID0gLWFbMV1cbiAgICBvdXRbMl0gPSAtYVsyXVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IG5vcm1hbGl6ZTtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gbm9ybWFsaXplXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZShvdXQsIGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdLFxuICAgICAgICB6ID0gYVsyXVxuICAgIHZhciBsZW4gPSB4KnggKyB5KnkgKyB6KnpcbiAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAvL1RPRE86IGV2YWx1YXRlIHVzZSBvZiBnbG1faW52c3FydCBoZXJlP1xuICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbilcbiAgICAgICAgb3V0WzBdID0gYVswXSAqIGxlblxuICAgICAgICBvdXRbMV0gPSBhWzFdICogbGVuXG4gICAgICAgIG91dFsyXSA9IGFbMl0gKiBsZW5cbiAgICB9XG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gcmFuZG9tO1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSB2ZWN0b3Igd2l0aCB0aGUgZ2l2ZW4gc2NhbGVcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IFtzY2FsZV0gTGVuZ3RoIG9mIHRoZSByZXN1bHRpbmcgdmVjdG9yLiBJZiBvbW1pdHRlZCwgYSB1bml0IHZlY3RvciB3aWxsIGJlIHJldHVybmVkXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIHJhbmRvbShvdXQsIHNjYWxlKSB7XG4gICAgc2NhbGUgPSBzY2FsZSB8fCAxLjBcblxuICAgIHZhciByID0gTWF0aC5yYW5kb20oKSAqIDIuMCAqIE1hdGguUElcbiAgICB2YXIgeiA9IChNYXRoLnJhbmRvbSgpICogMi4wKSAtIDEuMFxuICAgIHZhciB6U2NhbGUgPSBNYXRoLnNxcnQoMS4wLXoqeikgKiBzY2FsZVxuXG4gICAgb3V0WzBdID0gTWF0aC5jb3MocikgKiB6U2NhbGVcbiAgICBvdXRbMV0gPSBNYXRoLnNpbihyKSAqIHpTY2FsZVxuICAgIG91dFsyXSA9IHogKiBzY2FsZVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHJvdGF0ZVg7XG5cbi8qKlxuICogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgeC1heGlzXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzNcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IGMgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIHJvdGF0ZVgob3V0LCBhLCBiLCBjKXtcbiAgICB2YXIgYnkgPSBiWzFdXG4gICAgdmFyIGJ6ID0gYlsyXVxuXG4gICAgLy8gVHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cbiAgICB2YXIgcHkgPSBhWzFdIC0gYnlcbiAgICB2YXIgcHogPSBhWzJdIC0gYnpcblxuICAgIHZhciBzYyA9IE1hdGguc2luKGMpXG4gICAgdmFyIGNjID0gTWF0aC5jb3MoYylcblxuICAgIC8vIHBlcmZvcm0gcm90YXRpb24gYW5kIHRyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG4gICAgb3V0WzBdID0gYVswXVxuICAgIG91dFsxXSA9IGJ5ICsgcHkgKiBjYyAtIHB6ICogc2NcbiAgICBvdXRbMl0gPSBieiArIHB5ICogc2MgKyBweiAqIGNjXG5cbiAgICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJvdGF0ZVk7XG5cbi8qKlxuICogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgeS1heGlzXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzNcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IGMgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIHJvdGF0ZVkob3V0LCBhLCBiLCBjKXtcbiAgICB2YXIgYnggPSBiWzBdXG4gICAgdmFyIGJ6ID0gYlsyXVxuXG4gICAgLy8gdHJhbnNsYXRlIHBvaW50IHRvIHRoZSBvcmlnaW5cbiAgICB2YXIgcHggPSBhWzBdIC0gYnhcbiAgICB2YXIgcHogPSBhWzJdIC0gYnpcbiAgICBcbiAgICB2YXIgc2MgPSBNYXRoLnNpbihjKVxuICAgIHZhciBjYyA9IE1hdGguY29zKGMpXG4gIFxuICAgIC8vIHBlcmZvcm0gcm90YXRpb24gYW5kIHRyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG4gICAgb3V0WzBdID0gYnggKyBweiAqIHNjICsgcHggKiBjY1xuICAgIG91dFsxXSA9IGFbMV1cbiAgICBvdXRbMl0gPSBieiArIHB6ICogY2MgLSBweCAqIHNjXG4gIFxuICAgIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcm90YXRlWjtcblxuLyoqXG4gKiBSb3RhdGUgYSAzRCB2ZWN0b3IgYXJvdW5kIHRoZSB6LWF4aXNcbiAqIEBwYXJhbSB7dmVjM30gb3V0IFRoZSByZWNlaXZpbmcgdmVjM1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSB2ZWMzIHBvaW50IHRvIHJvdGF0ZVxuICogQHBhcmFtIHt2ZWMzfSBiIFRoZSBvcmlnaW4gb2YgdGhlIHJvdGF0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gYyBUaGUgYW5nbGUgb2Ygcm90YXRpb25cbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gcm90YXRlWihvdXQsIGEsIGIsIGMpe1xuICAgIHZhciBieCA9IGJbMF1cbiAgICB2YXIgYnkgPSBiWzFdXG5cbiAgICAvL1RyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG4gICAgdmFyIHB4ID0gYVswXSAtIGJ4XG4gICAgdmFyIHB5ID0gYVsxXSAtIGJ5XG4gIFxuICAgIHZhciBzYyA9IE1hdGguc2luKGMpXG4gICAgdmFyIGNjID0gTWF0aC5jb3MoYylcblxuICAgIC8vIHBlcmZvcm0gcm90YXRpb24gYW5kIHRyYW5zbGF0ZSB0byBjb3JyZWN0IHBvc2l0aW9uXG4gICAgb3V0WzBdID0gYnggKyBweCAqIGNjIC0gcHkgKiBzY1xuICAgIG91dFsxXSA9IGJ5ICsgcHggKiBzYyArIHB5ICogY2NcbiAgICBvdXRbMl0gPSBhWzJdXG4gIFxuICAgIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcm91bmRcblxuLyoqXG4gKiBNYXRoLnJvdW5kIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIHJvdW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIHJvdW5kKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLnJvdW5kKGFbMF0pXG4gIG91dFsxXSA9IE1hdGgucm91bmQoYVsxXSlcbiAgb3V0WzJdID0gTWF0aC5yb3VuZChhWzJdKVxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHNjYWxlO1xuXG4vKipcbiAqIFNjYWxlcyBhIHZlYzMgYnkgYSBzY2FsYXIgbnVtYmVyXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlcn0gYiBhbW91bnQgdG8gc2NhbGUgdGhlIHZlY3RvciBieVxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBzY2FsZShvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdICogYlxuICAgIG91dFsxXSA9IGFbMV0gKiBiXG4gICAgb3V0WzJdID0gYVsyXSAqIGJcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBzY2FsZUFuZEFkZDtcblxuLyoqXG4gKiBBZGRzIHR3byB2ZWMzJ3MgYWZ0ZXIgc2NhbGluZyB0aGUgc2Vjb25kIG9wZXJhbmQgYnkgYSBzY2FsYXIgdmFsdWVcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGUgdGhlIGFtb3VudCB0byBzY2FsZSBiIGJ5IGJlZm9yZSBhZGRpbmdcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gc2NhbGVBbmRBZGQob3V0LCBhLCBiLCBzY2FsZSkge1xuICAgIG91dFswXSA9IGFbMF0gKyAoYlswXSAqIHNjYWxlKVxuICAgIG91dFsxXSA9IGFbMV0gKyAoYlsxXSAqIHNjYWxlKVxuICAgIG91dFsyXSA9IGFbMl0gKyAoYlsyXSAqIHNjYWxlKVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHNldDtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzIHRvIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXJ9IHggWCBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFkgY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geiBaIGNvbXBvbmVudFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBzZXQob3V0LCB4LCB5LCB6KSB7XG4gICAgb3V0WzBdID0geFxuICAgIG91dFsxXSA9IHlcbiAgICBvdXRbMl0gPSB6XG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zcXVhcmVkRGlzdGFuY2UnKVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3NxdWFyZWRMZW5ndGgnKVxuIiwibW9kdWxlLmV4cG9ydHMgPSBzcXVhcmVkRGlzdGFuY2U7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBzcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gYSBhbmQgYlxuICovXG5mdW5jdGlvbiBzcXVhcmVkRGlzdGFuY2UoYSwgYikge1xuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXSxcbiAgICAgICAgeiA9IGJbMl0gLSBhWzJdXG4gICAgcmV0dXJuIHgqeCArIHkqeSArIHoqelxufSIsIm1vZHVsZS5leHBvcnRzID0gc3F1YXJlZExlbmd0aDtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzcXVhcmVkIGxlbmd0aCBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNhbGN1bGF0ZSBzcXVhcmVkIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBsZW5ndGggb2YgYVxuICovXG5mdW5jdGlvbiBzcXVhcmVkTGVuZ3RoKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdLFxuICAgICAgICB6ID0gYVsyXVxuICAgIHJldHVybiB4KnggKyB5KnkgKyB6Knpcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vc3VidHJhY3QnKVxuIiwibW9kdWxlLmV4cG9ydHMgPSBzdWJ0cmFjdDtcblxuLyoqXG4gKiBTdWJ0cmFjdHMgdmVjdG9yIGIgZnJvbSB2ZWN0b3IgYVxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gc3VidHJhY3Qob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAtIGJbMF1cbiAgICBvdXRbMV0gPSBhWzFdIC0gYlsxXVxuICAgIG91dFsyXSA9IGFbMl0gLSBiWzJdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gdHJhbnNmb3JtTWF0MztcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBtYXQzLlxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7bWF0NH0gbSB0aGUgM3gzIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1NYXQzKG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdXG4gICAgb3V0WzBdID0geCAqIG1bMF0gKyB5ICogbVszXSArIHogKiBtWzZdXG4gICAgb3V0WzFdID0geCAqIG1bMV0gKyB5ICogbVs0XSArIHogKiBtWzddXG4gICAgb3V0WzJdID0geCAqIG1bMl0gKyB5ICogbVs1XSArIHogKiBtWzhdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gdHJhbnNmb3JtTWF0NDtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBtYXQ0LlxuICogNHRoIHZlY3RvciBjb21wb25lbnQgaXMgaW1wbGljaXRseSAnMSdcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDR9IG0gbWF0cml4IHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybU1hdDQob3V0LCBhLCBtKSB7XG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl0sXG4gICAgICAgIHcgPSBtWzNdICogeCArIG1bN10gKiB5ICsgbVsxMV0gKiB6ICsgbVsxNV1cbiAgICB3ID0gdyB8fCAxLjBcbiAgICBvdXRbMF0gPSAobVswXSAqIHggKyBtWzRdICogeSArIG1bOF0gKiB6ICsgbVsxMl0pIC8gd1xuICAgIG91dFsxXSA9IChtWzFdICogeCArIG1bNV0gKiB5ICsgbVs5XSAqIHogKyBtWzEzXSkgLyB3XG4gICAgb3V0WzJdID0gKG1bMl0gKiB4ICsgbVs2XSAqIHkgKyBtWzEwXSAqIHogKyBtWzE0XSkgLyB3XG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gdHJhbnNmb3JtUXVhdDtcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSB2ZWMzIHdpdGggYSBxdWF0XG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHtxdWF0fSBxIHF1YXRlcm5pb24gdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtUXVhdChvdXQsIGEsIHEpIHtcbiAgICAvLyBiZW5jaG1hcmtzOiBodHRwOi8vanNwZXJmLmNvbS9xdWF0ZXJuaW9uLXRyYW5zZm9ybS12ZWMzLWltcGxlbWVudGF0aW9uc1xuXG4gICAgdmFyIHggPSBhWzBdLCB5ID0gYVsxXSwgeiA9IGFbMl0sXG4gICAgICAgIHF4ID0gcVswXSwgcXkgPSBxWzFdLCBxeiA9IHFbMl0sIHF3ID0gcVszXSxcblxuICAgICAgICAvLyBjYWxjdWxhdGUgcXVhdCAqIHZlY1xuICAgICAgICBpeCA9IHF3ICogeCArIHF5ICogeiAtIHF6ICogeSxcbiAgICAgICAgaXkgPSBxdyAqIHkgKyBxeiAqIHggLSBxeCAqIHosXG4gICAgICAgIGl6ID0gcXcgKiB6ICsgcXggKiB5IC0gcXkgKiB4LFxuICAgICAgICBpdyA9IC1xeCAqIHggLSBxeSAqIHkgLSBxeiAqIHpcblxuICAgIC8vIGNhbGN1bGF0ZSByZXN1bHQgKiBpbnZlcnNlIHF1YXRcbiAgICBvdXRbMF0gPSBpeCAqIHF3ICsgaXcgKiAtcXggKyBpeSAqIC1xeiAtIGl6ICogLXF5XG4gICAgb3V0WzFdID0gaXkgKiBxdyArIGl3ICogLXF5ICsgaXogKiAtcXggLSBpeCAqIC1xelxuICAgIG91dFsyXSA9IGl6ICogcXcgKyBpdyAqIC1xeiArIGl4ICogLXF5IC0gaXkgKiAtcXhcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzdHJpbmdzKSB7XHJcbiAgaWYgKHR5cGVvZiBzdHJpbmdzID09PSAnc3RyaW5nJykgc3RyaW5ncyA9IFtzdHJpbmdzXVxyXG4gIHZhciBleHBycyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpXHJcbiAgdmFyIHBhcnRzID0gW11cclxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZ3MubGVuZ3RoLTE7IGkrKykge1xyXG4gICAgcGFydHMucHVzaChzdHJpbmdzW2ldLCBleHByc1tpXSB8fCAnJylcclxuICB9XHJcbiAgcGFydHMucHVzaChzdHJpbmdzW2ldKVxyXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxyXG59XHJcbiIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gKG0gKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAoKHZhbHVlICogYykgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH1cbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpXG4gICAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgICB9XG4gIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiXG5cbmZ1bmN0aW9uIGlvdGEobikge1xuICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KG4pXG4gIGZvcih2YXIgaT0wOyBpPG47ICsraSkge1xuICAgIHJlc3VsdFtpXSA9IGlcbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW90YSIsIi8qIVxuICogRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIEJ1ZmZlclxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxuLy8gVGhlIF9pc0J1ZmZlciBjaGVjayBpcyBmb3IgU2FmYXJpIDUtNyBzdXBwb3J0LCBiZWNhdXNlIGl0J3MgbWlzc2luZ1xuLy8gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiAoaXNCdWZmZXIob2JqKSB8fCBpc1Nsb3dCdWZmZXIob2JqKSB8fCAhIW9iai5faXNCdWZmZXIpXG59XG5cbmZ1bmN0aW9uIGlzQnVmZmVyIChvYmopIHtcbiAgcmV0dXJuICEhb2JqLmNvbnN0cnVjdG9yICYmIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iailcbn1cblxuLy8gRm9yIE5vZGUgdjAuMTAgc3VwcG9ydC4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseS5cbmZ1bmN0aW9uIGlzU2xvd0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqLnJlYWRGbG9hdExFID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouc2xpY2UgPT09ICdmdW5jdGlvbicgJiYgaXNCdWZmZXIob2JqLnNsaWNlKDAsIDApKVxufVxuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ29kZUJ1aWxkZXIgPSBleHBvcnRzLmJ1ZmZlclNhbXBsZXJOYW1lID0gdm9pZCAwO1xuY29uc3QgZXhwcl8xID0gcmVxdWlyZShcIi4vZXhwcmVzc2lvbnMvZXhwclwiKTtcbmNvbnN0IHdlYmdscHJvZ3JhbWxvb3BfMSA9IHJlcXVpcmUoXCIuL3dlYmdscHJvZ3JhbWxvb3BcIik7XG5jb25zdCBGUkFHX1NFVCA9IGAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgZ2xfRnJhZ0Nvb3JkLnh5IC8gdVJlc29sdXRpb24pO1xcbmA7XG5jb25zdCBTQ0VORV9TRVQgPSBgdW5pZm9ybSBzYW1wbGVyMkQgdVNjZW5lU2FtcGxlcjtcXG5gO1xuY29uc3QgVElNRV9TRVQgPSBgdW5pZm9ybSBtZWRpdW1wIGZsb2F0IHVUaW1lO1xcbmA7XG5jb25zdCBCT0lMRVJQTEFURSA9IGAjaWZkZWYgR0xfRVNcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuI2VuZGlmXG5cbnVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xudW5pZm9ybSBtZWRpdW1wIHZlYzIgdVJlc29sdXRpb247XFxuYDtcbmZ1bmN0aW9uIGJ1ZmZlclNhbXBsZXJOYW1lKGJ1Zikge1xuICAgIC8vIHRleHR1cmUgMiBzYW1wbGVyIGhhcyBudW1iZXIgMCAoMCBhbmQgMSBhcmUgdXNlZCBmb3IgYmFjayBidWZmZXIgYW5kIHNjZW5lKVxuICAgIHJldHVybiBgdUJ1ZmZlclNhbXBsZXIke2J1Zn1gO1xufVxuZXhwb3J0cy5idWZmZXJTYW1wbGVyTmFtZSA9IGJ1ZmZlclNhbXBsZXJOYW1lO1xuZnVuY3Rpb24gYnVmZmVyU2FtcGxlckRlY2xhcmF0aW9uKGJ1Zikge1xuICAgIHJldHVybiBgdW5pZm9ybSBzYW1wbGVyMkQgJHtidWZmZXJTYW1wbGVyTmFtZShidWYpfTtgO1xufVxuY2xhc3MgQ29kZUJ1aWxkZXIge1xuICAgIGNvbnN0cnVjdG9yKGVmZmVjdExvb3ApIHtcbiAgICAgICAgdGhpcy5jYWxscyA9IFtdO1xuICAgICAgICB0aGlzLmV4dGVybmFsRnVuY3MgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMudW5pZm9ybURlY2xhcmF0aW9ucyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5jb3VudGVyID0gMDtcbiAgICAgICAgdGhpcy5iYXNlTG9vcCA9IGVmZmVjdExvb3A7XG4gICAgICAgIGNvbnN0IGJ1aWxkSW5mbyA9IHtcbiAgICAgICAgICAgIHVuaWZvcm1UeXBlczoge30sXG4gICAgICAgICAgICBleHRlcm5hbEZ1bmNzOiBuZXcgU2V0KCksXG4gICAgICAgICAgICBleHByczogW10sXG4gICAgICAgICAgICBuZWVkczoge1xuICAgICAgICAgICAgICAgIGNlbnRlclNhbXBsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgbmVpZ2hib3JTYW1wbGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNjZW5lQnVmZmVyOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0aW1lVW5pZm9ybTogZmFsc2UsXG4gICAgICAgICAgICAgICAgZXh0cmFCdWZmZXJzOiBuZXcgU2V0KCksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFkZEVmZmVjdExvb3AoZWZmZWN0TG9vcCwgMSwgYnVpbGRJbmZvKTtcbiAgICAgICAgLy8gYWRkIGFsbCB0aGUgdHlwZXMgdG8gdW5pZm9ybSBkZWNsYXJhdGlvbnMgZnJvbSB0aGUgYEJ1aWxkSW5mb2AgaW5zdGFuY2VcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIGJ1aWxkSW5mby51bmlmb3JtVHlwZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGVOYW1lID0gYnVpbGRJbmZvLnVuaWZvcm1UeXBlc1tuYW1lXTtcbiAgICAgICAgICAgIHRoaXMudW5pZm9ybURlY2xhcmF0aW9ucy5hZGQoYHVuaWZvcm0gbWVkaXVtcCAke3R5cGVOYW1lfSAke25hbWV9O2ApO1xuICAgICAgICB9XG4gICAgICAgIC8vdGhpcy51bmlmb3JtTmFtZXMgPSBPYmplY3Qua2V5cyhidWlsZEluZm8udW5pZm9ybVR5cGVzKTtcbiAgICAgICAgLy8gYWRkIGFsbCBleHRlcm5hbCBmdW5jdGlvbnMgZnJvbSB0aGUgYEJ1aWxkSW5mb2AgaW5zdGFuY2VcbiAgICAgICAgYnVpbGRJbmZvLmV4dGVybmFsRnVuY3MuZm9yRWFjaCgoZnVuYykgPT4gdGhpcy5leHRlcm5hbEZ1bmNzLmFkZChmdW5jKSk7XG4gICAgICAgIHRoaXMudG90YWxOZWVkcyA9IGJ1aWxkSW5mby5uZWVkcztcbiAgICAgICAgdGhpcy5leHBycyA9IGJ1aWxkSW5mby5leHBycztcbiAgICB9XG4gICAgYWRkRWZmZWN0TG9vcChlZmZlY3RMb29wLCBpbmRlbnRMZXZlbCwgYnVpbGRJbmZvLCB0b3BMZXZlbCA9IHRydWUpIHtcbiAgICAgICAgY29uc3QgbmVlZHNMb29wID0gIXRvcExldmVsICYmIGVmZmVjdExvb3AucmVwZWF0Lm51bSA+IDE7XG4gICAgICAgIGlmIChuZWVkc0xvb3ApIHtcbiAgICAgICAgICAgIGNvbnN0IGlOYW1lID0gXCJpXCIgKyB0aGlzLmNvdW50ZXI7XG4gICAgICAgICAgICBpbmRlbnRMZXZlbCsrO1xuICAgICAgICAgICAgY29uc3QgZm9yU3RhcnQgPSBcIiAgXCIucmVwZWF0KGluZGVudExldmVsIC0gMSkgK1xuICAgICAgICAgICAgICAgIGBmb3IgKGludCAke2lOYW1lfSA9IDA7ICR7aU5hbWV9IDwgJHtlZmZlY3RMb29wLnJlcGVhdC5udW19OyAke2lOYW1lfSsrKSB7YDtcbiAgICAgICAgICAgIHRoaXMuY2FsbHMucHVzaChmb3JTdGFydCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBlIG9mIGVmZmVjdExvb3AuZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBleHByXzEuRXhwcikge1xuICAgICAgICAgICAgICAgIGUucGFyc2UoYnVpbGRJbmZvKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbGxzLnB1c2goXCIgIFwiLnJlcGVhdChpbmRlbnRMZXZlbCkgKyBcImdsX0ZyYWdDb2xvciA9IFwiICsgZS5zb3VyY2VDb2RlICsgXCI7XCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuY291bnRlcisrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRFZmZlY3RMb29wKGUsIGluZGVudExldmVsLCBidWlsZEluZm8sIGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobmVlZHNMb29wKSB7XG4gICAgICAgICAgICB0aGlzLmNhbGxzLnB1c2goXCIgIFwiLnJlcGVhdChpbmRlbnRMZXZlbCAtIDEpICsgXCJ9XCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBpbGVQcm9ncmFtKGdsLCB2U2hhZGVyLCB1bmlmb3JtTG9jcykge1xuICAgICAgICAvLyBzZXQgdXAgdGhlIGZyYWdtZW50IHNoYWRlclxuICAgICAgICBjb25zdCBmU2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKGdsLkZSQUdNRU5UX1NIQURFUik7XG4gICAgICAgIGlmIChmU2hhZGVyID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwcm9ibGVtIGNyZWF0aW5nIGZyYWdtZW50IHNoYWRlclwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmdWxsQ29kZSA9IEJPSUxFUlBMQVRFICtcbiAgICAgICAgICAgICh0aGlzLnRvdGFsTmVlZHMuc2NlbmVCdWZmZXIgPyBTQ0VORV9TRVQgOiBcIlwiKSArXG4gICAgICAgICAgICAodGhpcy50b3RhbE5lZWRzLnRpbWVVbmlmb3JtID8gVElNRV9TRVQgOiBcIlwiKSArXG4gICAgICAgICAgICBBcnJheS5mcm9tKHRoaXMudG90YWxOZWVkcy5leHRyYUJ1ZmZlcnMpXG4gICAgICAgICAgICAgICAgLm1hcCgobikgPT4gYnVmZmVyU2FtcGxlckRlY2xhcmF0aW9uKG4pKVxuICAgICAgICAgICAgICAgIC5qb2luKFwiXFxuXCIpICtcbiAgICAgICAgICAgIFwiXFxuXCIgK1xuICAgICAgICAgICAgWy4uLnRoaXMudW5pZm9ybURlY2xhcmF0aW9uc10uam9pbihcIlxcblwiKSArXG4gICAgICAgICAgICBcIlxcblwiICtcbiAgICAgICAgICAgIFsuLi50aGlzLmV4dGVybmFsRnVuY3NdLmpvaW4oXCJcXG5cIikgK1xuICAgICAgICAgICAgXCJcXG5cIiArXG4gICAgICAgICAgICBcInZvaWQgbWFpbigpIHtcXG5cIiArXG4gICAgICAgICAgICAodGhpcy50b3RhbE5lZWRzLmNlbnRlclNhbXBsZSA/IEZSQUdfU0VUIDogXCJcIikgK1xuICAgICAgICAgICAgdGhpcy5jYWxscy5qb2luKFwiXFxuXCIpICtcbiAgICAgICAgICAgIFwiXFxufVwiO1xuICAgICAgICBnbC5zaGFkZXJTb3VyY2UoZlNoYWRlciwgZnVsbENvZGUpO1xuICAgICAgICBnbC5jb21waWxlU2hhZGVyKGZTaGFkZXIpO1xuICAgICAgICAvLyBzZXQgdXAgdGhlIHByb2dyYW1cbiAgICAgICAgY29uc3QgcHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKTtcbiAgICAgICAgaWYgKHByb2dyYW0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInByb2JsZW0gY3JlYXRpbmcgcHJvZ3JhbVwiKTtcbiAgICAgICAgfVxuICAgICAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdlNoYWRlcik7XG4gICAgICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmU2hhZGVyKTtcbiAgICAgICAgY29uc3Qgc2hhZGVyTG9nID0gKG5hbWUsIHNoYWRlcikgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb3V0cHV0ID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpO1xuICAgICAgICAgICAgaWYgKG91dHB1dClcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgJHtuYW1lfSBzaGFkZXIgaW5mbyBsb2dcXG4ke291dHB1dH1gKTtcbiAgICAgICAgfTtcbiAgICAgICAgc2hhZGVyTG9nKFwidmVydGV4XCIsIHZTaGFkZXIpO1xuICAgICAgICBzaGFkZXJMb2coXCJmcmFnbWVudFwiLCBmU2hhZGVyKTtcbiAgICAgICAgZ2wubGlua1Byb2dyYW0ocHJvZ3JhbSk7XG4gICAgICAgIC8vIHdlIG5lZWQgdG8gdXNlIHRoZSBwcm9ncmFtIGhlcmUgc28gd2UgY2FuIGdldCB1bmlmb3JtIGxvY2F0aW9uc1xuICAgICAgICBnbC51c2VQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICBjb25zb2xlLmxvZyhmdWxsQ29kZSk7XG4gICAgICAgIC8vIGZpbmQgYWxsIHVuaWZvcm0gbG9jYXRpb25zIGFuZCBhZGQgdGhlbSB0byB0aGUgZGljdGlvbmFyeVxuICAgICAgICBmb3IgKGNvbnN0IGV4cHIgb2YgdGhpcy5leHBycykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIGV4cHIudW5pZm9ybVZhbENoYW5nZU1hcCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChsb2NhdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb3VsZG4ndCBmaW5kIHVuaWZvcm0gXCIgKyBuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBlbmZvcmNlIHVuaXF1ZSBuYW1lcyBpbiB0aGUgc2FtZSBwcm9ncmFtXG4gICAgICAgICAgICAgICAgaWYgKHVuaWZvcm1Mb2NzW25hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5pZm9ybUxvY3NbbmFtZV0gPSB7IGxvY3M6IFtdLCBjb3VudGVyOiAwIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGFzc2lnbiB0aGUgbmFtZSB0byB0aGUgbG9jYXRpb25cbiAgICAgICAgICAgICAgICB1bmlmb3JtTG9jc1tuYW1lXS5sb2NzLnB1c2gobG9jYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHNldCB0aGUgdW5pZm9ybSByZXNvbHV0aW9uIChldmVyeSBwcm9ncmFtIGhhcyB0aGlzIHVuaWZvcm0pXG4gICAgICAgIGNvbnN0IHVSZXNvbHV0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidVJlc29sdXRpb25cIik7XG4gICAgICAgIGdsLnVuaWZvcm0yZih1UmVzb2x1dGlvbiwgZ2wuZHJhd2luZ0J1ZmZlcldpZHRoLCBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0KTtcbiAgICAgICAgaWYgKHRoaXMudG90YWxOZWVkcy5zY2VuZUJ1ZmZlcikge1xuICAgICAgICAgICAgLy8gVE9ETyBhbGxvdyBmb3IgdGV4dHVyZSBvcHRpb25zIGZvciBzY2VuZSB0ZXh0dXJlXG4gICAgICAgICAgICBjb25zdCBsb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcInVTY2VuZVNhbXBsZXJcIik7XG4gICAgICAgICAgICAvLyBwdXQgdGhlIHNjZW5lIGJ1ZmZlciBpbiB0ZXh0dXJlIDEgKDAgaXMgdXNlZCBmb3IgdGhlIGJhY2tidWZmZXIpXG4gICAgICAgICAgICBnbC51bmlmb3JtMWkobG9jYXRpb24sIDEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldCBhbGwgc2FtcGxlciB1bmlmb3Jtc1xuICAgICAgICBmb3IgKGNvbnN0IGIgb2YgdGhpcy50b3RhbE5lZWRzLmV4dHJhQnVmZmVycykge1xuICAgICAgICAgICAgY29uc3QgbG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgYnVmZmVyU2FtcGxlck5hbWUoYikpO1xuICAgICAgICAgICAgLy8gb2Zmc2V0IHRoZSB0ZXh0dXJlIGxvY2F0aW9uIGJ5IDIgKDAgYW5kIDEgYXJlIHVzZWQgZm9yIHNjZW5lIGFuZCBvcmlnaW5hbClcbiAgICAgICAgICAgIGdsLnVuaWZvcm0xaShsb2NhdGlvbiwgYiArIDIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGdldCBhdHRyaWJ1dGVcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBnbC5nZXRBdHRyaWJMb2NhdGlvbihwcm9ncmFtLCBcImFQb3NpdGlvblwiKTtcbiAgICAgICAgLy8gZW5hYmxlIHRoZSBhdHRyaWJ1dGVcbiAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkocG9zaXRpb24pO1xuICAgICAgICAvLyBwb2ludHMgdG8gdGhlIHZlcnRpY2VzIGluIHRoZSBsYXN0IGJvdW5kIGFycmF5IGJ1ZmZlclxuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHBvc2l0aW9uLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuICAgICAgICByZXR1cm4gbmV3IHdlYmdscHJvZ3JhbWxvb3BfMS5XZWJHTFByb2dyYW1Mb29wKHByb2dyYW0sIHRoaXMuYmFzZUxvb3AucmVwZWF0LCBnbCwgdGhpcy50b3RhbE5lZWRzLCB0aGlzLmV4cHJzKTtcbiAgICB9XG59XG5leHBvcnRzLkNvZGVCdWlsZGVyID0gQ29kZUJ1aWxkZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYTEgPSBleHBvcnRzLkFyaXR5MUhvbW9nZW5vdXNFeHByID0gdm9pZCAwO1xuY29uc3QgZXhwcl8xID0gcmVxdWlyZShcIi4vZXhwclwiKTtcbmZ1bmN0aW9uIGdlbkFyaXR5MVNvdXJjZUxpc3QobmFtZSwgdmFsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2VjdGlvbnM6IFtuYW1lICsgXCIoXCIsIFwiKVwiXSxcbiAgICAgICAgdmFsdWVzOiBbdmFsXSxcbiAgICB9O1xufVxuY2xhc3MgQXJpdHkxSG9tb2dlbm91c0V4cHIgZXh0ZW5kcyBleHByXzEuT3BlcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKHZhbCwgb3BlcmF0aW9uKSB7XG4gICAgICAgIHN1cGVyKHZhbCwgZ2VuQXJpdHkxU291cmNlTGlzdChvcGVyYXRpb24sIHZhbCksIFtcInVWYWxcIl0pO1xuICAgICAgICB0aGlzLnZhbCA9IHZhbDtcbiAgICB9XG4gICAgc2V0VmFsKHJpZ2h0KSB7XG4gICAgICAgIHRoaXMuc2V0VW5pZm9ybShcInVWYWxcIiArIHRoaXMuaWQsIHJpZ2h0KTtcbiAgICB9XG59XG5leHBvcnRzLkFyaXR5MUhvbW9nZW5vdXNFeHByID0gQXJpdHkxSG9tb2dlbm91c0V4cHI7XG5mdW5jdGlvbiBhMShuYW1lLCB2YWwpIHtcbiAgICByZXR1cm4gbmV3IEFyaXR5MUhvbW9nZW5vdXNFeHByKGV4cHJfMS53cmFwSW5WYWx1ZSh2YWwpLCBuYW1lKTtcbn1cbmV4cG9ydHMuYTEgPSBhMTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hMiA9IGV4cG9ydHMuQXJpdHkySG9tb2dlbm91c0V4cHIgPSB2b2lkIDA7XG5jb25zdCBleHByXzEgPSByZXF1aXJlKFwiLi9leHByXCIpO1xuZnVuY3Rpb24gZ2VuQXJpdHkxU291cmNlTGlzdChuYW1lLCB2YWwxLCB2YWwyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2VjdGlvbnM6IFtuYW1lICsgXCIoXCIsIFwiLFwiLCBcIilcIl0sXG4gICAgICAgIHZhbHVlczogW3ZhbDEsIHZhbDJdLFxuICAgIH07XG59XG5jbGFzcyBBcml0eTJIb21vZ2Vub3VzRXhwciBleHRlbmRzIGV4cHJfMS5PcGVyYXRvciB7XG4gICAgY29uc3RydWN0b3IobmFtZSwgdmFsMSwgdmFsMikge1xuICAgICAgICBzdXBlcih2YWwxLCBnZW5Bcml0eTFTb3VyY2VMaXN0KG5hbWUsIHZhbDEsIHZhbDIpLCBbXCJ1QmFzZVwiLCBcInVFeHBvbmVudFwiXSk7XG4gICAgfVxuICAgIHNldEZpcnN0VmFsKGxlZnQpIHtcbiAgICAgICAgdGhpcy5zZXRVbmlmb3JtKFwidUJhc2VcIiArIHRoaXMuaWQsIGxlZnQpO1xuICAgIH1cbiAgICBzZXRTZWNvbmRWYWwocmlnaHQpIHtcbiAgICAgICAgdGhpcy5zZXRVbmlmb3JtKFwidUV4cG9uZW50XCIgKyB0aGlzLmlkLCByaWdodCk7XG4gICAgfVxufVxuZXhwb3J0cy5Bcml0eTJIb21vZ2Vub3VzRXhwciA9IEFyaXR5MkhvbW9nZW5vdXNFeHByO1xuLy8gaW1wbGVtZW50YXRpb25cbmZ1bmN0aW9uIGEyKG5hbWUsIHZhbDEsIHZhbDIpIHtcbiAgICByZXR1cm4gbmV3IEFyaXR5MkhvbW9nZW5vdXNFeHByKG5hbWUsIGV4cHJfMS53cmFwSW5WYWx1ZSh2YWwxKSwgZXhwcl8xLndyYXBJblZhbHVlKHZhbDIpKTtcbn1cbmV4cG9ydHMuYTIgPSBhMjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ibHVyMmQgPSBleHBvcnRzLkJsdXIyZExvb3AgPSB2b2lkIDA7XG5jb25zdCBtZXJnZXBhc3NfMSA9IHJlcXVpcmUoXCIuLi9tZXJnZXBhc3NcIik7XG5jb25zdCBibHVyZXhwcl8xID0gcmVxdWlyZShcIi4vYmx1cmV4cHJcIik7XG5jb25zdCBleHByXzEgPSByZXF1aXJlKFwiLi9leHByXCIpO1xuY29uc3QgdmVjZXhwcnNfMSA9IHJlcXVpcmUoXCIuL3ZlY2V4cHJzXCIpO1xuY2xhc3MgQmx1cjJkTG9vcCBleHRlbmRzIG1lcmdlcGFzc18xLkVmZmVjdExvb3Age1xuICAgIGNvbnN0cnVjdG9yKGhvcml6b250YWxFeHByLCB2ZXJ0aWNhbEV4cHIsIHJlcHMgPSAyLCB0YXBzKSB7XG4gICAgICAgIGNvbnN0IHNpZGUgPSBibHVyZXhwcl8xLmdhdXNzKHZlY2V4cHJzXzEudmVjMihob3Jpem9udGFsRXhwciwgMCksIHRhcHMpO1xuICAgICAgICBjb25zdCB1cCA9IGJsdXJleHByXzEuZ2F1c3ModmVjZXhwcnNfMS52ZWMyKDAsIHZlcnRpY2FsRXhwciksIHRhcHMpO1xuICAgICAgICBzdXBlcihbc2lkZSwgdXBdLCB7IG51bTogcmVwcyB9KTtcbiAgICB9XG59XG5leHBvcnRzLkJsdXIyZExvb3AgPSBCbHVyMmRMb29wO1xuZnVuY3Rpb24gYmx1cjJkKGhvcml6b250YWxFeHByLCB2ZXJ0aWNhbEV4cHIsIHJlcHMsIHRhcHMpIHtcbiAgICByZXR1cm4gbmV3IEJsdXIyZExvb3AoZXhwcl8xLm4yZShob3Jpem9udGFsRXhwciksIGV4cHJfMS5uMmUodmVydGljYWxFeHByKSwgcmVwcywgdGFwcyk7XG59XG5leHBvcnRzLmJsdXIyZCA9IGJsdXIyZDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nYXVzcyA9IGV4cG9ydHMuQmx1ckV4cHIgPSB2b2lkIDA7XG5jb25zdCBnbHNsZnVuY3Rpb25zXzEgPSByZXF1aXJlKFwiLi4vZ2xzbGZ1bmN0aW9uc1wiKTtcbmNvbnN0IGV4cHJfMSA9IHJlcXVpcmUoXCIuL2V4cHJcIik7XG5mdW5jdGlvbiBnZW5CbHVyU291cmNlKGRpcmVjdGlvbiwgdGFwcywgYnVmZmVyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2VjdGlvbnM6IFtgZ2F1c3Mke3RhcHN9JHtidWZmZXIgPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBcIl9cIiArIGJ1ZmZlcn0oYCwgXCIpXCJdLFxuICAgICAgICB2YWx1ZXM6IFtkaXJlY3Rpb25dLFxuICAgIH07XG59XG5mdW5jdGlvbiB0YXBzVG9GdW5jU291cmNlKHRhcHMpIHtcbiAgICBzd2l0Y2ggKHRhcHMpIHtcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgcmV0dXJuIGdsc2xmdW5jdGlvbnNfMS5nbHNsRnVuY3MuZ2F1c3M1O1xuICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICByZXR1cm4gZ2xzbGZ1bmN0aW9uc18xLmdsc2xGdW5jcy5nYXVzczk7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICByZXR1cm4gZ2xzbGZ1bmN0aW9uc18xLmdsc2xGdW5jcy5nYXVzczEzO1xuICAgIH1cbn1cbmNsYXNzIEJsdXJFeHByIGV4dGVuZHMgZXhwcl8xLkV4cHJWZWM0IHtcbiAgICBjb25zdHJ1Y3RvcihkaXJlY3Rpb24sIHRhcHMgPSA1LCBzYW1wbGVyTnVtKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgYWxyZWFkeSBndWFyYW50ZWVkIGJ5IHR5cGVzY3JpcHRcbiAgICAgICAgaWYgKCFbNSwgOSwgMTNdLmluY2x1ZGVzKHRhcHMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0YXBzIGZvciBnYXVzcyBibHVyIGNhbiBvbmx5IGJlIDUsIDkgb3IgMTNcIik7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoZ2VuQmx1clNvdXJjZShkaXJlY3Rpb24sIHRhcHMsIHNhbXBsZXJOdW0pLCBbXCJ1RGlyZWN0aW9uXCJdKTtcbiAgICAgICAgaWYgKHNhbXBsZXJOdW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5uZWVkcy5uZWlnaGJvclNhbXBsZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmV4dGVybmFsRnVuY3MgPSBbdGFwc1RvRnVuY1NvdXJjZSh0YXBzKV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm5lZWRzLmV4dHJhQnVmZmVycyA9IG5ldyBTZXQoW3NhbXBsZXJOdW1dKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidGFwc1wiLCB0YXBzKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwic2FtcGxlck51bVwiLCBzYW1wbGVyTnVtKTtcbiAgICAgICAgICAgIHRoaXMuZXh0ZXJuYWxGdW5jcyA9IFtcbiAgICAgICAgICAgICAgICBnbHNsZnVuY3Rpb25zXzEucmVwbGFjZVNhbXBsZXIodGFwc1RvRnVuY1NvdXJjZSh0YXBzKSwgL3ZlYzRcXHNnYXVzc1swLTldKy9nLCBzYW1wbGVyTnVtKSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0RGlyZWN0aW9uKGRpcmVjdGlvbikge1xuICAgICAgICB0aGlzLnNldFVuaWZvcm0oXCJ1RGlyZWN0aW9uXCIgKyB0aGlzLmlkLCBkaXJlY3Rpb24pO1xuICAgIH1cbn1cbmV4cG9ydHMuQmx1ckV4cHIgPSBCbHVyRXhwcjtcbmZ1bmN0aW9uIGdhdXNzKGRpcmVjdGlvbiwgdGFwcyA9IDUsIHNhbXBsZXJOdW0pIHtcbiAgICByZXR1cm4gbmV3IEJsdXJFeHByKGRpcmVjdGlvbiwgdGFwcywgc2FtcGxlck51bSk7XG59XG5leHBvcnRzLmdhdXNzID0gZ2F1c3M7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYnJpZ2h0bmVzcyA9IGV4cG9ydHMuQnJpZ2h0bmVzcyA9IHZvaWQgMDtcbmNvbnN0IGdsc2xmdW5jdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi9nbHNsZnVuY3Rpb25zXCIpO1xuY29uc3QgZXhwcl8xID0gcmVxdWlyZShcIi4vZXhwclwiKTtcbmNvbnN0IGZyYWdjb2xvcmV4cHJfMSA9IHJlcXVpcmUoXCIuL2ZyYWdjb2xvcmV4cHJcIik7XG5jbGFzcyBCcmlnaHRuZXNzIGV4dGVuZHMgZXhwcl8xLkV4cHJWZWM0IHtcbiAgICBjb25zdHJ1Y3Rvcih2YWwsIGNvbCA9IGZyYWdjb2xvcmV4cHJfMS5mY29sb3IoKSkge1xuICAgICAgICBzdXBlcihleHByXzEudGFnIGAoYnJpZ2h0bmVzcygke3ZhbH0sICR7Y29sfSkpYCwgW1widUJyaWdodG5lc3NcIiwgXCJ1Q29sb3JcIl0pO1xuICAgICAgICB0aGlzLmV4dGVybmFsRnVuY3MgPSBbZ2xzbGZ1bmN0aW9uc18xLmdsc2xGdW5jcy5icmlnaHRuZXNzXTtcbiAgICB9XG4gICAgc2V0QnJpZ2h0bmVzcyhicmlnaHRuZXNzKSB7XG4gICAgICAgIHRoaXMuc2V0VW5pZm9ybShcInVCcmlnaHRuZXNzXCIgKyB0aGlzLmlkLCBicmlnaHRuZXNzKTtcbiAgICB9XG59XG5leHBvcnRzLkJyaWdodG5lc3MgPSBCcmlnaHRuZXNzO1xuZnVuY3Rpb24gYnJpZ2h0bmVzcyh2YWwsIGNvbCkge1xuICAgIHJldHVybiBuZXcgQnJpZ2h0bmVzcyhleHByXzEubjJlKHZhbCksIGNvbCk7XG59XG5leHBvcnRzLmJyaWdodG5lc3MgPSBicmlnaHRuZXNzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNoYW5uZWwgPSBleHBvcnRzLkJ1ZmZlclNhbXBsZUV4cHIgPSB2b2lkIDA7XG5jb25zdCBjb2RlYnVpbGRlcl8xID0gcmVxdWlyZShcIi4uL2NvZGVidWlsZGVyXCIpO1xuY29uc3QgZXhwcl8xID0gcmVxdWlyZShcIi4vZXhwclwiKTtcbmNvbnN0IG5vcm1mcmFnY29vcmRleHByXzEgPSByZXF1aXJlKFwiLi9ub3JtZnJhZ2Nvb3JkZXhwclwiKTtcbmZ1bmN0aW9uIGdlbkJ1ZmZlclNhbXBsZXJTb3VyY2UoYnVmLCBjb29yZCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHNlY3Rpb25zOiBbYHRleHR1cmUyRCgke2NvZGVidWlsZGVyXzEuYnVmZmVyU2FtcGxlck5hbWUoYnVmKX0sIGAsIGApYF0sXG4gICAgICAgIHZhbHVlczogW2Nvb3JkXSxcbiAgICB9O1xufVxuY2xhc3MgQnVmZmVyU2FtcGxlRXhwciBleHRlbmRzIGV4cHJfMS5FeHByVmVjNCB7XG4gICAgY29uc3RydWN0b3IoYnVmLCBjb29yZCA9IG5vcm1mcmFnY29vcmRleHByXzEubmZjb29yZCgpKSB7XG4gICAgICAgIHN1cGVyKGdlbkJ1ZmZlclNhbXBsZXJTb3VyY2UoYnVmLCBjb29yZCksIFtcInVWZWNcIl0pO1xuICAgICAgICB0aGlzLm5lZWRzLmV4dHJhQnVmZmVycyA9IG5ldyBTZXQoW2J1Zl0pO1xuICAgIH1cbn1cbmV4cG9ydHMuQnVmZmVyU2FtcGxlRXhwciA9IEJ1ZmZlclNhbXBsZUV4cHI7XG5mdW5jdGlvbiBjaGFubmVsKGNoYW5uZWwsIHZlYykge1xuICAgIHJldHVybiBuZXcgQnVmZmVyU2FtcGxlRXhwcihjaGFubmVsLCB2ZWMpO1xufVxuZXhwb3J0cy5jaGFubmVsID0gY2hhbm5lbDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jaGFuZ2Vjb21wID0gZXhwb3J0cy5DaGFuZ2VDb21wRXhwciA9IHZvaWQgMDtcbmNvbnN0IGV4cHJfMSA9IHJlcXVpcmUoXCIuL2V4cHJcIik7XG5jb25zdCBnZXRjb21wZXhwcl8xID0gcmVxdWlyZShcIi4vZ2V0Y29tcGV4cHJcIik7XG5mdW5jdGlvbiBnZXRDaGFuZ2VGdW5jKHR5cCwgaWQsIHNldHRlciwgY29tcHMsIG9wID0gXCJcIikge1xuICAgIHJldHVybiBgJHt0eXB9IGNoYW5nZWNvbXBfJHtpZH0oJHt0eXB9IGNvbCwgJHtzZXR0ZXIudHlwZVN0cmluZygpfSBzZXR0ZXIpIHtcbiAgY29sLiR7Y29tcHN9ICR7b3B9PSBzZXR0ZXI7XG4gIHJldHVybiBjb2w7XG59YDtcbn1cbmZ1bmN0aW9uIGNoZWNrR2V0Q29tcG9uZW50cyhjb21wcywgc2V0dGVyLCB2ZWMpIHtcbiAgICAvLyBzZXR0ZXIgaGFzIGRpZmZlcmVudCBsZW5ndGggdGhhbiBjb21wb25lbnRzXG4gICAgaWYgKGNvbXBzLmxlbmd0aCAhPT0gZ2V0Y29tcGV4cHJfMS50eXBlU3RyaW5nVG9MZW5ndGgoc2V0dGVyLnR5cGVTdHJpbmcoKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29tcG9uZW50cyBsZW5ndGggbXVzdCBiZSBlcXVhbCB0byB0aGUgdGFyZ2V0IGZsb2F0L3ZlY1wiKTtcbiAgICB9XG4gICAgLy8gZHVwbGljYXRlIGNvbXBvbmVudHNcbiAgICBpZiAoZHVwbGljYXRlQ29tcG9uZW50cyhjb21wcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZHVwbGljYXRlIGNvbXBvbmVudHMgbm90IGFsbG93ZWQgb24gbGVmdCBzaWRlXCIpO1xuICAgIH1cbiAgICAvLyBsZWdhbCBjb21wb25lbnRzXG4gICAgZ2V0Y29tcGV4cHJfMS5jaGVja0xlZ2FsQ29tcG9uZW50cyhjb21wcywgdmVjKTtcbn1cbmZ1bmN0aW9uIGR1cGxpY2F0ZUNvbXBvbmVudHMoY29tcHMpIHtcbiAgICByZXR1cm4gbmV3IFNldChjb21wcy5zcGxpdChcIlwiKSkuc2l6ZSAhPT0gY29tcHMubGVuZ3RoO1xufVxuY2xhc3MgQ2hhbmdlQ29tcEV4cHIgZXh0ZW5kcyBleHByXzEuT3BlcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKHZlYywgc2V0dGVyLCBjb21wcywgb3ApIHtcbiAgICAgICAgY2hlY2tHZXRDb21wb25lbnRzKGNvbXBzLCBzZXR0ZXIsIHZlYyk7XG4gICAgICAgIC8vIHBhcnQgb2YgbmFtZSBvZiBjdXN0b20gZnVuY3Rpb25cbiAgICAgICAgY29uc3Qgc3VmZml4ID0gYCR7dmVjLnR5cGVTdHJpbmcoKX1fJHtzZXR0ZXIudHlwZVN0cmluZygpfV8ke2NvbXBzfWA7XG4gICAgICAgIHN1cGVyKHZlYywgeyBzZWN0aW9uczogW2BjaGFuZ2Vjb21wXyR7c3VmZml4fShgLCBcIiwgXCIsIFwiKVwiXSwgdmFsdWVzOiBbdmVjLCBzZXR0ZXJdIH0sIFtcInVPcmlnaW5hbFwiLCBcInVOZXdcIl0pO1xuICAgICAgICB0aGlzLmV4dGVybmFsRnVuY3MgPSBbXG4gICAgICAgICAgICBnZXRDaGFuZ2VGdW5jKHZlYy50eXBlU3RyaW5nKCksIHN1ZmZpeCwgc2V0dGVyLCBjb21wcywgb3ApLFxuICAgICAgICBdO1xuICAgIH1cbiAgICBzZXRPcmlnaW5hbCh2ZWMpIHtcbiAgICAgICAgdGhpcy5zZXRVbmlmb3JtKFwidU9yaWdpbmFsXCIgKyB0aGlzLmlkLCB2ZWMpO1xuICAgIH1cbiAgICBzZXROZXcoc2V0dGVyKSB7XG4gICAgICAgIHRoaXMuc2V0VW5pZm9ybShcInVOZXdcIiArIHRoaXMuaWQsIHNldHRlcik7XG4gICAgfVxufVxuZXhwb3J0cy5DaGFuZ2VDb21wRXhwciA9IENoYW5nZUNvbXBFeHByO1xuZnVuY3Rpb24gY2hhbmdlY29tcCh2ZWMsIHNldHRlciwgY29tcHMsIG9wKSB7XG4gICAgcmV0dXJuIG5ldyBDaGFuZ2VDb21wRXhwcih2ZWMsIGV4cHJfMS53cmFwSW5WYWx1ZShzZXR0ZXIpLCBjb21wcywgb3ApO1xufVxuZXhwb3J0cy5jaGFuZ2Vjb21wID0gY2hhbmdlY29tcDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jb250cmFzdCA9IGV4cG9ydHMuQ29udHJhc3QgPSB2b2lkIDA7XG5jb25zdCBnbHNsZnVuY3Rpb25zXzEgPSByZXF1aXJlKFwiLi4vZ2xzbGZ1bmN0aW9uc1wiKTtcbmNvbnN0IGV4cHJfMSA9IHJlcXVpcmUoXCIuL2V4cHJcIik7XG5jb25zdCBmcmFnY29sb3JleHByXzEgPSByZXF1aXJlKFwiLi9mcmFnY29sb3JleHByXCIpO1xuY2xhc3MgQ29udHJhc3QgZXh0ZW5kcyBleHByXzEuRXhwclZlYzQge1xuICAgIGNvbnN0cnVjdG9yKHZhbCwgY29sID0gZnJhZ2NvbG9yZXhwcl8xLmZjb2xvcigpKSB7XG4gICAgICAgIHN1cGVyKGV4cHJfMS50YWcgYGNvbnRyYXN0KCR7dmFsfSwgJHtjb2x9KWAsIFtcInVWYWxcIiwgXCJ1Q29sXCJdKTtcbiAgICAgICAgdGhpcy5leHRlcm5hbEZ1bmNzID0gW2dsc2xmdW5jdGlvbnNfMS5nbHNsRnVuY3MuY29udHJhc3RdO1xuICAgIH1cbiAgICBzZXRDb250cmFzdChjb250cmFzdCkge1xuICAgICAgICB0aGlzLnNldFVuaWZvcm0oXCJ1Q29udHJhc3RcIiArIHRoaXMuaWQsIGNvbnRyYXN0KTtcbiAgICB9XG59XG5leHBvcnRzLkNvbnRyYXN0ID0gQ29udHJhc3Q7XG5mdW5jdGlvbiBjb250cmFzdCh2YWwsIGNvbCkge1xuICAgIHJldHVybiBuZXcgQ29udHJhc3QoZXhwcl8xLm4yZSh2YWwpLCBjb2wpO1xufVxuZXhwb3J0cy5jb250cmFzdCA9IGNvbnRyYXN0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlcHRoMm9jY2x1c2lvbiA9IGV4cG9ydHMuRGVwdGhUb09jY2x1c2lvbkV4cHIgPSB2b2lkIDA7XG5jb25zdCBleHByXzEgPSByZXF1aXJlKFwiLi9leHByXCIpO1xuY29uc3QgdmVjZXhwcnNfMSA9IHJlcXVpcmUoXCIuL3ZlY2V4cHJzXCIpO1xuY29uc3QgYnVmZmVyc2FtcGxlZXhwcl8xID0gcmVxdWlyZShcIi4vYnVmZmVyc2FtcGxlZXhwclwiKTtcbi8vIFRPRE8gcmVjb25zaWRlciB3aGV0aGVyIHdlIG5lZWQgdGhpc1xuY2xhc3MgRGVwdGhUb09jY2x1c2lvbkV4cHIgZXh0ZW5kcyBleHByXzEuRXhwclZlYzQge1xuICAgIGNvbnN0cnVjdG9yKGRlcHRoQ29sID0gYnVmZmVyc2FtcGxlZXhwcl8xLmNoYW5uZWwoMCksIG5ld0NvbCA9IHZlY2V4cHJzXzEudmVjNCgxLCAxLCAxLCAxKSwgdGhyZXNob2xkID0gZXhwcl8xLmZsb2F0KDAuMDEpKSB7XG4gICAgICAgIHN1cGVyKGV4cHJfMS50YWcgYGRlcHRoMm9jY2x1c2lvbigke2RlcHRoQ29sfSwgJHtuZXdDb2x9LCAke3RocmVzaG9sZH0pYCwgW1xuICAgICAgICAgICAgXCJ1RGVwdGhcIixcbiAgICAgICAgICAgIFwidU5ld0NvbFwiLFxuICAgICAgICAgICAgXCJ1VGhyZXNob2xkXCIsXG4gICAgICAgIF0pO1xuICAgIH1cbn1cbmV4cG9ydHMuRGVwdGhUb09jY2x1c2lvbkV4cHIgPSBEZXB0aFRvT2NjbHVzaW9uRXhwcjtcbmZ1bmN0aW9uIGRlcHRoMm9jY2x1c2lvbihkZXB0aENvbCwgbmV3Q29sLCB0aHJlc2hvbGQpIHtcbiAgICByZXR1cm4gbmV3IERlcHRoVG9PY2NsdXNpb25FeHByKGRlcHRoQ29sLCBuZXdDb2wsIGV4cHJfMS5uMmUodGhyZXNob2xkKSk7XG59XG5leHBvcnRzLmRlcHRoMm9jY2x1c2lvbiA9IGRlcHRoMm9jY2x1c2lvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kb2YgPSBleHBvcnRzLkRvRkxvb3AgPSB2b2lkIDA7XG5jb25zdCBtZXJnZXBhc3NfMSA9IHJlcXVpcmUoXCIuLi9tZXJnZXBhc3NcIik7XG5jb25zdCBibHVyZXhwcl8xID0gcmVxdWlyZShcIi4vYmx1cmV4cHJcIik7XG5jb25zdCBidWZmZXJzYW1wbGVleHByXzEgPSByZXF1aXJlKFwiLi9idWZmZXJzYW1wbGVleHByXCIpO1xuY29uc3QgZXhwcl8xID0gcmVxdWlyZShcIi4vZXhwclwiKTtcbmNvbnN0IGdhdXNzaWFuZXhwcl8xID0gcmVxdWlyZShcIi4vZ2F1c3NpYW5leHByXCIpO1xuY29uc3QgZ2V0Y29tcGV4cHJfMSA9IHJlcXVpcmUoXCIuL2dldGNvbXBleHByXCIpO1xuY29uc3Qgb3BleHByXzEgPSByZXF1aXJlKFwiLi9vcGV4cHJcIik7XG5jb25zdCBhcml0eTJfMSA9IHJlcXVpcmUoXCIuL2FyaXR5MlwiKTtcbmNvbnN0IHZlY2V4cHJzXzEgPSByZXF1aXJlKFwiLi92ZWNleHByc1wiKTtcbmNsYXNzIERvRkxvb3AgZXh0ZW5kcyBtZXJnZXBhc3NfMS5FZmZlY3RMb29wIHtcbiAgICBjb25zdHJ1Y3Rvcihmb2N1cyA9IGV4cHJfMS5tdXQoZXhwcl8xLnBmbG9hdCgwLjMpKSwgcmFkID0gZXhwcl8xLm11dChleHByXzEucGZsb2F0KDAuMDEpKSwgZGVwdGggPSBnZXRjb21wZXhwcl8xLmdldGNvbXAoYnVmZmVyc2FtcGxlZXhwcl8xLmNoYW5uZWwoMCksIFwiclwiKSwgcmVwcyA9IDIpIHtcbiAgICAgICAgbGV0IGd1YXNzaWFuRXhwciA9IGdhdXNzaWFuZXhwcl8xLmdhdXNzaWFuKGRlcHRoLCBmb2N1cywgcmFkKTtcbiAgICAgICAgLy8gVE9ETyBvcHRpb25hbCB0YXBzIG51bWJlclxuICAgICAgICBjb25zdCBzaWRlID0gYmx1cmV4cHJfMS5nYXVzcyh2ZWNleHByc18xLnZlYzIoYXJpdHkyXzEuYTIoXCJwb3dcIiwgb3BleHByXzEub3AoMSwgXCItXCIsIGd1YXNzaWFuRXhwciksIDQpLCAwKSwgMTMpO1xuICAgICAgICBjb25zdCB1cCA9IGJsdXJleHByXzEuZ2F1c3ModmVjZXhwcnNfMS52ZWMyKDAsIGFyaXR5Ml8xLmEyKFwicG93XCIsIG9wZXhwcl8xLm9wKDEsIFwiLVwiLCBndWFzc2lhbkV4cHIpLCA0KSksIDEzKTtcbiAgICAgICAgc3VwZXIoW3NpZGUsIHVwXSwgeyBudW06IHJlcHMgfSk7XG4gICAgICAgIHRoaXMuZ2F1c3NpYW4gPSBndWFzc2lhbkV4cHI7XG4gICAgfVxuICAgIHNldERlcHRoKGRlcHRoKSB7XG4gICAgICAgIC8vIHRoaXMgdHJhbnNsYXRlcyB0aGUgZ2F1c3NpYW4gY3VydmUgdG8gdGhlIHNpZGVcbiAgICAgICAgdGhpcy5nYXVzc2lhbi5zZXRBKGRlcHRoKTtcbiAgICB9XG4gICAgc2V0UmFkaXVzKHJhZGl1cykge1xuICAgICAgICAvLyB0aGlzIHNjYWxlcyB0aGUgZ2F1c3NpYW4gY3VydmUgdG8gZm9jdXMgb24gYSBsYXJnZXIgYmFuZCBvZiBkZXB0aFxuICAgICAgICB0aGlzLmdhdXNzaWFuLnNldEIocmFkaXVzKTtcbiAgICB9XG59XG5leHBvcnRzLkRvRkxvb3AgPSBEb0ZMb29wO1xuZnVuY3Rpb24gZG9mKGZvY3VzLCByYWQsIGRlcHRoLCByZXBzKSB7XG4gICAgcmV0dXJuIG5ldyBEb0ZMb29wKGV4cHJfMS5uMmUoZm9jdXMpLCBleHByXzEubjJlKHJhZCksIGV4cHJfMS5uMmUoZGVwdGgpLCByZXBzKTtcbn1cbmV4cG9ydHMuZG9mID0gZG9mO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRhZyA9IGV4cG9ydHMud3JhcEluVmFsdWUgPSBleHBvcnRzLnBmbG9hdCA9IGV4cG9ydHMubjJwID0gZXhwb3J0cy5uMmUgPSBleHBvcnRzLk9wZXJhdG9yID0gZXhwb3J0cy5FeHByVmVjNCA9IGV4cG9ydHMuRXhwclZlYzMgPSBleHBvcnRzLkV4cHJWZWMyID0gZXhwb3J0cy5mbG9hdCA9IGV4cG9ydHMuRXhwckZsb2F0ID0gZXhwb3J0cy5CYXNpY0Zsb2F0ID0gZXhwb3J0cy5FeHByVmVjID0gZXhwb3J0cy5CYXNpY1ZlYzQgPSBleHBvcnRzLkJhc2ljVmVjMyA9IGV4cG9ydHMuQmFzaWNWZWMyID0gZXhwb3J0cy5CYXNpY1ZlYyA9IGV4cG9ydHMuUHJpbWl0aXZlVmVjNCA9IGV4cG9ydHMuUHJpbWl0aXZlVmVjMyA9IGV4cG9ydHMuUHJpbWl0aXZlVmVjMiA9IGV4cG9ydHMuUHJpbWl0aXZlVmVjID0gZXhwb3J0cy5QcmltaXRpdmVGbG9hdCA9IGV4cG9ydHMuUHJpbWl0aXZlID0gZXhwb3J0cy5tdXQgPSBleHBvcnRzLk11dGFibGUgPSBleHBvcnRzLkV4cHIgPSB2b2lkIDA7XG5jb25zdCBtZXJnZXBhc3NfMSA9IHJlcXVpcmUoXCIuLi9tZXJnZXBhc3NcIik7XG5jb25zdCB3ZWJnbHByb2dyYW1sb29wXzEgPSByZXF1aXJlKFwiLi4vd2ViZ2xwcm9ncmFtbG9vcFwiKTtcbmZ1bmN0aW9uIHRvR0xTTEZsb2F0U3RyaW5nKG51bSkge1xuICAgIGxldCBzdHIgPSBcIlwiICsgbnVtO1xuICAgIGlmICghc3RyLmluY2x1ZGVzKFwiLlwiKSlcbiAgICAgICAgc3RyICs9IFwiLlwiO1xuICAgIHJldHVybiBzdHI7XG59XG5jbGFzcyBFeHByIHtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2VMaXN0cywgZGVmYXVsdE5hbWVzKSB7XG4gICAgICAgIHRoaXMubmVlZHMgPSB7XG4gICAgICAgICAgICBuZWlnaGJvclNhbXBsZTogZmFsc2UsXG4gICAgICAgICAgICBjZW50ZXJTYW1wbGU6IGZhbHNlLFxuICAgICAgICAgICAgc2NlbmVCdWZmZXI6IGZhbHNlLFxuICAgICAgICAgICAgdGltZVVuaWZvcm06IGZhbHNlLFxuICAgICAgICAgICAgZXh0cmFCdWZmZXJzOiBuZXcgU2V0KCksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudW5pZm9ybVZhbENoYW5nZU1hcCA9IHt9O1xuICAgICAgICB0aGlzLmRlZmF1bHROYW1lTWFwID0ge307XG4gICAgICAgIHRoaXMuZXh0ZXJuYWxGdW5jcyA9IFtdO1xuICAgICAgICB0aGlzLnNvdXJjZUNvZGUgPSBcIlwiO1xuICAgICAgICB0aGlzLmlkID0gXCJfaWRfXCIgKyBFeHByLmNvdW50O1xuICAgICAgICBFeHByLmNvdW50Kys7XG4gICAgICAgIGlmIChzb3VyY2VMaXN0cy5zZWN0aW9ucy5sZW5ndGggLSBzb3VyY2VMaXN0cy52YWx1ZXMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGNhbm5vdCBoYXBwZW4gaWYgeW91IHVzZSBgdGFnYCB0byBkZXN0cnVjdHVyZSBhIHRlbXBsYXRlIHN0cmluZ1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwid3JvbmcgbGVuZ3RocyBmb3Igc291cmNlIGFuZCB2YWx1ZXNcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvdXJjZUxpc3RzLnZhbHVlcy5sZW5ndGggIT09IGRlZmF1bHROYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImRlZmF1bHQgbmFtZXMgbGlzdCBsZW5ndGggZG9lc24ndCBtYXRjaCB2YWx1ZXMgbGlzdCBsZW5ndGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zb3VyY2VMaXN0cyA9IHNvdXJjZUxpc3RzO1xuICAgICAgICB0aGlzLmRlZmF1bHROYW1lcyA9IGRlZmF1bHROYW1lcztcbiAgICB9XG4gICAgYXBwbHlVbmlmb3JtcyhnbCwgdW5pZm9ybUxvY3MpIHtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIHRoaXMudW5pZm9ybVZhbENoYW5nZU1hcCkge1xuICAgICAgICAgICAgY29uc3QgbG9jID0gdW5pZm9ybUxvY3NbbmFtZV07XG4gICAgICAgICAgICBpZiAodGhpcy51bmlmb3JtVmFsQ2hhbmdlTWFwW25hbWVdLmNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICAvL3RoaXMudW5pZm9ybVZhbENoYW5nZU1hcFtuYW1lXS5jaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy51bmlmb3JtVmFsQ2hhbmdlTWFwW25hbWVdLnZhbC5hcHBseVVuaWZvcm0oZ2wsIGxvYy5sb2NzW2xvYy5jb3VudGVyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpbmNyZW1lbnQgYW5kIHJlc2V0IHRoZSBjb3VudGVyIHRvIHdyYXAgYmFjayBhcm91bmQgdG8gZmlyc3QgbG9jYXRpb25cbiAgICAgICAgICAgIGxvYy5jb3VudGVyKys7XG4gICAgICAgICAgICBsb2MuY291bnRlciAlPSBsb2MubG9jcy5sZW5ndGg7XG4gICAgICAgICAgICAvLyBvbmNlIHdlIGhhdmUgd3JhcHBlZCB0aGVuIHdlIGtub3cgYWxsIHVuaWZvcm1zIGhhdmUgYmVlbiBjaGFuZ2VkXG4gICAgICAgICAgICBpZiAobG9jLmNvdW50ZXIgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVuaWZvcm1WYWxDaGFuZ2VNYXBbbmFtZV0uY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldFNhbXBsZU51bShtdWx0ID0gMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZWVkcy5uZWlnaGJvclNhbXBsZSA/IG11bHQgOiAwO1xuICAgIH1cbiAgICBzZXRVbmlmb3JtKG5hbWUsIG5ld1ZhbCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBuZXdWYWwgPSB3cmFwSW5WYWx1ZShuZXdWYWwpO1xuICAgICAgICBjb25zdCBvcmlnaW5hbE5hbWUgPSBuYW1lO1xuICAgICAgICBpZiAodHlwZW9mIG5ld1ZhbCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgbmV3VmFsID0gbjJwKG5ld1ZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEobmV3VmFsIGluc3RhbmNlb2YgUHJpbWl0aXZlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IHNldCBhIG5vbi1wcmltaXRpdmVcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgbmFtZSBkb2VzIG5vdCBleGlzdCwgdHJ5IG1hcHBpbmcgZGVmYXVsdCBuYW1lIHRvIG5ldyBuYW1lXG4gICAgICAgIGlmICgoKF9hID0gdGhpcy51bmlmb3JtVmFsQ2hhbmdlTWFwW25hbWVdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudmFsKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBuYW1lID0gdGhpcy5kZWZhdWx0TmFtZU1hcFtuYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbGRWYWwgPSAoX2IgPSB0aGlzLnVuaWZvcm1WYWxDaGFuZ2VNYXBbbmFtZV0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi52YWw7XG4gICAgICAgIGlmIChvbGRWYWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJpZWQgdG8gc2V0IHVuaWZvcm0gXCIgK1xuICAgICAgICAgICAgICAgIG5hbWUgK1xuICAgICAgICAgICAgICAgIFwiIHdoaWNoIGRvZXNuJ3QgZXhpc3QuIG9yaWdpbmFsIG5hbWU6IFwiICtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbGRWYWwudHlwZVN0cmluZygpICE9PSBuZXdWYWwudHlwZVN0cmluZygpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cmllZCB0byBzZXQgdW5pZm9ybSBcIiArIG5hbWUgKyBcIiB0byBhIG5ldyB0eXBlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudW5pZm9ybVZhbENoYW5nZU1hcFtuYW1lXS52YWwgPSBuZXdWYWw7XG4gICAgICAgIHRoaXMudW5pZm9ybVZhbENoYW5nZU1hcFtuYW1lXS5jaGFuZ2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqIHBhcnNlcyB0aGlzIGV4cHJlc3Npb24gaW50byBhIHN0cmluZywgYWRkaW5nIGluZm8gYXMgaXQgcmVjdXJzZXMgKi9cbiAgICBwYXJzZShidWlsZEluZm8pIHtcbiAgICAgICAgdGhpcy5zb3VyY2VDb2RlID0gXCJcIjtcbiAgICAgICAgYnVpbGRJbmZvLmV4cHJzLnB1c2godGhpcyk7XG4gICAgICAgIGJ1aWxkSW5mby5uZWVkcyA9IHdlYmdscHJvZ3JhbWxvb3BfMS51cGRhdGVOZWVkcyhidWlsZEluZm8ubmVlZHMsIHRoaXMubmVlZHMpO1xuICAgICAgICAvLyBhZGQgZWFjaCBvZiB0aGUgZXh0ZXJuYWwgZnVuY3MgdG8gdGhlIGJ1aWxkZXJcbiAgICAgICAgdGhpcy5leHRlcm5hbEZ1bmNzLmZvckVhY2goKGZ1bmMpID0+IGJ1aWxkSW5mby5leHRlcm5hbEZ1bmNzLmFkZChmdW5jKSk7XG4gICAgICAgIC8vIHB1dCBhbGwgb2YgdGhlIHZhbHVlcyBiZXR3ZWVuIGFsbCBvZiB0aGUgc291cmNlIHNlY3Rpb25zXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5zb3VyY2VMaXN0cy52YWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuc291cmNlQ29kZSArPVxuICAgICAgICAgICAgICAgIHRoaXMuc291cmNlTGlzdHMuc2VjdGlvbnNbaV0gK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvdXJjZUxpc3RzLnZhbHVlc1tpXS5wYXJzZShidWlsZEluZm8sIHRoaXMuZGVmYXVsdE5hbWVzW2ldLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPIGRvZXMgc291cmNlQ29kZSBoYXZlIHRvIGJlIGEgbWVtYmVyP1xuICAgICAgICB0aGlzLnNvdXJjZUNvZGUgKz0gdGhpcy5zb3VyY2VMaXN0cy5zZWN0aW9uc1t0aGlzLnNvdXJjZUxpc3RzLnNlY3Rpb25zLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gdGhpcy5zb3VyY2VDb2RlO1xuICAgIH1cbn1cbmV4cG9ydHMuRXhwciA9IEV4cHI7XG5FeHByLmNvdW50ID0gMDtcbmNsYXNzIE11dGFibGUge1xuICAgIGNvbnN0cnVjdG9yKHByaW1pdGl2ZSwgbmFtZSkge1xuICAgICAgICB0aGlzLnByaW1pdGl2ZSA9IHByaW1pdGl2ZTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB9XG4gICAgcGFyc2UoYnVpbGRJbmZvLCBkZWZhdWx0TmFtZSwgZW5jKSB7XG4gICAgICAgIGlmIChlbmMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJpZWQgdG8gcHV0IGEgbXV0YWJsZSBleHByZXNzaW9uIGF0IHRoZSB0b3AgbGV2ZWxcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWNjZXB0IHRoZSBkZWZhdWx0IG5hbWUgaWYgZ2l2ZW4gbm8gbmFtZVxuICAgICAgICBpZiAodGhpcy5uYW1lID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBkZWZhdWx0TmFtZSArIGVuYy5pZDtcbiAgICAgICAgLy8gc2V0IHRvIHRydWUgc28gdGhleSBhcmUgc2V0IHRvIHRoZWlyIGRlZmF1bHQgdmFsdWVzIG9uIGZpcnN0IGRyYXdcbiAgICAgICAgYnVpbGRJbmZvLnVuaWZvcm1UeXBlc1t0aGlzLm5hbWVdID0gdGhpcy5wcmltaXRpdmUudHlwZVN0cmluZygpO1xuICAgICAgICAvLyBhZGQgdGhlIG5hbWUgbWFwcGluZ1xuICAgICAgICBlbmMudW5pZm9ybVZhbENoYW5nZU1hcFt0aGlzLm5hbWVdID0ge1xuICAgICAgICAgICAgdmFsOiB0aGlzLnByaW1pdGl2ZSxcbiAgICAgICAgICAgIGNoYW5nZWQ6IHRydWUsXG4gICAgICAgIH07XG4gICAgICAgIC8vIGFkZCB0aGUgbmV3IHR5cGUgdG8gdGhlIG1hcFxuICAgICAgICBlbmMuZGVmYXVsdE5hbWVNYXBbZGVmYXVsdE5hbWUgKyBlbmMuaWRdID0gdGhpcy5uYW1lO1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lO1xuICAgIH1cbiAgICBhcHBseVVuaWZvcm0oZ2wsIGxvYykge1xuICAgICAgICB0aGlzLnByaW1pdGl2ZS5hcHBseVVuaWZvcm0oZ2wsIGxvYyk7XG4gICAgfVxuICAgIHR5cGVTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByaW1pdGl2ZS50eXBlU3RyaW5nKCk7XG4gICAgfVxufVxuZXhwb3J0cy5NdXRhYmxlID0gTXV0YWJsZTtcbmZ1bmN0aW9uIG11dCh2YWwsIG5hbWUpIHtcbiAgICBjb25zdCBwcmltaXRpdmUgPSB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiID8gbjJwKHZhbCkgOiB2YWw7XG4gICAgcmV0dXJuIG5ldyBNdXRhYmxlKHByaW1pdGl2ZSwgbmFtZSk7XG59XG5leHBvcnRzLm11dCA9IG11dDtcbmNsYXNzIFByaW1pdGl2ZSB7XG4gICAgcGFyc2UoYnVpbGRJbmZvLCBkZWZhdWx0TmFtZSwgZW5jKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gICAgfVxufVxuZXhwb3J0cy5QcmltaXRpdmUgPSBQcmltaXRpdmU7XG5jbGFzcyBQcmltaXRpdmVGbG9hdCBleHRlbmRzIFByaW1pdGl2ZSB7XG4gICAgY29uc3RydWN0b3IobnVtKSB7XG4gICAgICAgIGlmICghaXNGaW5pdGUobnVtKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm51bWJlciBub3QgZmluaXRlXCIpO1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnZhbHVlID0gbnVtO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHN0ciA9IFwiXCIgKyB0aGlzLnZhbHVlO1xuICAgICAgICBpZiAoIXN0ci5pbmNsdWRlcyhcIi5cIikpXG4gICAgICAgICAgICBzdHIgKz0gXCIuXCI7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIHR5cGVTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBcImZsb2F0XCI7XG4gICAgfVxuICAgIGFwcGx5VW5pZm9ybShnbCwgbG9jKSB7XG4gICAgICAgIGdsLnVuaWZvcm0xZihsb2MsIHRoaXMudmFsdWUpO1xuICAgIH1cbn1cbmV4cG9ydHMuUHJpbWl0aXZlRmxvYXQgPSBQcmltaXRpdmVGbG9hdDtcbmNsYXNzIFByaW1pdGl2ZVZlYyBleHRlbmRzIFByaW1pdGl2ZSB7XG4gICAgY29uc3RydWN0b3IoY29tcHMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSBjb21wcztcbiAgICB9XG4gICAgdHlwZVN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIChcInZlY1wiICsgdGhpcy52YWx1ZXMubGVuZ3RoKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLnR5cGVTdHJpbmd9KCR7dGhpcy52YWx1ZXNcbiAgICAgICAgICAgIC5tYXAoKG4pID0+IHRvR0xTTEZsb2F0U3RyaW5nKG4pKVxuICAgICAgICAgICAgLmpvaW4oXCIsIFwiKX0pYDtcbiAgICB9XG59XG5leHBvcnRzLlByaW1pdGl2ZVZlYyA9IFByaW1pdGl2ZVZlYztcbmNsYXNzIFByaW1pdGl2ZVZlYzIgZXh0ZW5kcyBQcmltaXRpdmVWZWMge1xuICAgIGFwcGx5VW5pZm9ybShnbCwgbG9jKSB7XG4gICAgICAgIGdsLnVuaWZvcm0yZihsb2MsIHRoaXMudmFsdWVzWzBdLCB0aGlzLnZhbHVlc1sxXSk7XG4gICAgfVxufVxuZXhwb3J0cy5QcmltaXRpdmVWZWMyID0gUHJpbWl0aXZlVmVjMjtcbmNsYXNzIFByaW1pdGl2ZVZlYzMgZXh0ZW5kcyBQcmltaXRpdmVWZWMge1xuICAgIGFwcGx5VW5pZm9ybShnbCwgbG9jKSB7XG4gICAgICAgIGdsLnVuaWZvcm0zZihsb2MsIHRoaXMudmFsdWVzWzBdLCB0aGlzLnZhbHVlc1sxXSwgdGhpcy52YWx1ZXNbMl0pO1xuICAgIH1cbn1cbmV4cG9ydHMuUHJpbWl0aXZlVmVjMyA9IFByaW1pdGl2ZVZlYzM7XG5jbGFzcyBQcmltaXRpdmVWZWM0IGV4dGVuZHMgUHJpbWl0aXZlVmVjIHtcbiAgICBhcHBseVVuaWZvcm0oZ2wsIGxvYykge1xuICAgICAgICBnbC51bmlmb3JtNGYobG9jLCB0aGlzLnZhbHVlc1swXSwgdGhpcy52YWx1ZXNbMV0sIHRoaXMudmFsdWVzWzJdLCB0aGlzLnZhbHVlc1szXSk7XG4gICAgfVxufVxuZXhwb3J0cy5QcmltaXRpdmVWZWM0ID0gUHJpbWl0aXZlVmVjNDtcbmNsYXNzIEJhc2ljVmVjIGV4dGVuZHMgRXhwciB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlTGlzdHMsIGRlZmF1bHROYW1lcykge1xuICAgICAgICBzdXBlcihzb3VyY2VMaXN0cywgZGVmYXVsdE5hbWVzKTtcbiAgICAgICAgLy8gdGhpcyBjYXN0IGlzIGZpbmUgYXMgbG9uZyBhcyB5b3Ugb25seSBpbnN0YW50aWF0ZSB0aGVzZSB3aXRoIHRoZVxuICAgICAgICAvLyBzaG9ydGhhbmQgdmVyc2lvblxuICAgICAgICBjb25zdCB2YWx1ZXMgPSBzb3VyY2VMaXN0cy52YWx1ZXM7XG4gICAgICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xuICAgICAgICB0aGlzLmRlZmF1bHROYW1lcyA9IGRlZmF1bHROYW1lcztcbiAgICB9XG4gICAgdHlwZVN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIChcInZlY1wiICsgdGhpcy52YWx1ZXMubGVuZ3RoKTtcbiAgICB9XG4gICAgc2V0Q29tcChpbmRleCwgcHJpbWl0aXZlKSB7XG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgaW5kZXggPj0gdGhpcy52YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvdXQgb2YgYm91bmRzIG9mIHNldHRpbmcgY29tcG9uZW50XCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0VW5pZm9ybSh0aGlzLmRlZmF1bHROYW1lc1tpbmRleF0gKyB0aGlzLmlkLCBuMnAocHJpbWl0aXZlKSk7XG4gICAgfVxufVxuZXhwb3J0cy5CYXNpY1ZlYyA9IEJhc2ljVmVjO1xuY2xhc3MgQmFzaWNWZWMyIGV4dGVuZHMgQmFzaWNWZWMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmJ2ZWMyID0gdW5kZWZpbmVkOyAvLyBicmFuZCBmb3Igbm9taW5hbCB0eXBpbmdcbiAgICB9XG59XG5leHBvcnRzLkJhc2ljVmVjMiA9IEJhc2ljVmVjMjtcbmNsYXNzIEJhc2ljVmVjMyBleHRlbmRzIEJhc2ljVmVjIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5idmVjMyA9IHVuZGVmaW5lZDsgLy8gYnJhbmQgZm9yIG5vbWluYWwgdHlwaW5nXG4gICAgfVxufVxuZXhwb3J0cy5CYXNpY1ZlYzMgPSBCYXNpY1ZlYzM7XG5jbGFzcyBCYXNpY1ZlYzQgZXh0ZW5kcyBCYXNpY1ZlYyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuYnZlYzQgPSB1bmRlZmluZWQ7IC8vIGJyYW5kIGZvciBub21pbmFsIHR5cGluZ1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzaWNWZWM0ID0gQmFzaWNWZWM0O1xuY2xhc3MgRXhwclZlYyBleHRlbmRzIEV4cHIge1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZUxpc3RzLCBkZWZhdWx0TmFtZXMpIHtcbiAgICAgICAgc3VwZXIoc291cmNlTGlzdHMsIGRlZmF1bHROYW1lcyk7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IHNvdXJjZUxpc3RzLnZhbHVlcztcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgICAgIHRoaXMuZGVmYXVsdE5hbWVzID0gZGVmYXVsdE5hbWVzO1xuICAgIH1cbn1cbmV4cG9ydHMuRXhwclZlYyA9IEV4cHJWZWM7XG5jbGFzcyBCYXNpY0Zsb2F0IGV4dGVuZHMgRXhwciB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlTGlzdHMsIGRlZmF1bHROYW1lcykge1xuICAgICAgICBzdXBlcihzb3VyY2VMaXN0cywgZGVmYXVsdE5hbWVzKTtcbiAgICAgICAgdGhpcy5mbG9hdCA9IHVuZGVmaW5lZDsgLy8gYnJhbmQgZm9yIG5vbWluYWwgdHlwaW5nXG4gICAgfVxuICAgIHNldFZhbChwcmltaXRpdmUpIHtcbiAgICAgICAgdGhpcy5zZXRVbmlmb3JtKFwidUZsb2F0XCIgKyB0aGlzLmlkLCBuMnAocHJpbWl0aXZlKSk7XG4gICAgfVxuICAgIHR5cGVTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBcImZsb2F0XCI7XG4gICAgfVxufVxuZXhwb3J0cy5CYXNpY0Zsb2F0ID0gQmFzaWNGbG9hdDtcbmNsYXNzIEV4cHJGbG9hdCBleHRlbmRzIEV4cHIge1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZUxpc3RzLCBkZWZhdWx0TmFtZXMpIHtcbiAgICAgICAgc3VwZXIoc291cmNlTGlzdHMsIGRlZmF1bHROYW1lcyk7XG4gICAgICAgIHRoaXMuZmxvYXQgPSB1bmRlZmluZWQ7IC8vIGJyYW5kIGZvciBub21pbmFsIHR5cGluZ1xuICAgIH1cbiAgICBzZXRWYWwocHJpbWl0aXZlKSB7XG4gICAgICAgIHRoaXMuc2V0VW5pZm9ybShcInVGbG9hdFwiICsgdGhpcy5pZCwgbjJwKHByaW1pdGl2ZSkpO1xuICAgIH1cbiAgICB0eXBlU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gXCJmbG9hdFwiO1xuICAgIH1cbn1cbmV4cG9ydHMuRXhwckZsb2F0ID0gRXhwckZsb2F0O1xuZnVuY3Rpb24gZmxvYXQodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKVxuICAgICAgICB2YWx1ZSA9IG4ycCh2YWx1ZSk7XG4gICAgcmV0dXJuIG5ldyBCYXNpY0Zsb2F0KHsgc2VjdGlvbnM6IFtcIlwiLCBcIlwiXSwgdmFsdWVzOiBbdmFsdWVdIH0sIFtcInVGbG9hdFwiXSk7XG59XG5leHBvcnRzLmZsb2F0ID0gZmxvYXQ7XG5jbGFzcyBFeHByVmVjMiBleHRlbmRzIEV4cHJWZWMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZlYzIgPSB1bmRlZmluZWQ7IC8vIGJyYW5kIGZvciBub21pbmFsIHR5cGluZ1xuICAgIH1cbiAgICB0eXBlU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gXCJ2ZWMyXCI7XG4gICAgfVxufVxuZXhwb3J0cy5FeHByVmVjMiA9IEV4cHJWZWMyO1xuY2xhc3MgRXhwclZlYzMgZXh0ZW5kcyBFeHByVmVjIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy52ZWMzID0gdW5kZWZpbmVkOyAvLyBicmFuZCBmb3Igbm9taW5hbCB0eXBpbmdcbiAgICB9XG4gICAgdHlwZVN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFwidmVjM1wiO1xuICAgIH1cbn1cbmV4cG9ydHMuRXhwclZlYzMgPSBFeHByVmVjMztcbmNsYXNzIEV4cHJWZWM0IGV4dGVuZHMgRXhwclZlYyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudmVjNCA9IHVuZGVmaW5lZDsgLy8gYnJhbmQgZm9yIG5vbWluYWwgdHlwaW5nXG4gICAgfVxuICAgIHJlcGVhdChudW0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBtZXJnZXBhc3NfMS5FZmZlY3RMb29wKFt0aGlzXSwgeyBudW06IG51bSB9KTtcbiAgICB9XG4gICAgZ2VuUHJvZ3JhbXMoZ2wsIHZTaGFkZXIsIHVuaWZvcm1Mb2NzKSB7XG4gICAgICAgIHJldHVybiBuZXcgbWVyZ2VwYXNzXzEuRWZmZWN0TG9vcChbdGhpc10sIHsgbnVtOiAxIH0pLmdlblByb2dyYW1zKGdsLCB2U2hhZGVyLCB1bmlmb3JtTG9jcyk7XG4gICAgfVxuICAgIHR5cGVTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBcInZlYzRcIjtcbiAgICB9XG59XG5leHBvcnRzLkV4cHJWZWM0ID0gRXhwclZlYzQ7XG5jbGFzcyBPcGVyYXRvciBleHRlbmRzIEV4cHIge1xuICAgIGNvbnN0cnVjdG9yKHJldCwgc291cmNlTGlzdHMsIGRlZmF1bHROYW1lcykge1xuICAgICAgICBzdXBlcihzb3VyY2VMaXN0cywgZGVmYXVsdE5hbWVzKTtcbiAgICAgICAgdGhpcy5yZXQgPSByZXQ7XG4gICAgfVxuICAgIHR5cGVTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJldC50eXBlU3RyaW5nKCk7XG4gICAgfVxufVxuZXhwb3J0cy5PcGVyYXRvciA9IE9wZXJhdG9yO1xuZnVuY3Rpb24gbjJlKG51bSkge1xuICAgIGlmIChudW0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICBpZiAobnVtIGluc3RhbmNlb2YgUHJpbWl0aXZlRmxvYXQgfHxcbiAgICAgICAgbnVtIGluc3RhbmNlb2YgRXhwckZsb2F0IHx8XG4gICAgICAgIG51bSBpbnN0YW5jZW9mIE9wZXJhdG9yIHx8XG4gICAgICAgIG51bSBpbnN0YW5jZW9mIE11dGFibGUgfHxcbiAgICAgICAgbnVtIGluc3RhbmNlb2YgQmFzaWNGbG9hdClcbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICByZXR1cm4gbmV3IFByaW1pdGl2ZUZsb2F0KG51bSk7XG59XG5leHBvcnRzLm4yZSA9IG4yZTtcbi8qKiBudW1iZXIgdG8gcHJpbWl0aXZlIGZsb2F0ICovXG5mdW5jdGlvbiBuMnAobnVtKSB7XG4gICAgaWYgKG51bSBpbnN0YW5jZW9mIFByaW1pdGl2ZUZsb2F0KVxuICAgICAgICByZXR1cm4gbnVtO1xuICAgIHJldHVybiBuZXcgUHJpbWl0aXZlRmxvYXQobnVtKTtcbn1cbmV4cG9ydHMubjJwID0gbjJwO1xuZnVuY3Rpb24gcGZsb2F0KG51bSkge1xuICAgIHJldHVybiBuZXcgUHJpbWl0aXZlRmxvYXQobnVtKTtcbn1cbmV4cG9ydHMucGZsb2F0ID0gcGZsb2F0O1xuZnVuY3Rpb24gd3JhcEluVmFsdWUobnVtKSB7XG4gICAgaWYgKHR5cGVvZiBudW0gPT09IFwibnVtYmVyXCIpXG4gICAgICAgIHJldHVybiBwZmxvYXQobnVtKTtcbiAgICByZXR1cm4gbnVtO1xufVxuZXhwb3J0cy53cmFwSW5WYWx1ZSA9IHdyYXBJblZhbHVlO1xuZnVuY3Rpb24gdGFnKHN0cmluZ3MsIC4uLnZhbHVlcykge1xuICAgIHJldHVybiB7IHNlY3Rpb25zOiBzdHJpbmdzLmNvbmNhdChbXSksIHZhbHVlczogdmFsdWVzIH07XG59XG5leHBvcnRzLnRhZyA9IHRhZztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mY29sb3IgPSBleHBvcnRzLkZyYWdDb2xvckV4cHIgPSB2b2lkIDA7XG5jb25zdCBleHByXzEgPSByZXF1aXJlKFwiLi9leHByXCIpO1xuY2xhc3MgRnJhZ0NvbG9yRXhwciBleHRlbmRzIGV4cHJfMS5FeHByVmVjNCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKGV4cHJfMS50YWcgYGdsX0ZyYWdDb2xvcmAsIFtdKTtcbiAgICAgICAgdGhpcy5uZWVkcy5jZW50ZXJTYW1wbGUgPSB0cnVlO1xuICAgIH1cbn1cbmV4cG9ydHMuRnJhZ0NvbG9yRXhwciA9IEZyYWdDb2xvckV4cHI7XG5mdW5jdGlvbiBmY29sb3IoKSB7XG4gICAgcmV0dXJuIG5ldyBGcmFnQ29sb3JFeHByKCk7XG59XG5leHBvcnRzLmZjb2xvciA9IGZjb2xvcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5meGFhID0gdm9pZCAwO1xuY29uc3QgZXhwcl8xID0gcmVxdWlyZShcIi4vZXhwclwiKTtcbmNvbnN0IGdsc2xmdW5jdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi9nbHNsZnVuY3Rpb25zXCIpO1xuY2xhc3MgRlhBQUV4cHIgZXh0ZW5kcyBleHByXzEuRXhwclZlYzQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihleHByXzEudGFnIGBmeGFhKClgLCBbXSk7XG4gICAgICAgIHRoaXMuZXh0ZXJuYWxGdW5jcyA9IFtnbHNsZnVuY3Rpb25zXzEuZ2xzbEZ1bmNzLmZ4YWFdO1xuICAgICAgICB0aGlzLm5lZWRzLm5laWdoYm9yU2FtcGxlID0gdHJ1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBmeGFhKCkge1xuICAgIHJldHVybiBuZXcgRlhBQUV4cHIoKTtcbn1cbmV4cG9ydHMuZnhhYSA9IGZ4YWE7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2F1c3NpYW4gPSBleHBvcnRzLkdhdXNzaWFuRXhwciA9IHZvaWQgMDtcbmNvbnN0IGV4cHJfMSA9IHJlcXVpcmUoXCIuL2V4cHJcIik7XG5jb25zdCBnbHNsZnVuY3Rpb25zXzEgPSByZXF1aXJlKFwiLi4vZ2xzbGZ1bmN0aW9uc1wiKTtcbmNsYXNzIEdhdXNzaWFuRXhwciBleHRlbmRzIGV4cHJfMS5FeHByRmxvYXQge1xuICAgIGNvbnN0cnVjdG9yKHgsIGEsIGIpIHtcbiAgICAgICAgc3VwZXIoZXhwcl8xLnRhZyBgZ2F1c3NpYW4oJHt4fSwgJHthfSwgJHtifSlgLCBbXCJ1RmxvYXRYXCIsIFwidUZsb2F0QVwiLCBcInVGbG9hdEJcIl0pO1xuICAgICAgICB0aGlzLmV4dGVybmFsRnVuY3MgPSBbZ2xzbGZ1bmN0aW9uc18xLmdsc2xGdW5jcy5nYXVzc2lhbl07XG4gICAgfVxuICAgIHNldFgoeCkge1xuICAgICAgICB0aGlzLnNldFVuaWZvcm0oXCJ1RmxvYXRYXCIgKyB0aGlzLmlkLCB4KTtcbiAgICB9XG4gICAgc2V0QShhKSB7XG4gICAgICAgIHRoaXMuc2V0VW5pZm9ybShcInVGbG9hdEFcIiArIHRoaXMuaWQsIGEpO1xuICAgIH1cbiAgICBzZXRCKGIpIHtcbiAgICAgICAgdGhpcy5zZXRVbmlmb3JtKFwidUZsb2F0QlwiICsgdGhpcy5pZCwgYik7XG4gICAgfVxufVxuZXhwb3J0cy5HYXVzc2lhbkV4cHIgPSBHYXVzc2lhbkV4cHI7XG5mdW5jdGlvbiBnYXVzc2lhbih4LCBhID0gMCwgYiA9IDEpIHtcbiAgICByZXR1cm4gbmV3IEdhdXNzaWFuRXhwcihleHByXzEubjJlKHgpLCBleHByXzEubjJlKGEpLCBleHByXzEubjJlKGIpKTtcbn1cbmV4cG9ydHMuZ2F1c3NpYW4gPSBnYXVzc2lhbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXQ0Y29tcCA9IGV4cG9ydHMuZ2V0M2NvbXAgPSBleHBvcnRzLmdldDJjb21wID0gZXhwb3J0cy5nZXRjb21wID0gZXhwb3J0cy5HZXQ0Q29tcEV4cHIgPSBleHBvcnRzLkdldDNDb21wRXhwciA9IGV4cG9ydHMuR2V0MkNvbXBFeHByID0gZXhwb3J0cy5HZXRDb21wRXhwciA9IGV4cG9ydHMuY2hlY2tMZWdhbENvbXBvbmVudHMgPSBleHBvcnRzLnR5cGVTdHJpbmdUb0xlbmd0aCA9IHZvaWQgMDtcbmNvbnN0IGV4cHJfMSA9IHJlcXVpcmUoXCIuL2V4cHJcIik7XG4vLyBUT0RPIHRoaXMgc2hvdWxkIHByb2JhYmx5IGJlIHNvbWV3aGVyZSBlbHNlXG5mdW5jdGlvbiB0eXBlU3RyaW5nVG9MZW5ndGgoc3RyKSB7XG4gICAgc3dpdGNoIChzdHIpIHtcbiAgICAgICAgY2FzZSBcImZsb2F0XCI6XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgY2FzZSBcInZlYzJcIjpcbiAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICBjYXNlIFwidmVjM1wiOlxuICAgICAgICAgICAgcmV0dXJuIDM7XG4gICAgICAgIGNhc2UgXCJ2ZWM0XCI6XG4gICAgICAgICAgICByZXR1cm4gNDtcbiAgICB9XG59XG5leHBvcnRzLnR5cGVTdHJpbmdUb0xlbmd0aCA9IHR5cGVTdHJpbmdUb0xlbmd0aDtcbmZ1bmN0aW9uIGdlbkNvbXBTb3VyY2UodmVjLCBjb21wb25lbnRzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2VjdGlvbnM6IFtcIlwiLCBcIi5cIiArIGNvbXBvbmVudHNdLFxuICAgICAgICB2YWx1ZXM6IFt2ZWNdLFxuICAgIH07XG59XG5mdW5jdGlvbiBjaGVja0xlZ2FsQ29tcG9uZW50cyhjb21wcywgdmVjKSB7XG4gICAgY29uc3QgY2hlY2sgPSAocmFuZ2UsIGRvbWFpbikgPT4ge1xuICAgICAgICBsZXQgaW5zaWRlID0gMDtcbiAgICAgICAgbGV0IG91dHNpZGUgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IGMgb2YgcmFuZ2UpIHtcbiAgICAgICAgICAgIGRvbWFpbi5pbmNsdWRlcyhjKSA/IGluc2lkZSsrIDogb3V0c2lkZSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnNpZGUgPT09IGluc2lkZSAmJiAhb3V0c2lkZTtcbiAgICB9O1xuICAgIGNvbnN0IGluTGVuID0gdHlwZVN0cmluZ1RvTGVuZ3RoKHZlYy50eXBlU3RyaW5nKCkpO1xuICAgIGNvbnN0IHJnYmFDaGVjayA9IGNoZWNrKGNvbXBzLCBcInJnYmFcIi5zdWJzdHIoMCwgaW5MZW4pKTtcbiAgICBjb25zdCB4eXp3Q2hlY2sgPSBjaGVjayhjb21wcywgXCJ4eXp3XCIuc3Vic3RyKDAsIGluTGVuKSk7XG4gICAgY29uc3Qgc3RwcUNoZWNrID0gY2hlY2soY29tcHMsIFwic3RwcVwiLnN1YnN0cigwLCBpbkxlbikpO1xuICAgIGlmICghKHJnYmFDaGVjayB8fCB4eXp3Q2hlY2sgfHwgc3RwcUNoZWNrKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb21wb25lbnQgc2V0cyBhcmUgbWl4ZWQgb3IgaW5jb3JyZWN0IGVudGlyZWx5XCIpO1xuICAgIH1cbn1cbmV4cG9ydHMuY2hlY2tMZWdhbENvbXBvbmVudHMgPSBjaGVja0xlZ2FsQ29tcG9uZW50cztcbmZ1bmN0aW9uIGNoZWNrR2V0Q29tcG9uZW50cyhjb21wcywgb3V0TGVuLCB2ZWMpIHtcbiAgICBpZiAoY29tcHMubGVuZ3RoID4gb3V0TGVuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0b28gbWFueSBjb21wb25lbnRzXCIpO1xuICAgIGNoZWNrTGVnYWxDb21wb25lbnRzKGNvbXBzLCB2ZWMpO1xufVxuY2xhc3MgR2V0Q29tcEV4cHIgZXh0ZW5kcyBleHByXzEuRXhwckZsb2F0IHtcbiAgICBjb25zdHJ1Y3Rvcih2ZWMsIGNvbXBzKSB7XG4gICAgICAgIGNoZWNrR2V0Q29tcG9uZW50cyhjb21wcywgMSwgdmVjKTtcbiAgICAgICAgc3VwZXIoZ2VuQ29tcFNvdXJjZSh2ZWMsIGNvbXBzKSwgW1widVZlY1wiXSk7XG4gICAgfVxufVxuZXhwb3J0cy5HZXRDb21wRXhwciA9IEdldENvbXBFeHByO1xuY2xhc3MgR2V0MkNvbXBFeHByIGV4dGVuZHMgZXhwcl8xLkV4cHJWZWMyIHtcbiAgICBjb25zdHJ1Y3Rvcih2ZWMsIGNvbXBzKSB7XG4gICAgICAgIGNoZWNrR2V0Q29tcG9uZW50cyhjb21wcywgMiwgdmVjKTtcbiAgICAgICAgc3VwZXIoZ2VuQ29tcFNvdXJjZSh2ZWMsIGNvbXBzKSwgW1widVZlY1wiXSk7XG4gICAgfVxufVxuZXhwb3J0cy5HZXQyQ29tcEV4cHIgPSBHZXQyQ29tcEV4cHI7XG5jbGFzcyBHZXQzQ29tcEV4cHIgZXh0ZW5kcyBleHByXzEuRXhwclZlYzMge1xuICAgIGNvbnN0cnVjdG9yKHZlYywgY29tcHMpIHtcbiAgICAgICAgY2hlY2tHZXRDb21wb25lbnRzKGNvbXBzLCAzLCB2ZWMpO1xuICAgICAgICBzdXBlcihnZW5Db21wU291cmNlKHZlYywgY29tcHMpLCBbXCJ1VmVjXCJdKTtcbiAgICB9XG59XG5leHBvcnRzLkdldDNDb21wRXhwciA9IEdldDNDb21wRXhwcjtcbmNsYXNzIEdldDRDb21wRXhwciBleHRlbmRzIGV4cHJfMS5FeHByVmVjNCB7XG4gICAgY29uc3RydWN0b3IodmVjLCBjb21wcykge1xuICAgICAgICBjaGVja0dldENvbXBvbmVudHMoY29tcHMsIDQsIHZlYyk7XG4gICAgICAgIHN1cGVyKGdlbkNvbXBTb3VyY2UodmVjLCBjb21wcyksIFtcInVWZWNcIl0pO1xuICAgIH1cbn1cbmV4cG9ydHMuR2V0NENvbXBFeHByID0gR2V0NENvbXBFeHByO1xuZnVuY3Rpb24gZ2V0Y29tcCh2ZWMsIGNvbXBzKSB7XG4gICAgcmV0dXJuIG5ldyBHZXRDb21wRXhwcih2ZWMsIGNvbXBzKTtcbn1cbmV4cG9ydHMuZ2V0Y29tcCA9IGdldGNvbXA7XG5mdW5jdGlvbiBnZXQyY29tcCh2ZWMsIGNvbXBzKSB7XG4gICAgcmV0dXJuIG5ldyBHZXQyQ29tcEV4cHIodmVjLCBjb21wcyk7XG59XG5leHBvcnRzLmdldDJjb21wID0gZ2V0MmNvbXA7XG5mdW5jdGlvbiBnZXQzY29tcCh2ZWMsIGNvbXBzKSB7XG4gICAgcmV0dXJuIG5ldyBHZXQzQ29tcEV4cHIodmVjLCBjb21wcyk7XG59XG5leHBvcnRzLmdldDNjb21wID0gZ2V0M2NvbXA7XG5mdW5jdGlvbiBnZXQ0Y29tcCh2ZWMsIGNvbXBzKSB7XG4gICAgcmV0dXJuIG5ldyBHZXQ0Q29tcEV4cHIodmVjLCBjb21wcyk7XG59XG5leHBvcnRzLmdldDRjb21wID0gZ2V0NGNvbXA7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ29kcmF5cyA9IGV4cG9ydHMuR29kUmF5c0V4cHIgPSB2b2lkIDA7XG5jb25zdCBleHByXzEgPSByZXF1aXJlKFwiLi9leHByXCIpO1xuY29uc3QgZnJhZ2NvbG9yZXhwcl8xID0gcmVxdWlyZShcIi4vZnJhZ2NvbG9yZXhwclwiKTtcbmNvbnN0IGdsc2xmdW5jdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi9nbHNsZnVuY3Rpb25zXCIpO1xuY29uc3QgdmVjZXhwcnNfMSA9IHJlcXVpcmUoXCIuL3ZlY2V4cHJzXCIpO1xuY2xhc3MgR29kUmF5c0V4cHIgZXh0ZW5kcyBleHByXzEuRXhwclZlYzQge1xuICAgIGNvbnN0cnVjdG9yKGNvbCwgZXhwb3N1cmUsIGRlY2F5LCBkZW5zaXR5LCB3ZWlnaHQsIGxpZ2h0UG9zLCBzYW1wbGVyTnVtLCBjb252ZXJ0RGVwdGgpIHtcbiAgICAgICAgLy8gVE9ETyB0aGUgbWV0YXByb2dyYW1taW5nIGhlcmUgaXMgbm90IHNvIGdvb2QhXG4gICAgICAgIC8vIGxlYXZpbmcgb2ZmIHRoZSBmdW5jdGlvbiBjYWxsIHNlY3Rpb24gZm9yIG5vd1xuICAgICAgICBjb25zdCBzb3VyY2VMaXN0cyA9IGV4cHJfMS50YWcgYCR7Y29sfSwgJHtleHBvc3VyZX0sICR7ZGVjYXl9LCAke2RlbnNpdHl9LCAke3dlaWdodH0sICR7bGlnaHRQb3N9LCAke2NvbnZlcnREZXB0aCAhPT0gdW5kZWZpbmVkID8gY29udmVydERlcHRoLnRocmVzaG9sZCA6IGV4cHJfMS5mbG9hdCgwKX0sICR7Y29udmVydERlcHRoICE9PSB1bmRlZmluZWQgPyBjb252ZXJ0RGVwdGgubmV3Q29sb3IgOiB2ZWNleHByc18xLnZlYzQoMCwgMCwgMCwgMCl9KWA7XG4gICAgICAgIC8vIGFwcGVuZCB0aGUgXzxudW0+IG9udG8gdGhlIGZ1bmN0aW9uIG5hbWVcbiAgICAgICAgLy8gYWxzbyBhZGQgX2RlcHRoIGlmIHRoaXMgaXMgYSB2ZXJzaW9uIG9mIHRoZSBmdW5jdGlvbiB0aGF0IHVzZXMgZGVwdGggYnVmZmVyXG4gICAgICAgIHNvdXJjZUxpc3RzLnNlY3Rpb25zWzBdICs9IGBnb2RyYXlzXyR7c2FtcGxlck51bX0ke2NvbnZlcnREZXB0aCAhPT0gdW5kZWZpbmVkID8gXCJfZGVwdGhcIiA6IFwiXCJ9KGA7XG4gICAgICAgIHN1cGVyKHNvdXJjZUxpc3RzLCBbXG4gICAgICAgICAgICBcInVDb2xcIixcbiAgICAgICAgICAgIFwidUV4cG9zdXJlXCIsXG4gICAgICAgICAgICBcInVEZWNheVwiLFxuICAgICAgICAgICAgXCJ1RGVuc2l0eVwiLFxuICAgICAgICAgICAgXCJ1V2VpZ2h0XCIsXG4gICAgICAgICAgICBcInVMaWdodFBvc1wiLFxuICAgICAgICAgICAgXCJ1VGhyZXNob2xkXCIsXG4gICAgICAgICAgICBcInVOZXdDb2xvclwiLFxuICAgICAgICBdKTtcbiAgICAgICAgbGV0IGN1c3RvbUdvZFJheUZ1bmMgPSBnbHNsZnVuY3Rpb25zXzEucmVwbGFjZVNhbXBsZXIoZ2xzbGZ1bmN0aW9uc18xLmdsc2xGdW5jcy5nb2RyYXlzLCAvdmVjNFxcc2dvZHJheXMvZywgc2FtcGxlck51bSwgY29udmVydERlcHRoID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBcIl9kZXB0aFwiKTtcbiAgICAgICAgaWYgKGNvbnZlcnREZXB0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyB1bmNvbW1lbnQgdGhlIGxpbmUgdGhhdCBkb2VzIHRoZSBjb252ZXJzaW9uXG4gICAgICAgICAgICBjdXN0b21Hb2RSYXlGdW5jID0gY3VzdG9tR29kUmF5RnVuYy5yZXBsYWNlKC9cXC9cXC91bmNvbW1lbnRcXHMvZywgXCJcIik7XG4gICAgICAgICAgICB0aGlzLmV4dGVybmFsRnVuY3MucHVzaChnbHNsZnVuY3Rpb25zXzEuZ2xzbEZ1bmNzLmRlcHRoMm9jY2x1c2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5leHRlcm5hbEZ1bmNzLnB1c2goY3VzdG9tR29kUmF5RnVuYyk7XG4gICAgICAgIHRoaXMubmVlZHMuZXh0cmFCdWZmZXJzID0gbmV3IFNldChbMF0pO1xuICAgIH1cbiAgICBzZXRDb2xvcihjb2xvcikge1xuICAgICAgICB0aGlzLnNldFVuaWZvcm0oXCJ1Q29sXCIgKyB0aGlzLmlkLCBjb2xvcik7XG4gICAgfVxuICAgIHNldEV4cG9zdXJlKGV4cG9zdXJlKSB7XG4gICAgICAgIHRoaXMuc2V0VW5pZm9ybShcInVFeHBvc3VyZVwiICsgdGhpcy5pZCwgZXhwb3N1cmUpO1xuICAgIH1cbiAgICBzZXREZWNheShkZWNheSkge1xuICAgICAgICB0aGlzLnNldFVuaWZvcm0oXCJ1RGVjYXlcIiArIHRoaXMuaWQsIGRlY2F5KTtcbiAgICB9XG4gICAgc2V0RGVuc2l0eShkZW5zaXR5KSB7XG4gICAgICAgIHRoaXMuc2V0VW5pZm9ybShcInVEZW5zaXR5XCIgKyB0aGlzLmlkLCBkZW5zaXR5KTtcbiAgICB9XG4gICAgc2V0V2VpZ2h0KHdlaWdodCkge1xuICAgICAgICB0aGlzLnNldFVuaWZvcm0oXCJ1V2VpZ2h0XCIgKyB0aGlzLmlkLCB3ZWlnaHQpO1xuICAgIH1cbiAgICBzZXRMaWdodFBvcyhsaWdodFBvcykge1xuICAgICAgICB0aGlzLnNldFVuaWZvcm0oXCJ1TGlnaHRQb3NcIiArIHRoaXMuaWQsIGxpZ2h0UG9zKTtcbiAgICB9XG4gICAgLy8gdGhlc2Ugb25seSBtYXR0ZXIgd2hlbiB5b3UncmUgdXNpbmcgYSBkZXB0aCBidWZmZXIgYW5kIG5vdCBhbiBvY2NsdXNpb25cbiAgICAvLyBidWZmZXIgKGFsdGhvdWdoIHJpZ2h0IG5vdywgeW91J2xsIHN0aWxsIGJlIGFibGUgdG8gc2V0IHRoZW0pXG4gICAgc2V0VGhyZXNob2xkKHRocmVzaG9sZCkge1xuICAgICAgICB0aGlzLnNldFVuaWZvcm0oXCJ1VGhyZXNob2xkXCIgKyB0aGlzLmlkLCB0aHJlc2hvbGQpO1xuICAgIH1cbiAgICBzZXROZXdjb2xvcihuZXdDb2xvcikge1xuICAgICAgICB0aGlzLnNldFVuaWZvcm0oXCJ1TmV3Q29sb3JcIiArIHRoaXMuaWQsIG5ld0NvbG9yKTtcbiAgICB9XG59XG5leHBvcnRzLkdvZFJheXNFeHByID0gR29kUmF5c0V4cHI7XG4vLyBzYW5lIGdvZHJheSBkZWZhdWx0cyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9FcmthbWFuL2dsc2wtZ29kcmF5cy9ibG9iL21hc3Rlci9leGFtcGxlL2luZGV4LmpzXG5mdW5jdGlvbiBnb2RyYXlzKGNvbCA9IGZyYWdjb2xvcmV4cHJfMS5mY29sb3IoKSwgZXhwb3N1cmUgPSAxLjAsIGRlY2F5ID0gMS4wLCBkZW5zaXR5ID0gMS4wLCB3ZWlnaHQgPSAwLjAxLCBsaWdodFBvcyA9IHZlY2V4cHJzXzEudmVjMigwLjUsIDAuNSksIHNhbXBsZXJOdW0gPSAwLCBjb252ZXJ0RGVwdGgpIHtcbiAgICByZXR1cm4gbmV3IEdvZFJheXNFeHByKGNvbCwgZXhwcl8xLm4yZShleHBvc3VyZSksIGV4cHJfMS5uMmUoZGVjYXkpLCBleHByXzEubjJlKGRlbnNpdHkpLCBleHByXzEubjJlKHdlaWdodCksIGxpZ2h0UG9zLCBzYW1wbGVyTnVtLCBjb252ZXJ0RGVwdGggPT09IHVuZGVmaW5lZFxuICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICA6IHtcbiAgICAgICAgICAgIHRocmVzaG9sZDogZXhwcl8xLm4yZShjb252ZXJ0RGVwdGgudGhyZXNob2xkKSxcbiAgICAgICAgICAgIG5ld0NvbG9yOiBjb252ZXJ0RGVwdGgubmV3Q29sb3IsXG4gICAgICAgIH0pO1xufVxuZXhwb3J0cy5nb2RyYXlzID0gZ29kcmF5cztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ncmFpbiA9IGV4cG9ydHMuR3JhaW5FeHByID0gdm9pZCAwO1xuY29uc3QgZ2xzbGZ1bmN0aW9uc18xID0gcmVxdWlyZShcIi4uL2dsc2xmdW5jdGlvbnNcIik7XG5jb25zdCBleHByXzEgPSByZXF1aXJlKFwiLi9leHByXCIpO1xuY2xhc3MgR3JhaW5FeHByIGV4dGVuZHMgZXhwcl8xLkV4cHJWZWM0IHtcbiAgICBjb25zdHJ1Y3Rvcih2YWwpIHtcbiAgICAgICAgLy8gVE9ETyBjb21wb3NlIHdpdGggb3RoZXIgZXhwcmVzc2lvbnMgcmF0aGVyIHRoYW4gd3JpdGUgZnVsbCBnbHNsP1xuICAgICAgICBzdXBlcihleHByXzEudGFnIGB2ZWM0KCgxLjAgLSAke3ZhbH0gKiByYW5kb20oZ2xfRnJhZ0Nvb3JkLnh5KSkgKiBnbF9GcmFnQ29sb3IucmdiLCBnbF9GcmFnQ29sb3IuYSk7YCwgW1widUdyYWluXCJdKTtcbiAgICAgICAgdGhpcy5leHRlcm5hbEZ1bmNzID0gW2dsc2xmdW5jdGlvbnNfMS5nbHNsRnVuY3MucmFuZG9tXTtcbiAgICAgICAgLy8gVE9ETyBnZXQgcmlkIG9mIHRoaXMgaWYgd2UgY2hvb3NlIHRvIHVzZSBmY29sb3IgaW5zdGVhZCBsYXRlclxuICAgICAgICB0aGlzLm5lZWRzLmNlbnRlclNhbXBsZSA9IHRydWU7XG4gICAgfVxuICAgIHNldEdyYWluKGdyYWluKSB7XG4gICAgICAgIHRoaXMuc2V0VW5pZm9ybShcInVHcmFpblwiICsgdGhpcy5pZCwgZ3JhaW4pO1xuICAgIH1cbn1cbmV4cG9ydHMuR3JhaW5FeHByID0gR3JhaW5FeHByO1xuZnVuY3Rpb24gZ3JhaW4odmFsKSB7XG4gICAgcmV0dXJuIG5ldyBHcmFpbkV4cHIoZXhwcl8xLm4yZSh2YWwpKTtcbn1cbmV4cG9ydHMuZ3JhaW4gPSBncmFpbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5oc3YycmdiID0gZXhwb3J0cy5IU1ZUb1JHQkV4cHIgPSB2b2lkIDA7XG5jb25zdCBleHByXzEgPSByZXF1aXJlKFwiLi9leHByXCIpO1xuY29uc3QgZ2xzbGZ1bmN0aW9uc18xID0gcmVxdWlyZShcIi4uL2dsc2xmdW5jdGlvbnNcIik7XG5jbGFzcyBIU1ZUb1JHQkV4cHIgZXh0ZW5kcyBleHByXzEuRXhwclZlYzQge1xuICAgIGNvbnN0cnVjdG9yKGNvbCkge1xuICAgICAgICBzdXBlcihleHByXzEudGFnIGBoc3YycmdiKCR7Y29sfSlgLCBbXCJ1SFNWQ29sXCJdKTtcbiAgICAgICAgdGhpcy5leHRlcm5hbEZ1bmNzID0gW2dsc2xmdW5jdGlvbnNfMS5nbHNsRnVuY3MuaHN2MnJnYl07XG4gICAgfVxuICAgIHNldENvbG9yKGNvbCkge1xuICAgICAgICB0aGlzLnNldFVuaWZvcm0oXCJ1SFNWQ29sXCIsIGNvbCk7XG4gICAgfVxufVxuZXhwb3J0cy5IU1ZUb1JHQkV4cHIgPSBIU1ZUb1JHQkV4cHI7XG5mdW5jdGlvbiBoc3YycmdiKGNvbCkge1xuICAgIHJldHVybiBuZXcgSFNWVG9SR0JFeHByKGNvbCk7XG59XG5leHBvcnRzLmhzdjJyZ2IgPSBoc3YycmdiO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmxlbiA9IGV4cG9ydHMuTGVuRXhwciA9IHZvaWQgMDtcbmNvbnN0IGV4cHJfMSA9IHJlcXVpcmUoXCIuL2V4cHJcIik7XG5jbGFzcyBMZW5FeHByIGV4dGVuZHMgZXhwcl8xLkV4cHJGbG9hdCB7XG4gICAgY29uc3RydWN0b3IodmVjKSB7XG4gICAgICAgIHN1cGVyKGV4cHJfMS50YWcgYChsZW5ndGgoJHt2ZWN9KSlgLCBbXCJ1VmVjXCJdKTtcbiAgICAgICAgdGhpcy52ZWMgPSB2ZWM7XG4gICAgfVxuICAgIHNldFZlYyh2ZWMpIHtcbiAgICAgICAgdGhpcy5zZXRVbmlmb3JtKFwidVZlY1wiICsgdGhpcy5pZCwgdmVjKTtcbiAgICB9XG59XG5leHBvcnRzLkxlbkV4cHIgPSBMZW5FeHByO1xuZnVuY3Rpb24gbGVuKHZlYykge1xuICAgIHJldHVybiBuZXcgTGVuRXhwcih2ZWMpO1xufVxuZXhwb3J0cy5sZW4gPSBsZW47XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubmNmY29vcmQgPSBleHBvcnRzLk5vcm1DZW50ZXJGcmFnQ29vcmRFeHByID0gdm9pZCAwO1xuY29uc3QgZXhwcl8xID0gcmVxdWlyZShcIi4vZXhwclwiKTtcbmNsYXNzIE5vcm1DZW50ZXJGcmFnQ29vcmRFeHByIGV4dGVuZHMgZXhwcl8xLkV4cHJWZWMyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoZXhwcl8xLnRhZyBgKGdsX0ZyYWdDb29yZC54eSAvIHVSZXNvbHV0aW9uIC0gMC41KWAsIFtdKTtcbiAgICB9XG59XG5leHBvcnRzLk5vcm1DZW50ZXJGcmFnQ29vcmRFeHByID0gTm9ybUNlbnRlckZyYWdDb29yZEV4cHI7XG5mdW5jdGlvbiBuY2Zjb29yZCgpIHtcbiAgICByZXR1cm4gbmV3IE5vcm1DZW50ZXJGcmFnQ29vcmRFeHByKCk7XG59XG5leHBvcnRzLm5jZmNvb3JkID0gbmNmY29vcmQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubmZjb29yZCA9IGV4cG9ydHMuTm9ybUZyYWdDb29yZEV4cHIgPSB2b2lkIDA7XG5jb25zdCBleHByXzEgPSByZXF1aXJlKFwiLi9leHByXCIpO1xuY2xhc3MgTm9ybUZyYWdDb29yZEV4cHIgZXh0ZW5kcyBleHByXzEuRXhwclZlYzIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihleHByXzEudGFnIGAoZ2xfRnJhZ0Nvb3JkLnh5IC8gdVJlc29sdXRpb24pYCwgW10pO1xuICAgIH1cbn1cbmV4cG9ydHMuTm9ybUZyYWdDb29yZEV4cHIgPSBOb3JtRnJhZ0Nvb3JkRXhwcjtcbmZ1bmN0aW9uIG5mY29vcmQoKSB7XG4gICAgcmV0dXJuIG5ldyBOb3JtRnJhZ0Nvb3JkRXhwcigpO1xufVxuZXhwb3J0cy5uZmNvb3JkID0gbmZjb29yZDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5vcCA9IGV4cG9ydHMuT3BFeHByID0gdm9pZCAwO1xuY29uc3QgZXhwcl8xID0gcmVxdWlyZShcIi4vZXhwclwiKTtcbmZ1bmN0aW9uIGdlbk9wU291cmNlTGlzdChsZWZ0LCBvcCwgcmlnaHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzZWN0aW9uczogW1wiKFwiLCBgICR7b3B9IGAsIFwiKVwiXSxcbiAgICAgICAgdmFsdWVzOiBbbGVmdCwgcmlnaHRdLFxuICAgIH07XG59XG5jbGFzcyBPcEV4cHIgZXh0ZW5kcyBleHByXzEuT3BlcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGxlZnQsIG9wLCByaWdodCkge1xuICAgICAgICBzdXBlcihsZWZ0LCBnZW5PcFNvdXJjZUxpc3QobGVmdCwgb3AsIHJpZ2h0KSwgW1widUxlZnRcIiwgXCJ1UmlnaHRcIl0pO1xuICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgfVxuICAgIHNldExlZnQobGVmdCkge1xuICAgICAgICB0aGlzLnNldFVuaWZvcm0oXCJ1TGVmdFwiICsgdGhpcy5pZCwgbGVmdCk7XG4gICAgfVxuICAgIHNldFJpZ2h0KHJpZ2h0KSB7XG4gICAgICAgIHRoaXMuc2V0VW5pZm9ybShcInVSaWdodFwiICsgdGhpcy5pZCwgcmlnaHQpO1xuICAgIH1cbn1cbmV4cG9ydHMuT3BFeHByID0gT3BFeHByO1xuLy8gaW1wbGVtZW50YXRpb25cbmZ1bmN0aW9uIG9wKGxlZnQsIG9wLCByaWdodCkge1xuICAgIHJldHVybiBuZXcgT3BFeHByKGV4cHJfMS53cmFwSW5WYWx1ZShsZWZ0KSwgb3AsIGV4cHJfMS53cmFwSW5WYWx1ZShyaWdodCkpO1xufVxuZXhwb3J0cy5vcCA9IG9wO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBibHVyID0gZXhwb3J0cy5Qb3dlckJsdXJMb29wID0gdm9pZCAwO1xuY29uc3QgbWVyZ2VwYXNzXzEgPSByZXF1aXJlKFwiLi4vbWVyZ2VwYXNzXCIpO1xuY29uc3QgYmx1cmV4cHJfMSA9IHJlcXVpcmUoXCIuL2JsdXJleHByXCIpO1xuY29uc3QgdmVjZXhwcnNfMSA9IHJlcXVpcmUoXCIuL3ZlY2V4cHJzXCIpO1xuY29uc3QgZXhwcl8xID0gcmVxdWlyZShcIi4vZXhwclwiKTtcbmNvbnN0IGJhc2VMb2cgPSAoeCwgeSkgPT4gTWF0aC5sb2coeSkgLyBNYXRoLmxvZyh4KTtcbmNsYXNzIFBvd2VyQmx1ckxvb3AgZXh0ZW5kcyBtZXJnZXBhc3NfMS5FZmZlY3RMb29wIHtcbiAgICBjb25zdHJ1Y3RvcihzaXplKSB7XG4gICAgICAgIGNvbnN0IHNpZGUgPSBibHVyZXhwcl8xLmdhdXNzKGV4cHJfMS5tdXQodmVjZXhwcnNfMS5wdmVjMihzaXplLCAwKSkpO1xuICAgICAgICBjb25zdCB1cCA9IGJsdXJleHByXzEuZ2F1c3MoZXhwcl8xLm11dCh2ZWNleHByc18xLnB2ZWMyKDAsIHNpemUpKSk7XG4gICAgICAgIGNvbnN0IHJlcHMgPSBNYXRoLmNlaWwoYmFzZUxvZygyLCBzaXplKSk7XG4gICAgICAgIHN1cGVyKFtzaWRlLCB1cF0sIHtcbiAgICAgICAgICAgIG51bTogcmVwcyArIDEsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgICAgICB0aGlzLnJlcGVhdC5mdW5jID0gKGkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlID0gdGhpcy5zaXplIC8gTWF0aC5wb3coMiwgaSk7XG4gICAgICAgICAgICB1cC5zZXREaXJlY3Rpb24odmVjZXhwcnNfMS5wdmVjMigwLCBkaXN0YW5jZSkpO1xuICAgICAgICAgICAgc2lkZS5zZXREaXJlY3Rpb24odmVjZXhwcnNfMS5wdmVjMihkaXN0YW5jZSwgMCkpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBzZXRTaXplKHNpemUpIHtcbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICAgICAgdGhpcy5yZXBlYXQubnVtID0gTWF0aC5jZWlsKGJhc2VMb2coMiwgc2l6ZSkpO1xuICAgIH1cbn1cbmV4cG9ydHMuUG93ZXJCbHVyTG9vcCA9IFBvd2VyQmx1ckxvb3A7XG4vKipcbiAqIGZhc3QgYXBwcm94aW1hdGUgYmx1ciBmb3IgbGFyZ2UgYmx1ciByYWRpdXMgdGhhdCBtaWdodCBsb29rIGdvb2QgaW4gc29tZSBjYXNlc1xuICovXG5mdW5jdGlvbiBwYmx1cihzaXplKSB7XG4gICAgcmV0dXJuIG5ldyBQb3dlckJsdXJMb29wKHNpemUpO1xufVxuZXhwb3J0cy5wYmx1ciA9IHBibHVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJhbmRvbUV4cHIgPSB2b2lkIDA7XG5jb25zdCBnbHNsZnVuY3Rpb25zXzEgPSByZXF1aXJlKFwiLi4vZ2xzbGZ1bmN0aW9uc1wiKTtcbmNvbnN0IGV4cHJfMSA9IHJlcXVpcmUoXCIuL2V4cHJcIik7XG5jbGFzcyBSYW5kb21FeHByIGV4dGVuZHMgZXhwcl8xLkV4cHJWZWM0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoZXhwcl8xLnRhZyBgKHJhbmRvbShnbF9GcmFnQ29vcmQueHkpKWAsIFtdKTtcbiAgICAgICAgdGhpcy5leHRlcm5hbEZ1bmNzID0gW2dsc2xmdW5jdGlvbnNfMS5nbHNsRnVuY3MucmFuZG9tXTtcbiAgICB9XG59XG5leHBvcnRzLlJhbmRvbUV4cHIgPSBSYW5kb21FeHByO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJnYjJoc3YgPSBleHBvcnRzLlJHQlRvSFNWRXhwciA9IHZvaWQgMDtcbmNvbnN0IGV4cHJfMSA9IHJlcXVpcmUoXCIuL2V4cHJcIik7XG5jb25zdCBnbHNsZnVuY3Rpb25zXzEgPSByZXF1aXJlKFwiLi4vZ2xzbGZ1bmN0aW9uc1wiKTtcbmNsYXNzIFJHQlRvSFNWRXhwciBleHRlbmRzIGV4cHJfMS5FeHByVmVjNCB7XG4gICAgY29uc3RydWN0b3IoY29sKSB7XG4gICAgICAgIHN1cGVyKGV4cHJfMS50YWcgYHJnYjJoc3YoJHtjb2x9KWAsIFtcInVSR0JDb2xcIl0pO1xuICAgICAgICB0aGlzLmV4dGVybmFsRnVuY3MgPSBbZ2xzbGZ1bmN0aW9uc18xLmdsc2xGdW5jcy5yZ2IyaHN2XTtcbiAgICB9XG4gICAgc2V0Q29sb3IoY29sKSB7XG4gICAgICAgIHRoaXMuc2V0VW5pZm9ybShcInVSR0JDb2xcIiwgY29sKTtcbiAgICB9XG59XG5leHBvcnRzLlJHQlRvSFNWRXhwciA9IFJHQlRvSFNWRXhwcjtcbmZ1bmN0aW9uIHJnYjJoc3YoY29sKSB7XG4gICAgcmV0dXJuIG5ldyBSR0JUb0hTVkV4cHIoY29sKTtcbn1cbmV4cG9ydHMucmdiMmhzdiA9IHJnYjJoc3Y7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaW5wdXQgPSBleHBvcnRzLlNjZW5lU2FtcGxlRXhwciA9IHZvaWQgMDtcbmNvbnN0IGV4cHJfMSA9IHJlcXVpcmUoXCIuL2V4cHJcIik7XG5jb25zdCBub3JtZnJhZ2Nvb3JkZXhwcl8xID0gcmVxdWlyZShcIi4vbm9ybWZyYWdjb29yZGV4cHJcIik7XG5jbGFzcyBTY2VuZVNhbXBsZUV4cHIgZXh0ZW5kcyBleHByXzEuRXhwclZlYzQge1xuICAgIGNvbnN0cnVjdG9yKGNvb3JkID0gbm9ybWZyYWdjb29yZGV4cHJfMS5uZmNvb3JkKCkpIHtcbiAgICAgICAgc3VwZXIoZXhwcl8xLnRhZyBgdGV4dHVyZTJEKHVTY2VuZVNhbXBsZXIsICR7Y29vcmR9KWAsIFtcInVDb29yZFwiXSk7XG4gICAgICAgIHRoaXMubmVlZHMuc2NlbmVCdWZmZXIgPSB0cnVlO1xuICAgIH1cbiAgICBzZXRDb29yZChjb29yZCkge1xuICAgICAgICB0aGlzLnNldFVuaWZvcm0oXCJ1Q29vcmRcIiwgY29vcmQpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2NlbmVTYW1wbGVFeHByID0gU2NlbmVTYW1wbGVFeHByO1xuZnVuY3Rpb24gaW5wdXQodmVjKSB7XG4gICAgcmV0dXJuIG5ldyBTY2VuZVNhbXBsZUV4cHIodmVjKTtcbn1cbmV4cG9ydHMuaW5wdXQgPSBpbnB1dDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zZXRjb2xvciA9IGV4cG9ydHMuU2V0Q29sb3JFeHByID0gdm9pZCAwO1xuY29uc3QgZXhwcl8xID0gcmVxdWlyZShcIi4vZXhwclwiKTtcbmNsYXNzIFNldENvbG9yRXhwciBleHRlbmRzIGV4cHJfMS5FeHByVmVjNCB7XG4gICAgY29uc3RydWN0b3IodmFsKSB7XG4gICAgICAgIHN1cGVyKGV4cHJfMS50YWcgYCgke3ZhbH0pYCwgW1widVZhbFwiXSk7XG4gICAgfVxuICAgIHNldFZhbCh2YWwpIHtcbiAgICAgICAgdGhpcy5zZXRVbmlmb3JtKFwidVZhbFwiLCB2YWwpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2V0Q29sb3JFeHByID0gU2V0Q29sb3JFeHByO1xuZnVuY3Rpb24gc2V0Y29sb3IodmFsKSB7XG4gICAgcmV0dXJuIG5ldyBTZXRDb2xvckV4cHIodmFsKTtcbn1cbmV4cG9ydHMuc2V0Y29sb3IgPSBzZXRjb2xvcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy50aW1lID0gZXhwb3J0cy5UaW1lRXhwciA9IHZvaWQgMDtcbmNvbnN0IGV4cHJfMSA9IHJlcXVpcmUoXCIuL2V4cHJcIik7XG5jbGFzcyBUaW1lRXhwciBleHRlbmRzIGV4cHJfMS5FeHByRmxvYXQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihleHByXzEudGFnIGB1VGltZWAsIFtdKTtcbiAgICAgICAgdGhpcy5uZWVkcy50aW1lVW5pZm9ybSA9IHRydWU7XG4gICAgfVxufVxuZXhwb3J0cy5UaW1lRXhwciA9IFRpbWVFeHByO1xuZnVuY3Rpb24gdGltZSgpIHtcbiAgICByZXR1cm4gbmV3IFRpbWVFeHByKCk7XG59XG5leHBvcnRzLnRpbWUgPSB0aW1lO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRydWVkZXB0aCA9IGV4cG9ydHMuVHJ1ZURlcHRoRXhwciA9IHZvaWQgMDtcbmNvbnN0IGV4cHJfMSA9IHJlcXVpcmUoXCIuL2V4cHJcIik7XG5jb25zdCBnbHNsZnVuY3Rpb25zXzEgPSByZXF1aXJlKFwiLi4vZ2xzbGZ1bmN0aW9uc1wiKTtcbmNsYXNzIFRydWVEZXB0aEV4cHIgZXh0ZW5kcyBleHByXzEuRXhwckZsb2F0IHtcbiAgICBjb25zdHJ1Y3RvcihkaXN0KSB7XG4gICAgICAgIHN1cGVyKGV4cHJfMS50YWcgYHRydWVkZXB0aCgke2Rpc3R9KWAsIFtcInVEaXN0XCJdKTtcbiAgICAgICAgdGhpcy5leHRlcm5hbEZ1bmNzID0gW2dsc2xmdW5jdGlvbnNfMS5nbHNsRnVuY3MudHJ1ZWRlcHRoXTtcbiAgICB9XG4gICAgc2V0RGlzdChkaXN0KSB7XG4gICAgICAgIHRoaXMuc2V0VW5pZm9ybShcInVEaXN0XCIsIGRpc3QpO1xuICAgIH1cbn1cbmV4cG9ydHMuVHJ1ZURlcHRoRXhwciA9IFRydWVEZXB0aEV4cHI7XG5mdW5jdGlvbiB0cnVlZGVwdGgoZGlzdCkge1xuICAgIHJldHVybiBuZXcgVHJ1ZURlcHRoRXhwcihleHByXzEubjJlKGRpc3QpKTtcbn1cbmV4cG9ydHMudHJ1ZWRlcHRoID0gdHJ1ZWRlcHRoO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnB2ZWM0ID0gZXhwb3J0cy5wdmVjMyA9IGV4cG9ydHMucHZlYzIgPSBleHBvcnRzLnZlYzQgPSBleHBvcnRzLnZlYzMgPSBleHBvcnRzLnZlYzIgPSB2b2lkIDA7XG5jb25zdCBleHByXzEgPSByZXF1aXJlKFwiLi9leHByXCIpO1xuZnVuY3Rpb24gdmVjU291cmNlTGlzdCguLi5jb21wb25lbnRzKSB7XG4gICAgY29uc3Qgc2VjdGlvbnMgPSBbXCJ2ZWNcIiArIGNvbXBvbmVudHMubGVuZ3RoICsgXCIoXCJdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29tcG9uZW50cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgc2VjdGlvbnMucHVzaChcIiwgXCIpO1xuICAgIH1cbiAgICBjb25zdCBkZWZhdWx0TmFtZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGVmYXVsdE5hbWVzLnB1c2goXCJ1Q29tcFwiICsgaSk7XG4gICAgfVxuICAgIHNlY3Rpb25zLnB1c2goXCIpXCIpO1xuICAgIHJldHVybiBbeyBzZWN0aW9uczogc2VjdGlvbnMsIHZhbHVlczogY29tcG9uZW50cyB9LCBkZWZhdWx0TmFtZXNdO1xufVxuLy8gZXhwcmVzc2lvbiB2ZWN0b3Igc2hvcnRoYW5kc1xuZnVuY3Rpb24gdmVjMihjb21wMSwgY29tcDIpIHtcbiAgICByZXR1cm4gbmV3IGV4cHJfMS5CYXNpY1ZlYzIoLi4udmVjU291cmNlTGlzdCguLi5bY29tcDEsIGNvbXAyXS5tYXAoKGMpID0+IGV4cHJfMS5uMmUoYykpKSk7XG59XG5leHBvcnRzLnZlYzIgPSB2ZWMyO1xuZnVuY3Rpb24gdmVjMyhjb21wMSwgY29tcDIsIGNvbXAzKSB7XG4gICAgcmV0dXJuIG5ldyBleHByXzEuQmFzaWNWZWMzKC4uLnZlY1NvdXJjZUxpc3QoLi4uW2NvbXAxLCBjb21wMiwgY29tcDNdLm1hcCgoYykgPT4gZXhwcl8xLm4yZShjKSkpKTtcbn1cbmV4cG9ydHMudmVjMyA9IHZlYzM7XG5mdW5jdGlvbiB2ZWM0KGNvbXAxLCBjb21wMiwgY29tcDMsIGNvbXA0KSB7XG4gICAgcmV0dXJuIG5ldyBleHByXzEuQmFzaWNWZWM0KC4uLnZlY1NvdXJjZUxpc3QoLi4uW2NvbXAxLCBjb21wMiwgY29tcDMsIGNvbXA0XS5tYXAoKGMpID0+IGV4cHJfMS5uMmUoYykpKSk7XG59XG5leHBvcnRzLnZlYzQgPSB2ZWM0O1xuLy8gcHJpbWl0aXZlIHZlY3RvciBzaG9ydGhhbmRzXG5mdW5jdGlvbiBwdmVjMihjb21wMSwgY29tcDIpIHtcbiAgICByZXR1cm4gbmV3IGV4cHJfMS5QcmltaXRpdmVWZWMyKFtjb21wMSwgY29tcDJdKTtcbn1cbmV4cG9ydHMucHZlYzIgPSBwdmVjMjtcbmZ1bmN0aW9uIHB2ZWMzKGNvbXAxLCBjb21wMiwgY29tcDMpIHtcbiAgICByZXR1cm4gbmV3IGV4cHJfMS5QcmltaXRpdmVWZWMyKFtjb21wMSwgY29tcDIsIGNvbXAzXSk7XG59XG5leHBvcnRzLnB2ZWMzID0gcHZlYzM7XG5mdW5jdGlvbiBwdmVjNChjb21wMSwgY29tcDIsIGNvbXAzLCBjb21wNCkge1xuICAgIHJldHVybiBuZXcgZXhwcl8xLlByaW1pdGl2ZVZlYzIoW2NvbXAxLCBjb21wMiwgY29tcDMsIGNvbXA0XSk7XG59XG5leHBvcnRzLnB2ZWM0ID0gcHZlYzQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZXBsYWNlU2FtcGxlciA9IGV4cG9ydHMuY2FwdHVyZUFuZEFwcGVuZCA9IGV4cG9ydHMuZ2xzbEZ1bmNzID0gdm9pZCAwO1xuLy8gYWRhcHRlZCBmcm9tIFRoZSBCb29rIG9mIFNoYWRlcnNcbmV4cG9ydHMuZ2xzbEZ1bmNzID0ge1xuICAgIC8vIFRPRE8gcmVwbGFjZSB3aXRoIGEgYmV0dGVyIG9uZVxuICAgIHJhbmRvbTogYGZsb2F0IHJhbmRvbSh2ZWMyIHN0KSB7XG4gIHJldHVybiBmcmFjdChzaW4oZG90KHN0Lnh5IC8gOTkuLCB2ZWMyKDEyLjk4OTgsIDc4LjIzMykpKSAqIDQzNzU4LjU0NTMxMjMpO1xufWAsXG4gICAgLy8gIHJvdGF0ZTJkOiBgbWF0MiByb3RhdGUyZChmbG9hdCBhbmdsZSkge1xuICAgIC8vICByZXR1cm4gbWF0Mihjb3MoYW5nbGUpLCAtc2luKGFuZ2xlKSwgc2luKGFuZ2xlKSwgY29zKGFuZ2xlKSk7XG4gICAgLy99YCxcbiAgICAvLyAgc2NhbGU6IGBtYXQyIHNjYWxlKHZlYzIgc2NhbGUpIHtcbiAgICAvLyAgcmV0dXJuIG1hdDIoc2NhbGUueCwgMC4wLCAwLjAsIHNjYWxlLnkpO1xuICAgIC8vfWAsXG4gICAgaHN2MnJnYjogYHZlYzQgaHN2MnJnYih2ZWM0IGNvKXtcbiAgdmVjMyBjID0gY28ueHl6O1xuICB2ZWMzIHJnYiA9IGNsYW1wKGFicyhtb2QoXG4gICAgYy54ICogNi4wICsgdmVjMygwLjAsIDQuMCwgMi4wKSwgNi4wKSAtIDMuMCkgLSAxLjAsIDAuMCwgMS4wKTtcbiAgcmdiID0gcmdiICogcmdiICogKDMuMCAtIDIuMCAqIHJnYik7XG4gIHZlYzMgaHN2ID0gYy56ICogbWl4KHZlYzMoMS4wKSwgcmdiLCBjLnkpO1xuICByZXR1cm4gdmVjNChoc3YueCwgaHN2LnksIGhzdi56LCBjby5hKTtcbn1gLFxuICAgIHJnYjJoc3Y6IGB2ZWM0IHJnYjJoc3YodmVjNCBjbyl7XG4gIHZlYzMgYyA9IGNvLnJnYjtcbiAgdmVjNCBLID0gdmVjNCgwLjAsIC0xLjAgLyAzLjAsIDIuMCAvIDMuMCwgLTEuMCk7XG4gIHZlYzQgcCA9IG1peCh2ZWM0KGMuYmcsIEsud3opLFxuICAgICAgICAgICAgICAgdmVjNChjLmdiLCBLLnh5KSxcbiAgICAgICAgICAgICAgIHN0ZXAoYy5iLCBjLmcpKTtcbiAgdmVjNCBxID0gbWl4KHZlYzQocC54eXcsIGMuciksXG4gICAgICAgICAgICAgICB2ZWM0KGMuciwgcC55engpLFxuICAgICAgICAgICAgICAgc3RlcChwLngsIGMucikpO1xuICBmbG9hdCBkID0gcS54IC0gbWluKHEudywgcS55KTtcbiAgZmxvYXQgZSA9IDEuMGUtMTA7XG4gIHJldHVybiB2ZWM0KGFicyhxLnogKyAocS53IC0gcS55KSAvICg2LjAgKiBkICsgZSkpLFxuICAgICAgICAgICAgICBkIC8gKHEueCArIGUpLFxuICAgICAgICAgICAgICBxLngsIGNvLmEpO1xufWAsXG4gICAgLy8gVE9ETyBjb2RlLWdlbiBnYXVzc2lhbiBibHVyIG9mIGFyYml0cmFyeSB0YXBzIGJ5IGNhbGN1bGF0aW5nIHRoZSBjdXJ2ZT9cbiAgICAvLyBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL0phbTMvZ2xzbC1mYXN0LWdhdXNzaWFuLWJsdXIvYmxvYi9tYXN0ZXIvNS5nbHNsXG4gICAgZ2F1c3M1OiBgdmVjNCBnYXVzczUodmVjMiBkaXIpIHtcbiAgdmVjMiB1diA9IGdsX0ZyYWdDb29yZC54eSAvIHVSZXNvbHV0aW9uO1xuICB2ZWM0IGNvbCA9IHZlYzQoMC4wKTtcbiAgdmVjMiBvZmYxID0gdmVjMigxLjMzMzMzMzMzMzMzMzMzMzMpICogZGlyO1xuICBjb2wgKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB1dikgKiAwLjI5NDExNzY0NzA1ODgyMzU0O1xuICBjb2wgKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB1diArIChvZmYxIC8gdVJlc29sdXRpb24pKSAqIDAuMzUyOTQxMTc2NDcwNTg4MjY7XG4gIGNvbCArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHV2IC0gKG9mZjEgLyB1UmVzb2x1dGlvbikpICogMC4zNTI5NDExNzY0NzA1ODgyNjtcbiAgcmV0dXJuIGNvbDtcbn1gLFxuICAgIGdhdXNzOTogYHZlYzQgZ2F1c3M5KHZlYzIgZGlyKSB7XG4gIHZlYzIgdXYgPSBnbF9GcmFnQ29vcmQueHkgLyB1UmVzb2x1dGlvbjtcbiAgdmVjNCBjb2wgPSB2ZWM0KDAuMCk7XG4gIHZlYzIgb2ZmMSA9IHZlYzIoMS4zODQ2MTUzODQ2KSAqIGRpcjtcbiAgdmVjMiBvZmYyID0gdmVjMigzLjIzMDc2OTIzMDgpICogZGlyO1xuICBjb2wgKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB1dikgKiAwLjIyNzAyNzAyNzA7XG4gIGNvbCArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHV2ICsgKG9mZjEgLyB1UmVzb2x1dGlvbikpICogMC4zMTYyMTYyMTYyO1xuICBjb2wgKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB1diAtIChvZmYxIC8gdVJlc29sdXRpb24pKSAqIDAuMzE2MjE2MjE2MjtcbiAgY29sICs9IHRleHR1cmUyRCh1U2FtcGxlciwgdXYgKyAob2ZmMiAvIHVSZXNvbHV0aW9uKSkgKiAwLjA3MDI3MDI3MDM7XG4gIGNvbCArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHV2IC0gKG9mZjIgLyB1UmVzb2x1dGlvbikpICogMC4wNzAyNzAyNzAzO1xuICByZXR1cm4gY29sO1xufWAsXG4gICAgZ2F1c3MxMzogYHZlYzQgZ2F1c3MxMyh2ZWMyIGRpcikge1xuICB2ZWMyIHV2ID0gZ2xfRnJhZ0Nvb3JkLnh5IC8gdVJlc29sdXRpb247XG4gIHZlYzQgY29sID0gdmVjNCgwLjApO1xuICB2ZWMyIG9mZjEgPSB2ZWMyKDEuNDExNzY0NzA1ODgyMzUzKSAqIGRpcjtcbiAgdmVjMiBvZmYyID0gdmVjMigzLjI5NDExNzY0NzA1ODgyMzQpICogZGlyO1xuICB2ZWMyIG9mZjMgPSB2ZWMyKDUuMTc2NDcwNTg4MjM1Mjk0KSAqIGRpcjtcbiAgY29sICs9IHRleHR1cmUyRCh1U2FtcGxlciwgdXYpICogMC4xOTY0ODI1NTAxNTExNDA0O1xuICBjb2wgKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB1diArIChvZmYxIC8gdVJlc29sdXRpb24pKSAqIDAuMjk2OTA2OTY0NjcyODM0NDtcbiAgY29sICs9IHRleHR1cmUyRCh1U2FtcGxlciwgdXYgLSAob2ZmMSAvIHVSZXNvbHV0aW9uKSkgKiAwLjI5NjkwNjk2NDY3MjgzNDQ7XG4gIGNvbCArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHV2ICsgKG9mZjIgLyB1UmVzb2x1dGlvbikpICogMC4wOTQ0NzAzOTc4NTA0NDczMjtcbiAgY29sICs9IHRleHR1cmUyRCh1U2FtcGxlciwgdXYgLSAob2ZmMiAvIHVSZXNvbHV0aW9uKSkgKiAwLjA5NDQ3MDM5Nzg1MDQ0NzMyO1xuICBjb2wgKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB1diArIChvZmYzIC8gdVJlc29sdXRpb24pKSAqIDAuMDEwMzgxMzYyNDAxMTQ4MDU3O1xuICBjb2wgKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB1diAtIChvZmYzIC8gdVJlc29sdXRpb24pKSAqIDAuMDEwMzgxMzYyNDAxMTQ4MDU3O1xuICByZXR1cm4gY29sO1xufWAsXG4gICAgY29udHJhc3Q6IGB2ZWM0IGNvbnRyYXN0KGZsb2F0IHZhbCwgdmVjNCBjb2wpIHtcbiAgY29sLnJnYiAvPSBjb2wuYTtcbiAgY29sLnJnYiA9ICgoY29sLnJnYiAtIDAuNSkgKiB2YWwpICsgMC41O1xuICBjb2wucmdiICo9IGNvbC5hO1xuICByZXR1cm4gY29sO1xufWAsXG4gICAgYnJpZ2h0bmVzczogYHZlYzQgYnJpZ2h0bmVzcyhmbG9hdCB2YWwsIHZlYzQgY29sKSB7XG4gIGNvbC5yZ2IgLz0gY29sLmE7XG4gIGNvbC5yZ2IgKz0gdmFsO1xuICBjb2wucmdiICo9IGNvbC5hO1xuICByZXR1cm4gY29sO1xufWAsXG4gICAgLy8gYWRhcHRlZCBmcm9tIGh0dHBzOi8vd3d3LnNoYWRlcnRveS5jb20vdmlldy9sczNHV1Mgd2hpY2ggd2FzIGFkYXB0ZWQgZnJvbVxuICAgIC8vIGh0dHA6Ly93d3cuZ2Vla3MzZC5jb20vMjAxMTA0MDUvZnhhYS1mYXN0LWFwcHJveGltYXRlLWFudGktYWxpYXNpbmctZGVtby1nbHNsLW9wZW5nbC10ZXN0LXJhZGVvbi1nZWZvcmNlLzMvXG4gICAgLy8gcGFzcyBpbiBub3JtYWxpemVkIGNvb3JkaW5hdGVzIHRvIHJjcEZyYW1lXG4gICAgZnhhYTogYHZlYzQgZnhhYSgpIHtcbiAgZmxvYXQgRlhBQV9TUEFOX01BWCA9IDguMDtcbiAgZmxvYXQgRlhBQV9SRURVQ0VfTVVMID0gMS4wIC8gRlhBQV9TUEFOX01BWDtcbiAgZmxvYXQgRlhBQV9SRURVQ0VfTUlOID0gMS4wIC8gMTI4LjA7XG4gIGZsb2F0IEZYQUFfU1VCUElYX1NISUZUID0gMS4wIC8gNC4wO1xuXG4gIHZlYzIgcmNwRnJhbWUgPSAxLiAvIHVSZXNvbHV0aW9uLnh5O1xuICB2ZWMyIHRfdXYgPSBnbF9GcmFnQ29vcmQueHkgLyB1UmVzb2x1dGlvbi54eTsgXG4gIHZlYzQgdXYgPSB2ZWM0KHRfdXYsIHRfdXYgLSAocmNwRnJhbWUgKiAoMC41ICsgRlhBQV9TVUJQSVhfU0hJRlQpKSk7XG5cbiAgdmVjMyByZ2JOVyA9IHRleHR1cmUyRCh1U2FtcGxlciwgdXYuencpLnh5ejtcbiAgdmVjMyByZ2JORSA9IHRleHR1cmUyRCh1U2FtcGxlciwgdXYuencgKyB2ZWMyKDEsMCkgKiByY3BGcmFtZS54eSkueHl6O1xuICB2ZWMzIHJnYlNXID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB1di56dyArIHZlYzIoMCwxKSAqIHJjcEZyYW1lLnh5KS54eXo7XG4gIHZlYzMgcmdiU0UgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHV2Lnp3ICsgdmVjMigxLDEpICogcmNwRnJhbWUueHkpLnh5ejtcbiAgdmVjNCByZ2JNZnVsbCA9IHRleHR1cmUyRCh1U2FtcGxlciwgdXYueHkpO1xuICB2ZWMzIHJnYk0gPSByZ2JNZnVsbC54eXo7XG4gIGZsb2F0IGFscGhhID0gcmdiTWZ1bGwuYTtcblxuICB2ZWMzIGx1bWEgPSB2ZWMzKDAuMjk5LCAwLjU4NywgMC4xMTQpO1xuICBmbG9hdCBsdW1hTlcgPSBkb3QocmdiTlcsIGx1bWEpO1xuICBmbG9hdCBsdW1hTkUgPSBkb3QocmdiTkUsIGx1bWEpO1xuICBmbG9hdCBsdW1hU1cgPSBkb3QocmdiU1csIGx1bWEpO1xuICBmbG9hdCBsdW1hU0UgPSBkb3QocmdiU0UsIGx1bWEpO1xuICBmbG9hdCBsdW1hTSA9IGRvdChyZ2JNLCAgbHVtYSk7XG5cbiAgZmxvYXQgbHVtYU1pbiA9IG1pbihsdW1hTSwgbWluKG1pbihsdW1hTlcsIGx1bWFORSksIG1pbihsdW1hU1csIGx1bWFTRSkpKTtcbiAgZmxvYXQgbHVtYU1heCA9IG1heChsdW1hTSwgbWF4KG1heChsdW1hTlcsIGx1bWFORSksIG1heChsdW1hU1csIGx1bWFTRSkpKTtcblxuICB2ZWMyIGRpcjtcbiAgZGlyLnggPSAtKChsdW1hTlcgKyBsdW1hTkUpIC0gKGx1bWFTVyArIGx1bWFTRSkpO1xuICBkaXIueSA9ICgobHVtYU5XICsgbHVtYVNXKSAtIChsdW1hTkUgKyBsdW1hU0UpKTtcblxuICBmbG9hdCBkaXJSZWR1Y2UgPSBtYXgoXG4gICAgKGx1bWFOVyArIGx1bWFORSArIGx1bWFTVyArIGx1bWFTRSkgKiAoMC4yNSAqIEZYQUFfUkVEVUNFX01VTCksIEZYQUFfUkVEVUNFX01JTik7XG4gIGZsb2F0IHJjcERpck1pbiA9IDEuMC8obWluKGFicyhkaXIueCksIGFicyhkaXIueSkpICsgZGlyUmVkdWNlKTtcblxuICBkaXIgPSBtaW4odmVjMihGWEFBX1NQQU5fTUFYLCAgRlhBQV9TUEFOX01BWCksXG4gICAgbWF4KHZlYzIoLUZYQUFfU1BBTl9NQVgsIC1GWEFBX1NQQU5fTUFYKSxcbiAgICBkaXIgKiByY3BEaXJNaW4pKSAqIHJjcEZyYW1lLnh5O1xuXG4gIHZlYzMgcmdiQSA9ICgxLjAgLyAyLjApICogKFxuICAgIHRleHR1cmUyRCh1U2FtcGxlciwgdXYueHkgKyBkaXIgKiAoMS4wIC8gMy4wIC0gMC41KSkueHl6ICtcbiAgICB0ZXh0dXJlMkQodVNhbXBsZXIsIHV2Lnh5ICsgZGlyICogKDIuMCAvIDMuMCAtIDAuNSkpLnh5eik7XG4gIHZlYzMgcmdiQiA9IHJnYkEgKiAoMS4wIC8gMi4wKSArICgxLjAgLyA0LjApICogKFxuICAgIHRleHR1cmUyRCh1U2FtcGxlciwgdXYueHkgKyBkaXIgKiAoMC4wIC8gMy4wIC0gMC41KSkueHl6ICtcbiAgICB0ZXh0dXJlMkQodVNhbXBsZXIsIHV2Lnh5ICsgZGlyICogKDMuMCAvIDMuMCAtIDAuNSkpLnh5eik7XG5cbiAgZmxvYXQgbHVtYUIgPSBkb3QocmdiQiwgbHVtYSk7XG5cbiAgaWYobHVtYUIgPCBsdW1hTWluIHx8IGx1bWFCID4gbHVtYU1heCkge1xuICAgIHJldHVybiB2ZWM0KHJnYkEuciwgcmdiQS5nLCByZ2JBLmIsIGFscGhhKTtcbiAgfVxuXG4gIHJldHVybiB2ZWM0KHJnYkIuciwgcmdiQi5nLCByZ2JCLmIsIGFscGhhKTtcbn1gLFxuICAgIC8vIG5vcm1hbCBjdXJ2ZSBpcyBhID0gMCBhbmQgYiA9IDFcbiAgICBnYXVzc2lhbjogYGZsb2F0IGdhdXNzaWFuKGZsb2F0IHgsIGZsb2F0IGEsIGZsb2F0IGIpIHtcbiAgZmxvYXQgZSA9IDIuNzE4Mjg7XG4gIHJldHVybiBwb3coZSwgLXBvdyh4IC0gYSwgMi4pIC8gYik7XG59YCxcbiAgICAvLyBmb3IgY2FsY3VsYXRpbmcgdGhlIHRydWUgZGlzdGFuY2UgZnJvbSAwIHRvIDEgZGVwdGggYnVmZmVyXG4gICAgdHJ1ZWRlcHRoOiBgZmxvYXQgdHJ1ZWRlcHRoKGZsb2F0IGkpIHtcbiAgaSA9IG1heChpLCAwLjAwMDAwMDAxKTtcbiAgcmV0dXJuICgxLiAtIGkpIC8gaTtcbn1gLFxuICAgIC8vIGJhc2VkIG9mZiBvZiBodHRwczovL2ZhYmllbnNhbmdsYXJkLm5ldC9saWdodFNjYXR0ZXJpbmcvaW5kZXgucGhwXG4gICAgZ29kcmF5czogYHZlYzQgZ29kcmF5cyhcbiAgdmVjNCBjb2wsXG4gIGZsb2F0IGV4cG9zdXJlLFxuICBmbG9hdCBkZWNheSxcbiAgZmxvYXQgZGVuc2l0eSxcbiAgZmxvYXQgd2VpZ2h0LFxuICB2ZWMyIGxpZ2h0UG9zLFxuICBmbG9hdCB0aHJlc2hvbGQsXG4gIHZlYzQgbmV3Q29sb3Jcbikge1xuICB2ZWMyIHRleENvb3JkID0gZ2xfRnJhZ0Nvb3JkLnh5IC8gdVJlc29sdXRpb247XG4gIHZlYzIgZGVsdGFUZXhDb29yZCA9IHRleENvb3JkIC0gbGlnaHRQb3M7XG5cbiAgY29uc3QgaW50IE5VTV9TQU1QTEVTID0gMTAwO1xuICBkZWx0YVRleENvb3JkICo9IDEuIC8gZmxvYXQoTlVNX1NBTVBMRVMpICogZGVuc2l0eTtcbiAgZmxvYXQgaWxsdW1pbmF0aW9uRGVjYXkgPSAxLjA7XG5cbiAgZm9yIChpbnQgaT0wOyBpIDwgTlVNX1NBTVBMRVM7IGkrKykge1xuICAgIHRleENvb3JkIC09IGRlbHRhVGV4Q29vcmQ7XG4gICAgdmVjNCBzYW1wbGUgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHRleENvb3JkKTtcbiAgICAvL3VuY29tbWVudCBzYW1wbGUgPSBkZXB0aDJvY2NsdXNpb24oc2FtcGxlLCBuZXdDb2xvciwgdGhyZXNob2xkKTtcbiAgICBzYW1wbGUgKj0gaWxsdW1pbmF0aW9uRGVjYXkgKiB3ZWlnaHQ7XG4gICAgY29sICs9IHNhbXBsZTtcbiAgICBpbGx1bWluYXRpb25EZWNheSAqPSBkZWNheTtcbiAgfVxuICByZXR1cm4gY29sICogZXhwb3N1cmU7XG59YCxcbiAgICBkZXB0aDJvY2NsdXNpb246IGB2ZWM0IGRlcHRoMm9jY2x1c2lvbih2ZWM0IGRlcHRoQ29sLCB2ZWM0IG5ld0NvbCwgZmxvYXQgdGhyZXNob2xkKSB7XG4gIGZsb2F0IHJlZCA9IDEuIC0gY2VpbChkZXB0aENvbC5yIC0gdGhyZXNob2xkKTtcbiAgcmV0dXJuIHZlYzQobmV3Q29sLnJnYiAqIHJlZCwgMS4wKTtcbn1gLFxufTtcbmZ1bmN0aW9uIGNhcHR1cmVBbmRBcHBlbmQoc3RyLCByZWcsIHN1ZmZpeCkge1xuICAgIGNvbnN0IG1hdGNoZXMgPSBzdHIubWF0Y2gocmVnKTtcbiAgICBpZiAobWF0Y2hlcyA9PT0gbnVsbClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gbWF0Y2ggaW4gdGhlIGdpdmVuIHN0cmluZ1wiKTtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UocmVnLCBtYXRjaGVzWzBdICsgc3VmZml4KTtcbn1cbmV4cG9ydHMuY2FwdHVyZUFuZEFwcGVuZCA9IGNhcHR1cmVBbmRBcHBlbmQ7XG5mdW5jdGlvbiByZXBsYWNlU2FtcGxlcihmdWxsU3RyaW5nLCBmdW5jUmVnRXhwLCBzYW1wbGVyTnVtLCBleHRyYSkge1xuICAgIHJldHVybiBjYXB0dXJlQW5kQXBwZW5kKGZ1bGxTdHJpbmcucmVwbGFjZSgvdVNhbXBsZXIvZywgXCJ1QnVmZmVyU2FtcGxlclwiICsgc2FtcGxlck51bSksIGZ1bmNSZWdFeHAsIFwiX1wiICsgc2FtcGxlck51bSArIChleHRyYSA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IGV4dHJhKSk7XG59XG5leHBvcnRzLnJlcGxhY2VTYW1wbGVyID0gcmVwbGFjZVNhbXBsZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19leHBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2V4cG9ydFN0YXIpIHx8IGZ1bmN0aW9uKG0sIGV4cG9ydHMpIHtcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgX19jcmVhdGVCaW5kaW5nKGV4cG9ydHMsIG0sIHApO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9tZXJnZXBhc3NcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2V4cHJ0eXBlc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZ2xzbGZ1bmN0aW9uc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZXhwcmVzc2lvbnMvYmx1cmV4cHJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2V4cHJlc3Npb25zL3JhbmRvbWV4cHJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2V4cHJlc3Npb25zL2ZyYWdjb2xvcmV4cHJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2V4cHJlc3Npb25zL3ZlY2V4cHJzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9leHByZXNzaW9ucy9vcGV4cHJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2V4cHJlc3Npb25zL3Bvd2VyYmx1clwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZXhwcmVzc2lvbnMvYmx1cjJkbG9vcFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZXhwcmVzc2lvbnMvbGVuZXhwclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZXhwcmVzc2lvbnMvbm9ybWZyYWdjb29yZGV4cHJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2V4cHJlc3Npb25zL25vcm1jZW50ZXJmcmFnY29vcmRleHByXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9leHByZXNzaW9ucy9zY2VuZXNhbXBsZWV4cHJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2V4cHJlc3Npb25zL2JyaWdodG5lc3NleHByXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9leHByZXNzaW9ucy9zZXRjb2xvcmV4cHJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2V4cHJlc3Npb25zL2NvbnRyYXN0ZXhwclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZXhwcmVzc2lvbnMvZ3JhaW5leHByXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9leHByZXNzaW9ucy9nZXRjb21wZXhwclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZXhwcmVzc2lvbnMvY2hhbmdlY29tcGV4cHJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2V4cHJlc3Npb25zL3JnYnRvaHN2ZXhwclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZXhwcmVzc2lvbnMvaHN2dG9yZ2JleHByXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9leHByZXNzaW9ucy90aW1lZXhwclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZXhwcmVzc2lvbnMvYXJpdHkxXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9leHByZXNzaW9ucy9hcml0eTJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2V4cHJlc3Npb25zL2Z4YWFleHByXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9leHByZXNzaW9ucy9idWZmZXJzYW1wbGVleHByXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9leHByZXNzaW9ucy9kb2Zsb29wXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9leHByZXNzaW9ucy90cnVlZGVwdGhleHByXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9leHByZXNzaW9ucy9nb2RyYXlzZXhwclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZXhwcmVzc2lvbnMvZGVwdGh0b29jY2x1c2lvbmV4cHJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2V4cHJlc3Npb25zL2V4cHJcIiksIGV4cG9ydHMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNlbmRUZXh0dXJlID0gZXhwb3J0cy5tYWtlVGV4dHVyZSA9IGV4cG9ydHMuTWVyZ2VyID0gZXhwb3J0cy5sb29wID0gZXhwb3J0cy5FZmZlY3RMb29wID0gdm9pZCAwO1xuY29uc3QgY29kZWJ1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL2NvZGVidWlsZGVyXCIpO1xuY29uc3Qgd2ViZ2xwcm9ncmFtbG9vcF8xID0gcmVxdWlyZShcIi4vd2ViZ2xwcm9ncmFtbG9vcFwiKTtcbmNsYXNzIEVmZmVjdExvb3Age1xuICAgIGNvbnN0cnVjdG9yKGVmZmVjdHMsIHJlcGVhdCkge1xuICAgICAgICB0aGlzLmVmZmVjdHMgPSBlZmZlY3RzO1xuICAgICAgICB0aGlzLnJlcGVhdCA9IHJlcGVhdDtcbiAgICB9XG4gICAgZ2V0U2FtcGxlTnVtKG11bHQgPSAxLCBzbGljZVN0YXJ0ID0gMCwgc2xpY2VFbmQgPSB0aGlzLmVmZmVjdHMubGVuZ3RoKSB7XG4gICAgICAgIG11bHQgKj0gdGhpcy5yZXBlYXQubnVtO1xuICAgICAgICBsZXQgYWNjID0gMDtcbiAgICAgICAgY29uc3Qgc2xpY2VkID0gdGhpcy5lZmZlY3RzLnNsaWNlKHNsaWNlU3RhcnQsIHNsaWNlRW5kKTtcbiAgICAgICAgZm9yIChjb25zdCBlIG9mIHNsaWNlZCkge1xuICAgICAgICAgICAgYWNjICs9IGUuZ2V0U2FtcGxlTnVtKG11bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2M7XG4gICAgfVxuICAgIC8qKiBwbGFjZXMgZWZmZWN0cyBpbnRvIGxvb3BzIGJyb2tlbiB1cCBieSBzYW1wbGluZyBlZmZlY3RzICovXG4gICAgcmVncm91cCgpIHtcbiAgICAgICAgbGV0IHNhbXBsZUNvdW50ID0gMDtcbiAgICAgICAgLyoqIG51bWJlciBvZiBzYW1wbGVzIGluIGFsbCBwcmV2aW91cyAqL1xuICAgICAgICBsZXQgcHJldlNhbXBsZUNvdW50ID0gMDtcbiAgICAgICAgbGV0IHByZXZFZmZlY3RzID0gW107XG4gICAgICAgIGNvbnN0IHJlZ3JvdXBlZEVmZmVjdHMgPSBbXTtcbiAgICAgICAgY29uc3QgYnJlYWtPZmYgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAocHJldkVmZmVjdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIGJyZWFrIG9mZiBhbGwgcHJldmlvdXMgZWZmZWN0cyBpbnRvIHRoZWlyIG93biBsb29wXG4gICAgICAgICAgICAgICAgaWYgKHByZXZFZmZlY3RzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIHRvIHByZXZlbnQgd3JhcHBpbmcgaW4gYW5vdGhlciBlZmZlY3QgbG9vcFxuICAgICAgICAgICAgICAgICAgICByZWdyb3VwZWRFZmZlY3RzLnB1c2gocHJldkVmZmVjdHNbMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVncm91cGVkRWZmZWN0cy5wdXNoKG5ldyBFZmZlY3RMb29wKHByZXZFZmZlY3RzLCB7IG51bTogMSB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNhbXBsZUNvdW50IC09IHByZXZTYW1wbGVDb3VudDtcbiAgICAgICAgICAgICAgICBwcmV2RWZmZWN0cyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKGNvbnN0IGUgb2YgdGhpcy5lZmZlY3RzKSB7XG4gICAgICAgICAgICBjb25zdCBzYW1wbGVOdW0gPSBlLmdldFNhbXBsZU51bSgpO1xuICAgICAgICAgICAgcHJldlNhbXBsZUNvdW50ID0gc2FtcGxlQ291bnQ7XG4gICAgICAgICAgICBzYW1wbGVDb3VudCArPSBzYW1wbGVOdW07XG4gICAgICAgICAgICBpZiAoc2FtcGxlQ291bnQgPiAwKVxuICAgICAgICAgICAgICAgIGJyZWFrT2ZmKCk7XG4gICAgICAgICAgICBwcmV2RWZmZWN0cy5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHB1c2ggb24gYWxsIHRoZSBzdHJhZ2dsaW5nIGVmZmVjdHMgYWZ0ZXIgdGhlIGdyb3VwaW5nIGlzIGRvbmVcbiAgICAgICAgYnJlYWtPZmYoKTtcbiAgICAgICAgcmV0dXJuIHJlZ3JvdXBlZEVmZmVjdHM7XG4gICAgfVxuICAgIC8qKiByZWN1cnNpdmUgZGVzY2VudCBwYXJzZXIgZm9yIHR1cm5pbmcgZWZmZWN0cyBpbnRvIHByb2dyYW1zICovXG4gICAgZ2VuUHJvZ3JhbXMoZ2wsIHZTaGFkZXIsIHVuaWZvcm1Mb2NzKSB7XG4gICAgICAgIC8vIHZhbGlkYXRlXG4gICAgICAgIGNvbnN0IGZ1bGxTYW1wbGVOdW0gPSB0aGlzLmdldFNhbXBsZU51bSgpIC8gdGhpcy5yZXBlYXQubnVtO1xuICAgICAgICBjb25zdCBmaXJzdFNhbXBsZU51bSA9IHRoaXMuZ2V0U2FtcGxlTnVtKHVuZGVmaW5lZCwgMCwgMSkgLyB0aGlzLnJlcGVhdC5udW07XG4gICAgICAgIGNvbnN0IHJlc3RTYW1wbGVOdW0gPSB0aGlzLmdldFNhbXBsZU51bSh1bmRlZmluZWQsIDEpIC8gdGhpcy5yZXBlYXQubnVtO1xuICAgICAgICBpZiAoZnVsbFNhbXBsZU51bSA9PT0gMCB8fCAoZmlyc3RTYW1wbGVOdW0gPT09IDEgJiYgcmVzdFNhbXBsZU51bSA9PT0gMCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvZGVCdWlsZGVyID0gbmV3IGNvZGVidWlsZGVyXzEuQ29kZUJ1aWxkZXIodGhpcyk7XG4gICAgICAgICAgICBjb25zdCBwcm9ncmFtID0gY29kZUJ1aWxkZXIuY29tcGlsZVByb2dyYW0oZ2wsIHZTaGFkZXIsIHVuaWZvcm1Mb2NzKTtcbiAgICAgICAgICAgIHJldHVybiBwcm9ncmFtO1xuICAgICAgICB9XG4gICAgICAgIC8vIG90aGVyd2lzZSwgcmVncm91cCBhbmQgdHJ5IGFnYWluIG9uIHJlZ3JvdXBlZCBsb29wc1xuICAgICAgICB0aGlzLmVmZmVjdHMgPSB0aGlzLnJlZ3JvdXAoKTtcbiAgICAgICAgLy8gb2theSB0byBoYXZlIHVuZGVmaW5lZCBuZWVkcyBoZXJlXG4gICAgICAgIHJldHVybiBuZXcgd2ViZ2xwcm9ncmFtbG9vcF8xLldlYkdMUHJvZ3JhbUxvb3AodGhpcy5lZmZlY3RzLm1hcCgoZSkgPT4gZS5nZW5Qcm9ncmFtcyhnbCwgdlNoYWRlciwgdW5pZm9ybUxvY3MpKSwgdGhpcy5yZXBlYXQsIGdsKTtcbiAgICB9XG59XG5leHBvcnRzLkVmZmVjdExvb3AgPSBFZmZlY3RMb29wO1xuZnVuY3Rpb24gbG9vcChlZmZlY3RzLCByZXApIHtcbiAgICByZXR1cm4gbmV3IEVmZmVjdExvb3AoZWZmZWN0cywgeyBudW06IHJlcCB9KTtcbn1cbmV4cG9ydHMubG9vcCA9IGxvb3A7XG5jb25zdCBWX1NPVVJDRSA9IGBhdHRyaWJ1dGUgdmVjMiBhUG9zaXRpb247XG52b2lkIG1haW4oKSB7XG4gIGdsX1Bvc2l0aW9uID0gdmVjNChhUG9zaXRpb24sIDAuMCwgMS4wKTtcbn1cXG5gO1xuY2xhc3MgTWVyZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcihlZmZlY3RzLCBzb3VyY2UsIGdsLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy51bmlmb3JtTG9jcyA9IHt9O1xuICAgICAgICAvKiogYWRkaXRpb25hbCBjaGFubmVscyAqL1xuICAgICAgICB0aGlzLmNoYW5uZWxzID0gW107XG4gICAgICAgIC8vIHNldCBjaGFubmVscyBpZiBwcm92aWRlZCB3aXRoIGNoYW5uZWxzXG4gICAgICAgIGlmICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNoYW5uZWxzKSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhpcy5jaGFubmVscyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jaGFubmVscztcbiAgICAgICAgLy8gd3JhcCB0aGUgZ2l2ZW4gbGlzdCBvZiBlZmZlY3RzIGFzIGEgbG9vcCBpZiBuZWVkIGJlXG4gICAgICAgIGlmICghKGVmZmVjdHMgaW5zdGFuY2VvZiBFZmZlY3RMb29wKSkge1xuICAgICAgICAgICAgdGhpcy5lZmZlY3RMb29wID0gbmV3IEVmZmVjdExvb3AoZWZmZWN0cywgeyBudW06IDEgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVmZmVjdExvb3AgPSBlZmZlY3RzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmVmZmVjdExvb3AuZWZmZWN0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImxpc3Qgb2YgZWZmZWN0cyB3YXMgZW1wdHlcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuZ2wgPSBnbDtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgLy8gc2V0IHRoZSB2aWV3cG9ydFxuICAgICAgICB0aGlzLmdsLnZpZXdwb3J0KDAsIDAsIHRoaXMuZ2wuZHJhd2luZ0J1ZmZlcldpZHRoLCB0aGlzLmdsLmRyYXdpbmdCdWZmZXJIZWlnaHQpO1xuICAgICAgICAvLyBzZXQgdXAgdGhlIHZlcnRleCBidWZmZXJcbiAgICAgICAgY29uc3QgdmVydGV4QnVmZmVyID0gdGhpcy5nbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgdGhpcy5nbC5iaW5kQnVmZmVyKHRoaXMuZ2wuQVJSQVlfQlVGRkVSLCB2ZXJ0ZXhCdWZmZXIpO1xuICAgICAgICBjb25zdCB2ZXJ0ZXhBcnJheSA9IFstMSwgLTEsIDEsIC0xLCAtMSwgMSwgLTEsIDEsIDEsIC0xLCAxLCAxXTtcbiAgICAgICAgY29uc3QgdHJpYW5nbGVzID0gbmV3IEZsb2F0MzJBcnJheSh2ZXJ0ZXhBcnJheSk7XG4gICAgICAgIHRoaXMuZ2wuYnVmZmVyRGF0YSh0aGlzLmdsLkFSUkFZX0JVRkZFUiwgdHJpYW5nbGVzLCB0aGlzLmdsLlNUQVRJQ19EUkFXKTtcbiAgICAgICAgLy8gY29tcGlsZSB0aGUgc2ltcGxlIHZlcnRleCBzaGFkZXIgKDIgYmlnIHRyaWFuZ2xlcylcbiAgICAgICAgY29uc3QgdlNoYWRlciA9IHRoaXMuZ2wuY3JlYXRlU2hhZGVyKHRoaXMuZ2wuVkVSVEVYX1NIQURFUik7XG4gICAgICAgIGlmICh2U2hhZGVyID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwcm9ibGVtIGNyZWF0aW5nIHRoZSB2ZXJ0ZXggc2hhZGVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ2wuc2hhZGVyU291cmNlKHZTaGFkZXIsIFZfU09VUkNFKTtcbiAgICAgICAgdGhpcy5nbC5jb21waWxlU2hhZGVyKHZTaGFkZXIpO1xuICAgICAgICAvLyBtYWtlIHRleHR1cmVzXG4gICAgICAgIHRoaXMudGV4ID0ge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgZnJvbnQgdGV4dHVyZSB0aGUgc291cmNlIGlmIHdlJ3JlIGdpdmVuIGEgdGV4dHVyZSBpbnN0ZWFkIG9mXG4gICAgICAgICAgICAvLyBhbiBpbWFnZVxuICAgICAgICAgICAgYmFjazogc291cmNlIGluc3RhbmNlb2YgV2ViR0xUZXh0dXJlXG4gICAgICAgICAgICAgICAgPyBzb3VyY2VcbiAgICAgICAgICAgICAgICA6IG1ha2VUZXh0dXJlKHRoaXMuZ2wsIHRoaXMub3B0aW9ucyksXG4gICAgICAgICAgICBmcm9udDogbWFrZVRleHR1cmUodGhpcy5nbCwgdGhpcy5vcHRpb25zKSxcbiAgICAgICAgICAgIHNjZW5lOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBidWZUZXh0dXJlczogW10sXG4gICAgICAgIH07XG4gICAgICAgIC8vIGNyZWF0ZSB0aGUgZnJhbWVidWZmZXJcbiAgICAgICAgY29uc3QgZnJhbWVidWZmZXIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgICAgICBpZiAoZnJhbWVidWZmZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInByb2JsZW0gY3JlYXRpbmcgdGhlIGZyYW1lYnVmZmVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZnJhbWVidWZmZXIgPSBmcmFtZWJ1ZmZlcjtcbiAgICAgICAgLy8gZ2VuZXJhdGUgdGhlIGZyYWdtZW50IHNoYWRlcnMgYW5kIHByb2dyYW1zXG4gICAgICAgIHRoaXMucHJvZ3JhbUxvb3AgPSB0aGlzLmVmZmVjdExvb3AuZ2VuUHJvZ3JhbXModGhpcy5nbCwgdlNoYWRlciwgdGhpcy51bmlmb3JtTG9jcyk7XG4gICAgICAgIC8vIGZpbmQgdGhlIGZpbmFsIHByb2dyYW1cbiAgICAgICAgbGV0IGF0Qm90dG9tID0gZmFsc2U7XG4gICAgICAgIGxldCBjdXJyUHJvZ3JhbUxvb3AgPSB0aGlzLnByb2dyYW1Mb29wO1xuICAgICAgICB3aGlsZSAoIWF0Qm90dG9tKSB7XG4gICAgICAgICAgICBpZiAoY3VyclByb2dyYW1Mb29wLnByb2dyYW1FbGVtZW50IGluc3RhbmNlb2YgV2ViR0xQcm9ncmFtKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgdHJhdmVsZWQgcmlnaHQgYW5kIGhpdCBhIHByb2dyYW0sIHNvIGl0IG11c3QgYmUgdGhlIGxhc3RcbiAgICAgICAgICAgICAgICBjdXJyUHJvZ3JhbUxvb3AubGFzdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYXRCb3R0b20gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gc2V0IHRoZSBjdXJyZW50IHByb2dyYW0gbG9vcCB0byB0aGUgbGFzdCBpbiB0aGUgbGlzdFxuICAgICAgICAgICAgICAgIGN1cnJQcm9ncmFtTG9vcCA9XG4gICAgICAgICAgICAgICAgICAgIGN1cnJQcm9ncmFtTG9vcC5wcm9ncmFtRWxlbWVudFtjdXJyUHJvZ3JhbUxvb3AucHJvZ3JhbUVsZW1lbnQubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucHJvZ3JhbUxvb3AuZ2V0VG90YWxOZWVkcygpLnNjZW5lQnVmZmVyKSB7XG4gICAgICAgICAgICB0aGlzLnRleC5zY2VuZSA9IG1ha2VUZXh0dXJlKHRoaXMuZ2wsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2codGhpcy5wcm9ncmFtTG9vcCk7XG4gICAgICAgIC8vIGNyZWF0ZSB4IGFtb3VudCBvZiBlbXB0eSB0ZXh0dXJlcyBiYXNlZCBvbiBidWZmZXJzIG5lZWRlZFxuICAgICAgICBsZXQgY2hhbm5lbHNOZWVkZWQgPSAwO1xuICAgICAgICBpZiAoKChfYSA9IHRoaXMucHJvZ3JhbUxvb3AudG90YWxOZWVkcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmV4dHJhQnVmZmVycykgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2hhbm5lbHNOZWVkZWQgPVxuICAgICAgICAgICAgICAgIE1hdGgubWF4KC4uLnRoaXMucHJvZ3JhbUxvb3AudG90YWxOZWVkcy5leHRyYUJ1ZmZlcnMpICsgMTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY2hhbm5lbHNTdXBwbGllZCA9IHRoaXMuY2hhbm5lbHMubGVuZ3RoO1xuICAgICAgICBpZiAoY2hhbm5lbHNOZWVkZWQgPiBjaGFubmVsc1N1cHBsaWVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgZW5vdWdoIGNoYW5uZWxzIHN1cHBsaWVkIGZvciB0aGlzIGVmZmVjdFwiKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hhbm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHRleE9ySW1hZ2UgPSB0aGlzLmNoYW5uZWxzW2ldO1xuICAgICAgICAgICAgaWYgKCEodGV4T3JJbWFnZSBpbnN0YW5jZW9mIFdlYkdMVGV4dHVyZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgYSBuZXcgdGV4dHVyZTsgd2Ugd2lsbCB1cGRhdGUgdGhpcyB3aXRoIHRoZSBpbWFnZSBzb3VyY2UgZXZlcnkgZHJhd1xuICAgICAgICAgICAgICAgIGNvbnN0IHRleHR1cmUgPSBtYWtlVGV4dHVyZSh0aGlzLmdsLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHRoaXMudGV4LmJ1ZlRleHR1cmVzLnB1c2godGV4dHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIGFscmVhZHkgYSB0ZXh0dXJlOyB0aGUgdXNlciB3aWxsIGhhbmRsZSB1cGRhdGluZyB0aGlzXG4gICAgICAgICAgICAgICAgdGhpcy50ZXguYnVmVGV4dHVyZXMucHVzaCh0ZXhPckltYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBkcmF3KHRpbWUgPSAwKSB7XG4gICAgICAgIC8vIFRPRE8gZG91YmxlIGNoZWNrIGlmIHRoaXMgaXMgbmVjY2Vzc2FyeVxuICAgICAgICBjb25zdCBvcmlnaW5hbEZyb250ID0gdGhpcy50ZXguZnJvbnQ7XG4gICAgICAgIGNvbnN0IG9yaWdpbmFsQmFjayA9IHRoaXMudGV4LmJhY2s7XG4gICAgICAgIHRoaXMuZ2wuYWN0aXZlVGV4dHVyZSh0aGlzLmdsLlRFWFRVUkUwKTtcbiAgICAgICAgdGhpcy5nbC5iaW5kVGV4dHVyZSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRoaXMudGV4LmJhY2spO1xuICAgICAgICBzZW5kVGV4dHVyZSh0aGlzLmdsLCB0aGlzLnNvdXJjZSk7XG4gICAgICAgIC8vIGJpbmQgdGhlIHNjZW5lIGJ1ZmZlclxuICAgICAgICBpZiAodGhpcy5wcm9ncmFtTG9vcC5nZXRUb3RhbE5lZWRzKCkuc2NlbmVCdWZmZXIgJiZcbiAgICAgICAgICAgIHRoaXMudGV4LnNjZW5lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZ2wuYWN0aXZlVGV4dHVyZSh0aGlzLmdsLlRFWFRVUkUxKTtcbiAgICAgICAgICAgIHRoaXMuZ2wuYmluZFRleHR1cmUodGhpcy5nbC5URVhUVVJFXzJELCB0aGlzLnRleC5zY2VuZSk7XG4gICAgICAgICAgICBzZW5kVGV4dHVyZSh0aGlzLmdsLCB0aGlzLnNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYmluZCB0aGUgYWRkaXRpb25hbCBidWZmZXJzXG4gICAgICAgIGxldCBjb3VudGVyID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBiIG9mIHRoaXMuY2hhbm5lbHMpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gd2hhdCdzIHRoZSBsaW1pdCBvbiBhbW91bnQgb2YgdGV4dHVyZXM/XG4gICAgICAgICAgICB0aGlzLmdsLmFjdGl2ZVRleHR1cmUodGhpcy5nbC5URVhUVVJFMiArIGNvdW50ZXIpO1xuICAgICAgICAgICAgdGhpcy5nbC5iaW5kVGV4dHVyZSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRoaXMudGV4LmJ1ZlRleHR1cmVzW2NvdW50ZXJdKTtcbiAgICAgICAgICAgIHNlbmRUZXh0dXJlKHRoaXMuZ2wsIGIpO1xuICAgICAgICAgICAgY291bnRlcisrO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN3YXAgdGV4dHVyZXMgYmVmb3JlIGJlZ2lubmluZyBkcmF3XG4gICAgICAgIHRoaXMucHJvZ3JhbUxvb3AuZHJhdyh0aGlzLmdsLCB0aGlzLnRleCwgdGhpcy5mcmFtZWJ1ZmZlciwgdGhpcy51bmlmb3JtTG9jcywgdGhpcy5wcm9ncmFtTG9vcC5sYXN0LCB0aW1lKTtcbiAgICAgICAgLy8gbWFrZSBzdXJlIGZyb250IGFuZCBiYWNrIGFyZSBpbiBzYW1lIG9yZGVyXG4gICAgICAgIHRoaXMudGV4LmZyb250ID0gb3JpZ2luYWxGcm9udDtcbiAgICAgICAgdGhpcy50ZXguYmFjayA9IG9yaWdpbmFsQmFjaztcbiAgICB9XG59XG5leHBvcnRzLk1lcmdlciA9IE1lcmdlcjtcbmZ1bmN0aW9uIG1ha2VUZXh0dXJlKGdsLCBvcHRpb25zKSB7XG4gICAgY29uc3QgdGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICBpZiAodGV4dHVyZSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwcm9ibGVtIGNyZWF0aW5nIHRleHR1cmVcIik7XG4gICAgfVxuICAgIC8vIGZsaXAgdGhlIG9yZGVyIG9mIHRoZSBwaXhlbHMsIG9yIGVsc2UgaXQgZGlzcGxheXMgdXBzaWRlIGRvd25cbiAgICBnbC5waXhlbFN0b3JlaShnbC5VTlBBQ0tfRkxJUF9ZX1dFQkdMLCB0cnVlKTtcbiAgICAvLyBiaW5kIHRoZSB0ZXh0dXJlIGFmdGVyIGNyZWF0aW5nIGl0XG4gICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4dHVyZSk7XG4gICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCBnbC5kcmF3aW5nQnVmZmVyV2lkdGgsIGdsLmRyYXdpbmdCdWZmZXJIZWlnaHQsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwpO1xuICAgIGNvbnN0IGZpbHRlck1vZGUgPSAoZikgPT4gZiA9PT0gdW5kZWZpbmVkIHx8IGYgPT09IFwibGluZWFyXCIgPyBnbC5MSU5FQVIgOiBnbC5ORUFSRVNUO1xuICAgIC8vIGhvdyB0byBtYXAgdGV4dHVyZSBlbGVtZW50XG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGZpbHRlck1vZGUob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm1pbkZpbHRlck1vZGUpKTtcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgZmlsdGVyTW9kZShvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWF4RmlsdGVyTW9kZSkpO1xuICAgIGlmICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmVkZ2VNb2RlKSAhPT0gXCJ3cmFwXCIpIHtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dHVyZTtcbn1cbmV4cG9ydHMubWFrZVRleHR1cmUgPSBtYWtlVGV4dHVyZTtcbmZ1bmN0aW9uIHNlbmRUZXh0dXJlKGdsLCBzcmMpIHtcbiAgICAvLyBpZiB5b3UgYXJlIHVzaW5nIHRleHR1cmVzIGluc3RlYWQgb2YgaW1hZ2VzLCB0aGUgdXNlciBpcyByZXNwb25zaWJsZSBmb3JcbiAgICAvLyBkb2luZyBgdGV4SW1hZ2UyRGAgYW5kIHVwZGF0aW5nIGl0IHdpdGggbmV3IGluZm8sIHNvIGp1c3QgcmV0dXJuXG4gICAgaWYgKHNyYyBpbnN0YW5jZW9mIFdlYkdMVGV4dHVyZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQSwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgc3JjKTtcbn1cbmV4cG9ydHMuc2VuZFRleHR1cmUgPSBzZW5kVGV4dHVyZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5XZWJHTFByb2dyYW1Mb29wID0gZXhwb3J0cy51cGRhdGVOZWVkcyA9IHZvaWQgMDtcbi8vIHVwZGF0ZSBtZSBvbiBjaGFuZ2UgdG8gbmVlZHNcbmV4cG9ydHMudXBkYXRlTmVlZHMgPSAoYWNjLCBjdXJyKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmVpZ2hib3JTYW1wbGU6IGFjYy5uZWlnaGJvclNhbXBsZSB8fCBjdXJyLm5laWdoYm9yU2FtcGxlLFxuICAgICAgICBjZW50ZXJTYW1wbGU6IGFjYy5jZW50ZXJTYW1wbGUgfHwgY3Vyci5jZW50ZXJTYW1wbGUsXG4gICAgICAgIHNjZW5lQnVmZmVyOiBhY2Muc2NlbmVCdWZmZXIgfHwgY3Vyci5zY2VuZUJ1ZmZlcixcbiAgICAgICAgdGltZVVuaWZvcm06IGFjYy50aW1lVW5pZm9ybSB8fCBjdXJyLnRpbWVVbmlmb3JtLFxuICAgICAgICBleHRyYUJ1ZmZlcnM6IG5ldyBTZXQoWy4uLmFjYy5leHRyYUJ1ZmZlcnMsIC4uLmN1cnIuZXh0cmFCdWZmZXJzXSksXG4gICAgfTtcbn07XG5jbGFzcyBXZWJHTFByb2dyYW1Mb29wIHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9ncmFtRWxlbWVudCwgcmVwZWF0LCBnbCwgdG90YWxOZWVkcywgLy8gb25seSBkZWZpbmVkIHdoZW4gbGVhZlxuICAgIGVmZmVjdHMgPSBbXSAvLyBvbmx5IHBvcHVsYXRlZCB3aGVuIGxlYWZcbiAgICApIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmxhc3QgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wcm9ncmFtRWxlbWVudCA9IHByb2dyYW1FbGVtZW50O1xuICAgICAgICB0aGlzLnJlcGVhdCA9IHJlcGVhdDtcbiAgICAgICAgdGhpcy50b3RhbE5lZWRzID0gdG90YWxOZWVkcztcbiAgICAgICAgdGhpcy5lZmZlY3RzID0gZWZmZWN0cztcbiAgICAgICAgaWYgKHByb2dyYW1FbGVtZW50IGluc3RhbmNlb2YgV2ViR0xQcm9ncmFtKSB7XG4gICAgICAgICAgICBpZiAoZ2wgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInByb2dyYW0gZWxlbWVudCBpcyBhIHByb2dyYW0gYnV0IGNvbnRleHQgaXMgdW5kZWZpbmVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChfYSA9IHRoaXMudG90YWxOZWVkcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRpbWVVbmlmb3JtKSB7XG4gICAgICAgICAgICAgICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGltZUxvYyA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtRWxlbWVudCwgXCJ1VGltZVwiKTtcbiAgICAgICAgICAgICAgICBpZiAodGltZUxvYyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb3VsZCBub3QgZ2V0IHRoZSB0aW1lIHVuaWZvcm0gbG9jYXRpb25cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMudGltZUxvYyA9IHRpbWVMb2M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0VG90YWxOZWVkcygpIHtcbiAgICAgICAgLy8gZ28gdGhyb3VnaCBuZWVkcyBvZiBwcm9ncmFtIGxvb3BcbiAgICAgICAgaWYgKCEodGhpcy5wcm9ncmFtRWxlbWVudCBpbnN0YW5jZW9mIFdlYkdMUHJvZ3JhbSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGFsbE5lZWRzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHAgb2YgdGhpcy5wcm9ncmFtRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGFsbE5lZWRzLnB1c2gocC5nZXRUb3RhbE5lZWRzKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdXBkYXRlIG1lIG9uIGNoYW5nZSB0byBuZWVkc1xuICAgICAgICAgICAgcmV0dXJuIGFsbE5lZWRzLnJlZHVjZShleHBvcnRzLnVwZGF0ZU5lZWRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50b3RhbE5lZWRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRvdGFsIG5lZWRzIG9mIHdlYmdsIHByb2dyYW0gd2FzIHNvbWVob3cgdW5kZWZpbmVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRvdGFsTmVlZHM7XG4gICAgfVxuICAgIGRyYXcoZ2wsIHRleCwgZnJhbWVidWZmZXIsIHVuaWZvcm1Mb2NzLCBsYXN0LCB0aW1lKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yZXBlYXQubnVtOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0xhc3QgPSBpID09PSB0aGlzLnJlcGVhdC5udW0gLSAxO1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvZ3JhbUVsZW1lbnQgaW5zdGFuY2VvZiBXZWJHTFByb2dyYW0pIHtcbiAgICAgICAgICAgICAgICAvLyBlZmZlY3RzIGxpc3QgaXMgcG9wdWxhdGVkXG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ2wudXNlUHJvZ3JhbSh0aGlzLnByb2dyYW1FbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChfYSA9IHRoaXMudG90YWxOZWVkcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNjZW5lQnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGV4LnNjZW5lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJuZWVkcyBzY2VuZSBidWZmZXIsIGJ1dCBzY2VuZSB0ZXh0dXJlIGlzIHNvbWVob3cgdW5kZWZpbmVkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXguc2NlbmUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZWZmZWN0IG9mIHRoaXMuZWZmZWN0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWZmZWN0LmFwcGx5VW5pZm9ybXMoZ2wsIHVuaWZvcm1Mb2NzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoKF9iID0gdGhpcy50b3RhbE5lZWRzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudGltZVVuaWZvcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRpbWVMb2MgPT09IHVuZGVmaW5lZCB8fCB0aW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0aW1lIG9yIGxvY2F0aW9uIGlzIHVuZGVmaW5lZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGdsLnVuaWZvcm0xZih0aGlzLnRpbWVMb2MsIHRpbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChuZXdMYXN0ICYmIGxhc3QgJiYgdGhpcy5sYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGFyZSBvbiB0aGUgZmluYWwgcGFzcyBvZiB0aGUgZmluYWwgbG9vcCwgc28gZHJhdyBzY3JlZW4gYnlcbiAgICAgICAgICAgICAgICAgICAgLy8gc2V0dGluZyB0byB0aGUgZGVmYXVsdCBmcmFtZWJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgaGF2ZSB0byBib3VuY2UgYmV0d2VlbiB0d28gdGV4dHVyZXNcbiAgICAgICAgICAgICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVzZSB0aGUgZnJhbWVidWZmZXIgdG8gd3JpdGUgdG8gZnJvbnQgdGV4dHVyZVxuICAgICAgICAgICAgICAgICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRleC5mcm9udCwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGFsbG93cyB1cyB0byByZWFkIGZyb20gYHRleEJhY2tgXG4gICAgICAgICAgICAgICAgLy8gZGVmYXVsdCBzYW1wbGVyIGlzIDAsIHNvIGB1U2FtcGxlcmAgdW5pZm9ybSB3aWxsIGFsd2F5cyBzYW1wbGUgZnJvbSB0ZXh0dXJlIDBcbiAgICAgICAgICAgICAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwKTtcbiAgICAgICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXguYmFjayk7XG4gICAgICAgICAgICAgICAgW3RleC5iYWNrLCB0ZXguZnJvbnRdID0gW3RleC5mcm9udCwgdGV4LmJhY2tdO1xuICAgICAgICAgICAgICAgIC8vIGdvIGJhY2sgdG8gdGhlIGRlZmF1bHQgZnJhbWVidWZmZXIgb2JqZWN0XG4gICAgICAgICAgICAgICAgLy8gdXNlIG91ciBsYXN0IHByb2dyYW0gYXMgdGhlIGRyYXcgcHJvZ3JhbVxuICAgICAgICAgICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVTLCAwLCA2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlcGVhdC5mdW5jICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXBlYXQuZnVuYyhpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwIG9mIHRoaXMucHJvZ3JhbUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcC5kcmF3KGdsLCB0ZXgsIGZyYW1lYnVmZmVyLCB1bmlmb3JtTG9jcywgbmV3TGFzdCwgdGltZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5XZWJHTFByb2dyYW1Mb29wID0gV2ViR0xQcm9ncmFtTG9vcDtcbiIsIlwidXNlIHN0cmljdFwiXG5cbnZhciBjb21waWxlID0gcmVxdWlyZShcImN3aXNlLWNvbXBpbGVyXCIpXG5cbnZhciBFbXB0eVByb2MgPSB7XG4gIGJvZHk6IFwiXCIsXG4gIGFyZ3M6IFtdLFxuICB0aGlzVmFyczogW10sXG4gIGxvY2FsVmFyczogW11cbn1cblxuZnVuY3Rpb24gZml4dXAoeCkge1xuICBpZigheCkge1xuICAgIHJldHVybiBFbXB0eVByb2NcbiAgfVxuICBmb3IodmFyIGk9MDsgaTx4LmFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYSA9IHguYXJnc1tpXVxuICAgIGlmKGkgPT09IDApIHtcbiAgICAgIHguYXJnc1tpXSA9IHtuYW1lOiBhLCBsdmFsdWU6dHJ1ZSwgcnZhbHVlOiAhIXgucnZhbHVlLCBjb3VudDp4LmNvdW50fHwxIH1cbiAgICB9IGVsc2Uge1xuICAgICAgeC5hcmdzW2ldID0ge25hbWU6IGEsIGx2YWx1ZTpmYWxzZSwgcnZhbHVlOnRydWUsIGNvdW50OiAxfVxuICAgIH1cbiAgfVxuICBpZigheC50aGlzVmFycykge1xuICAgIHgudGhpc1ZhcnMgPSBbXVxuICB9XG4gIGlmKCF4LmxvY2FsVmFycykge1xuICAgIHgubG9jYWxWYXJzID0gW11cbiAgfVxuICByZXR1cm4geFxufVxuXG5mdW5jdGlvbiBwY29tcGlsZSh1c2VyX2FyZ3MpIHtcbiAgcmV0dXJuIGNvbXBpbGUoe1xuICAgIGFyZ3M6ICAgICB1c2VyX2FyZ3MuYXJncyxcbiAgICBwcmU6ICAgICAgZml4dXAodXNlcl9hcmdzLnByZSksXG4gICAgYm9keTogICAgIGZpeHVwKHVzZXJfYXJncy5ib2R5KSxcbiAgICBwb3N0OiAgICAgZml4dXAodXNlcl9hcmdzLnByb2MpLFxuICAgIGZ1bmNOYW1lOiB1c2VyX2FyZ3MuZnVuY05hbWVcbiAgfSlcbn1cblxuZnVuY3Rpb24gbWFrZU9wKHVzZXJfYXJncykge1xuICB2YXIgYXJncyA9IFtdXG4gIGZvcih2YXIgaT0wOyBpPHVzZXJfYXJncy5hcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgYXJncy5wdXNoKFwiYVwiK2kpXG4gIH1cbiAgdmFyIHdyYXBwZXIgPSBuZXcgRnVuY3Rpb24oXCJQXCIsIFtcbiAgICBcInJldHVybiBmdW5jdGlvbiBcIiwgdXNlcl9hcmdzLmZ1bmNOYW1lLCBcIl9uZGFycmF5b3BzKFwiLCBhcmdzLmpvaW4oXCIsXCIpLCBcIikge1AoXCIsIGFyZ3Muam9pbihcIixcIiksIFwiKTtyZXR1cm4gYTB9XCJcbiAgXS5qb2luKFwiXCIpKVxuICByZXR1cm4gd3JhcHBlcihwY29tcGlsZSh1c2VyX2FyZ3MpKVxufVxuXG52YXIgYXNzaWduX29wcyA9IHtcbiAgYWRkOiAgXCIrXCIsXG4gIHN1YjogIFwiLVwiLFxuICBtdWw6ICBcIipcIixcbiAgZGl2OiAgXCIvXCIsXG4gIG1vZDogIFwiJVwiLFxuICBiYW5kOiBcIiZcIixcbiAgYm9yOiAgXCJ8XCIsXG4gIGJ4b3I6IFwiXlwiLFxuICBsc2hpZnQ6IFwiPDxcIixcbiAgcnNoaWZ0OiBcIj4+XCIsXG4gIHJyc2hpZnQ6IFwiPj4+XCJcbn1cbjsoZnVuY3Rpb24oKXtcbiAgZm9yKHZhciBpZCBpbiBhc3NpZ25fb3BzKSB7XG4gICAgdmFyIG9wID0gYXNzaWduX29wc1tpZF1cbiAgICBleHBvcnRzW2lkXSA9IG1ha2VPcCh7XG4gICAgICBhcmdzOiBbXCJhcnJheVwiLFwiYXJyYXlcIixcImFycmF5XCJdLFxuICAgICAgYm9keToge2FyZ3M6W1wiYVwiLFwiYlwiLFwiY1wiXSxcbiAgICAgICAgICAgICBib2R5OiBcImE9YlwiK29wK1wiY1wifSxcbiAgICAgIGZ1bmNOYW1lOiBpZFxuICAgIH0pXG4gICAgZXhwb3J0c1tpZCtcImVxXCJdID0gbWFrZU9wKHtcbiAgICAgIGFyZ3M6IFtcImFycmF5XCIsXCJhcnJheVwiXSxcbiAgICAgIGJvZHk6IHthcmdzOltcImFcIixcImJcIl0sXG4gICAgICAgICAgICAgYm9keTpcImFcIitvcCtcIj1iXCJ9LFxuICAgICAgcnZhbHVlOiB0cnVlLFxuICAgICAgZnVuY05hbWU6IGlkK1wiZXFcIlxuICAgIH0pXG4gICAgZXhwb3J0c1tpZCtcInNcIl0gPSBtYWtlT3Aoe1xuICAgICAgYXJnczogW1wiYXJyYXlcIiwgXCJhcnJheVwiLCBcInNjYWxhclwiXSxcbiAgICAgIGJvZHk6IHthcmdzOltcImFcIixcImJcIixcInNcIl0sXG4gICAgICAgICAgICAgYm9keTpcImE9YlwiK29wK1wic1wifSxcbiAgICAgIGZ1bmNOYW1lOiBpZCtcInNcIlxuICAgIH0pXG4gICAgZXhwb3J0c1tpZCtcInNlcVwiXSA9IG1ha2VPcCh7XG4gICAgICBhcmdzOiBbXCJhcnJheVwiLFwic2NhbGFyXCJdLFxuICAgICAgYm9keToge2FyZ3M6W1wiYVwiLFwic1wiXSxcbiAgICAgICAgICAgICBib2R5OlwiYVwiK29wK1wiPXNcIn0sXG4gICAgICBydmFsdWU6IHRydWUsXG4gICAgICBmdW5jTmFtZTogaWQrXCJzZXFcIlxuICAgIH0pXG4gIH1cbn0pKCk7XG5cbnZhciB1bmFyeV9vcHMgPSB7XG4gIG5vdDogXCIhXCIsXG4gIGJub3Q6IFwiflwiLFxuICBuZWc6IFwiLVwiLFxuICByZWNpcDogXCIxLjAvXCJcbn1cbjsoZnVuY3Rpb24oKXtcbiAgZm9yKHZhciBpZCBpbiB1bmFyeV9vcHMpIHtcbiAgICB2YXIgb3AgPSB1bmFyeV9vcHNbaWRdXG4gICAgZXhwb3J0c1tpZF0gPSBtYWtlT3Aoe1xuICAgICAgYXJnczogW1wiYXJyYXlcIiwgXCJhcnJheVwiXSxcbiAgICAgIGJvZHk6IHthcmdzOltcImFcIixcImJcIl0sXG4gICAgICAgICAgICAgYm9keTpcImE9XCIrb3ArXCJiXCJ9LFxuICAgICAgZnVuY05hbWU6IGlkXG4gICAgfSlcbiAgICBleHBvcnRzW2lkK1wiZXFcIl0gPSBtYWtlT3Aoe1xuICAgICAgYXJnczogW1wiYXJyYXlcIl0sXG4gICAgICBib2R5OiB7YXJnczpbXCJhXCJdLFxuICAgICAgICAgICAgIGJvZHk6XCJhPVwiK29wK1wiYVwifSxcbiAgICAgIHJ2YWx1ZTogdHJ1ZSxcbiAgICAgIGNvdW50OiAyLFxuICAgICAgZnVuY05hbWU6IGlkK1wiZXFcIlxuICAgIH0pXG4gIH1cbn0pKCk7XG5cbnZhciBiaW5hcnlfb3BzID0ge1xuICBhbmQ6IFwiJiZcIixcbiAgb3I6IFwifHxcIixcbiAgZXE6IFwiPT09XCIsXG4gIG5lcTogXCIhPT1cIixcbiAgbHQ6IFwiPFwiLFxuICBndDogXCI+XCIsXG4gIGxlcTogXCI8PVwiLFxuICBnZXE6IFwiPj1cIlxufVxuOyhmdW5jdGlvbigpIHtcbiAgZm9yKHZhciBpZCBpbiBiaW5hcnlfb3BzKSB7XG4gICAgdmFyIG9wID0gYmluYXJ5X29wc1tpZF1cbiAgICBleHBvcnRzW2lkXSA9IG1ha2VPcCh7XG4gICAgICBhcmdzOiBbXCJhcnJheVwiLFwiYXJyYXlcIixcImFycmF5XCJdLFxuICAgICAgYm9keToge2FyZ3M6W1wiYVwiLCBcImJcIiwgXCJjXCJdLFxuICAgICAgICAgICAgIGJvZHk6XCJhPWJcIitvcCtcImNcIn0sXG4gICAgICBmdW5jTmFtZTogaWRcbiAgICB9KVxuICAgIGV4cG9ydHNbaWQrXCJzXCJdID0gbWFrZU9wKHtcbiAgICAgIGFyZ3M6IFtcImFycmF5XCIsXCJhcnJheVwiLFwic2NhbGFyXCJdLFxuICAgICAgYm9keToge2FyZ3M6W1wiYVwiLCBcImJcIiwgXCJzXCJdLFxuICAgICAgICAgICAgIGJvZHk6XCJhPWJcIitvcCtcInNcIn0sXG4gICAgICBmdW5jTmFtZTogaWQrXCJzXCJcbiAgICB9KVxuICAgIGV4cG9ydHNbaWQrXCJlcVwiXSA9IG1ha2VPcCh7XG4gICAgICBhcmdzOiBbXCJhcnJheVwiLCBcImFycmF5XCJdLFxuICAgICAgYm9keToge2FyZ3M6W1wiYVwiLCBcImJcIl0sXG4gICAgICAgICAgICAgYm9keTpcImE9YVwiK29wK1wiYlwifSxcbiAgICAgIHJ2YWx1ZTp0cnVlLFxuICAgICAgY291bnQ6MixcbiAgICAgIGZ1bmNOYW1lOiBpZCtcImVxXCJcbiAgICB9KVxuICAgIGV4cG9ydHNbaWQrXCJzZXFcIl0gPSBtYWtlT3Aoe1xuICAgICAgYXJnczogW1wiYXJyYXlcIiwgXCJzY2FsYXJcIl0sXG4gICAgICBib2R5OiB7YXJnczpbXCJhXCIsXCJzXCJdLFxuICAgICAgICAgICAgIGJvZHk6XCJhPWFcIitvcCtcInNcIn0sXG4gICAgICBydmFsdWU6dHJ1ZSxcbiAgICAgIGNvdW50OjIsXG4gICAgICBmdW5jTmFtZTogaWQrXCJzZXFcIlxuICAgIH0pXG4gIH1cbn0pKCk7XG5cbnZhciBtYXRoX3VuYXJ5ID0gW1xuICBcImFic1wiLFxuICBcImFjb3NcIixcbiAgXCJhc2luXCIsXG4gIFwiYXRhblwiLFxuICBcImNlaWxcIixcbiAgXCJjb3NcIixcbiAgXCJleHBcIixcbiAgXCJmbG9vclwiLFxuICBcImxvZ1wiLFxuICBcInJvdW5kXCIsXG4gIFwic2luXCIsXG4gIFwic3FydFwiLFxuICBcInRhblwiXG5dXG47KGZ1bmN0aW9uKCkge1xuICBmb3IodmFyIGk9MDsgaTxtYXRoX3VuYXJ5Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGYgPSBtYXRoX3VuYXJ5W2ldXG4gICAgZXhwb3J0c1tmXSA9IG1ha2VPcCh7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtcImFycmF5XCIsIFwiYXJyYXlcIl0sXG4gICAgICAgICAgICAgICAgICAgIHByZToge2FyZ3M6W10sIGJvZHk6XCJ0aGlzX2Y9TWF0aC5cIitmLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgICBib2R5OiB7YXJnczpbXCJhXCIsXCJiXCJdLCBib2R5OlwiYT10aGlzX2YoYilcIiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY05hbWU6IGZcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgZXhwb3J0c1tmK1wiZXFcIl0gPSBtYWtlT3Aoe1xuICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtcImFycmF5XCJdLFxuICAgICAgICAgICAgICAgICAgICAgIHByZToge2FyZ3M6W10sIGJvZHk6XCJ0aGlzX2Y9TWF0aC5cIitmLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IHthcmdzOiBbXCJhXCJdLCBib2R5OlwiYT10aGlzX2YoYSlcIiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgICAgICBydmFsdWU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgY291bnQ6IDIsXG4gICAgICAgICAgICAgICAgICAgICAgZnVuY05hbWU6IGYrXCJlcVwiXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gIH1cbn0pKCk7XG5cbnZhciBtYXRoX2NvbW0gPSBbXG4gIFwibWF4XCIsXG4gIFwibWluXCIsXG4gIFwiYXRhbjJcIixcbiAgXCJwb3dcIlxuXVxuOyhmdW5jdGlvbigpe1xuICBmb3IodmFyIGk9MDsgaTxtYXRoX2NvbW0ubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgZj0gbWF0aF9jb21tW2ldXG4gICAgZXhwb3J0c1tmXSA9IG1ha2VPcCh7XG4gICAgICAgICAgICAgICAgICBhcmdzOltcImFycmF5XCIsIFwiYXJyYXlcIiwgXCJhcnJheVwiXSxcbiAgICAgICAgICAgICAgICAgIHByZToge2FyZ3M6W10sIGJvZHk6XCJ0aGlzX2Y9TWF0aC5cIitmLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgYm9keToge2FyZ3M6W1wiYVwiLFwiYlwiLFwiY1wiXSwgYm9keTpcImE9dGhpc19mKGIsYylcIiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBmXG4gICAgICAgICAgICAgICAgfSlcbiAgICBleHBvcnRzW2YrXCJzXCJdID0gbWFrZU9wKHtcbiAgICAgICAgICAgICAgICAgIGFyZ3M6W1wiYXJyYXlcIiwgXCJhcnJheVwiLCBcInNjYWxhclwiXSxcbiAgICAgICAgICAgICAgICAgIHByZToge2FyZ3M6W10sIGJvZHk6XCJ0aGlzX2Y9TWF0aC5cIitmLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgYm9keToge2FyZ3M6W1wiYVwiLFwiYlwiLFwiY1wiXSwgYm9keTpcImE9dGhpc19mKGIsYylcIiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBmK1wic1wiXG4gICAgICAgICAgICAgICAgICB9KVxuICAgIGV4cG9ydHNbZitcImVxXCJdID0gbWFrZU9wKHsgYXJnczpbXCJhcnJheVwiLCBcImFycmF5XCJdLFxuICAgICAgICAgICAgICAgICAgcHJlOiB7YXJnczpbXSwgYm9keTpcInRoaXNfZj1NYXRoLlwiK2YsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICBib2R5OiB7YXJnczpbXCJhXCIsXCJiXCJdLCBib2R5OlwiYT10aGlzX2YoYSxiKVwiLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgcnZhbHVlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgY291bnQ6IDIsXG4gICAgICAgICAgICAgICAgICBmdW5jTmFtZTogZitcImVxXCJcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgZXhwb3J0c1tmK1wic2VxXCJdID0gbWFrZU9wKHsgYXJnczpbXCJhcnJheVwiLCBcInNjYWxhclwiXSxcbiAgICAgICAgICAgICAgICAgIHByZToge2FyZ3M6W10sIGJvZHk6XCJ0aGlzX2Y9TWF0aC5cIitmLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgYm9keToge2FyZ3M6W1wiYVwiLFwiYlwiXSwgYm9keTpcImE9dGhpc19mKGEsYilcIiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgIHJ2YWx1ZTp0cnVlLFxuICAgICAgICAgICAgICAgICAgY291bnQ6MixcbiAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBmK1wic2VxXCJcbiAgICAgICAgICAgICAgICAgIH0pXG4gIH1cbn0pKCk7XG5cbnZhciBtYXRoX25vbmNvbW0gPSBbXG4gIFwiYXRhbjJcIixcbiAgXCJwb3dcIlxuXVxuOyhmdW5jdGlvbigpe1xuICBmb3IodmFyIGk9MDsgaTxtYXRoX25vbmNvbW0ubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgZj0gbWF0aF9ub25jb21tW2ldXG4gICAgZXhwb3J0c1tmK1wib3BcIl0gPSBtYWtlT3Aoe1xuICAgICAgICAgICAgICAgICAgYXJnczpbXCJhcnJheVwiLCBcImFycmF5XCIsIFwiYXJyYXlcIl0sXG4gICAgICAgICAgICAgICAgICBwcmU6IHthcmdzOltdLCBib2R5OlwidGhpc19mPU1hdGguXCIrZiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgIGJvZHk6IHthcmdzOltcImFcIixcImJcIixcImNcIl0sIGJvZHk6XCJhPXRoaXNfZihjLGIpXCIsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICBmdW5jTmFtZTogZitcIm9wXCJcbiAgICAgICAgICAgICAgICB9KVxuICAgIGV4cG9ydHNbZitcIm9wc1wiXSA9IG1ha2VPcCh7XG4gICAgICAgICAgICAgICAgICBhcmdzOltcImFycmF5XCIsIFwiYXJyYXlcIiwgXCJzY2FsYXJcIl0sXG4gICAgICAgICAgICAgICAgICBwcmU6IHthcmdzOltdLCBib2R5OlwidGhpc19mPU1hdGguXCIrZiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgIGJvZHk6IHthcmdzOltcImFcIixcImJcIixcImNcIl0sIGJvZHk6XCJhPXRoaXNfZihjLGIpXCIsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICBmdW5jTmFtZTogZitcIm9wc1wiXG4gICAgICAgICAgICAgICAgICB9KVxuICAgIGV4cG9ydHNbZitcIm9wZXFcIl0gPSBtYWtlT3AoeyBhcmdzOltcImFycmF5XCIsIFwiYXJyYXlcIl0sXG4gICAgICAgICAgICAgICAgICBwcmU6IHthcmdzOltdLCBib2R5OlwidGhpc19mPU1hdGguXCIrZiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgIGJvZHk6IHthcmdzOltcImFcIixcImJcIl0sIGJvZHk6XCJhPXRoaXNfZihiLGEpXCIsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICBydmFsdWU6IHRydWUsXG4gICAgICAgICAgICAgICAgICBjb3VudDogMixcbiAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBmK1wib3BlcVwiXG4gICAgICAgICAgICAgICAgICB9KVxuICAgIGV4cG9ydHNbZitcIm9wc2VxXCJdID0gbWFrZU9wKHsgYXJnczpbXCJhcnJheVwiLCBcInNjYWxhclwiXSxcbiAgICAgICAgICAgICAgICAgIHByZToge2FyZ3M6W10sIGJvZHk6XCJ0aGlzX2Y9TWF0aC5cIitmLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgYm9keToge2FyZ3M6W1wiYVwiLFwiYlwiXSwgYm9keTpcImE9dGhpc19mKGIsYSlcIiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgIHJ2YWx1ZTp0cnVlLFxuICAgICAgICAgICAgICAgICAgY291bnQ6MixcbiAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBmK1wib3BzZXFcIlxuICAgICAgICAgICAgICAgICAgfSlcbiAgfVxufSkoKTtcblxuZXhwb3J0cy5hbnkgPSBjb21waWxlKHtcbiAgYXJnczpbXCJhcnJheVwiXSxcbiAgcHJlOiBFbXB0eVByb2MsXG4gIGJvZHk6IHthcmdzOlt7bmFtZTpcImFcIiwgbHZhbHVlOmZhbHNlLCBydmFsdWU6dHJ1ZSwgY291bnQ6MX1dLCBib2R5OiBcImlmKGEpe3JldHVybiB0cnVlfVwiLCBsb2NhbFZhcnM6IFtdLCB0aGlzVmFyczogW119LFxuICBwb3N0OiB7YXJnczpbXSwgbG9jYWxWYXJzOltdLCB0aGlzVmFyczpbXSwgYm9keTpcInJldHVybiBmYWxzZVwifSxcbiAgZnVuY05hbWU6IFwiYW55XCJcbn0pXG5cbmV4cG9ydHMuYWxsID0gY29tcGlsZSh7XG4gIGFyZ3M6W1wiYXJyYXlcIl0sXG4gIHByZTogRW1wdHlQcm9jLFxuICBib2R5OiB7YXJnczpbe25hbWU6XCJ4XCIsIGx2YWx1ZTpmYWxzZSwgcnZhbHVlOnRydWUsIGNvdW50OjF9XSwgYm9keTogXCJpZigheCl7cmV0dXJuIGZhbHNlfVwiLCBsb2NhbFZhcnM6IFtdLCB0aGlzVmFyczogW119LFxuICBwb3N0OiB7YXJnczpbXSwgbG9jYWxWYXJzOltdLCB0aGlzVmFyczpbXSwgYm9keTpcInJldHVybiB0cnVlXCJ9LFxuICBmdW5jTmFtZTogXCJhbGxcIlxufSlcblxuZXhwb3J0cy5zdW0gPSBjb21waWxlKHtcbiAgYXJnczpbXCJhcnJheVwiXSxcbiAgcHJlOiB7YXJnczpbXSwgbG9jYWxWYXJzOltdLCB0aGlzVmFyczpbXCJ0aGlzX3NcIl0sIGJvZHk6XCJ0aGlzX3M9MFwifSxcbiAgYm9keToge2FyZ3M6W3tuYW1lOlwiYVwiLCBsdmFsdWU6ZmFsc2UsIHJ2YWx1ZTp0cnVlLCBjb3VudDoxfV0sIGJvZHk6IFwidGhpc19zKz1hXCIsIGxvY2FsVmFyczogW10sIHRoaXNWYXJzOiBbXCJ0aGlzX3NcIl19LFxuICBwb3N0OiB7YXJnczpbXSwgbG9jYWxWYXJzOltdLCB0aGlzVmFyczpbXCJ0aGlzX3NcIl0sIGJvZHk6XCJyZXR1cm4gdGhpc19zXCJ9LFxuICBmdW5jTmFtZTogXCJzdW1cIlxufSlcblxuZXhwb3J0cy5wcm9kID0gY29tcGlsZSh7XG4gIGFyZ3M6W1wiYXJyYXlcIl0sXG4gIHByZToge2FyZ3M6W10sIGxvY2FsVmFyczpbXSwgdGhpc1ZhcnM6W1widGhpc19zXCJdLCBib2R5OlwidGhpc19zPTFcIn0sXG4gIGJvZHk6IHthcmdzOlt7bmFtZTpcImFcIiwgbHZhbHVlOmZhbHNlLCBydmFsdWU6dHJ1ZSwgY291bnQ6MX1dLCBib2R5OiBcInRoaXNfcyo9YVwiLCBsb2NhbFZhcnM6IFtdLCB0aGlzVmFyczogW1widGhpc19zXCJdfSxcbiAgcG9zdDoge2FyZ3M6W10sIGxvY2FsVmFyczpbXSwgdGhpc1ZhcnM6W1widGhpc19zXCJdLCBib2R5OlwicmV0dXJuIHRoaXNfc1wifSxcbiAgZnVuY05hbWU6IFwicHJvZFwiXG59KVxuXG5leHBvcnRzLm5vcm0yc3F1YXJlZCA9IGNvbXBpbGUoe1xuICBhcmdzOltcImFycmF5XCJdLFxuICBwcmU6IHthcmdzOltdLCBsb2NhbFZhcnM6W10sIHRoaXNWYXJzOltcInRoaXNfc1wiXSwgYm9keTpcInRoaXNfcz0wXCJ9LFxuICBib2R5OiB7YXJnczpbe25hbWU6XCJhXCIsIGx2YWx1ZTpmYWxzZSwgcnZhbHVlOnRydWUsIGNvdW50OjJ9XSwgYm9keTogXCJ0aGlzX3MrPWEqYVwiLCBsb2NhbFZhcnM6IFtdLCB0aGlzVmFyczogW1widGhpc19zXCJdfSxcbiAgcG9zdDoge2FyZ3M6W10sIGxvY2FsVmFyczpbXSwgdGhpc1ZhcnM6W1widGhpc19zXCJdLCBib2R5OlwicmV0dXJuIHRoaXNfc1wifSxcbiAgZnVuY05hbWU6IFwibm9ybTJzcXVhcmVkXCJcbn0pXG4gIFxuZXhwb3J0cy5ub3JtMiA9IGNvbXBpbGUoe1xuICBhcmdzOltcImFycmF5XCJdLFxuICBwcmU6IHthcmdzOltdLCBsb2NhbFZhcnM6W10sIHRoaXNWYXJzOltcInRoaXNfc1wiXSwgYm9keTpcInRoaXNfcz0wXCJ9LFxuICBib2R5OiB7YXJnczpbe25hbWU6XCJhXCIsIGx2YWx1ZTpmYWxzZSwgcnZhbHVlOnRydWUsIGNvdW50OjJ9XSwgYm9keTogXCJ0aGlzX3MrPWEqYVwiLCBsb2NhbFZhcnM6IFtdLCB0aGlzVmFyczogW1widGhpc19zXCJdfSxcbiAgcG9zdDoge2FyZ3M6W10sIGxvY2FsVmFyczpbXSwgdGhpc1ZhcnM6W1widGhpc19zXCJdLCBib2R5OlwicmV0dXJuIE1hdGguc3FydCh0aGlzX3MpXCJ9LFxuICBmdW5jTmFtZTogXCJub3JtMlwiXG59KVxuICBcblxuZXhwb3J0cy5ub3JtaW5mID0gY29tcGlsZSh7XG4gIGFyZ3M6W1wiYXJyYXlcIl0sXG4gIHByZToge2FyZ3M6W10sIGxvY2FsVmFyczpbXSwgdGhpc1ZhcnM6W1widGhpc19zXCJdLCBib2R5OlwidGhpc19zPTBcIn0sXG4gIGJvZHk6IHthcmdzOlt7bmFtZTpcImFcIiwgbHZhbHVlOmZhbHNlLCBydmFsdWU6dHJ1ZSwgY291bnQ6NH1dLCBib2R5OlwiaWYoLWE+dGhpc19zKXt0aGlzX3M9LWF9ZWxzZSBpZihhPnRoaXNfcyl7dGhpc19zPWF9XCIsIGxvY2FsVmFyczogW10sIHRoaXNWYXJzOiBbXCJ0aGlzX3NcIl19LFxuICBwb3N0OiB7YXJnczpbXSwgbG9jYWxWYXJzOltdLCB0aGlzVmFyczpbXCJ0aGlzX3NcIl0sIGJvZHk6XCJyZXR1cm4gdGhpc19zXCJ9LFxuICBmdW5jTmFtZTogXCJub3JtaW5mXCJcbn0pXG5cbmV4cG9ydHMubm9ybTEgPSBjb21waWxlKHtcbiAgYXJnczpbXCJhcnJheVwiXSxcbiAgcHJlOiB7YXJnczpbXSwgbG9jYWxWYXJzOltdLCB0aGlzVmFyczpbXCJ0aGlzX3NcIl0sIGJvZHk6XCJ0aGlzX3M9MFwifSxcbiAgYm9keToge2FyZ3M6W3tuYW1lOlwiYVwiLCBsdmFsdWU6ZmFsc2UsIHJ2YWx1ZTp0cnVlLCBjb3VudDozfV0sIGJvZHk6IFwidGhpc19zKz1hPDA/LWE6YVwiLCBsb2NhbFZhcnM6IFtdLCB0aGlzVmFyczogW1widGhpc19zXCJdfSxcbiAgcG9zdDoge2FyZ3M6W10sIGxvY2FsVmFyczpbXSwgdGhpc1ZhcnM6W1widGhpc19zXCJdLCBib2R5OlwicmV0dXJuIHRoaXNfc1wifSxcbiAgZnVuY05hbWU6IFwibm9ybTFcIlxufSlcblxuZXhwb3J0cy5zdXAgPSBjb21waWxlKHtcbiAgYXJnczogWyBcImFycmF5XCIgXSxcbiAgcHJlOlxuICAgeyBib2R5OiBcInRoaXNfaD0tSW5maW5pdHlcIixcbiAgICAgYXJnczogW10sXG4gICAgIHRoaXNWYXJzOiBbIFwidGhpc19oXCIgXSxcbiAgICAgbG9jYWxWYXJzOiBbXSB9LFxuICBib2R5OlxuICAgeyBib2R5OiBcImlmKF9pbmxpbmVfMV9hcmcwXz50aGlzX2gpdGhpc19oPV9pbmxpbmVfMV9hcmcwX1wiLFxuICAgICBhcmdzOiBbe1wibmFtZVwiOlwiX2lubGluZV8xX2FyZzBfXCIsXCJsdmFsdWVcIjpmYWxzZSxcInJ2YWx1ZVwiOnRydWUsXCJjb3VudFwiOjJ9IF0sXG4gICAgIHRoaXNWYXJzOiBbIFwidGhpc19oXCIgXSxcbiAgICAgbG9jYWxWYXJzOiBbXSB9LFxuICBwb3N0OlxuICAgeyBib2R5OiBcInJldHVybiB0aGlzX2hcIixcbiAgICAgYXJnczogW10sXG4gICAgIHRoaXNWYXJzOiBbIFwidGhpc19oXCIgXSxcbiAgICAgbG9jYWxWYXJzOiBbXSB9XG4gfSlcblxuZXhwb3J0cy5pbmYgPSBjb21waWxlKHtcbiAgYXJnczogWyBcImFycmF5XCIgXSxcbiAgcHJlOlxuICAgeyBib2R5OiBcInRoaXNfaD1JbmZpbml0eVwiLFxuICAgICBhcmdzOiBbXSxcbiAgICAgdGhpc1ZhcnM6IFsgXCJ0aGlzX2hcIiBdLFxuICAgICBsb2NhbFZhcnM6IFtdIH0sXG4gIGJvZHk6XG4gICB7IGJvZHk6IFwiaWYoX2lubGluZV8xX2FyZzBfPHRoaXNfaCl0aGlzX2g9X2lubGluZV8xX2FyZzBfXCIsXG4gICAgIGFyZ3M6IFt7XCJuYW1lXCI6XCJfaW5saW5lXzFfYXJnMF9cIixcImx2YWx1ZVwiOmZhbHNlLFwicnZhbHVlXCI6dHJ1ZSxcImNvdW50XCI6Mn0gXSxcbiAgICAgdGhpc1ZhcnM6IFsgXCJ0aGlzX2hcIiBdLFxuICAgICBsb2NhbFZhcnM6IFtdIH0sXG4gIHBvc3Q6XG4gICB7IGJvZHk6IFwicmV0dXJuIHRoaXNfaFwiLFxuICAgICBhcmdzOiBbXSxcbiAgICAgdGhpc1ZhcnM6IFsgXCJ0aGlzX2hcIiBdLFxuICAgICBsb2NhbFZhcnM6IFtdIH1cbiB9KVxuXG5leHBvcnRzLmFyZ21pbiA9IGNvbXBpbGUoe1xuICBhcmdzOltcImluZGV4XCIsXCJhcnJheVwiLFwic2hhcGVcIl0sXG4gIHByZTp7XG4gICAgYm9keTpcInt0aGlzX3Y9SW5maW5pdHk7dGhpc19pPV9pbmxpbmVfMF9hcmcyXy5zbGljZSgwKX1cIixcbiAgICBhcmdzOltcbiAgICAgIHtuYW1lOlwiX2lubGluZV8wX2FyZzBfXCIsbHZhbHVlOmZhbHNlLHJ2YWx1ZTpmYWxzZSxjb3VudDowfSxcbiAgICAgIHtuYW1lOlwiX2lubGluZV8wX2FyZzFfXCIsbHZhbHVlOmZhbHNlLHJ2YWx1ZTpmYWxzZSxjb3VudDowfSxcbiAgICAgIHtuYW1lOlwiX2lubGluZV8wX2FyZzJfXCIsbHZhbHVlOmZhbHNlLHJ2YWx1ZTp0cnVlLGNvdW50OjF9XG4gICAgICBdLFxuICAgIHRoaXNWYXJzOltcInRoaXNfaVwiLFwidGhpc192XCJdLFxuICAgIGxvY2FsVmFyczpbXX0sXG4gIGJvZHk6e1xuICAgIGJvZHk6XCJ7aWYoX2lubGluZV8xX2FyZzFfPHRoaXNfdil7dGhpc192PV9pbmxpbmVfMV9hcmcxXztmb3IodmFyIF9pbmxpbmVfMV9rPTA7X2lubGluZV8xX2s8X2lubGluZV8xX2FyZzBfLmxlbmd0aDsrK19pbmxpbmVfMV9rKXt0aGlzX2lbX2lubGluZV8xX2tdPV9pbmxpbmVfMV9hcmcwX1tfaW5saW5lXzFfa119fX1cIixcbiAgICBhcmdzOltcbiAgICAgIHtuYW1lOlwiX2lubGluZV8xX2FyZzBfXCIsbHZhbHVlOmZhbHNlLHJ2YWx1ZTp0cnVlLGNvdW50OjJ9LFxuICAgICAge25hbWU6XCJfaW5saW5lXzFfYXJnMV9cIixsdmFsdWU6ZmFsc2UscnZhbHVlOnRydWUsY291bnQ6Mn1dLFxuICAgIHRoaXNWYXJzOltcInRoaXNfaVwiLFwidGhpc192XCJdLFxuICAgIGxvY2FsVmFyczpbXCJfaW5saW5lXzFfa1wiXX0sXG4gIHBvc3Q6e1xuICAgIGJvZHk6XCJ7cmV0dXJuIHRoaXNfaX1cIixcbiAgICBhcmdzOltdLFxuICAgIHRoaXNWYXJzOltcInRoaXNfaVwiXSxcbiAgICBsb2NhbFZhcnM6W119XG59KVxuXG5leHBvcnRzLmFyZ21heCA9IGNvbXBpbGUoe1xuICBhcmdzOltcImluZGV4XCIsXCJhcnJheVwiLFwic2hhcGVcIl0sXG4gIHByZTp7XG4gICAgYm9keTpcInt0aGlzX3Y9LUluZmluaXR5O3RoaXNfaT1faW5saW5lXzBfYXJnMl8uc2xpY2UoMCl9XCIsXG4gICAgYXJnczpbXG4gICAgICB7bmFtZTpcIl9pbmxpbmVfMF9hcmcwX1wiLGx2YWx1ZTpmYWxzZSxydmFsdWU6ZmFsc2UsY291bnQ6MH0sXG4gICAgICB7bmFtZTpcIl9pbmxpbmVfMF9hcmcxX1wiLGx2YWx1ZTpmYWxzZSxydmFsdWU6ZmFsc2UsY291bnQ6MH0sXG4gICAgICB7bmFtZTpcIl9pbmxpbmVfMF9hcmcyX1wiLGx2YWx1ZTpmYWxzZSxydmFsdWU6dHJ1ZSxjb3VudDoxfVxuICAgICAgXSxcbiAgICB0aGlzVmFyczpbXCJ0aGlzX2lcIixcInRoaXNfdlwiXSxcbiAgICBsb2NhbFZhcnM6W119LFxuICBib2R5OntcbiAgICBib2R5Olwie2lmKF9pbmxpbmVfMV9hcmcxXz50aGlzX3Ype3RoaXNfdj1faW5saW5lXzFfYXJnMV87Zm9yKHZhciBfaW5saW5lXzFfaz0wO19pbmxpbmVfMV9rPF9pbmxpbmVfMV9hcmcwXy5sZW5ndGg7KytfaW5saW5lXzFfayl7dGhpc19pW19pbmxpbmVfMV9rXT1faW5saW5lXzFfYXJnMF9bX2lubGluZV8xX2tdfX19XCIsXG4gICAgYXJnczpbXG4gICAgICB7bmFtZTpcIl9pbmxpbmVfMV9hcmcwX1wiLGx2YWx1ZTpmYWxzZSxydmFsdWU6dHJ1ZSxjb3VudDoyfSxcbiAgICAgIHtuYW1lOlwiX2lubGluZV8xX2FyZzFfXCIsbHZhbHVlOmZhbHNlLHJ2YWx1ZTp0cnVlLGNvdW50OjJ9XSxcbiAgICB0aGlzVmFyczpbXCJ0aGlzX2lcIixcInRoaXNfdlwiXSxcbiAgICBsb2NhbFZhcnM6W1wiX2lubGluZV8xX2tcIl19LFxuICBwb3N0OntcbiAgICBib2R5Olwie3JldHVybiB0aGlzX2l9XCIsXG4gICAgYXJnczpbXSxcbiAgICB0aGlzVmFyczpbXCJ0aGlzX2lcIl0sXG4gICAgbG9jYWxWYXJzOltdfVxufSkgIFxuXG5leHBvcnRzLnJhbmRvbSA9IG1ha2VPcCh7XG4gIGFyZ3M6IFtcImFycmF5XCJdLFxuICBwcmU6IHthcmdzOltdLCBib2R5OlwidGhpc19mPU1hdGgucmFuZG9tXCIsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gIGJvZHk6IHthcmdzOiBbXCJhXCJdLCBib2R5OlwiYT10aGlzX2YoKVwiLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICBmdW5jTmFtZTogXCJyYW5kb21cIlxufSlcblxuZXhwb3J0cy5hc3NpZ24gPSBtYWtlT3Aoe1xuICBhcmdzOltcImFycmF5XCIsIFwiYXJyYXlcIl0sXG4gIGJvZHk6IHthcmdzOltcImFcIiwgXCJiXCJdLCBib2R5OlwiYT1iXCJ9LFxuICBmdW5jTmFtZTogXCJhc3NpZ25cIiB9KVxuXG5leHBvcnRzLmFzc2lnbnMgPSBtYWtlT3Aoe1xuICBhcmdzOltcImFycmF5XCIsIFwic2NhbGFyXCJdLFxuICBib2R5OiB7YXJnczpbXCJhXCIsIFwiYlwiXSwgYm9keTpcImE9YlwifSxcbiAgZnVuY05hbWU6IFwiYXNzaWduc1wiIH0pXG5cblxuZXhwb3J0cy5lcXVhbHMgPSBjb21waWxlKHtcbiAgYXJnczpbXCJhcnJheVwiLCBcImFycmF5XCJdLFxuICBwcmU6IEVtcHR5UHJvYyxcbiAgYm9keToge2FyZ3M6W3tuYW1lOlwieFwiLCBsdmFsdWU6ZmFsc2UsIHJ2YWx1ZTp0cnVlLCBjb3VudDoxfSxcbiAgICAgICAgICAgICAgIHtuYW1lOlwieVwiLCBsdmFsdWU6ZmFsc2UsIHJ2YWx1ZTp0cnVlLCBjb3VudDoxfV0sIFxuICAgICAgICBib2R5OiBcImlmKHghPT15KXtyZXR1cm4gZmFsc2V9XCIsIFxuICAgICAgICBsb2NhbFZhcnM6IFtdLCBcbiAgICAgICAgdGhpc1ZhcnM6IFtdfSxcbiAgcG9zdDoge2FyZ3M6W10sIGxvY2FsVmFyczpbXSwgdGhpc1ZhcnM6W10sIGJvZHk6XCJyZXR1cm4gdHJ1ZVwifSxcbiAgZnVuY05hbWU6IFwiZXF1YWxzXCJcbn0pXG5cblxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIG5kYXJyYXkgPSByZXF1aXJlKFwibmRhcnJheVwiKVxudmFyIGRvX2NvbnZlcnQgPSByZXF1aXJlKFwiLi9kb0NvbnZlcnQuanNcIilcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb252ZXJ0KGFyciwgcmVzdWx0KSB7XG4gIHZhciBzaGFwZSA9IFtdLCBjID0gYXJyLCBzeiA9IDFcbiAgd2hpbGUoQXJyYXkuaXNBcnJheShjKSkge1xuICAgIHNoYXBlLnB1c2goYy5sZW5ndGgpXG4gICAgc3ogKj0gYy5sZW5ndGhcbiAgICBjID0gY1swXVxuICB9XG4gIGlmKHNoYXBlLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBuZGFycmF5KClcbiAgfVxuICBpZighcmVzdWx0KSB7XG4gICAgcmVzdWx0ID0gbmRhcnJheShuZXcgRmxvYXQ2NEFycmF5KHN6KSwgc2hhcGUpXG4gIH1cbiAgZG9fY29udmVydChyZXN1bHQsIGFycilcbiAgcmV0dXJuIHJlc3VsdFxufVxuIiwibW9kdWxlLmV4cG9ydHM9cmVxdWlyZSgnY3dpc2UtY29tcGlsZXInKSh7XCJhcmdzXCI6W1wiYXJyYXlcIixcInNjYWxhclwiLFwiaW5kZXhcIl0sXCJwcmVcIjp7XCJib2R5XCI6XCJ7fVwiLFwiYXJnc1wiOltdLFwidGhpc1ZhcnNcIjpbXSxcImxvY2FsVmFyc1wiOltdfSxcImJvZHlcIjp7XCJib2R5XCI6XCJ7XFxudmFyIF9pbmxpbmVfMV92PV9pbmxpbmVfMV9hcmcxXyxfaW5saW5lXzFfaVxcbmZvcihfaW5saW5lXzFfaT0wO19pbmxpbmVfMV9pPF9pbmxpbmVfMV9hcmcyXy5sZW5ndGgtMTsrK19pbmxpbmVfMV9pKSB7XFxuX2lubGluZV8xX3Y9X2lubGluZV8xX3ZbX2lubGluZV8xX2FyZzJfW19pbmxpbmVfMV9pXV1cXG59XFxuX2lubGluZV8xX2FyZzBfPV9pbmxpbmVfMV92W19pbmxpbmVfMV9hcmcyX1tfaW5saW5lXzFfYXJnMl8ubGVuZ3RoLTFdXVxcbn1cIixcImFyZ3NcIjpbe1wibmFtZVwiOlwiX2lubGluZV8xX2FyZzBfXCIsXCJsdmFsdWVcIjp0cnVlLFwicnZhbHVlXCI6ZmFsc2UsXCJjb3VudFwiOjF9LHtcIm5hbWVcIjpcIl9pbmxpbmVfMV9hcmcxX1wiLFwibHZhbHVlXCI6ZmFsc2UsXCJydmFsdWVcIjp0cnVlLFwiY291bnRcIjoxfSx7XCJuYW1lXCI6XCJfaW5saW5lXzFfYXJnMl9cIixcImx2YWx1ZVwiOmZhbHNlLFwicnZhbHVlXCI6dHJ1ZSxcImNvdW50XCI6NH1dLFwidGhpc1ZhcnNcIjpbXSxcImxvY2FsVmFyc1wiOltcIl9pbmxpbmVfMV9pXCIsXCJfaW5saW5lXzFfdlwiXX0sXCJwb3N0XCI6e1wiYm9keVwiOlwie31cIixcImFyZ3NcIjpbXSxcInRoaXNWYXJzXCI6W10sXCJsb2NhbFZhcnNcIjpbXX0sXCJmdW5jTmFtZVwiOlwiY29udmVydFwiLFwiYmxvY2tTaXplXCI6NjR9KVxuIiwidmFyIGlvdGEgPSByZXF1aXJlKFwiaW90YS1hcnJheVwiKVxudmFyIGlzQnVmZmVyID0gcmVxdWlyZShcImlzLWJ1ZmZlclwiKVxuXG52YXIgaGFzVHlwZWRBcnJheXMgID0gKCh0eXBlb2YgRmxvYXQ2NEFycmF5KSAhPT0gXCJ1bmRlZmluZWRcIilcblxuZnVuY3Rpb24gY29tcGFyZTFzdChhLCBiKSB7XG4gIHJldHVybiBhWzBdIC0gYlswXVxufVxuXG5mdW5jdGlvbiBvcmRlcigpIHtcbiAgdmFyIHN0cmlkZSA9IHRoaXMuc3RyaWRlXG4gIHZhciB0ZXJtcyA9IG5ldyBBcnJheShzdHJpZGUubGVuZ3RoKVxuICB2YXIgaVxuICBmb3IoaT0wOyBpPHRlcm1zLmxlbmd0aDsgKytpKSB7XG4gICAgdGVybXNbaV0gPSBbTWF0aC5hYnMoc3RyaWRlW2ldKSwgaV1cbiAgfVxuICB0ZXJtcy5zb3J0KGNvbXBhcmUxc3QpXG4gIHZhciByZXN1bHQgPSBuZXcgQXJyYXkodGVybXMubGVuZ3RoKVxuICBmb3IoaT0wOyBpPHJlc3VsdC5sZW5ndGg7ICsraSkge1xuICAgIHJlc3VsdFtpXSA9IHRlcm1zW2ldWzFdXG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBjb21waWxlQ29uc3RydWN0b3IoZHR5cGUsIGRpbWVuc2lvbikge1xuICB2YXIgY2xhc3NOYW1lID0gW1wiVmlld1wiLCBkaW1lbnNpb24sIFwiZFwiLCBkdHlwZV0uam9pbihcIlwiKVxuICBpZihkaW1lbnNpb24gPCAwKSB7XG4gICAgY2xhc3NOYW1lID0gXCJWaWV3X05pbFwiICsgZHR5cGVcbiAgfVxuICB2YXIgdXNlR2V0dGVycyA9IChkdHlwZSA9PT0gXCJnZW5lcmljXCIpXG5cbiAgaWYoZGltZW5zaW9uID09PSAtMSkge1xuICAgIC8vU3BlY2lhbCBjYXNlIGZvciB0cml2aWFsIGFycmF5c1xuICAgIHZhciBjb2RlID1cbiAgICAgIFwiZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiKGEpe3RoaXMuZGF0YT1hO307XFxcbnZhciBwcm90bz1cIitjbGFzc05hbWUrXCIucHJvdG90eXBlO1xcXG5wcm90by5kdHlwZT0nXCIrZHR5cGUrXCInO1xcXG5wcm90by5pbmRleD1mdW5jdGlvbigpe3JldHVybiAtMX07XFxcbnByb3RvLnNpemU9MDtcXFxucHJvdG8uZGltZW5zaW9uPS0xO1xcXG5wcm90by5zaGFwZT1wcm90by5zdHJpZGU9cHJvdG8ub3JkZXI9W107XFxcbnByb3RvLmxvPXByb3RvLmhpPXByb3RvLnRyYW5zcG9zZT1wcm90by5zdGVwPVxcXG5mdW5jdGlvbigpe3JldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKHRoaXMuZGF0YSk7fTtcXFxucHJvdG8uZ2V0PXByb3RvLnNldD1mdW5jdGlvbigpe307XFxcbnByb3RvLnBpY2s9ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbH07XFxcbnJldHVybiBmdW5jdGlvbiBjb25zdHJ1Y3RfXCIrY2xhc3NOYW1lK1wiKGEpe3JldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKGEpO31cIlxuICAgIHZhciBwcm9jZWR1cmUgPSBuZXcgRnVuY3Rpb24oY29kZSlcbiAgICByZXR1cm4gcHJvY2VkdXJlKClcbiAgfSBlbHNlIGlmKGRpbWVuc2lvbiA9PT0gMCkge1xuICAgIC8vU3BlY2lhbCBjYXNlIGZvciAwZCBhcnJheXNcbiAgICB2YXIgY29kZSA9XG4gICAgICBcImZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIihhLGQpIHtcXFxudGhpcy5kYXRhID0gYTtcXFxudGhpcy5vZmZzZXQgPSBkXFxcbn07XFxcbnZhciBwcm90bz1cIitjbGFzc05hbWUrXCIucHJvdG90eXBlO1xcXG5wcm90by5kdHlwZT0nXCIrZHR5cGUrXCInO1xcXG5wcm90by5pbmRleD1mdW5jdGlvbigpe3JldHVybiB0aGlzLm9mZnNldH07XFxcbnByb3RvLmRpbWVuc2lvbj0wO1xcXG5wcm90by5zaXplPTE7XFxcbnByb3RvLnNoYXBlPVxcXG5wcm90by5zdHJpZGU9XFxcbnByb3RvLm9yZGVyPVtdO1xcXG5wcm90by5sbz1cXFxucHJvdG8uaGk9XFxcbnByb3RvLnRyYW5zcG9zZT1cXFxucHJvdG8uc3RlcD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfY29weSgpIHtcXFxucmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIodGhpcy5kYXRhLHRoaXMub2Zmc2V0KVxcXG59O1xcXG5wcm90by5waWNrPWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9waWNrKCl7XFxcbnJldHVybiBUcml2aWFsQXJyYXkodGhpcy5kYXRhKTtcXFxufTtcXFxucHJvdG8udmFsdWVPZj1wcm90by5nZXQ9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX2dldCgpe1xcXG5yZXR1cm4gXCIrKHVzZUdldHRlcnMgPyBcInRoaXMuZGF0YS5nZXQodGhpcy5vZmZzZXQpXCIgOiBcInRoaXMuZGF0YVt0aGlzLm9mZnNldF1cIikrXG5cIn07XFxcbnByb3RvLnNldD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfc2V0KHYpe1xcXG5yZXR1cm4gXCIrKHVzZUdldHRlcnMgPyBcInRoaXMuZGF0YS5zZXQodGhpcy5vZmZzZXQsdilcIiA6IFwidGhpcy5kYXRhW3RoaXMub2Zmc2V0XT12XCIpK1wiXFxcbn07XFxcbnJldHVybiBmdW5jdGlvbiBjb25zdHJ1Y3RfXCIrY2xhc3NOYW1lK1wiKGEsYixjLGQpe3JldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKGEsZCl9XCJcbiAgICB2YXIgcHJvY2VkdXJlID0gbmV3IEZ1bmN0aW9uKFwiVHJpdmlhbEFycmF5XCIsIGNvZGUpXG4gICAgcmV0dXJuIHByb2NlZHVyZShDQUNIRURfQ09OU1RSVUNUT1JTW2R0eXBlXVswXSlcbiAgfVxuXG4gIHZhciBjb2RlID0gW1wiJ3VzZSBzdHJpY3QnXCJdXG5cbiAgLy9DcmVhdGUgY29uc3RydWN0b3IgZm9yIHZpZXdcbiAgdmFyIGluZGljZXMgPSBpb3RhKGRpbWVuc2lvbilcbiAgdmFyIGFyZ3MgPSBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7IHJldHVybiBcImlcIitpIH0pXG4gIHZhciBpbmRleF9zdHIgPSBcInRoaXMub2Zmc2V0K1wiICsgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgICByZXR1cm4gXCJ0aGlzLnN0cmlkZVtcIiArIGkgKyBcIl0qaVwiICsgaVxuICAgICAgfSkuam9pbihcIitcIilcbiAgdmFyIHNoYXBlQXJnID0gaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiYlwiK2lcbiAgICB9KS5qb2luKFwiLFwiKVxuICB2YXIgc3RyaWRlQXJnID0gaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiY1wiK2lcbiAgICB9KS5qb2luKFwiLFwiKVxuICBjb2RlLnB1c2goXG4gICAgXCJmdW5jdGlvbiBcIitjbGFzc05hbWUrXCIoYSxcIiArIHNoYXBlQXJnICsgXCIsXCIgKyBzdHJpZGVBcmcgKyBcIixkKXt0aGlzLmRhdGE9YVwiLFxuICAgICAgXCJ0aGlzLnNoYXBlPVtcIiArIHNoYXBlQXJnICsgXCJdXCIsXG4gICAgICBcInRoaXMuc3RyaWRlPVtcIiArIHN0cmlkZUFyZyArIFwiXVwiLFxuICAgICAgXCJ0aGlzLm9mZnNldD1kfDB9XCIsXG4gICAgXCJ2YXIgcHJvdG89XCIrY2xhc3NOYW1lK1wiLnByb3RvdHlwZVwiLFxuICAgIFwicHJvdG8uZHR5cGU9J1wiK2R0eXBlK1wiJ1wiLFxuICAgIFwicHJvdG8uZGltZW5zaW9uPVwiK2RpbWVuc2lvbilcblxuICAvL3ZpZXcuc2l6ZTpcbiAgY29kZS5wdXNoKFwiT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCdzaXplJyx7Z2V0OmZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9zaXplKCl7XFxcbnJldHVybiBcIitpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7IHJldHVybiBcInRoaXMuc2hhcGVbXCIraStcIl1cIiB9KS5qb2luKFwiKlwiKSxcblwifX0pXCIpXG5cbiAgLy92aWV3Lm9yZGVyOlxuICBpZihkaW1lbnNpb24gPT09IDEpIHtcbiAgICBjb2RlLnB1c2goXCJwcm90by5vcmRlcj1bMF1cIilcbiAgfSBlbHNlIHtcbiAgICBjb2RlLnB1c2goXCJPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sJ29yZGVyJyx7Z2V0OlwiKVxuICAgIGlmKGRpbWVuc2lvbiA8IDQpIHtcbiAgICAgIGNvZGUucHVzaChcImZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9vcmRlcigpe1wiKVxuICAgICAgaWYoZGltZW5zaW9uID09PSAyKSB7XG4gICAgICAgIGNvZGUucHVzaChcInJldHVybiAoTWF0aC5hYnModGhpcy5zdHJpZGVbMF0pPk1hdGguYWJzKHRoaXMuc3RyaWRlWzFdKSk/WzEsMF06WzAsMV19fSlcIilcbiAgICAgIH0gZWxzZSBpZihkaW1lbnNpb24gPT09IDMpIHtcbiAgICAgICAgY29kZS5wdXNoKFxuXCJ2YXIgczA9TWF0aC5hYnModGhpcy5zdHJpZGVbMF0pLHMxPU1hdGguYWJzKHRoaXMuc3RyaWRlWzFdKSxzMj1NYXRoLmFicyh0aGlzLnN0cmlkZVsyXSk7XFxcbmlmKHMwPnMxKXtcXFxuaWYoczE+czIpe1xcXG5yZXR1cm4gWzIsMSwwXTtcXFxufWVsc2UgaWYoczA+czIpe1xcXG5yZXR1cm4gWzEsMiwwXTtcXFxufWVsc2V7XFxcbnJldHVybiBbMSwwLDJdO1xcXG59XFxcbn1lbHNlIGlmKHMwPnMyKXtcXFxucmV0dXJuIFsyLDAsMV07XFxcbn1lbHNlIGlmKHMyPnMxKXtcXFxucmV0dXJuIFswLDEsMl07XFxcbn1lbHNle1xcXG5yZXR1cm4gWzAsMiwxXTtcXFxufX19KVwiKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb2RlLnB1c2goXCJPUkRFUn0pXCIpXG4gICAgfVxuICB9XG5cbiAgLy92aWV3LnNldChpMCwgLi4uLCB2KTpcbiAgY29kZS5wdXNoKFxuXCJwcm90by5zZXQ9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3NldChcIithcmdzLmpvaW4oXCIsXCIpK1wiLHYpe1wiKVxuICBpZih1c2VHZXR0ZXJzKSB7XG4gICAgY29kZS5wdXNoKFwicmV0dXJuIHRoaXMuZGF0YS5zZXQoXCIraW5kZXhfc3RyK1wiLHYpfVwiKVxuICB9IGVsc2Uge1xuICAgIGNvZGUucHVzaChcInJldHVybiB0aGlzLmRhdGFbXCIraW5kZXhfc3RyK1wiXT12fVwiKVxuICB9XG5cbiAgLy92aWV3LmdldChpMCwgLi4uKTpcbiAgY29kZS5wdXNoKFwicHJvdG8uZ2V0PWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9nZXQoXCIrYXJncy5qb2luKFwiLFwiKStcIil7XCIpXG4gIGlmKHVzZUdldHRlcnMpIHtcbiAgICBjb2RlLnB1c2goXCJyZXR1cm4gdGhpcy5kYXRhLmdldChcIitpbmRleF9zdHIrXCIpfVwiKVxuICB9IGVsc2Uge1xuICAgIGNvZGUucHVzaChcInJldHVybiB0aGlzLmRhdGFbXCIraW5kZXhfc3RyK1wiXX1cIilcbiAgfVxuXG4gIC8vdmlldy5pbmRleDpcbiAgY29kZS5wdXNoKFxuICAgIFwicHJvdG8uaW5kZXg9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX2luZGV4KFwiLCBhcmdzLmpvaW4oKSwgXCIpe3JldHVybiBcIitpbmRleF9zdHIrXCJ9XCIpXG5cbiAgLy92aWV3LmhpKCk6XG4gIGNvZGUucHVzaChcInByb3RvLmhpPWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9oaShcIithcmdzLmpvaW4oXCIsXCIpK1wiKXtyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFtcIih0eXBlb2YgaVwiLGksXCIhPT0nbnVtYmVyJ3x8aVwiLGksXCI8MCk/dGhpcy5zaGFwZVtcIiwgaSwgXCJdOmlcIiwgaSxcInwwXCJdLmpvaW4oXCJcIilcbiAgICB9KS5qb2luKFwiLFwiKStcIixcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJ0aGlzLnN0cmlkZVtcIitpICsgXCJdXCJcbiAgICB9KS5qb2luKFwiLFwiKStcIix0aGlzLm9mZnNldCl9XCIpXG5cbiAgLy92aWV3LmxvKCk6XG4gIHZhciBhX3ZhcnMgPSBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7IHJldHVybiBcImFcIitpK1wiPXRoaXMuc2hhcGVbXCIraStcIl1cIiB9KVxuICB2YXIgY192YXJzID0gaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkgeyByZXR1cm4gXCJjXCIraStcIj10aGlzLnN0cmlkZVtcIitpK1wiXVwiIH0pXG4gIGNvZGUucHVzaChcInByb3RvLmxvPWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9sbyhcIithcmdzLmpvaW4oXCIsXCIpK1wiKXt2YXIgYj10aGlzLm9mZnNldCxkPTAsXCIrYV92YXJzLmpvaW4oXCIsXCIpK1wiLFwiK2NfdmFycy5qb2luKFwiLFwiKSlcbiAgZm9yKHZhciBpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICBjb2RlLnB1c2goXG5cImlmKHR5cGVvZiBpXCIraStcIj09PSdudW1iZXInJiZpXCIraStcIj49MCl7XFxcbmQ9aVwiK2krXCJ8MDtcXFxuYis9Y1wiK2krXCIqZDtcXFxuYVwiK2krXCItPWR9XCIpXG4gIH1cbiAgY29kZS5wdXNoKFwicmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIodGhpcy5kYXRhLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImFcIitpXG4gICAgfSkuam9pbihcIixcIikrXCIsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiY1wiK2lcbiAgICB9KS5qb2luKFwiLFwiKStcIixiKX1cIilcblxuICAvL3ZpZXcuc3RlcCgpOlxuICBjb2RlLnB1c2goXCJwcm90by5zdGVwPWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9zdGVwKFwiK2FyZ3Muam9pbihcIixcIikrXCIpe3ZhciBcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJhXCIraStcIj10aGlzLnNoYXBlW1wiK2krXCJdXCJcbiAgICB9KS5qb2luKFwiLFwiKStcIixcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJiXCIraStcIj10aGlzLnN0cmlkZVtcIitpK1wiXVwiXG4gICAgfSkuam9pbihcIixcIikrXCIsYz10aGlzLm9mZnNldCxkPTAsY2VpbD1NYXRoLmNlaWxcIilcbiAgZm9yKHZhciBpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICBjb2RlLnB1c2goXG5cImlmKHR5cGVvZiBpXCIraStcIj09PSdudW1iZXInKXtcXFxuZD1pXCIraStcInwwO1xcXG5pZihkPDApe1xcXG5jKz1iXCIraStcIiooYVwiK2krXCItMSk7XFxcbmFcIitpK1wiPWNlaWwoLWFcIitpK1wiL2QpXFxcbn1lbHNle1xcXG5hXCIraStcIj1jZWlsKGFcIitpK1wiL2QpXFxcbn1cXFxuYlwiK2krXCIqPWRcXFxufVwiKVxuICB9XG4gIGNvZGUucHVzaChcInJldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKHRoaXMuZGF0YSxcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJhXCIgKyBpXG4gICAgfSkuam9pbihcIixcIikrXCIsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiYlwiICsgaVxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLGMpfVwiKVxuXG4gIC8vdmlldy50cmFuc3Bvc2UoKTpcbiAgdmFyIHRTaGFwZSA9IG5ldyBBcnJheShkaW1lbnNpb24pXG4gIHZhciB0U3RyaWRlID0gbmV3IEFycmF5KGRpbWVuc2lvbilcbiAgZm9yKHZhciBpPTA7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICB0U2hhcGVbaV0gPSBcImFbaVwiK2krXCJdXCJcbiAgICB0U3RyaWRlW2ldID0gXCJiW2lcIitpK1wiXVwiXG4gIH1cbiAgY29kZS5wdXNoKFwicHJvdG8udHJhbnNwb3NlPWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl90cmFuc3Bvc2UoXCIrYXJncytcIil7XCIrXG4gICAgYXJncy5tYXAoZnVuY3Rpb24obixpZHgpIHsgcmV0dXJuIG4gKyBcIj0oXCIgKyBuICsgXCI9PT11bmRlZmluZWQ/XCIgKyBpZHggKyBcIjpcIiArIG4gKyBcInwwKVwifSkuam9pbihcIjtcIiksXG4gICAgXCJ2YXIgYT10aGlzLnNoYXBlLGI9dGhpcy5zdHJpZGU7cmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIodGhpcy5kYXRhLFwiK3RTaGFwZS5qb2luKFwiLFwiKStcIixcIit0U3RyaWRlLmpvaW4oXCIsXCIpK1wiLHRoaXMub2Zmc2V0KX1cIilcblxuICAvL3ZpZXcucGljaygpOlxuICBjb2RlLnB1c2goXCJwcm90by5waWNrPWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9waWNrKFwiK2FyZ3MrXCIpe3ZhciBhPVtdLGI9W10sYz10aGlzLm9mZnNldFwiKVxuICBmb3IodmFyIGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIGNvZGUucHVzaChcImlmKHR5cGVvZiBpXCIraStcIj09PSdudW1iZXInJiZpXCIraStcIj49MCl7Yz0oYyt0aGlzLnN0cmlkZVtcIitpK1wiXSppXCIraStcIil8MH1lbHNle2EucHVzaCh0aGlzLnNoYXBlW1wiK2krXCJdKTtiLnB1c2godGhpcy5zdHJpZGVbXCIraStcIl0pfVwiKVxuICB9XG4gIGNvZGUucHVzaChcInZhciBjdG9yPUNUT1JfTElTVFthLmxlbmd0aCsxXTtyZXR1cm4gY3Rvcih0aGlzLmRhdGEsYSxiLGMpfVwiKVxuXG4gIC8vQWRkIHJldHVybiBzdGF0ZW1lbnRcbiAgY29kZS5wdXNoKFwicmV0dXJuIGZ1bmN0aW9uIGNvbnN0cnVjdF9cIitjbGFzc05hbWUrXCIoZGF0YSxzaGFwZSxzdHJpZGUsb2Zmc2V0KXtyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIihkYXRhLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcInNoYXBlW1wiK2krXCJdXCJcbiAgICB9KS5qb2luKFwiLFwiKStcIixcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJzdHJpZGVbXCIraStcIl1cIlxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLG9mZnNldCl9XCIpXG5cbiAgLy9Db21waWxlIHByb2NlZHVyZVxuICB2YXIgcHJvY2VkdXJlID0gbmV3IEZ1bmN0aW9uKFwiQ1RPUl9MSVNUXCIsIFwiT1JERVJcIiwgY29kZS5qb2luKFwiXFxuXCIpKVxuICByZXR1cm4gcHJvY2VkdXJlKENBQ0hFRF9DT05TVFJVQ1RPUlNbZHR5cGVdLCBvcmRlcilcbn1cblxuZnVuY3Rpb24gYXJyYXlEVHlwZShkYXRhKSB7XG4gIGlmKGlzQnVmZmVyKGRhdGEpKSB7XG4gICAgcmV0dXJuIFwiYnVmZmVyXCJcbiAgfVxuICBpZihoYXNUeXBlZEFycmF5cykge1xuICAgIHN3aXRjaChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZGF0YSkpIHtcbiAgICAgIGNhc2UgXCJbb2JqZWN0IEZsb2F0NjRBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwiZmxvYXQ2NFwiXG4gICAgICBjYXNlIFwiW29iamVjdCBGbG9hdDMyQXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcImZsb2F0MzJcIlxuICAgICAgY2FzZSBcIltvYmplY3QgSW50OEFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJpbnQ4XCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IEludDE2QXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcImludDE2XCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IEludDMyQXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcImludDMyXCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IFVpbnQ4QXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcInVpbnQ4XCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IFVpbnQxNkFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJ1aW50MTZcIlxuICAgICAgY2FzZSBcIltvYmplY3QgVWludDMyQXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcInVpbnQzMlwiXG4gICAgICBjYXNlIFwiW29iamVjdCBVaW50OENsYW1wZWRBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwidWludDhfY2xhbXBlZFwiXG4gICAgICBjYXNlIFwiW29iamVjdCBCaWdJbnQ2NEFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJiaWdpbnQ2NFwiXG4gICAgICBjYXNlIFwiW29iamVjdCBCaWdVaW50NjRBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwiYmlndWludDY0XCJcbiAgICB9XG4gIH1cbiAgaWYoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgIHJldHVybiBcImFycmF5XCJcbiAgfVxuICByZXR1cm4gXCJnZW5lcmljXCJcbn1cblxudmFyIENBQ0hFRF9DT05TVFJVQ1RPUlMgPSB7XG4gIFwiZmxvYXQzMlwiOltdLFxuICBcImZsb2F0NjRcIjpbXSxcbiAgXCJpbnQ4XCI6W10sXG4gIFwiaW50MTZcIjpbXSxcbiAgXCJpbnQzMlwiOltdLFxuICBcInVpbnQ4XCI6W10sXG4gIFwidWludDE2XCI6W10sXG4gIFwidWludDMyXCI6W10sXG4gIFwiYXJyYXlcIjpbXSxcbiAgXCJ1aW50OF9jbGFtcGVkXCI6W10sXG4gIFwiYmlnaW50NjRcIjogW10sXG4gIFwiYmlndWludDY0XCI6IFtdLFxuICBcImJ1ZmZlclwiOltdLFxuICBcImdlbmVyaWNcIjpbXVxufVxuXG47KGZ1bmN0aW9uKCkge1xuICBmb3IodmFyIGlkIGluIENBQ0hFRF9DT05TVFJVQ1RPUlMpIHtcbiAgICBDQUNIRURfQ09OU1RSVUNUT1JTW2lkXS5wdXNoKGNvbXBpbGVDb25zdHJ1Y3RvcihpZCwgLTEpKVxuICB9XG59KTtcblxuZnVuY3Rpb24gd3JhcHBlZE5EQXJyYXlDdG9yKGRhdGEsIHNoYXBlLCBzdHJpZGUsIG9mZnNldCkge1xuICBpZihkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgY3RvciA9IENBQ0hFRF9DT05TVFJVQ1RPUlMuYXJyYXlbMF1cbiAgICByZXR1cm4gY3RvcihbXSlcbiAgfSBlbHNlIGlmKHR5cGVvZiBkYXRhID09PSBcIm51bWJlclwiKSB7XG4gICAgZGF0YSA9IFtkYXRhXVxuICB9XG4gIGlmKHNoYXBlID09PSB1bmRlZmluZWQpIHtcbiAgICBzaGFwZSA9IFsgZGF0YS5sZW5ndGggXVxuICB9XG4gIHZhciBkID0gc2hhcGUubGVuZ3RoXG4gIGlmKHN0cmlkZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RyaWRlID0gbmV3IEFycmF5KGQpXG4gICAgZm9yKHZhciBpPWQtMSwgc3o9MTsgaT49MDsgLS1pKSB7XG4gICAgICBzdHJpZGVbaV0gPSBzelxuICAgICAgc3ogKj0gc2hhcGVbaV1cbiAgICB9XG4gIH1cbiAgaWYob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBvZmZzZXQgPSAwXG4gICAgZm9yKHZhciBpPTA7IGk8ZDsgKytpKSB7XG4gICAgICBpZihzdHJpZGVbaV0gPCAwKSB7XG4gICAgICAgIG9mZnNldCAtPSAoc2hhcGVbaV0tMSkqc3RyaWRlW2ldXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciBkdHlwZSA9IGFycmF5RFR5cGUoZGF0YSlcbiAgdmFyIGN0b3JfbGlzdCA9IENBQ0hFRF9DT05TVFJVQ1RPUlNbZHR5cGVdXG4gIHdoaWxlKGN0b3JfbGlzdC5sZW5ndGggPD0gZCsxKSB7XG4gICAgY3Rvcl9saXN0LnB1c2goY29tcGlsZUNvbnN0cnVjdG9yKGR0eXBlLCBjdG9yX2xpc3QubGVuZ3RoLTEpKVxuICB9XG4gIHZhciBjdG9yID0gY3Rvcl9saXN0W2QrMV1cbiAgcmV0dXJuIGN0b3IoZGF0YSwgc2hhcGUsIHN0cmlkZSwgb2Zmc2V0KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdyYXBwZWROREFycmF5Q3RvclxuIiwiLy8gKGMpIERlYW4gTWNOYW1lZSA8ZGVhbkBnbWFpbC5jb20+LCAyMDEzLlxuLy9cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kZWFubS9vbWdnaWZcbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4vLyBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0b1xuLy8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGVcbi8vIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vclxuLy8gc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbi8vIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbi8vIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4vLyBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuLy8gRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HU1xuLy8gSU4gVEhFIFNPRlRXQVJFLlxuLy9cbi8vIG9tZ2dpZiBpcyBhIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgYSBHSUYgODlhIGVuY29kZXIgYW5kIGRlY29kZXIsXG4vLyBpbmNsdWRpbmcgYW5pbWF0aW9uIGFuZCBjb21wcmVzc2lvbi4gIEl0IGRvZXMgbm90IHJlbHkgb24gYW55IHNwZWNpZmljXG4vLyB1bmRlcmx5aW5nIHN5c3RlbSwgc28gc2hvdWxkIHJ1biBpbiB0aGUgYnJvd3NlciwgTm9kZSwgb3IgUGxhc2suXG5cblwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBHaWZXcml0ZXIoYnVmLCB3aWR0aCwgaGVpZ2h0LCBnb3B0cykge1xuICB2YXIgcCA9IDA7XG5cbiAgdmFyIGdvcHRzID0gZ29wdHMgPT09IHVuZGVmaW5lZCA/IHsgfSA6IGdvcHRzO1xuICB2YXIgbG9vcF9jb3VudCA9IGdvcHRzLmxvb3AgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBnb3B0cy5sb29wO1xuICB2YXIgZ2xvYmFsX3BhbGV0dGUgPSBnb3B0cy5wYWxldHRlID09PSB1bmRlZmluZWQgPyBudWxsIDogZ29wdHMucGFsZXR0ZTtcblxuICBpZiAod2lkdGggPD0gMCB8fCBoZWlnaHQgPD0gMCB8fCB3aWR0aCA+IDY1NTM1IHx8IGhlaWdodCA+IDY1NTM1KVxuICAgIHRocm93IG5ldyBFcnJvcihcIldpZHRoL0hlaWdodCBpbnZhbGlkLlwiKTtcblxuICBmdW5jdGlvbiBjaGVja19wYWxldHRlX2FuZF9udW1fY29sb3JzKHBhbGV0dGUpIHtcbiAgICB2YXIgbnVtX2NvbG9ycyA9IHBhbGV0dGUubGVuZ3RoO1xuICAgIGlmIChudW1fY29sb3JzIDwgMiB8fCBudW1fY29sb3JzID4gMjU2IHx8ICBudW1fY29sb3JzICYgKG51bV9jb2xvcnMtMSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBcIkludmFsaWQgY29kZS9jb2xvciBsZW5ndGgsIG11c3QgYmUgcG93ZXIgb2YgMiBhbmQgMiAuLiAyNTYuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbnVtX2NvbG9ycztcbiAgfVxuXG4gIC8vIC0gSGVhZGVyLlxuICBidWZbcCsrXSA9IDB4NDc7IGJ1ZltwKytdID0gMHg0OTsgYnVmW3ArK10gPSAweDQ2OyAgLy8gR0lGXG4gIGJ1ZltwKytdID0gMHgzODsgYnVmW3ArK10gPSAweDM5OyBidWZbcCsrXSA9IDB4NjE7ICAvLyA4OWFcblxuICAvLyBIYW5kbGluZyBvZiBHbG9iYWwgQ29sb3IgVGFibGUgKHBhbGV0dGUpIGFuZCBiYWNrZ3JvdW5kIGluZGV4LlxuICB2YXIgZ3BfbnVtX2NvbG9yc19wb3cyID0gMDtcbiAgdmFyIGJhY2tncm91bmQgPSAwO1xuICBpZiAoZ2xvYmFsX3BhbGV0dGUgIT09IG51bGwpIHtcbiAgICB2YXIgZ3BfbnVtX2NvbG9ycyA9IGNoZWNrX3BhbGV0dGVfYW5kX251bV9jb2xvcnMoZ2xvYmFsX3BhbGV0dGUpO1xuICAgIHdoaWxlIChncF9udW1fY29sb3JzID4+PSAxKSArK2dwX251bV9jb2xvcnNfcG93MjtcbiAgICBncF9udW1fY29sb3JzID0gMSA8PCBncF9udW1fY29sb3JzX3BvdzI7XG4gICAgLS1ncF9udW1fY29sb3JzX3BvdzI7XG4gICAgaWYgKGdvcHRzLmJhY2tncm91bmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYmFja2dyb3VuZCA9IGdvcHRzLmJhY2tncm91bmQ7XG4gICAgICBpZiAoYmFja2dyb3VuZCA+PSBncF9udW1fY29sb3JzKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCYWNrZ3JvdW5kIGluZGV4IG91dCBvZiByYW5nZS5cIik7XG4gICAgICAvLyBUaGUgR0lGIHNwZWMgc3RhdGVzIHRoYXQgYSBiYWNrZ3JvdW5kIGluZGV4IG9mIDAgc2hvdWxkIGJlIGlnbm9yZWQsIHNvXG4gICAgICAvLyB0aGlzIGlzIHByb2JhYmx5IGEgbWlzdGFrZSBhbmQgeW91IHJlYWxseSB3YW50IHRvIHNldCBpdCB0byBhbm90aGVyXG4gICAgICAvLyBzbG90IGluIHRoZSBwYWxldHRlLiAgQnV0IGFjdHVhbGx5IGluIHRoZSBlbmQgbW9zdCBicm93c2VycywgZXRjIGVuZFxuICAgICAgLy8gdXAgaWdub3JpbmcgdGhpcyBhbG1vc3QgY29tcGxldGVseSAoaW5jbHVkaW5nIGZvciBkaXNwb3NlIGJhY2tncm91bmQpLlxuICAgICAgaWYgKGJhY2tncm91bmQgPT09IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJhY2tncm91bmQgaW5kZXggZXhwbGljaXRseSBwYXNzZWQgYXMgMC5cIik7XG4gICAgfVxuICB9XG5cbiAgLy8gLSBMb2dpY2FsIFNjcmVlbiBEZXNjcmlwdG9yLlxuICAvLyBOT1RFKGRlYW5tKTogdy9oIGFwcGFyZW50bHkgaWdub3JlZCBieSBpbXBsZW1lbnRhdGlvbnMsIGJ1dCBzZXQgYW55d2F5LlxuICBidWZbcCsrXSA9IHdpZHRoICYgMHhmZjsgYnVmW3ArK10gPSB3aWR0aCA+PiA4ICYgMHhmZjtcbiAgYnVmW3ArK10gPSBoZWlnaHQgJiAweGZmOyBidWZbcCsrXSA9IGhlaWdodCA+PiA4ICYgMHhmZjtcbiAgLy8gTk9URTogSW5kaWNhdGVzIDAtYnBwIG9yaWdpbmFsIGNvbG9yIHJlc29sdXRpb24gKHVudXNlZD8pLlxuICBidWZbcCsrXSA9IChnbG9iYWxfcGFsZXR0ZSAhPT0gbnVsbCA/IDB4ODAgOiAwKSB8ICAvLyBHbG9iYWwgQ29sb3IgVGFibGUgRmxhZy5cbiAgICAgICAgICAgICBncF9udW1fY29sb3JzX3BvdzI7ICAvLyBOT1RFOiBObyBzb3J0IGZsYWcgKHVudXNlZD8pLlxuICBidWZbcCsrXSA9IGJhY2tncm91bmQ7ICAvLyBCYWNrZ3JvdW5kIENvbG9yIEluZGV4LlxuICBidWZbcCsrXSA9IDA7ICAvLyBQaXhlbCBhc3BlY3QgcmF0aW8gKHVudXNlZD8pLlxuXG4gIC8vIC0gR2xvYmFsIENvbG9yIFRhYmxlXG4gIGlmIChnbG9iYWxfcGFsZXR0ZSAhPT0gbnVsbCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IGdsb2JhbF9wYWxldHRlLmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcbiAgICAgIHZhciByZ2IgPSBnbG9iYWxfcGFsZXR0ZVtpXTtcbiAgICAgIGJ1ZltwKytdID0gcmdiID4+IDE2ICYgMHhmZjtcbiAgICAgIGJ1ZltwKytdID0gcmdiID4+IDggJiAweGZmO1xuICAgICAgYnVmW3ArK10gPSByZ2IgJiAweGZmO1xuICAgIH1cbiAgfVxuXG4gIGlmIChsb29wX2NvdW50ICE9PSBudWxsKSB7ICAvLyBOZXRzY2FwZSBibG9jayBmb3IgbG9vcGluZy5cbiAgICBpZiAobG9vcF9jb3VudCA8IDAgfHwgbG9vcF9jb3VudCA+IDY1NTM1KVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTG9vcCBjb3VudCBpbnZhbGlkLlwiKVxuICAgIC8vIEV4dGVuc2lvbiBjb2RlLCBsYWJlbCwgYW5kIGxlbmd0aC5cbiAgICBidWZbcCsrXSA9IDB4MjE7IGJ1ZltwKytdID0gMHhmZjsgYnVmW3ArK10gPSAweDBiO1xuICAgIC8vIE5FVFNDQVBFMi4wXG4gICAgYnVmW3ArK10gPSAweDRlOyBidWZbcCsrXSA9IDB4NDU7IGJ1ZltwKytdID0gMHg1NDsgYnVmW3ArK10gPSAweDUzO1xuICAgIGJ1ZltwKytdID0gMHg0MzsgYnVmW3ArK10gPSAweDQxOyBidWZbcCsrXSA9IDB4NTA7IGJ1ZltwKytdID0gMHg0NTtcbiAgICBidWZbcCsrXSA9IDB4MzI7IGJ1ZltwKytdID0gMHgyZTsgYnVmW3ArK10gPSAweDMwO1xuICAgIC8vIFN1Yi1ibG9ja1xuICAgIGJ1ZltwKytdID0gMHgwMzsgYnVmW3ArK10gPSAweDAxO1xuICAgIGJ1ZltwKytdID0gbG9vcF9jb3VudCAmIDB4ZmY7IGJ1ZltwKytdID0gbG9vcF9jb3VudCA+PiA4ICYgMHhmZjtcbiAgICBidWZbcCsrXSA9IDB4MDA7ICAvLyBUZXJtaW5hdG9yLlxuICB9XG5cblxuICB2YXIgZW5kZWQgPSBmYWxzZTtcblxuICB0aGlzLmFkZEZyYW1lID0gZnVuY3Rpb24oeCwgeSwgdywgaCwgaW5kZXhlZF9waXhlbHMsIG9wdHMpIHtcbiAgICBpZiAoZW5kZWQgPT09IHRydWUpIHsgLS1wOyBlbmRlZCA9IGZhbHNlOyB9ICAvLyBVbi1lbmQuXG5cbiAgICBvcHRzID0gb3B0cyA9PT0gdW5kZWZpbmVkID8geyB9IDogb3B0cztcblxuICAgIC8vIFRPRE8oZGVhbm0pOiBCb3VuZHMgY2hlY2sgeCwgeS4gIERvIHRoZXkgbmVlZCB0byBiZSB3aXRoaW4gdGhlIHZpcnR1YWxcbiAgICAvLyBjYW52YXMgd2lkdGgvaGVpZ2h0LCBJIGltYWdpbmU/XG4gICAgaWYgKHggPCAwIHx8IHkgPCAwIHx8IHggPiA2NTUzNSB8fCB5ID4gNjU1MzUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ4L3kgaW52YWxpZC5cIilcblxuICAgIGlmICh3IDw9IDAgfHwgaCA8PSAwIHx8IHcgPiA2NTUzNSB8fCBoID4gNjU1MzUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXaWR0aC9IZWlnaHQgaW52YWxpZC5cIilcblxuICAgIGlmIChpbmRleGVkX3BpeGVscy5sZW5ndGggPCB3ICogaClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vdCBlbm91Z2ggcGl4ZWxzIGZvciB0aGUgZnJhbWUgc2l6ZS5cIik7XG5cbiAgICB2YXIgdXNpbmdfbG9jYWxfcGFsZXR0ZSA9IHRydWU7XG4gICAgdmFyIHBhbGV0dGUgPSBvcHRzLnBhbGV0dGU7XG4gICAgaWYgKHBhbGV0dGUgPT09IHVuZGVmaW5lZCB8fCBwYWxldHRlID09PSBudWxsKSB7XG4gICAgICB1c2luZ19sb2NhbF9wYWxldHRlID0gZmFsc2U7XG4gICAgICBwYWxldHRlID0gZ2xvYmFsX3BhbGV0dGU7XG4gICAgfVxuXG4gICAgaWYgKHBhbGV0dGUgPT09IHVuZGVmaW5lZCB8fCBwYWxldHRlID09PSBudWxsKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBzdXBwbHkgZWl0aGVyIGEgbG9jYWwgb3IgZ2xvYmFsIHBhbGV0dGUuXCIpO1xuXG4gICAgdmFyIG51bV9jb2xvcnMgPSBjaGVja19wYWxldHRlX2FuZF9udW1fY29sb3JzKHBhbGV0dGUpO1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUgbWluX2NvZGVfc2l6ZSAocG93ZXIgb2YgMiksIGRlc3Ryb3lpbmcgbnVtX2NvbG9ycy5cbiAgICB2YXIgbWluX2NvZGVfc2l6ZSA9IDA7XG4gICAgd2hpbGUgKG51bV9jb2xvcnMgPj49IDEpICsrbWluX2NvZGVfc2l6ZTtcbiAgICBudW1fY29sb3JzID0gMSA8PCBtaW5fY29kZV9zaXplOyAgLy8gTm93IHdlIGNhbiBlYXNpbHkgZ2V0IGl0IGJhY2suXG5cbiAgICB2YXIgZGVsYXkgPSBvcHRzLmRlbGF5ID09PSB1bmRlZmluZWQgPyAwIDogb3B0cy5kZWxheTtcblxuICAgIC8vIEZyb20gdGhlIHNwZWM6XG4gICAgLy8gICAgIDAgLSAgIE5vIGRpc3Bvc2FsIHNwZWNpZmllZC4gVGhlIGRlY29kZXIgaXNcbiAgICAvLyAgICAgICAgICAgbm90IHJlcXVpcmVkIHRvIHRha2UgYW55IGFjdGlvbi5cbiAgICAvLyAgICAgMSAtICAgRG8gbm90IGRpc3Bvc2UuIFRoZSBncmFwaGljIGlzIHRvIGJlIGxlZnRcbiAgICAvLyAgICAgICAgICAgaW4gcGxhY2UuXG4gICAgLy8gICAgIDIgLSAgIFJlc3RvcmUgdG8gYmFja2dyb3VuZCBjb2xvci4gVGhlIGFyZWEgdXNlZCBieSB0aGVcbiAgICAvLyAgICAgICAgICAgZ3JhcGhpYyBtdXN0IGJlIHJlc3RvcmVkIHRvIHRoZSBiYWNrZ3JvdW5kIGNvbG9yLlxuICAgIC8vICAgICAzIC0gICBSZXN0b3JlIHRvIHByZXZpb3VzLiBUaGUgZGVjb2RlciBpcyByZXF1aXJlZCB0b1xuICAgIC8vICAgICAgICAgICByZXN0b3JlIHRoZSBhcmVhIG92ZXJ3cml0dGVuIGJ5IHRoZSBncmFwaGljIHdpdGhcbiAgICAvLyAgICAgICAgICAgd2hhdCB3YXMgdGhlcmUgcHJpb3IgdG8gcmVuZGVyaW5nIHRoZSBncmFwaGljLlxuICAgIC8vICA0LTcgLSAgICBUbyBiZSBkZWZpbmVkLlxuICAgIC8vIE5PVEUoZGVhbm0pOiBEaXNwb3NlIGJhY2tncm91bmQgZG9lc24ndCByZWFsbHkgd29yaywgYXBwYXJlbnRseSBtb3N0XG4gICAgLy8gYnJvd3NlcnMgaWdub3JlIHRoZSBiYWNrZ3JvdW5kIHBhbGV0dGUgaW5kZXggYW5kIGNsZWFyIHRvIHRyYW5zcGFyZW5jeS5cbiAgICB2YXIgZGlzcG9zYWwgPSBvcHRzLmRpc3Bvc2FsID09PSB1bmRlZmluZWQgPyAwIDogb3B0cy5kaXNwb3NhbDtcbiAgICBpZiAoZGlzcG9zYWwgPCAwIHx8IGRpc3Bvc2FsID4gMykgIC8vIDQtNyBpcyByZXNlcnZlZC5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpc3Bvc2FsIG91dCBvZiByYW5nZS5cIik7XG5cbiAgICB2YXIgdXNlX3RyYW5zcGFyZW5jeSA9IGZhbHNlO1xuICAgIHZhciB0cmFuc3BhcmVudF9pbmRleCA9IDA7XG4gICAgaWYgKG9wdHMudHJhbnNwYXJlbnQgIT09IHVuZGVmaW5lZCAmJiBvcHRzLnRyYW5zcGFyZW50ICE9PSBudWxsKSB7XG4gICAgICB1c2VfdHJhbnNwYXJlbmN5ID0gdHJ1ZTtcbiAgICAgIHRyYW5zcGFyZW50X2luZGV4ID0gb3B0cy50cmFuc3BhcmVudDtcbiAgICAgIGlmICh0cmFuc3BhcmVudF9pbmRleCA8IDAgfHwgdHJhbnNwYXJlbnRfaW5kZXggPj0gbnVtX2NvbG9ycylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNwYXJlbnQgY29sb3IgaW5kZXguXCIpO1xuICAgIH1cblxuICAgIGlmIChkaXNwb3NhbCAhPT0gMCB8fCB1c2VfdHJhbnNwYXJlbmN5IHx8IGRlbGF5ICE9PSAwKSB7XG4gICAgICAvLyAtIEdyYXBoaWNzIENvbnRyb2wgRXh0ZW5zaW9uXG4gICAgICBidWZbcCsrXSA9IDB4MjE7IGJ1ZltwKytdID0gMHhmOTsgIC8vIEV4dGVuc2lvbiAvIExhYmVsLlxuICAgICAgYnVmW3ArK10gPSA0OyAgLy8gQnl0ZSBzaXplLlxuXG4gICAgICBidWZbcCsrXSA9IGRpc3Bvc2FsIDw8IDIgfCAodXNlX3RyYW5zcGFyZW5jeSA9PT0gdHJ1ZSA/IDEgOiAwKTtcbiAgICAgIGJ1ZltwKytdID0gZGVsYXkgJiAweGZmOyBidWZbcCsrXSA9IGRlbGF5ID4+IDggJiAweGZmO1xuICAgICAgYnVmW3ArK10gPSB0cmFuc3BhcmVudF9pbmRleDsgIC8vIFRyYW5zcGFyZW50IGNvbG9yIGluZGV4LlxuICAgICAgYnVmW3ArK10gPSAwOyAgLy8gQmxvY2sgVGVybWluYXRvci5cbiAgICB9XG5cbiAgICAvLyAtIEltYWdlIERlc2NyaXB0b3JcbiAgICBidWZbcCsrXSA9IDB4MmM7ICAvLyBJbWFnZSBTZXBlcmF0b3IuXG4gICAgYnVmW3ArK10gPSB4ICYgMHhmZjsgYnVmW3ArK10gPSB4ID4+IDggJiAweGZmOyAgLy8gTGVmdC5cbiAgICBidWZbcCsrXSA9IHkgJiAweGZmOyBidWZbcCsrXSA9IHkgPj4gOCAmIDB4ZmY7ICAvLyBUb3AuXG4gICAgYnVmW3ArK10gPSB3ICYgMHhmZjsgYnVmW3ArK10gPSB3ID4+IDggJiAweGZmO1xuICAgIGJ1ZltwKytdID0gaCAmIDB4ZmY7IGJ1ZltwKytdID0gaCA+PiA4ICYgMHhmZjtcbiAgICAvLyBOT1RFOiBObyBzb3J0IGZsYWcgKHVudXNlZD8pLlxuICAgIC8vIFRPRE8oZGVhbm0pOiBTdXBwb3J0IGludGVybGFjZS5cbiAgICBidWZbcCsrXSA9IHVzaW5nX2xvY2FsX3BhbGV0dGUgPT09IHRydWUgPyAoMHg4MCB8IChtaW5fY29kZV9zaXplLTEpKSA6IDA7XG5cbiAgICAvLyAtIExvY2FsIENvbG9yIFRhYmxlXG4gICAgaWYgKHVzaW5nX2xvY2FsX3BhbGV0dGUgPT09IHRydWUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBpbCA9IHBhbGV0dGUubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgICAgICB2YXIgcmdiID0gcGFsZXR0ZVtpXTtcbiAgICAgICAgYnVmW3ArK10gPSByZ2IgPj4gMTYgJiAweGZmO1xuICAgICAgICBidWZbcCsrXSA9IHJnYiA+PiA4ICYgMHhmZjtcbiAgICAgICAgYnVmW3ArK10gPSByZ2IgJiAweGZmO1xuICAgICAgfVxuICAgIH1cblxuICAgIHAgPSBHaWZXcml0ZXJPdXRwdXRMWldDb2RlU3RyZWFtKFxuICAgICAgICAgICAgYnVmLCBwLCBtaW5fY29kZV9zaXplIDwgMiA/IDIgOiBtaW5fY29kZV9zaXplLCBpbmRleGVkX3BpeGVscyk7XG5cbiAgICByZXR1cm4gcDtcbiAgfTtcblxuICB0aGlzLmVuZCA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChlbmRlZCA9PT0gZmFsc2UpIHtcbiAgICAgIGJ1ZltwKytdID0gMHgzYjsgIC8vIFRyYWlsZXIuXG4gICAgICBlbmRlZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9O1xuXG4gIHRoaXMuZ2V0T3V0cHV0QnVmZmVyID0gZnVuY3Rpb24oKSB7IHJldHVybiBidWY7IH07XG4gIHRoaXMuc2V0T3V0cHV0QnVmZmVyID0gZnVuY3Rpb24odikgeyBidWYgPSB2OyB9O1xuICB0aGlzLmdldE91dHB1dEJ1ZmZlclBvc2l0aW9uID0gZnVuY3Rpb24oKSB7IHJldHVybiBwOyB9O1xuICB0aGlzLnNldE91dHB1dEJ1ZmZlclBvc2l0aW9uID0gZnVuY3Rpb24odikgeyBwID0gdjsgfTtcbn1cblxuLy8gTWFpbiBjb21wcmVzc2lvbiByb3V0aW5lLCBwYWxldHRlIGluZGV4ZXMgLT4gTFpXIGNvZGUgc3RyZWFtLlxuLy8gfGluZGV4X3N0cmVhbXwgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBlbnRyeS5cbmZ1bmN0aW9uIEdpZldyaXRlck91dHB1dExaV0NvZGVTdHJlYW0oYnVmLCBwLCBtaW5fY29kZV9zaXplLCBpbmRleF9zdHJlYW0pIHtcbiAgYnVmW3ArK10gPSBtaW5fY29kZV9zaXplO1xuICB2YXIgY3VyX3N1YmJsb2NrID0gcCsrOyAgLy8gUG9pbnRpbmcgYXQgdGhlIGxlbmd0aCBmaWVsZC5cblxuICB2YXIgY2xlYXJfY29kZSA9IDEgPDwgbWluX2NvZGVfc2l6ZTtcbiAgdmFyIGNvZGVfbWFzayA9IGNsZWFyX2NvZGUgLSAxO1xuICB2YXIgZW9pX2NvZGUgPSBjbGVhcl9jb2RlICsgMTtcbiAgdmFyIG5leHRfY29kZSA9IGVvaV9jb2RlICsgMTtcblxuICB2YXIgY3VyX2NvZGVfc2l6ZSA9IG1pbl9jb2RlX3NpemUgKyAxOyAgLy8gTnVtYmVyIG9mIGJpdHMgcGVyIGNvZGUuXG4gIHZhciBjdXJfc2hpZnQgPSAwO1xuICAvLyBXZSBoYXZlIGF0IG1vc3QgMTItYml0IGNvZGVzLCBzbyB3ZSBzaG91bGQgaGF2ZSB0byBob2xkIGEgbWF4IG9mIDE5XG4gIC8vIGJpdHMgaGVyZSAoYW5kIHRoZW4gd2Ugd291bGQgd3JpdGUgb3V0KS5cbiAgdmFyIGN1ciA9IDA7XG5cbiAgZnVuY3Rpb24gZW1pdF9ieXRlc190b19idWZmZXIoYml0X2Jsb2NrX3NpemUpIHtcbiAgICB3aGlsZSAoY3VyX3NoaWZ0ID49IGJpdF9ibG9ja19zaXplKSB7XG4gICAgICBidWZbcCsrXSA9IGN1ciAmIDB4ZmY7XG4gICAgICBjdXIgPj49IDg7IGN1cl9zaGlmdCAtPSA4O1xuICAgICAgaWYgKHAgPT09IGN1cl9zdWJibG9jayArIDI1NikgeyAgLy8gRmluaXNoZWQgYSBzdWJibG9jay5cbiAgICAgICAgYnVmW2N1cl9zdWJibG9ja10gPSAyNTU7XG4gICAgICAgIGN1cl9zdWJibG9jayA9IHArKztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBlbWl0X2NvZGUoYykge1xuICAgIGN1ciB8PSBjIDw8IGN1cl9zaGlmdDtcbiAgICBjdXJfc2hpZnQgKz0gY3VyX2NvZGVfc2l6ZTtcbiAgICBlbWl0X2J5dGVzX3RvX2J1ZmZlcig4KTtcbiAgfVxuXG4gIC8vIEkgYW0gbm90IGFuIGV4cGVydCBvbiB0aGUgdG9waWMsIGFuZCBJIGRvbid0IHdhbnQgdG8gd3JpdGUgYSB0aGVzaXMuXG4gIC8vIEhvd2V2ZXIsIGl0IGlzIGdvb2QgdG8gb3V0bGluZSBoZXJlIHRoZSBiYXNpYyBhbGdvcml0aG0gYW5kIHRoZSBmZXcgZGF0YVxuICAvLyBzdHJ1Y3R1cmVzIGFuZCBvcHRpbWl6YXRpb25zIGhlcmUgdGhhdCBtYWtlIHRoaXMgaW1wbGVtZW50YXRpb24gZmFzdC5cbiAgLy8gVGhlIGJhc2ljIGlkZWEgYmVoaW5kIExaVyBpcyB0byBidWlsZCBhIHRhYmxlIG9mIHByZXZpb3VzbHkgc2VlbiBydW5zXG4gIC8vIGFkZHJlc3NlZCBieSBhIHNob3J0IGlkIChoZXJlaW4gY2FsbGVkIG91dHB1dCBjb2RlKS4gIEFsbCBkYXRhIGlzXG4gIC8vIHJlZmVyZW5jZWQgYnkgYSBjb2RlLCB3aGljaCByZXByZXNlbnRzIG9uZSBvciBtb3JlIHZhbHVlcyBmcm9tIHRoZVxuICAvLyBvcmlnaW5hbCBpbnB1dCBzdHJlYW0uICBBbGwgaW5wdXQgYnl0ZXMgY2FuIGJlIHJlZmVyZW5jZWQgYXMgdGhlIHNhbWVcbiAgLy8gdmFsdWUgYXMgYW4gb3V0cHV0IGNvZGUuICBTbyBpZiB5b3UgZGlkbid0IHdhbnQgYW55IGNvbXByZXNzaW9uLCB5b3VcbiAgLy8gY291bGQgbW9yZSBvciBsZXNzIGp1c3Qgb3V0cHV0IHRoZSBvcmlnaW5hbCBieXRlcyBhcyBjb2RlcyAodGhlcmUgYXJlXG4gIC8vIHNvbWUgZGV0YWlscyB0byB0aGlzLCBidXQgaXQgaXMgdGhlIGlkZWEpLiAgSW4gb3JkZXIgdG8gYWNoaWV2ZVxuICAvLyBjb21wcmVzc2lvbiwgdmFsdWVzIGdyZWF0ZXIgdGhlbiB0aGUgaW5wdXQgcmFuZ2UgKGNvZGVzIGNhbiBiZSB1cCB0b1xuICAvLyAxMi1iaXQgd2hpbGUgaW5wdXQgb25seSA4LWJpdCkgcmVwcmVzZW50IGEgc2VxdWVuY2Ugb2YgcHJldmlvdXNseSBzZWVuXG4gIC8vIGlucHV0cy4gIFRoZSBkZWNvbXByZXNzb3IgaXMgYWJsZSB0byBidWlsZCB0aGUgc2FtZSBtYXBwaW5nIHdoaWxlXG4gIC8vIGRlY29kaW5nLCBzbyB0aGVyZSBpcyBhbHdheXMgYSBzaGFyZWQgY29tbW9uIGtub3dsZWRnZSBiZXR3ZWVuIHRoZVxuICAvLyBlbmNvZGluZyBhbmQgZGVjb2Rlciwgd2hpY2ggaXMgYWxzbyBpbXBvcnRhbnQgZm9yIFwidGltaW5nXCIgYXNwZWN0cyBsaWtlXG4gIC8vIGhvdyB0byBoYW5kbGUgdmFyaWFibGUgYml0IHdpZHRoIGNvZGUgZW5jb2RpbmcuXG4gIC8vXG4gIC8vIE9uZSBvYnZpb3VzIGJ1dCB2ZXJ5IGltcG9ydGFudCBjb25zZXF1ZW5jZSBvZiB0aGUgdGFibGUgc3lzdGVtIGlzIHRoZXJlXG4gIC8vIGlzIGFsd2F5cyBhIHVuaXF1ZSBpZCAoYXQgbW9zdCAxMi1iaXRzKSB0byBtYXAgdGhlIHJ1bnMuICAnQScgbWlnaHQgYmVcbiAgLy8gNCwgdGhlbiAnQUEnIG1pZ2h0IGJlIDEwLCAnQUFBJyAxMSwgJ0FBQUEnIDEyLCBldGMuICBUaGlzIHJlbGF0aW9uc2hpcFxuICAvLyBjYW4gYmUgdXNlZCBmb3IgYW4gZWZmZWNpZW50IGxvb2t1cCBzdHJhdGVneSBmb3IgdGhlIGNvZGUgbWFwcGluZy4gIFdlXG4gIC8vIG5lZWQgdG8ga25vdyBpZiBhIHJ1biBoYXMgYmVlbiBzZWVuIGJlZm9yZSwgYW5kIGJlIGFibGUgdG8gbWFwIHRoYXQgcnVuXG4gIC8vIHRvIHRoZSBvdXRwdXQgY29kZS4gIFNpbmNlIHdlIHN0YXJ0IHdpdGgga25vd24gdW5pcXVlIGlkcyAoaW5wdXQgYnl0ZXMpLFxuICAvLyBhbmQgdGhlbiBmcm9tIHRob3NlIGJ1aWxkIG1vcmUgdW5pcXVlIGlkcyAodGFibGUgZW50cmllcyksIHdlIGNhblxuICAvLyBjb250aW51ZSB0aGlzIGNoYWluIChhbG1vc3QgbGlrZSBhIGxpbmtlZCBsaXN0KSB0byBhbHdheXMgaGF2ZSBzbWFsbFxuICAvLyBpbnRlZ2VyIHZhbHVlcyB0aGF0IHJlcHJlc2VudCB0aGUgY3VycmVudCBieXRlIGNoYWlucyBpbiB0aGUgZW5jb2Rlci5cbiAgLy8gVGhpcyBtZWFucyBpbnN0ZWFkIG9mIHRyYWNraW5nIHRoZSBpbnB1dCBieXRlcyAoQUFBQUJDRCkgdG8ga25vdyBvdXJcbiAgLy8gY3VycmVudCBzdGF0ZSwgd2UgY2FuIHRyYWNrIHRoZSB0YWJsZSBlbnRyeSBmb3IgQUFBQUJDIChpdCBpcyBndWFyYW50ZWVkXG4gIC8vIHRvIGV4aXN0IGJ5IHRoZSBuYXR1cmUgb2YgdGhlIGFsZ29yaXRobSkgYW5kIHRoZSBuZXh0IGNoYXJhY3RlciBELlxuICAvLyBUaGVyZWZvciB0aGUgdHVwbGUgb2YgKHRhYmxlX2VudHJ5LCBieXRlKSBpcyBndWFyYW50ZWVkIHRvIGFsc28gYmVcbiAgLy8gdW5pcXVlLiAgVGhpcyBhbGxvd3MgdXMgdG8gY3JlYXRlIGEgc2ltcGxlIGxvb2t1cCBrZXkgZm9yIG1hcHBpbmcgaW5wdXRcbiAgLy8gc2VxdWVuY2VzIHRvIGNvZGVzICh0YWJsZSBpbmRpY2VzKSB3aXRob3V0IGhhdmluZyB0byBzdG9yZSBvciBzZWFyY2hcbiAgLy8gYW55IG9mIHRoZSBjb2RlIHNlcXVlbmNlcy4gIFNvIGlmICdBQUFBJyBoYXMgYSB0YWJsZSBlbnRyeSBvZiAxMiwgdGhlXG4gIC8vIHR1cGxlIG9mICgnQUFBQScsIEspIGZvciBhbnkgaW5wdXQgYnl0ZSBLIHdpbGwgYmUgdW5pcXVlLCBhbmQgY2FuIGJlIG91clxuICAvLyBrZXkuICBUaGlzIGxlYWRzIHRvIGEgaW50ZWdlciB2YWx1ZSBhdCBtb3N0IDIwLWJpdHMsIHdoaWNoIGNhbiBhbHdheXNcbiAgLy8gZml0IGluIGFuIFNNSSB2YWx1ZSBhbmQgYmUgdXNlZCBhcyBhIGZhc3Qgc3BhcnNlIGFycmF5IC8gb2JqZWN0IGtleS5cblxuICAvLyBPdXRwdXQgY29kZSBmb3IgdGhlIGN1cnJlbnQgY29udGVudHMgb2YgdGhlIGluZGV4IGJ1ZmZlci5cbiAgdmFyIGliX2NvZGUgPSBpbmRleF9zdHJlYW1bMF0gJiBjb2RlX21hc2s7ICAvLyBMb2FkIGZpcnN0IGlucHV0IGluZGV4LlxuICB2YXIgY29kZV90YWJsZSA9IHsgfTsgIC8vIEtleSdkIG9uIG91ciAyMC1iaXQgXCJ0dXBsZVwiLlxuXG4gIGVtaXRfY29kZShjbGVhcl9jb2RlKTsgIC8vIFNwZWMgc2F5cyBmaXJzdCBjb2RlIHNob3VsZCBiZSBhIGNsZWFyIGNvZGUuXG5cbiAgLy8gRmlyc3QgaW5kZXggYWxyZWFkeSBsb2FkZWQsIHByb2Nlc3MgdGhlIHJlc3Qgb2YgdGhlIHN0cmVhbS5cbiAgZm9yICh2YXIgaSA9IDEsIGlsID0gaW5kZXhfc3RyZWFtLmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcbiAgICB2YXIgayA9IGluZGV4X3N0cmVhbVtpXSAmIGNvZGVfbWFzaztcbiAgICB2YXIgY3VyX2tleSA9IGliX2NvZGUgPDwgOCB8IGs7ICAvLyAocHJldiwgaykgdW5pcXVlIHR1cGxlLlxuICAgIHZhciBjdXJfY29kZSA9IGNvZGVfdGFibGVbY3VyX2tleV07ICAvLyBidWZmZXIgKyBrLlxuXG4gICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSB0byBjcmVhdGUgYSBuZXcgY29kZSB0YWJsZSBlbnRyeS5cbiAgICBpZiAoY3VyX2NvZGUgPT09IHVuZGVmaW5lZCkgeyAgLy8gV2UgZG9uJ3QgaGF2ZSBidWZmZXIgKyBrLlxuICAgICAgLy8gRW1pdCBpbmRleCBidWZmZXIgKHdpdGhvdXQgaykuXG4gICAgICAvLyBUaGlzIGlzIGFuIGlubGluZSB2ZXJzaW9uIG9mIGVtaXRfY29kZSwgYmVjYXVzZSB0aGlzIGlzIHRoZSBjb3JlXG4gICAgICAvLyB3cml0aW5nIHJvdXRpbmUgb2YgdGhlIGNvbXByZXNzb3IgKGFuZCBWOCBjYW5ub3QgaW5saW5lIGVtaXRfY29kZVxuICAgICAgLy8gYmVjYXVzZSBpdCBpcyBhIGNsb3N1cmUgaGVyZSBpbiBhIGRpZmZlcmVudCBjb250ZXh0KS4gIEFkZGl0aW9uYWxseVxuICAgICAgLy8gd2UgY2FuIGNhbGwgZW1pdF9ieXRlX3RvX2J1ZmZlciBsZXNzIG9mdGVuLCBiZWNhdXNlIHdlIGNhbiBoYXZlXG4gICAgICAvLyAzMC1iaXRzIChmcm9tIG91ciAzMS1iaXQgc2lnbmVkIFNNSSksIGFuZCB3ZSBrbm93IG91ciBjb2RlcyB3aWxsIG9ubHlcbiAgICAgIC8vIGJlIDEyLWJpdHMsIHNvIGNhbiBzYWZlbHkgaGF2ZSAxOC1iaXRzIHRoZXJlIHdpdGhvdXQgb3ZlcmZsb3cuXG4gICAgICAvLyBlbWl0X2NvZGUoaWJfY29kZSk7XG4gICAgICBjdXIgfD0gaWJfY29kZSA8PCBjdXJfc2hpZnQ7XG4gICAgICBjdXJfc2hpZnQgKz0gY3VyX2NvZGVfc2l6ZTtcbiAgICAgIHdoaWxlIChjdXJfc2hpZnQgPj0gOCkge1xuICAgICAgICBidWZbcCsrXSA9IGN1ciAmIDB4ZmY7XG4gICAgICAgIGN1ciA+Pj0gODsgY3VyX3NoaWZ0IC09IDg7XG4gICAgICAgIGlmIChwID09PSBjdXJfc3ViYmxvY2sgKyAyNTYpIHsgIC8vIEZpbmlzaGVkIGEgc3ViYmxvY2suXG4gICAgICAgICAgYnVmW2N1cl9zdWJibG9ja10gPSAyNTU7XG4gICAgICAgICAgY3VyX3N1YmJsb2NrID0gcCsrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXh0X2NvZGUgPT09IDQwOTYpIHsgIC8vIFRhYmxlIGZ1bGwsIG5lZWQgYSBjbGVhci5cbiAgICAgICAgZW1pdF9jb2RlKGNsZWFyX2NvZGUpO1xuICAgICAgICBuZXh0X2NvZGUgPSBlb2lfY29kZSArIDE7XG4gICAgICAgIGN1cl9jb2RlX3NpemUgPSBtaW5fY29kZV9zaXplICsgMTtcbiAgICAgICAgY29kZV90YWJsZSA9IHsgfTtcbiAgICAgIH0gZWxzZSB7ICAvLyBUYWJsZSBub3QgZnVsbCwgaW5zZXJ0IGEgbmV3IGVudHJ5LlxuICAgICAgICAvLyBJbmNyZWFzZSBvdXIgdmFyaWFibGUgYml0IGNvZGUgc2l6ZXMgaWYgbmVjZXNzYXJ5LiAgVGhpcyBpcyBhIGJpdFxuICAgICAgICAvLyB0cmlja3kgYXMgaXQgaXMgYmFzZWQgb24gXCJ0aW1pbmdcIiBiZXR3ZWVuIHRoZSBlbmNvZGluZyBhbmRcbiAgICAgICAgLy8gZGVjb2Rlci4gIEZyb20gdGhlIGVuY29kZXJzIHBlcnNwZWN0aXZlIHRoaXMgc2hvdWxkIGhhcHBlbiBhZnRlclxuICAgICAgICAvLyB3ZSd2ZSBhbHJlYWR5IGVtaXR0ZWQgdGhlIGluZGV4IGJ1ZmZlciBhbmQgYXJlIGFib3V0IHRvIGNyZWF0ZSB0aGVcbiAgICAgICAgLy8gZmlyc3QgdGFibGUgZW50cnkgdGhhdCB3b3VsZCBvdmVyZmxvdyBvdXIgY3VycmVudCBjb2RlIGJpdCBzaXplLlxuICAgICAgICBpZiAobmV4dF9jb2RlID49ICgxIDw8IGN1cl9jb2RlX3NpemUpKSArK2N1cl9jb2RlX3NpemU7XG4gICAgICAgIGNvZGVfdGFibGVbY3VyX2tleV0gPSBuZXh0X2NvZGUrKzsgIC8vIEluc2VydCBpbnRvIGNvZGUgdGFibGUuXG4gICAgICB9XG5cbiAgICAgIGliX2NvZGUgPSBrOyAgLy8gSW5kZXggYnVmZmVyIHRvIHNpbmdsZSBpbnB1dCBrLlxuICAgIH0gZWxzZSB7XG4gICAgICBpYl9jb2RlID0gY3VyX2NvZGU7ICAvLyBJbmRleCBidWZmZXIgdG8gc2VxdWVuY2UgaW4gY29kZSB0YWJsZS5cbiAgICB9XG4gIH1cblxuICBlbWl0X2NvZGUoaWJfY29kZSk7ICAvLyBUaGVyZSB3aWxsIHN0aWxsIGJlIHNvbWV0aGluZyBpbiB0aGUgaW5kZXggYnVmZmVyLlxuICBlbWl0X2NvZGUoZW9pX2NvZGUpOyAgLy8gRW5kIE9mIEluZm9ybWF0aW9uLlxuXG4gIC8vIEZsdXNoIC8gZmluYWxpemUgdGhlIHN1Yi1ibG9ja3Mgc3RyZWFtIHRvIHRoZSBidWZmZXIuXG4gIGVtaXRfYnl0ZXNfdG9fYnVmZmVyKDEpO1xuXG4gIC8vIEZpbmlzaCB0aGUgc3ViLWJsb2Nrcywgd3JpdGluZyBvdXQgYW55IHVuZmluaXNoZWQgbGVuZ3RocyBhbmRcbiAgLy8gdGVybWluYXRpbmcgd2l0aCBhIHN1Yi1ibG9jayBvZiBsZW5ndGggMC4gIElmIHdlIGhhdmUgYWxyZWFkeSBzdGFydGVkXG4gIC8vIGJ1dCBub3QgeWV0IHVzZWQgYSBzdWItYmxvY2sgaXQgY2FuIGp1c3QgYmVjb21lIHRoZSB0ZXJtaW5hdG9yLlxuICBpZiAoY3VyX3N1YmJsb2NrICsgMSA9PT0gcCkgeyAgLy8gU3RhcnRlZCBidXQgdW51c2VkLlxuICAgIGJ1ZltjdXJfc3ViYmxvY2tdID0gMDtcbiAgfSBlbHNlIHsgIC8vIFN0YXJ0ZWQgYW5kIHVzZWQsIHdyaXRlIGxlbmd0aCBhbmQgYWRkaXRpb25hbCB0ZXJtaW5hdG9yIGJsb2NrLlxuICAgIGJ1ZltjdXJfc3ViYmxvY2tdID0gcCAtIGN1cl9zdWJibG9jayAtIDE7XG4gICAgYnVmW3ArK10gPSAwO1xuICB9XG4gIHJldHVybiBwO1xufVxuXG5mdW5jdGlvbiBHaWZSZWFkZXIoYnVmKSB7XG4gIHZhciBwID0gMDtcblxuICAvLyAtIEhlYWRlciAoR0lGODdhIG9yIEdJRjg5YSkuXG4gIGlmIChidWZbcCsrXSAhPT0gMHg0NyB8fCAgICAgICAgICAgIGJ1ZltwKytdICE9PSAweDQ5IHx8IGJ1ZltwKytdICE9PSAweDQ2IHx8XG4gICAgICBidWZbcCsrXSAhPT0gMHgzOCB8fCAoYnVmW3ArK10rMSAmIDB4ZmQpICE9PSAweDM4IHx8IGJ1ZltwKytdICE9PSAweDYxKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBHSUYgODdhLzg5YSBoZWFkZXIuXCIpO1xuICB9XG5cbiAgLy8gLSBMb2dpY2FsIFNjcmVlbiBEZXNjcmlwdG9yLlxuICB2YXIgd2lkdGggPSBidWZbcCsrXSB8IGJ1ZltwKytdIDw8IDg7XG4gIHZhciBoZWlnaHQgPSBidWZbcCsrXSB8IGJ1ZltwKytdIDw8IDg7XG4gIHZhciBwZjAgPSBidWZbcCsrXTsgIC8vIDxQYWNrZWQgRmllbGRzPi5cbiAgdmFyIGdsb2JhbF9wYWxldHRlX2ZsYWcgPSBwZjAgPj4gNztcbiAgdmFyIG51bV9nbG9iYWxfY29sb3JzX3BvdzIgPSBwZjAgJiAweDc7XG4gIHZhciBudW1fZ2xvYmFsX2NvbG9ycyA9IDEgPDwgKG51bV9nbG9iYWxfY29sb3JzX3BvdzIgKyAxKTtcbiAgdmFyIGJhY2tncm91bmQgPSBidWZbcCsrXTtcbiAgYnVmW3ArK107ICAvLyBQaXhlbCBhc3BlY3QgcmF0aW8gKHVudXNlZD8pLlxuXG4gIHZhciBnbG9iYWxfcGFsZXR0ZV9vZmZzZXQgPSBudWxsO1xuICB2YXIgZ2xvYmFsX3BhbGV0dGVfc2l6ZSAgID0gbnVsbDtcblxuICBpZiAoZ2xvYmFsX3BhbGV0dGVfZmxhZykge1xuICAgIGdsb2JhbF9wYWxldHRlX29mZnNldCA9IHA7XG4gICAgZ2xvYmFsX3BhbGV0dGVfc2l6ZSA9IG51bV9nbG9iYWxfY29sb3JzO1xuICAgIHAgKz0gbnVtX2dsb2JhbF9jb2xvcnMgKiAzOyAgLy8gU2VlayBwYXN0IHBhbGV0dGUuXG4gIH1cblxuICB2YXIgbm9fZW9mID0gdHJ1ZTtcblxuICB2YXIgZnJhbWVzID0gWyBdO1xuXG4gIHZhciBkZWxheSA9IDA7XG4gIHZhciB0cmFuc3BhcmVudF9pbmRleCA9IG51bGw7XG4gIHZhciBkaXNwb3NhbCA9IDA7ICAvLyAwIC0gTm8gZGlzcG9zYWwgc3BlY2lmaWVkLlxuICB2YXIgbG9vcF9jb3VudCA9IG51bGw7XG5cbiAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICB0aGlzLmhlaWdodCA9IGhlaWdodDtcblxuICB3aGlsZSAobm9fZW9mICYmIHAgPCBidWYubGVuZ3RoKSB7XG4gICAgc3dpdGNoIChidWZbcCsrXSkge1xuICAgICAgY2FzZSAweDIxOiAgLy8gR3JhcGhpY3MgQ29udHJvbCBFeHRlbnNpb24gQmxvY2tcbiAgICAgICAgc3dpdGNoIChidWZbcCsrXSkge1xuICAgICAgICAgIGNhc2UgMHhmZjogIC8vIEFwcGxpY2F0aW9uIHNwZWNpZmljIGJsb2NrXG4gICAgICAgICAgICAvLyBUcnkgaWYgaXQncyBhIE5ldHNjYXBlIGJsb2NrICh3aXRoIGFuaW1hdGlvbiBsb29wIGNvdW50ZXIpLlxuICAgICAgICAgICAgaWYgKGJ1ZltwICAgXSAhPT0gMHgwYiB8fCAgLy8gMjEgRkYgYWxyZWFkeSByZWFkLCBjaGVjayBibG9jayBzaXplLlxuICAgICAgICAgICAgICAgIC8vIE5FVFNDQVBFMi4wXG4gICAgICAgICAgICAgICAgYnVmW3ArMSBdID09IDB4NGUgJiYgYnVmW3ArMiBdID09IDB4NDUgJiYgYnVmW3ArMyBdID09IDB4NTQgJiZcbiAgICAgICAgICAgICAgICBidWZbcCs0IF0gPT0gMHg1MyAmJiBidWZbcCs1IF0gPT0gMHg0MyAmJiBidWZbcCs2IF0gPT0gMHg0MSAmJlxuICAgICAgICAgICAgICAgIGJ1ZltwKzcgXSA9PSAweDUwICYmIGJ1ZltwKzggXSA9PSAweDQ1ICYmIGJ1ZltwKzkgXSA9PSAweDMyICYmXG4gICAgICAgICAgICAgICAgYnVmW3ArMTBdID09IDB4MmUgJiYgYnVmW3ArMTFdID09IDB4MzAgJiZcbiAgICAgICAgICAgICAgICAvLyBTdWItYmxvY2tcbiAgICAgICAgICAgICAgICBidWZbcCsxMl0gPT0gMHgwMyAmJiBidWZbcCsxM10gPT0gMHgwMSAmJiBidWZbcCsxNl0gPT0gMCkge1xuICAgICAgICAgICAgICBwICs9IDE0O1xuICAgICAgICAgICAgICBsb29wX2NvdW50ID0gYnVmW3ArK10gfCBidWZbcCsrXSA8PCA4O1xuICAgICAgICAgICAgICBwKys7ICAvLyBTa2lwIHRlcm1pbmF0b3IuXG4gICAgICAgICAgICB9IGVsc2UgeyAgLy8gV2UgZG9uJ3Qga25vdyB3aGF0IGl0IGlzLCBqdXN0IHRyeSB0byBnZXQgcGFzdCBpdC5cbiAgICAgICAgICAgICAgcCArPSAxMjtcbiAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHsgIC8vIFNlZWsgdGhyb3VnaCBzdWJibG9ja3MuXG4gICAgICAgICAgICAgICAgdmFyIGJsb2NrX3NpemUgPSBidWZbcCsrXTtcbiAgICAgICAgICAgICAgICAvLyBCYWQgYmxvY2sgc2l6ZSAoZXg6IHVuZGVmaW5lZCBmcm9tIGFuIG91dCBvZiBib3VuZHMgcmVhZCkuXG4gICAgICAgICAgICAgICAgaWYgKCEoYmxvY2tfc2l6ZSA+PSAwKSkgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIGJsb2NrIHNpemVcIik7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrX3NpemUgPT09IDApIGJyZWFrOyAgLy8gMCBzaXplIGlzIHRlcm1pbmF0b3JcbiAgICAgICAgICAgICAgICBwICs9IGJsb2NrX3NpemU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAweGY5OiAgLy8gR3JhcGhpY3MgQ29udHJvbCBFeHRlbnNpb25cbiAgICAgICAgICAgIGlmIChidWZbcCsrXSAhPT0gMHg0IHx8IGJ1ZltwKzRdICE9PSAwKVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGdyYXBoaWNzIGV4dGVuc2lvbiBibG9jay5cIik7XG4gICAgICAgICAgICB2YXIgcGYxID0gYnVmW3ArK107XG4gICAgICAgICAgICBkZWxheSA9IGJ1ZltwKytdIHwgYnVmW3ArK10gPDwgODtcbiAgICAgICAgICAgIHRyYW5zcGFyZW50X2luZGV4ID0gYnVmW3ArK107XG4gICAgICAgICAgICBpZiAoKHBmMSAmIDEpID09PSAwKSB0cmFuc3BhcmVudF9pbmRleCA9IG51bGw7XG4gICAgICAgICAgICBkaXNwb3NhbCA9IHBmMSA+PiAyICYgMHg3O1xuICAgICAgICAgICAgcCsrOyAgLy8gU2tpcCB0ZXJtaW5hdG9yLlxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDB4ZmU6ICAvLyBDb21tZW50IEV4dGVuc2lvbi5cbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7ICAvLyBTZWVrIHRocm91Z2ggc3ViYmxvY2tzLlxuICAgICAgICAgICAgICB2YXIgYmxvY2tfc2l6ZSA9IGJ1ZltwKytdO1xuICAgICAgICAgICAgICAvLyBCYWQgYmxvY2sgc2l6ZSAoZXg6IHVuZGVmaW5lZCBmcm9tIGFuIG91dCBvZiBib3VuZHMgcmVhZCkuXG4gICAgICAgICAgICAgIGlmICghKGJsb2NrX3NpemUgPj0gMCkpIHRocm93IEVycm9yKFwiSW52YWxpZCBibG9jayBzaXplXCIpO1xuICAgICAgICAgICAgICBpZiAoYmxvY2tfc2l6ZSA9PT0gMCkgYnJlYWs7ICAvLyAwIHNpemUgaXMgdGVybWluYXRvclxuICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhidWYuc2xpY2UocCwgcCtibG9ja19zaXplKS50b1N0cmluZygnYXNjaWknKSk7XG4gICAgICAgICAgICAgIHAgKz0gYmxvY2tfc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIlVua25vd24gZ3JhcGhpYyBjb250cm9sIGxhYmVsOiAweFwiICsgYnVmW3AtMV0udG9TdHJpbmcoMTYpKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAweDJjOiAgLy8gSW1hZ2UgRGVzY3JpcHRvci5cbiAgICAgICAgdmFyIHggPSBidWZbcCsrXSB8IGJ1ZltwKytdIDw8IDg7XG4gICAgICAgIHZhciB5ID0gYnVmW3ArK10gfCBidWZbcCsrXSA8PCA4O1xuICAgICAgICB2YXIgdyA9IGJ1ZltwKytdIHwgYnVmW3ArK10gPDwgODtcbiAgICAgICAgdmFyIGggPSBidWZbcCsrXSB8IGJ1ZltwKytdIDw8IDg7XG4gICAgICAgIHZhciBwZjIgPSBidWZbcCsrXTtcbiAgICAgICAgdmFyIGxvY2FsX3BhbGV0dGVfZmxhZyA9IHBmMiA+PiA3O1xuICAgICAgICB2YXIgaW50ZXJsYWNlX2ZsYWcgPSBwZjIgPj4gNiAmIDE7XG4gICAgICAgIHZhciBudW1fbG9jYWxfY29sb3JzX3BvdzIgPSBwZjIgJiAweDc7XG4gICAgICAgIHZhciBudW1fbG9jYWxfY29sb3JzID0gMSA8PCAobnVtX2xvY2FsX2NvbG9yc19wb3cyICsgMSk7XG4gICAgICAgIHZhciBwYWxldHRlX29mZnNldCA9IGdsb2JhbF9wYWxldHRlX29mZnNldDtcbiAgICAgICAgdmFyIHBhbGV0dGVfc2l6ZSA9IGdsb2JhbF9wYWxldHRlX3NpemU7XG4gICAgICAgIHZhciBoYXNfbG9jYWxfcGFsZXR0ZSA9IGZhbHNlO1xuICAgICAgICBpZiAobG9jYWxfcGFsZXR0ZV9mbGFnKSB7XG4gICAgICAgICAgdmFyIGhhc19sb2NhbF9wYWxldHRlID0gdHJ1ZTtcbiAgICAgICAgICBwYWxldHRlX29mZnNldCA9IHA7ICAvLyBPdmVycmlkZSB3aXRoIGxvY2FsIHBhbGV0dGUuXG4gICAgICAgICAgcGFsZXR0ZV9zaXplID0gbnVtX2xvY2FsX2NvbG9ycztcbiAgICAgICAgICBwICs9IG51bV9sb2NhbF9jb2xvcnMgKiAzOyAgLy8gU2VlayBwYXN0IHBhbGV0dGUuXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGF0YV9vZmZzZXQgPSBwO1xuXG4gICAgICAgIHArKzsgIC8vIGNvZGVzaXplXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgdmFyIGJsb2NrX3NpemUgPSBidWZbcCsrXTtcbiAgICAgICAgICAvLyBCYWQgYmxvY2sgc2l6ZSAoZXg6IHVuZGVmaW5lZCBmcm9tIGFuIG91dCBvZiBib3VuZHMgcmVhZCkuXG4gICAgICAgICAgaWYgKCEoYmxvY2tfc2l6ZSA+PSAwKSkgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIGJsb2NrIHNpemVcIik7XG4gICAgICAgICAgaWYgKGJsb2NrX3NpemUgPT09IDApIGJyZWFrOyAgLy8gMCBzaXplIGlzIHRlcm1pbmF0b3JcbiAgICAgICAgICBwICs9IGJsb2NrX3NpemU7XG4gICAgICAgIH1cblxuICAgICAgICBmcmFtZXMucHVzaCh7eDogeCwgeTogeSwgd2lkdGg6IHcsIGhlaWdodDogaCxcbiAgICAgICAgICAgICAgICAgICAgIGhhc19sb2NhbF9wYWxldHRlOiBoYXNfbG9jYWxfcGFsZXR0ZSxcbiAgICAgICAgICAgICAgICAgICAgIHBhbGV0dGVfb2Zmc2V0OiBwYWxldHRlX29mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgIHBhbGV0dGVfc2l6ZTogcGFsZXR0ZV9zaXplLFxuICAgICAgICAgICAgICAgICAgICAgZGF0YV9vZmZzZXQ6IGRhdGFfb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgZGF0YV9sZW5ndGg6IHAgLSBkYXRhX29mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgIHRyYW5zcGFyZW50X2luZGV4OiB0cmFuc3BhcmVudF9pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgIGludGVybGFjZWQ6ICEhaW50ZXJsYWNlX2ZsYWcsXG4gICAgICAgICAgICAgICAgICAgICBkZWxheTogZGVsYXksXG4gICAgICAgICAgICAgICAgICAgICBkaXNwb3NhbDogZGlzcG9zYWx9KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMHgzYjogIC8vIFRyYWlsZXIgTWFya2VyIChlbmQgb2YgZmlsZSkuXG4gICAgICAgIG5vX2VvZiA9IGZhbHNlO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBnaWYgYmxvY2s6IDB4XCIgKyBidWZbcC0xXS50b1N0cmluZygxNikpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB0aGlzLm51bUZyYW1lcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmcmFtZXMubGVuZ3RoO1xuICB9O1xuXG4gIHRoaXMubG9vcENvdW50ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGxvb3BfY291bnQ7XG4gIH07XG5cbiAgdGhpcy5mcmFtZUluZm8gPSBmdW5jdGlvbihmcmFtZV9udW0pIHtcbiAgICBpZiAoZnJhbWVfbnVtIDwgMCB8fCBmcmFtZV9udW0gPj0gZnJhbWVzLmxlbmd0aClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZyYW1lIGluZGV4IG91dCBvZiByYW5nZS5cIik7XG4gICAgcmV0dXJuIGZyYW1lc1tmcmFtZV9udW1dO1xuICB9XG5cbiAgdGhpcy5kZWNvZGVBbmRCbGl0RnJhbWVCR1JBID0gZnVuY3Rpb24oZnJhbWVfbnVtLCBwaXhlbHMpIHtcbiAgICB2YXIgZnJhbWUgPSB0aGlzLmZyYW1lSW5mbyhmcmFtZV9udW0pO1xuICAgIHZhciBudW1fcGl4ZWxzID0gZnJhbWUud2lkdGggKiBmcmFtZS5oZWlnaHQ7XG4gICAgdmFyIGluZGV4X3N0cmVhbSA9IG5ldyBVaW50OEFycmF5KG51bV9waXhlbHMpOyAgLy8gQXQgbW9zdCA4LWJpdCBpbmRpY2VzLlxuICAgIEdpZlJlYWRlckxaV091dHB1dEluZGV4U3RyZWFtKFxuICAgICAgICBidWYsIGZyYW1lLmRhdGFfb2Zmc2V0LCBpbmRleF9zdHJlYW0sIG51bV9waXhlbHMpO1xuICAgIHZhciBwYWxldHRlX29mZnNldCA9IGZyYW1lLnBhbGV0dGVfb2Zmc2V0O1xuXG4gICAgLy8gTk9URShkZWFubSk6IEl0IHNlZW1zIHRvIGJlIG11Y2ggZmFzdGVyIHRvIGNvbXBhcmUgaW5kZXggdG8gMjU2IHRoYW5cbiAgICAvLyB0byA9PT0gbnVsbC4gIE5vdCBzdXJlIHdoeSwgYnV0IENvbXBhcmVTdHViX0VRX1NUUklDVCBzaG93cyB1cCBoaWdoIGluXG4gICAgLy8gdGhlIHByb2ZpbGUsIG5vdCBzdXJlIGlmIGl0J3MgcmVsYXRlZCB0byB1c2luZyBhIFVpbnQ4QXJyYXkuXG4gICAgdmFyIHRyYW5zID0gZnJhbWUudHJhbnNwYXJlbnRfaW5kZXg7XG4gICAgaWYgKHRyYW5zID09PSBudWxsKSB0cmFucyA9IDI1NjtcblxuICAgIC8vIFdlIGFyZSBwb3NzaWJseSBqdXN0IGJsaXR0aW5nIHRvIGEgcG9ydGlvbiBvZiB0aGUgZW50aXJlIGZyYW1lLlxuICAgIC8vIFRoYXQgaXMgYSBzdWJyZWN0IHdpdGhpbiB0aGUgZnJhbWVyZWN0LCBzbyB0aGUgYWRkaXRpb25hbCBwaXhlbHNcbiAgICAvLyBtdXN0IGJlIHNraXBwZWQgb3ZlciBhZnRlciB3ZSBmaW5pc2hlZCBhIHNjYW5saW5lLlxuICAgIHZhciBmcmFtZXdpZHRoICA9IGZyYW1lLndpZHRoO1xuICAgIHZhciBmcmFtZXN0cmlkZSA9IHdpZHRoIC0gZnJhbWV3aWR0aDtcbiAgICB2YXIgeGxlZnQgICAgICAgPSBmcmFtZXdpZHRoOyAgLy8gTnVtYmVyIG9mIHN1YnJlY3QgcGl4ZWxzIGxlZnQgaW4gc2NhbmxpbmUuXG5cbiAgICAvLyBPdXRwdXQgaW5kaWNpZXMgb2YgdGhlIHRvcCBsZWZ0IGFuZCBib3R0b20gcmlnaHQgY29ybmVycyBvZiB0aGUgc3VicmVjdC5cbiAgICB2YXIgb3BiZWcgPSAoKGZyYW1lLnkgKiB3aWR0aCkgKyBmcmFtZS54KSAqIDQ7XG4gICAgdmFyIG9wZW5kID0gKChmcmFtZS55ICsgZnJhbWUuaGVpZ2h0KSAqIHdpZHRoICsgZnJhbWUueCkgKiA0O1xuICAgIHZhciBvcCAgICA9IG9wYmVnO1xuXG4gICAgdmFyIHNjYW5zdHJpZGUgPSBmcmFtZXN0cmlkZSAqIDQ7XG5cbiAgICAvLyBVc2Ugc2NhbnN0cmlkZSB0byBza2lwIHBhc3QgdGhlIHJvd3Mgd2hlbiBpbnRlcmxhY2luZy4gIFRoaXMgaXMgc2tpcHBpbmdcbiAgICAvLyA3IHJvd3MgZm9yIHRoZSBmaXJzdCB0d28gcGFzc2VzLCB0aGVuIDMgdGhlbiAxLlxuICAgIGlmIChmcmFtZS5pbnRlcmxhY2VkID09PSB0cnVlKSB7XG4gICAgICBzY2Fuc3RyaWRlICs9IHdpZHRoICogNCAqIDc7ICAvLyBQYXNzIDEuXG4gICAgfVxuXG4gICAgdmFyIGludGVybGFjZXNraXAgPSA4OyAgLy8gVHJhY2tpbmcgdGhlIHJvdyBpbnRlcnZhbCBpbiB0aGUgY3VycmVudCBwYXNzLlxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gaW5kZXhfc3RyZWFtLmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcbiAgICAgIHZhciBpbmRleCA9IGluZGV4X3N0cmVhbVtpXTtcblxuICAgICAgaWYgKHhsZWZ0ID09PSAwKSB7ICAvLyBCZWdpbm5pbmcgb2YgbmV3IHNjYW4gbGluZVxuICAgICAgICBvcCArPSBzY2Fuc3RyaWRlO1xuICAgICAgICB4bGVmdCA9IGZyYW1ld2lkdGg7XG4gICAgICAgIGlmIChvcCA+PSBvcGVuZCkgeyAvLyBDYXRjaCB0aGUgd3JhcCB0byBzd2l0Y2ggcGFzc2VzIHdoZW4gaW50ZXJsYWNpbmcuXG4gICAgICAgICAgc2NhbnN0cmlkZSA9IGZyYW1lc3RyaWRlICogNCArIHdpZHRoICogNCAqIChpbnRlcmxhY2Vza2lwLTEpO1xuICAgICAgICAgIC8vIGludGVybGFjZXNraXAgLyAyICogNCBpcyBpbnRlcmxhY2Vza2lwIDw8IDEuXG4gICAgICAgICAgb3AgPSBvcGJlZyArIChmcmFtZXdpZHRoICsgZnJhbWVzdHJpZGUpICogKGludGVybGFjZXNraXAgPDwgMSk7XG4gICAgICAgICAgaW50ZXJsYWNlc2tpcCA+Pj0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaW5kZXggPT09IHRyYW5zKSB7XG4gICAgICAgIG9wICs9IDQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgciA9IGJ1ZltwYWxldHRlX29mZnNldCArIGluZGV4ICogM107XG4gICAgICAgIHZhciBnID0gYnVmW3BhbGV0dGVfb2Zmc2V0ICsgaW5kZXggKiAzICsgMV07XG4gICAgICAgIHZhciBiID0gYnVmW3BhbGV0dGVfb2Zmc2V0ICsgaW5kZXggKiAzICsgMl07XG4gICAgICAgIHBpeGVsc1tvcCsrXSA9IGI7XG4gICAgICAgIHBpeGVsc1tvcCsrXSA9IGc7XG4gICAgICAgIHBpeGVsc1tvcCsrXSA9IHI7XG4gICAgICAgIHBpeGVsc1tvcCsrXSA9IDI1NTtcbiAgICAgIH1cbiAgICAgIC0teGxlZnQ7XG4gICAgfVxuICB9O1xuXG4gIC8vIEkgd2lsbCBnbyB0byBjb3B5IGFuZCBwYXN0ZSBoZWxsIG9uZSBkYXkuLi5cbiAgdGhpcy5kZWNvZGVBbmRCbGl0RnJhbWVSR0JBID0gZnVuY3Rpb24oZnJhbWVfbnVtLCBwaXhlbHMpIHtcbiAgICB2YXIgZnJhbWUgPSB0aGlzLmZyYW1lSW5mbyhmcmFtZV9udW0pO1xuICAgIHZhciBudW1fcGl4ZWxzID0gZnJhbWUud2lkdGggKiBmcmFtZS5oZWlnaHQ7XG4gICAgdmFyIGluZGV4X3N0cmVhbSA9IG5ldyBVaW50OEFycmF5KG51bV9waXhlbHMpOyAgLy8gQXQgbW9zdCA4LWJpdCBpbmRpY2VzLlxuICAgIEdpZlJlYWRlckxaV091dHB1dEluZGV4U3RyZWFtKFxuICAgICAgICBidWYsIGZyYW1lLmRhdGFfb2Zmc2V0LCBpbmRleF9zdHJlYW0sIG51bV9waXhlbHMpO1xuICAgIHZhciBwYWxldHRlX29mZnNldCA9IGZyYW1lLnBhbGV0dGVfb2Zmc2V0O1xuXG4gICAgLy8gTk9URShkZWFubSk6IEl0IHNlZW1zIHRvIGJlIG11Y2ggZmFzdGVyIHRvIGNvbXBhcmUgaW5kZXggdG8gMjU2IHRoYW5cbiAgICAvLyB0byA9PT0gbnVsbC4gIE5vdCBzdXJlIHdoeSwgYnV0IENvbXBhcmVTdHViX0VRX1NUUklDVCBzaG93cyB1cCBoaWdoIGluXG4gICAgLy8gdGhlIHByb2ZpbGUsIG5vdCBzdXJlIGlmIGl0J3MgcmVsYXRlZCB0byB1c2luZyBhIFVpbnQ4QXJyYXkuXG4gICAgdmFyIHRyYW5zID0gZnJhbWUudHJhbnNwYXJlbnRfaW5kZXg7XG4gICAgaWYgKHRyYW5zID09PSBudWxsKSB0cmFucyA9IDI1NjtcblxuICAgIC8vIFdlIGFyZSBwb3NzaWJseSBqdXN0IGJsaXR0aW5nIHRvIGEgcG9ydGlvbiBvZiB0aGUgZW50aXJlIGZyYW1lLlxuICAgIC8vIFRoYXQgaXMgYSBzdWJyZWN0IHdpdGhpbiB0aGUgZnJhbWVyZWN0LCBzbyB0aGUgYWRkaXRpb25hbCBwaXhlbHNcbiAgICAvLyBtdXN0IGJlIHNraXBwZWQgb3ZlciBhZnRlciB3ZSBmaW5pc2hlZCBhIHNjYW5saW5lLlxuICAgIHZhciBmcmFtZXdpZHRoICA9IGZyYW1lLndpZHRoO1xuICAgIHZhciBmcmFtZXN0cmlkZSA9IHdpZHRoIC0gZnJhbWV3aWR0aDtcbiAgICB2YXIgeGxlZnQgICAgICAgPSBmcmFtZXdpZHRoOyAgLy8gTnVtYmVyIG9mIHN1YnJlY3QgcGl4ZWxzIGxlZnQgaW4gc2NhbmxpbmUuXG5cbiAgICAvLyBPdXRwdXQgaW5kaWNpZXMgb2YgdGhlIHRvcCBsZWZ0IGFuZCBib3R0b20gcmlnaHQgY29ybmVycyBvZiB0aGUgc3VicmVjdC5cbiAgICB2YXIgb3BiZWcgPSAoKGZyYW1lLnkgKiB3aWR0aCkgKyBmcmFtZS54KSAqIDQ7XG4gICAgdmFyIG9wZW5kID0gKChmcmFtZS55ICsgZnJhbWUuaGVpZ2h0KSAqIHdpZHRoICsgZnJhbWUueCkgKiA0O1xuICAgIHZhciBvcCAgICA9IG9wYmVnO1xuXG4gICAgdmFyIHNjYW5zdHJpZGUgPSBmcmFtZXN0cmlkZSAqIDQ7XG5cbiAgICAvLyBVc2Ugc2NhbnN0cmlkZSB0byBza2lwIHBhc3QgdGhlIHJvd3Mgd2hlbiBpbnRlcmxhY2luZy4gIFRoaXMgaXMgc2tpcHBpbmdcbiAgICAvLyA3IHJvd3MgZm9yIHRoZSBmaXJzdCB0d28gcGFzc2VzLCB0aGVuIDMgdGhlbiAxLlxuICAgIGlmIChmcmFtZS5pbnRlcmxhY2VkID09PSB0cnVlKSB7XG4gICAgICBzY2Fuc3RyaWRlICs9IHdpZHRoICogNCAqIDc7ICAvLyBQYXNzIDEuXG4gICAgfVxuXG4gICAgdmFyIGludGVybGFjZXNraXAgPSA4OyAgLy8gVHJhY2tpbmcgdGhlIHJvdyBpbnRlcnZhbCBpbiB0aGUgY3VycmVudCBwYXNzLlxuXG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gaW5kZXhfc3RyZWFtLmxlbmd0aDsgaSA8IGlsOyArK2kpIHtcbiAgICAgIHZhciBpbmRleCA9IGluZGV4X3N0cmVhbVtpXTtcblxuICAgICAgaWYgKHhsZWZ0ID09PSAwKSB7ICAvLyBCZWdpbm5pbmcgb2YgbmV3IHNjYW4gbGluZVxuICAgICAgICBvcCArPSBzY2Fuc3RyaWRlO1xuICAgICAgICB4bGVmdCA9IGZyYW1ld2lkdGg7XG4gICAgICAgIGlmIChvcCA+PSBvcGVuZCkgeyAvLyBDYXRjaCB0aGUgd3JhcCB0byBzd2l0Y2ggcGFzc2VzIHdoZW4gaW50ZXJsYWNpbmcuXG4gICAgICAgICAgc2NhbnN0cmlkZSA9IGZyYW1lc3RyaWRlICogNCArIHdpZHRoICogNCAqIChpbnRlcmxhY2Vza2lwLTEpO1xuICAgICAgICAgIC8vIGludGVybGFjZXNraXAgLyAyICogNCBpcyBpbnRlcmxhY2Vza2lwIDw8IDEuXG4gICAgICAgICAgb3AgPSBvcGJlZyArIChmcmFtZXdpZHRoICsgZnJhbWVzdHJpZGUpICogKGludGVybGFjZXNraXAgPDwgMSk7XG4gICAgICAgICAgaW50ZXJsYWNlc2tpcCA+Pj0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaW5kZXggPT09IHRyYW5zKSB7XG4gICAgICAgIG9wICs9IDQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgciA9IGJ1ZltwYWxldHRlX29mZnNldCArIGluZGV4ICogM107XG4gICAgICAgIHZhciBnID0gYnVmW3BhbGV0dGVfb2Zmc2V0ICsgaW5kZXggKiAzICsgMV07XG4gICAgICAgIHZhciBiID0gYnVmW3BhbGV0dGVfb2Zmc2V0ICsgaW5kZXggKiAzICsgMl07XG4gICAgICAgIHBpeGVsc1tvcCsrXSA9IHI7XG4gICAgICAgIHBpeGVsc1tvcCsrXSA9IGc7XG4gICAgICAgIHBpeGVsc1tvcCsrXSA9IGI7XG4gICAgICAgIHBpeGVsc1tvcCsrXSA9IDI1NTtcbiAgICAgIH1cbiAgICAgIC0teGxlZnQ7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBHaWZSZWFkZXJMWldPdXRwdXRJbmRleFN0cmVhbShjb2RlX3N0cmVhbSwgcCwgb3V0cHV0LCBvdXRwdXRfbGVuZ3RoKSB7XG4gIHZhciBtaW5fY29kZV9zaXplID0gY29kZV9zdHJlYW1bcCsrXTtcblxuICB2YXIgY2xlYXJfY29kZSA9IDEgPDwgbWluX2NvZGVfc2l6ZTtcbiAgdmFyIGVvaV9jb2RlID0gY2xlYXJfY29kZSArIDE7XG4gIHZhciBuZXh0X2NvZGUgPSBlb2lfY29kZSArIDE7XG5cbiAgdmFyIGN1cl9jb2RlX3NpemUgPSBtaW5fY29kZV9zaXplICsgMTsgIC8vIE51bWJlciBvZiBiaXRzIHBlciBjb2RlLlxuICAvLyBOT1RFOiBUaGlzIHNoYXJlcyB0aGUgc2FtZSBuYW1lIGFzIHRoZSBlbmNvZGVyLCBidXQgaGFzIGEgZGlmZmVyZW50XG4gIC8vIG1lYW5pbmcgaGVyZS4gIEhlcmUgdGhpcyBtYXNrcyBlYWNoIGNvZGUgY29taW5nIGZyb20gdGhlIGNvZGUgc3RyZWFtLlxuICB2YXIgY29kZV9tYXNrID0gKDEgPDwgY3VyX2NvZGVfc2l6ZSkgLSAxO1xuICB2YXIgY3VyX3NoaWZ0ID0gMDtcbiAgdmFyIGN1ciA9IDA7XG5cbiAgdmFyIG9wID0gMDsgIC8vIE91dHB1dCBwb2ludGVyLlxuXG4gIHZhciBzdWJibG9ja19zaXplID0gY29kZV9zdHJlYW1bcCsrXTtcblxuICAvLyBUT0RPKGRlYW5tKTogV291bGQgdXNpbmcgYSBUeXBlZEFycmF5IGJlIGFueSBmYXN0ZXI/ICBBdCBsZWFzdCBpdCB3b3VsZFxuICAvLyBzb2x2ZSB0aGUgZmFzdCBtb2RlIC8gYmFja2luZyBzdG9yZSB1bmNlcnRhaW50eS5cbiAgLy8gdmFyIGNvZGVfdGFibGUgPSBBcnJheSg0MDk2KTtcbiAgdmFyIGNvZGVfdGFibGUgPSBuZXcgSW50MzJBcnJheSg0MDk2KTsgIC8vIENhbiBiZSBzaWduZWQsIHdlIG9ubHkgdXNlIDIwIGJpdHMuXG5cbiAgdmFyIHByZXZfY29kZSA9IG51bGw7ICAvLyBUcmFjayBjb2RlLTEuXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICAvLyBSZWFkIHVwIHRvIHR3byBieXRlcywgbWFraW5nIHN1cmUgd2UgYWx3YXlzIDEyLWJpdHMgZm9yIG1heCBzaXplZCBjb2RlLlxuICAgIHdoaWxlIChjdXJfc2hpZnQgPCAxNikge1xuICAgICAgaWYgKHN1YmJsb2NrX3NpemUgPT09IDApIGJyZWFrOyAgLy8gTm8gbW9yZSBkYXRhIHRvIGJlIHJlYWQuXG5cbiAgICAgIGN1ciB8PSBjb2RlX3N0cmVhbVtwKytdIDw8IGN1cl9zaGlmdDtcbiAgICAgIGN1cl9zaGlmdCArPSA4O1xuXG4gICAgICBpZiAoc3ViYmxvY2tfc2l6ZSA9PT0gMSkgeyAgLy8gTmV2ZXIgbGV0IGl0IGdldCB0byAwIHRvIGhvbGQgbG9naWMgYWJvdmUuXG4gICAgICAgIHN1YmJsb2NrX3NpemUgPSBjb2RlX3N0cmVhbVtwKytdOyAgLy8gTmV4dCBzdWJibG9jay5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC0tc3ViYmxvY2tfc2l6ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUT0RPKGRlYW5tKTogV2Ugc2hvdWxkIG5ldmVyIHJlYWxseSBnZXQgaGVyZSwgd2Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWRcbiAgICAvLyBhbmQgRU9JLlxuICAgIGlmIChjdXJfc2hpZnQgPCBjdXJfY29kZV9zaXplKVxuICAgICAgYnJlYWs7XG5cbiAgICB2YXIgY29kZSA9IGN1ciAmIGNvZGVfbWFzaztcbiAgICBjdXIgPj49IGN1cl9jb2RlX3NpemU7XG4gICAgY3VyX3NoaWZ0IC09IGN1cl9jb2RlX3NpemU7XG5cbiAgICAvLyBUT0RPKGRlYW5tKTogTWF5YmUgc2hvdWxkIGNoZWNrIHRoYXQgdGhlIGZpcnN0IGNvZGUgd2FzIGEgY2xlYXIgY29kZSxcbiAgICAvLyBhdCBsZWFzdCB0aGlzIGlzIHdoYXQgeW91J3JlIHN1cHBvc2VkIHRvIGRvLiAgQnV0IGFjdHVhbGx5IG91ciBlbmNvZGVyXG4gICAgLy8gbm93IGRvZXNuJ3QgZW1pdCBhIGNsZWFyIGNvZGUgZmlyc3QgYW55d2F5LlxuICAgIGlmIChjb2RlID09PSBjbGVhcl9jb2RlKSB7XG4gICAgICAvLyBXZSBkb24ndCBhY3R1YWxseSBoYXZlIHRvIGNsZWFyIHRoZSB0YWJsZS4gIFRoaXMgY291bGQgYmUgYSBnb29kIGlkZWFcbiAgICAgIC8vIGZvciBncmVhdGVyIGVycm9yIGNoZWNraW5nLCBidXQgd2UgZG9uJ3QgcmVhbGx5IGRvIGFueSBhbnl3YXkuICBXZVxuICAgICAgLy8gd2lsbCBqdXN0IHRyYWNrIGl0IHdpdGggbmV4dF9jb2RlIGFuZCBvdmVyd3JpdGUgb2xkIGVudHJpZXMuXG5cbiAgICAgIG5leHRfY29kZSA9IGVvaV9jb2RlICsgMTtcbiAgICAgIGN1cl9jb2RlX3NpemUgPSBtaW5fY29kZV9zaXplICsgMTtcbiAgICAgIGNvZGVfbWFzayA9ICgxIDw8IGN1cl9jb2RlX3NpemUpIC0gMTtcblxuICAgICAgLy8gRG9uJ3QgdXBkYXRlIHByZXZfY29kZSA/XG4gICAgICBwcmV2X2NvZGUgPSBudWxsO1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSBlb2lfY29kZSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gV2UgaGF2ZSBhIHNpbWlsYXIgc2l0dWF0aW9uIGFzIHRoZSBkZWNvZGVyLCB3aGVyZSB3ZSB3YW50IHRvIHN0b3JlXG4gICAgLy8gdmFyaWFibGUgbGVuZ3RoIGVudHJpZXMgKGNvZGUgdGFibGUgZW50cmllcyksIGJ1dCB3ZSB3YW50IHRvIGRvIGluIGFcbiAgICAvLyBmYXN0ZXIgbWFubmVyIHRoYW4gYW4gYXJyYXkgb2YgYXJyYXlzLiAgVGhlIGNvZGUgYmVsb3cgc3RvcmVzIHNvcnQgb2YgYVxuICAgIC8vIGxpbmtlZCBsaXN0IHdpdGhpbiB0aGUgY29kZSB0YWJsZSwgYW5kIHRoZW4gXCJjaGFzZXNcIiB0aHJvdWdoIGl0IHRvXG4gICAgLy8gY29uc3RydWN0IHRoZSBkaWN0aW9uYXJ5IGVudHJpZXMuICBXaGVuIGEgbmV3IGVudHJ5IGlzIGNyZWF0ZWQsIGp1c3QgdGhlXG4gICAgLy8gbGFzdCBieXRlIGlzIHN0b3JlZCwgYW5kIHRoZSByZXN0IChwcmVmaXgpIG9mIHRoZSBlbnRyeSBpcyBvbmx5XG4gICAgLy8gcmVmZXJlbmNlZCBieSBpdHMgdGFibGUgZW50cnkuICBUaGVuIHRoZSBjb2RlIGNoYXNlcyB0aHJvdWdoIHRoZVxuICAgIC8vIHByZWZpeGVzIHVudGlsIGl0IHJlYWNoZXMgYSBzaW5nbGUgYnl0ZSBjb2RlLiAgV2UgaGF2ZSB0byBjaGFzZSB0d2ljZSxcbiAgICAvLyBmaXJzdCB0byBjb21wdXRlIHRoZSBsZW5ndGgsIGFuZCB0aGVuIHRvIGFjdHVhbGx5IGNvcHkgdGhlIGRhdGEgdG8gdGhlXG4gICAgLy8gb3V0cHV0IChiYWNrd2FyZHMsIHNpbmNlIHdlIGtub3cgdGhlIGxlbmd0aCkuICBUaGUgYWx0ZXJuYXRpdmUgd291bGQgYmVcbiAgICAvLyBzdG9yaW5nIHNvbWV0aGluZyBpbiBhbiBpbnRlcm1lZGlhdGUgc3RhY2ssIGJ1dCB0aGF0IGRvZXNuJ3QgbWFrZSBhbnlcbiAgICAvLyBtb3JlIHNlbnNlLiAgSSBpbXBsZW1lbnRlZCBhbiBhcHByb2FjaCB3aGVyZSBpdCBhbHNvIHN0b3JlZCB0aGUgbGVuZ3RoXG4gICAgLy8gaW4gdGhlIGNvZGUgdGFibGUsIGFsdGhvdWdoIGl0J3MgYSBiaXQgdHJpY2t5IGJlY2F1c2UgeW91IHJ1biBvdXQgb2ZcbiAgICAvLyBiaXRzICgxMiArIDEyICsgOCksIGJ1dCBJIGRpZG4ndCBtZWFzdXJlIG11Y2ggaW1wcm92ZW1lbnRzICh0aGUgdGFibGVcbiAgICAvLyBlbnRyaWVzIGFyZSBnZW5lcmFsbHkgbm90IHRoZSBsb25nKS4gIEV2ZW4gd2hlbiBJIGNyZWF0ZWQgYmVuY2htYXJrcyBmb3JcbiAgICAvLyB2ZXJ5IGxvbmcgdGFibGUgZW50cmllcyB0aGUgY29tcGxleGl0eSBkaWQgbm90IHNlZW0gd29ydGggaXQuXG4gICAgLy8gVGhlIGNvZGUgdGFibGUgc3RvcmVzIHRoZSBwcmVmaXggZW50cnkgaW4gMTIgYml0cyBhbmQgdGhlbiB0aGUgc3VmZml4XG4gICAgLy8gYnl0ZSBpbiA4IGJpdHMsIHNvIGVhY2ggZW50cnkgaXMgMjAgYml0cy5cblxuICAgIHZhciBjaGFzZV9jb2RlID0gY29kZSA8IG5leHRfY29kZSA/IGNvZGUgOiBwcmV2X2NvZGU7XG5cbiAgICAvLyBDaGFzZSB3aGF0IHdlIHdpbGwgb3V0cHV0LCBlaXRoZXIge0NPREV9IG9yIHtDT0RFLTF9LlxuICAgIHZhciBjaGFzZV9sZW5ndGggPSAwO1xuICAgIHZhciBjaGFzZSA9IGNoYXNlX2NvZGU7XG4gICAgd2hpbGUgKGNoYXNlID4gY2xlYXJfY29kZSkge1xuICAgICAgY2hhc2UgPSBjb2RlX3RhYmxlW2NoYXNlXSA+PiA4O1xuICAgICAgKytjaGFzZV9sZW5ndGg7XG4gICAgfVxuXG4gICAgdmFyIGsgPSBjaGFzZTtcblxuICAgIHZhciBvcF9lbmQgPSBvcCArIGNoYXNlX2xlbmd0aCArIChjaGFzZV9jb2RlICE9PSBjb2RlID8gMSA6IDApO1xuICAgIGlmIChvcF9lbmQgPiBvdXRwdXRfbGVuZ3RoKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIldhcm5pbmcsIGdpZiBzdHJlYW0gbG9uZ2VyIHRoYW4gZXhwZWN0ZWQuXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEFscmVhZHkgaGF2ZSB0aGUgZmlyc3QgYnl0ZSBmcm9tIHRoZSBjaGFzZSwgbWlnaHQgYXMgd2VsbCB3cml0ZSBpdCBmYXN0LlxuICAgIG91dHB1dFtvcCsrXSA9IGs7XG5cbiAgICBvcCArPSBjaGFzZV9sZW5ndGg7XG4gICAgdmFyIGIgPSBvcDsgIC8vIFRyYWNrIHBvaW50ZXIsIHdyaXRpbmcgYmFja3dhcmRzLlxuXG4gICAgaWYgKGNoYXNlX2NvZGUgIT09IGNvZGUpICAvLyBUaGUgY2FzZSBvZiBlbWl0dGluZyB7Q09ERS0xfSArIGsuXG4gICAgICBvdXRwdXRbb3ArK10gPSBrO1xuXG4gICAgY2hhc2UgPSBjaGFzZV9jb2RlO1xuICAgIHdoaWxlIChjaGFzZV9sZW5ndGgtLSkge1xuICAgICAgY2hhc2UgPSBjb2RlX3RhYmxlW2NoYXNlXTtcbiAgICAgIG91dHB1dFstLWJdID0gY2hhc2UgJiAweGZmOyAgLy8gV3JpdGUgYmFja3dhcmRzLlxuICAgICAgY2hhc2UgPj49IDg7ICAvLyBQdWxsIGRvd24gdG8gdGhlIHByZWZpeCBjb2RlLlxuICAgIH1cblxuICAgIGlmIChwcmV2X2NvZGUgIT09IG51bGwgJiYgbmV4dF9jb2RlIDwgNDA5Nikge1xuICAgICAgY29kZV90YWJsZVtuZXh0X2NvZGUrK10gPSBwcmV2X2NvZGUgPDwgOCB8IGs7XG4gICAgICAvLyBUT0RPKGRlYW5tKTogRmlndXJlIG91dCB0aGlzIGNsZWFyaW5nIHZzIGNvZGUgZ3Jvd3RoIGxvZ2ljIGJldHRlci4gIElcbiAgICAgIC8vIGhhdmUgYW4gZmVlbGluZyB0aGF0IGl0IHNob3VsZCBqdXN0IGhhcHBlbiBzb21ld2hlcmUgZWxzZSwgZm9yIG5vdyBpdFxuICAgICAgLy8gaXMgYXdrd2FyZCBiZXR3ZWVuIHdoZW4gd2UgZ3JvdyBwYXN0IHRoZSBtYXggYW5kIHRoZW4gaGl0IGEgY2xlYXIgY29kZS5cbiAgICAgIC8vIEZvciBub3cganVzdCBjaGVjayBpZiB3ZSBoaXQgdGhlIG1heCAxMi1iaXRzICh0aGVuIGEgY2xlYXIgY29kZSBzaG91bGRcbiAgICAgIC8vIGZvbGxvdywgYWxzbyBvZiBjb3Vyc2UgZW5jb2RlZCBpbiAxMi1iaXRzKS5cbiAgICAgIGlmIChuZXh0X2NvZGUgPj0gY29kZV9tYXNrKzEgJiYgY3VyX2NvZGVfc2l6ZSA8IDEyKSB7XG4gICAgICAgICsrY3VyX2NvZGVfc2l6ZTtcbiAgICAgICAgY29kZV9tYXNrID0gY29kZV9tYXNrIDw8IDEgfCAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHByZXZfY29kZSA9IGNvZGU7XG4gIH1cblxuICBpZiAob3AgIT09IG91dHB1dF9sZW5ndGgpIHtcbiAgICBjb25zb2xlLmxvZyhcIldhcm5pbmcsIGdpZiBzdHJlYW0gc2hvcnRlciB0aGFuIGV4cGVjdGVkLlwiKTtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbi8vIENvbW1vbkpTLlxudHJ5IHsgZXhwb3J0cy5HaWZXcml0ZXIgPSBHaWZXcml0ZXI7IGV4cG9ydHMuR2lmUmVhZGVyID0gR2lmUmVhZGVyIH0gY2F0Y2goZSkge31cbiIsIi8vIC5kaXJuYW1lLCAuYmFzZW5hbWUsIGFuZCAuZXh0bmFtZSBtZXRob2RzIGFyZSBleHRyYWN0ZWQgZnJvbSBOb2RlLmpzIHY4LjExLjEsXG4vLyBiYWNrcG9ydGVkIGFuZCB0cmFuc3BsaXRlZCB3aXRoIEJhYmVsLCB3aXRoIGJhY2t3YXJkcy1jb21wYXQgZml4ZXNcblxuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIHJlc29sdmVzIC4gYW5kIC4uIGVsZW1lbnRzIGluIGEgcGF0aCBhcnJheSB3aXRoIGRpcmVjdG9yeSBuYW1lcyB0aGVyZVxuLy8gbXVzdCBiZSBubyBzbGFzaGVzLCBlbXB0eSBlbGVtZW50cywgb3IgZGV2aWNlIG5hbWVzIChjOlxcKSBpbiB0aGUgYXJyYXlcbi8vIChzbyBhbHNvIG5vIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoZXMgLSBpdCBkb2VzIG5vdCBkaXN0aW5ndWlzaFxuLy8gcmVsYXRpdmUgYW5kIGFic29sdXRlIHBhdGhzKVxuZnVuY3Rpb24gbm9ybWFsaXplQXJyYXkocGFydHMsIGFsbG93QWJvdmVSb290KSB7XG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBwYXJ0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIHZhciBsYXN0ID0gcGFydHNbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKGFsbG93QWJvdmVSb290KSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBwYXJ0cy51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJ0cztcbn1cblxuLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNvbHZlZFBhdGggPSAnJyxcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgIHZhciBwYXRoID0gKGkgPj0gMCkgPyBhcmd1bWVudHNbaV0gOiBwcm9jZXNzLmN3ZCgpO1xuXG4gICAgLy8gU2tpcCBlbXB0eSBhbmQgaW52YWxpZCBlbnRyaWVzXG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFyZXNvbHZlZEFic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xufTtcblxuLy8gcGF0aC5ub3JtYWxpemUocGF0aClcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKSxcbiAgICAgIHRyYWlsaW5nU2xhc2ggPSBzdWJzdHIocGF0aCwgLTEpID09PSAnLyc7XG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFpc0Fic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgcGF0aCA9ICcuJztcbiAgfVxuICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgcGF0aCArPSAnLyc7XG4gIH1cblxuICByZXR1cm4gKGlzQWJzb2x1dGUgPyAnLycgOiAnJykgKyBwYXRoO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuam9pbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICByZXR1cm4gZXhwb3J0cy5ub3JtYWxpemUoZmlsdGVyKHBhdGhzLCBmdW5jdGlvbihwLCBpbmRleCkge1xuICAgIGlmICh0eXBlb2YgcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLmpvaW4gbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9KS5qb2luKCcvJykpO1xufTtcblxuXG4vLyBwYXRoLnJlbGF0aXZlKGZyb20sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZWxhdGl2ZSA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gIGZyb20gPSBleHBvcnRzLnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpO1xuICB0byA9IGV4cG9ydHMucmVzb2x2ZSh0bykuc3Vic3RyKDEpO1xuXG4gIGZ1bmN0aW9uIHRyaW0oYXJyKSB7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBmb3IgKDsgc3RhcnQgPCBhcnIubGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoYXJyW3N0YXJ0XSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICBpZiAoYXJyW2VuZF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBbXTtcbiAgICByZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCArIDEpO1xuICB9XG5cbiAgdmFyIGZyb21QYXJ0cyA9IHRyaW0oZnJvbS5zcGxpdCgnLycpKTtcbiAgdmFyIHRvUGFydHMgPSB0cmltKHRvLnNwbGl0KCcvJykpO1xuXG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7XG4gIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7XG4gICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG91dHB1dFBhcnRzID0gW107XG4gIGZvciAodmFyIGkgPSBzYW1lUGFydHNMZW5ndGg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRQYXJ0cy5wdXNoKCcuLicpO1xuICB9XG5cbiAgb3V0cHV0UGFydHMgPSBvdXRwdXRQYXJ0cy5jb25jYXQodG9QYXJ0cy5zbGljZShzYW1lUGFydHNMZW5ndGgpKTtcblxuICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpO1xufTtcblxuZXhwb3J0cy5zZXAgPSAnLyc7XG5leHBvcnRzLmRlbGltaXRlciA9ICc6JztcblxuZXhwb3J0cy5kaXJuYW1lID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykgcGF0aCA9IHBhdGggKyAnJztcbiAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSByZXR1cm4gJy4nO1xuICB2YXIgY29kZSA9IHBhdGguY2hhckNvZGVBdCgwKTtcbiAgdmFyIGhhc1Jvb3QgPSBjb2RlID09PSA0NyAvKi8qLztcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgZm9yICh2YXIgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAxOyAtLWkpIHtcbiAgICBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvclxuICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVuZCA9PT0gLTEpIHJldHVybiBoYXNSb290ID8gJy8nIDogJy4nO1xuICBpZiAoaGFzUm9vdCAmJiBlbmQgPT09IDEpIHtcbiAgICAvLyByZXR1cm4gJy8vJztcbiAgICAvLyBCYWNrd2FyZHMtY29tcGF0IGZpeDpcbiAgICByZXR1cm4gJy8nO1xuICB9XG4gIHJldHVybiBwYXRoLnNsaWNlKDAsIGVuZCk7XG59O1xuXG5mdW5jdGlvbiBiYXNlbmFtZShwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHBhdGggPSBwYXRoICsgJyc7XG5cbiAgdmFyIHN0YXJ0ID0gMDtcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgdmFyIGk7XG5cbiAgZm9yIChpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIGlmIChwYXRoLmNoYXJDb2RlQXQoaSkgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoXG4gICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xuICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgIHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZW5kID09PSAtMSkge1xuICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91clxuICAgICAgLy8gcGF0aCBjb21wb25lbnRcbiAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgZW5kID0gaSArIDE7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVuZCA9PT0gLTEpIHJldHVybiAnJztcbiAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnQsIGVuZCk7XG59XG5cbi8vIFVzZXMgYSBtaXhlZCBhcHByb2FjaCBmb3IgYmFja3dhcmRzLWNvbXBhdGliaWxpdHksIGFzIGV4dCBiZWhhdmlvciBjaGFuZ2VkXG4vLyBpbiBuZXcgTm9kZS5qcyB2ZXJzaW9ucywgc28gb25seSBiYXNlbmFtZSgpIGFib3ZlIGlzIGJhY2twb3J0ZWQgaGVyZVxuZXhwb3J0cy5iYXNlbmFtZSA9IGZ1bmN0aW9uIChwYXRoLCBleHQpIHtcbiAgdmFyIGYgPSBiYXNlbmFtZShwYXRoKTtcbiAgaWYgKGV4dCAmJiBmLnN1YnN0cigtMSAqIGV4dC5sZW5ndGgpID09PSBleHQpIHtcbiAgICBmID0gZi5zdWJzdHIoMCwgZi5sZW5ndGggLSBleHQubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gZjtcbn07XG5cbmV4cG9ydHMuZXh0bmFtZSA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpIHBhdGggPSBwYXRoICsgJyc7XG4gIHZhciBzdGFydERvdCA9IC0xO1xuICB2YXIgc3RhcnRQYXJ0ID0gMDtcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgbWF0Y2hlZFNsYXNoID0gdHJ1ZTtcbiAgLy8gVHJhY2sgdGhlIHN0YXRlIG9mIGNoYXJhY3RlcnMgKGlmIGFueSkgd2Ugc2VlIGJlZm9yZSBvdXIgZmlyc3QgZG90IGFuZFxuICAvLyBhZnRlciBhbnkgcGF0aCBzZXBhcmF0b3Igd2UgZmluZFxuICB2YXIgcHJlRG90U3RhdGUgPSAwO1xuICBmb3IgKHZhciBpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgIHZhciBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjb2RlID09PSA0NyAvKi8qLykge1xuICAgICAgICAvLyBJZiB3ZSByZWFjaGVkIGEgcGF0aCBzZXBhcmF0b3IgdGhhdCB3YXMgbm90IHBhcnQgb2YgYSBzZXQgb2YgcGF0aFxuICAgICAgICAvLyBzZXBhcmF0b3JzIGF0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc3RvcCBub3dcbiAgICAgICAgaWYgKCFtYXRjaGVkU2xhc2gpIHtcbiAgICAgICAgICBzdGFydFBhcnQgPSBpICsgMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgLy8gV2Ugc2F3IHRoZSBmaXJzdCBub24tcGF0aCBzZXBhcmF0b3IsIG1hcmsgdGhpcyBhcyB0aGUgZW5kIG9mIG91clxuICAgICAgLy8gZXh0ZW5zaW9uXG4gICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICAgIGVuZCA9IGkgKyAxO1xuICAgIH1cbiAgICBpZiAoY29kZSA9PT0gNDYgLyouKi8pIHtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyBvdXIgZmlyc3QgZG90LCBtYXJrIGl0IGFzIHRoZSBzdGFydCBvZiBvdXIgZXh0ZW5zaW9uXG4gICAgICAgIGlmIChzdGFydERvdCA9PT0gLTEpXG4gICAgICAgICAgc3RhcnREb3QgPSBpO1xuICAgICAgICBlbHNlIGlmIChwcmVEb3RTdGF0ZSAhPT0gMSlcbiAgICAgICAgICBwcmVEb3RTdGF0ZSA9IDE7XG4gICAgfSBlbHNlIGlmIChzdGFydERvdCAhPT0gLTEpIHtcbiAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgYW5kIG5vbi1wYXRoIHNlcGFyYXRvciBiZWZvcmUgb3VyIGRvdCwgc28gd2Ugc2hvdWxkXG4gICAgICAvLyBoYXZlIGEgZ29vZCBjaGFuY2UgYXQgaGF2aW5nIGEgbm9uLWVtcHR5IGV4dGVuc2lvblxuICAgICAgcHJlRG90U3RhdGUgPSAtMTtcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhcnREb3QgPT09IC0xIHx8IGVuZCA9PT0gLTEgfHxcbiAgICAgIC8vIFdlIHNhdyBhIG5vbi1kb3QgY2hhcmFjdGVyIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgZG90XG4gICAgICBwcmVEb3RTdGF0ZSA9PT0gMCB8fFxuICAgICAgLy8gVGhlIChyaWdodC1tb3N0KSB0cmltbWVkIHBhdGggY29tcG9uZW50IGlzIGV4YWN0bHkgJy4uJ1xuICAgICAgcHJlRG90U3RhdGUgPT09IDEgJiYgc3RhcnREb3QgPT09IGVuZCAtIDEgJiYgc3RhcnREb3QgPT09IHN0YXJ0UGFydCArIDEpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgcmV0dXJuIHBhdGguc2xpY2Uoc3RhcnREb3QsIGVuZCk7XG59O1xuXG5mdW5jdGlvbiBmaWx0ZXIgKHhzLCBmKSB7XG4gICAgaWYgKHhzLmZpbHRlcikgcmV0dXJuIHhzLmZpbHRlcihmKTtcbiAgICB2YXIgcmVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZih4c1tpXSwgaSwgeHMpKSByZXMucHVzaCh4c1tpXSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5cbi8vIFN0cmluZy5wcm90b3R5cGUuc3Vic3RyIC0gbmVnYXRpdmUgaW5kZXggZG9uJ3Qgd29yayBpbiBJRThcbnZhciBzdWJzdHIgPSAnYWInLnN1YnN0cigtMSkgPT09ICdiJ1xuICAgID8gZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikgeyByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKSB9XG4gICAgOiBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7XG4gICAgICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gc3RyLmxlbmd0aCArIHN0YXJ0O1xuICAgICAgICByZXR1cm4gc3RyLnN1YnN0cihzdGFydCwgbGVuKTtcbiAgICB9XG47XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICAhcHJvY2Vzcy52ZXJzaW9uIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YwLicpID09PSAwIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLicpID09PSAwICYmIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS44LicpICE9PSAwKSB7XG4gIG1vZHVsZS5leHBvcnRzID0geyBuZXh0VGljazogbmV4dFRpY2sgfTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcHJvY2Vzc1xufVxuXG5mdW5jdGlvbiBuZXh0VGljayhmbiwgYXJnMSwgYXJnMiwgYXJnMykge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJjYWxsYmFja1wiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG4gIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgYXJncywgaTtcbiAgc3dpdGNoIChsZW4pIHtcbiAgY2FzZSAwOlxuICBjYXNlIDE6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZm4pO1xuICBjYXNlIDI6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrT25lKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxKTtcbiAgICB9KTtcbiAgY2FzZSAzOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1R3bygpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMik7XG4gICAgfSk7XG4gIGNhc2UgNDpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUaHJlZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgfSk7XG4gIGRlZmF1bHQ6XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICBhcmdzW2krK10gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGljaygpIHtcbiAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0pO1xuICB9XG59XG5cbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgfXJldHVybiBrZXlzO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleDtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fcmVhZGFibGUnKTtcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xuXG51dGlsLmluaGVyaXRzKER1cGxleCwgUmVhZGFibGUpO1xuXG57XG4gIC8vIGF2b2lkIHNjb3BlIGNyZWVwLCB0aGUga2V5cyBhcnJheSBjYW4gdGhlbiBiZSBjb2xsZWN0ZWRcbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7XG4gIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgIHZhciBtZXRob2QgPSBrZXlzW3ZdO1xuICAgIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKSBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG5cbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSkgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSkgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxuZnVuY3Rpb24gb25lbmQoKSB7XG4gIC8vIGlmIHdlIGFsbG93IGhhbGYtb3BlbiBzdGF0ZSwgb3IgaWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsXG4gIC8vIHRoZW4gd2UncmUgb2suXG4gIGlmICh0aGlzLmFsbG93SGFsZk9wZW4gfHwgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgcmV0dXJuO1xuXG4gIC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cbiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suXG4gIHBuYS5uZXh0VGljayhvbkVuZE5ULCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gb25FbmROVChzZWxmKSB7XG4gIHNlbGYuZW5kKCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cbkR1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLnB1c2gobnVsbCk7XG4gIHRoaXMuZW5kKCk7XG5cbiAgcG5hLm5leHRUaWNrKGNiLCBlcnIpO1xufTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbnZhciBFRWxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiAoZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG5cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgZGVidWdVdGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIGRlYnVnID0gdm9pZCAwO1xuaWYgKGRlYnVnVXRpbCAmJiBkZWJ1Z1V0aWwuZGVidWdsb2cpIHtcbiAgZGVidWcgPSBkZWJ1Z1V0aWwuZGVidWdsb2coJ3N0cmVhbScpO1xufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbiAoKSB7fTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyTGlzdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0Jyk7XG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xudmFyIFN0cmluZ0RlY29kZXI7XG5cbnV0aWwuaW5oZXJpdHMoUmVhZGFibGUsIFN0cmVhbSk7XG5cbnZhciBrUHJveHlFdmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG5cbmZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4pIHtcbiAgLy8gU2FkbHkgdGhpcyBpcyBub3QgY2FjaGVhYmxlIGFzIHNvbWUgbGlicmFyaWVzIGJ1bmRsZSB0aGVpciBvd25cbiAgLy8gZXZlbnQgZW1pdHRlciBpbXBsZW1lbnRhdGlvbiB3aXRoIHRoZW0uXG4gIGlmICh0eXBlb2YgZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHJldHVybiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lcihldmVudCwgZm4pO1xuXG4gIC8vIFRoaXMgaXMgYSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnlcbiAgLy8gdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuIFRoaXMgaXMgaGVyZSBvbmx5IGJlY2F1c2UgdGhpcyBjb2RlIG5lZWRzXG4gIC8vIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGVcbiAgLy8gdGhlIHByZXBlbmRMaXN0ZW5lcigpIG1ldGhvZC4gVGhlIGdvYWwgaXMgdG8gZXZlbnR1YWxseSByZW1vdmUgdGhpcyBoYWNrLlxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkgZW1pdHRlci5vbihldmVudCwgZm4pO2Vsc2UgaWYgKGlzQXJyYXkoZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkpIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0udW5zaGlmdChmbik7ZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXTtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbS5cbiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguXG4gIHZhciBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIHJlYWRhYmxlSHdtID0gb3B0aW9ucy5yZWFkYWJsZUhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG5cbiAgaWYgKGh3bSB8fCBod20gPT09IDApIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bTtlbHNlIGlmIChpc0R1cGxleCAmJiAocmVhZGFibGVId20gfHwgcmVhZGFibGVId20gPT09IDApKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSByZWFkYWJsZUh3bTtlbHNlIHRoaXMuaGlnaFdhdGVyTWFyayA9IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBNYXRoLmZsb29yKHRoaXMuaGlnaFdhdGVyTWFyayk7XG5cbiAgLy8gQSBsaW5rZWQgbGlzdCBpcyB1c2VkIHRvIHN0b3JlIGRhdGEgY2h1bmtzIGluc3RlYWQgb2YgYW4gYXJyYXkgYmVjYXVzZSB0aGVcbiAgLy8gbGlua2VkIGxpc3QgY2FuIHJlbW92ZSBlbGVtZW50cyBmcm9tIHRoZSBiZWdpbm5pbmcgZmFzdGVyIHRoYW5cbiAgLy8gYXJyYXkuc2hpZnQoKVxuICB0aGlzLmJ1ZmZlciA9IG5ldyBCdWZmZXJMaXN0KCk7XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IG51bGw7XG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZGluZyA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIGV2ZW50ICdyZWFkYWJsZScvJ2RhdGEnIGlzIGVtaXR0ZWRcbiAgLy8gaW1tZWRpYXRlbHksIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2VcbiAgLy8gYW55IGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHJlYWQgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuICB0aGlzLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gIC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7XG5cbiAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG5cbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5XG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlYWQgPT09ICdmdW5jdGlvbicpIHRoaXMuX3JlYWQgPSBvcHRpb25zLnJlYWQ7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMucHVzaChudWxsKTtcbiAgY2IoZXJyKTtcbn07XG5cbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgc2tpcENodW5rQ2hlY2s7XG5cbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICAgICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgICB9XG4gICAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBlbmNvZGluZywgZmFsc2UsIHNraXBDaHVua0NoZWNrKTtcbn07XG5cbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgbnVsbCwgdHJ1ZSwgZmFsc2UpO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCwgc2tpcENodW5rQ2hlY2spIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKCFza2lwQ2h1bmtDaGVjaykgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcbiAgICBpZiAoZXIpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGNodW5rKSAhPT0gQnVmZmVyLnByb3RvdHlwZSkge1xuICAgICAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWRkVG9Gcm9udCkge1xuICAgICAgICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpKTtlbHNlIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kZWQpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWVuY29kaW5nKSB7XG4gICAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcbiAgICAgICAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuay5sZW5ndGggIT09IDApIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7ZWxzZSBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBhZGRUb0Zyb250KSB7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xuICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9IGVsc2Uge1xuICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIGlmIChhZGRUb0Zyb250KSBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7ZWxzZSBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG5cbiAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKSBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgfVxuICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlcjtcbiAgaWYgKCFfaXNVaW50OEFycmF5KGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICByZXR1cm4gZXI7XG59XG5cbi8vIGlmIGl0J3MgcGFzdCB0aGUgaGlnaCB3YXRlciBtYXJrLCB3ZSBjYW4gcHVzaCBpbiBzb21lIG1vcmUuXG4vLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZVxuLy8gbW9yZSBieXRlcy4gIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsXG4vLyBzdWNoIGFzIHRoZSByZXBsLiAgQWxzbywgaWYgdGhlIHB1c2goKSB0cmlnZ2VyZWQgYVxuLy8gcmVhZGFibGUgZXZlbnQsIGFuZCB0aGUgdXNlciBjYWxsZWQgcmVhZChsYXJnZU51bWJlcikgc3VjaCB0aGF0XG4vLyBuZWVkUmVhZGFibGUgd2FzIHNldCwgdGhlbiB3ZSBvdWdodCB0byBwdXNoIG1vcmUsIHNvIHRoYXQgYW5vdGhlclxuLy8gJ3JlYWRhYmxlJyBldmVudCB3aWxsIGJlIHRyaWdnZXJlZC5cbmZ1bmN0aW9uIG5lZWRNb3JlRGF0YShzdGF0ZSkge1xuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5uZWVkUmVhZGFibGUgfHwgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPT09IGZhbHNlO1xufTtcblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSBlbmM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDhNQlxudmFyIE1BWF9IV00gPSAweDgwMDAwMDtcbmZ1bmN0aW9uIGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDIgdG8gcHJldmVudCBpbmNyZWFzaW5nIGh3bSBleGNlc3NpdmVseSBpblxuICAgIC8vIHRpbnkgYW1vdW50c1xuICAgIG4tLTtcbiAgICBuIHw9IG4gPj4+IDE7XG4gICAgbiB8PSBuID4+PiAyO1xuICAgIG4gfD0gbiA+Pj4gNDtcbiAgICBuIHw9IG4gPj4+IDg7XG4gICAgbiB8PSBuID4+PiAxNjtcbiAgICBuKys7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAobiA8PSAwIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgcmV0dXJuIDA7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXR1cm4gMTtcbiAgaWYgKG4gIT09IG4pIHtcbiAgICAvLyBPbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGgpIHJldHVybiBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aDtlbHNlIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIGN1cnJlbnQgaHdtLCB0aGVuIHJhaXNlIHRoZSBod20uXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaykgc3RhdGUuaGlnaFdhdGVyTWFyayA9IGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pO1xuICBpZiAobiA8PSBzdGF0ZS5sZW5ndGgpIHJldHVybiBuO1xuICAvLyBEb24ndCBoYXZlIGVub3VnaFxuICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gc3RhdGUubGVuZ3RoO1xufVxuXG4vLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAobikge1xuICBkZWJ1ZygncmVhZCcsIG4pO1xuICBuID0gcGFyc2VJbnQobiwgMTApO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgbk9yaWcgPSBuO1xuXG4gIGlmIChuICE9PSAwKSBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG4gIGlmIChuID09PSAwICYmIHN0YXRlLm5lZWRSZWFkYWJsZSAmJiAoc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO2Vsc2UgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7XG5cbiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkb1JlYWQgPSB0cnVlO1xuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XG4gIH1cblxuICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZG9SZWFkID0gZmFsc2U7XG4gICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xuICB9IGVsc2UgaWYgKGRvUmVhZCkge1xuICAgIGRlYnVnKCdkbyByZWFkJyk7XG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7XG4gICAgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgICAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG4gIH1cblxuICB2YXIgcmV0O1xuICBpZiAobiA+IDApIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtlbHNlIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgbiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUubGVuZ3RoIC09IG47XG4gIH1cblxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gICAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICAgIGlmICghc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgICAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG4gICAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgfVxuXG4gIGlmIChyZXQgIT09IG51bGwpIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUuZW5kZWQpIHJldHVybjtcbiAgaWYgKHN0YXRlLmRlY29kZXIpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbn1cblxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBpZiAoc3RhdGUuc3luYykgcG5hLm5leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7ZWxzZSBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgZGVidWcoJ2VtaXQgcmVhZGFibGUnKTtcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gIGZsb3coc3RyZWFtKTtcbn1cblxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwbmEubmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxuICAgICAgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO2Vsc2UgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignX3JlYWQoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uIChkZXN0LCBwaXBlT3B0cykge1xuICB2YXIgc3JjID0gdGhpcztcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcblxuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmIGRlc3QgIT09IHByb2Nlc3Muc3Rkb3V0ICYmIGRlc3QgIT09IHByb2Nlc3Muc3RkZXJyO1xuXG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiB1bnBpcGU7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBwbmEubmV4dFRpY2soZW5kRm4pO2Vsc2Ugc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcblxuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlLCB1bnBpcGVJbmZvKSB7XG4gICAgZGVidWcoJ29udW5waXBlJyk7XG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcbiAgICAgIGlmICh1bnBpcGVJbmZvICYmIHVucGlwZUluZm8uaGFzVW5waXBlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdW5waXBlSW5mby5oYXNVbnBpcGVkID0gdHJ1ZTtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgdW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuXG4gICAgY2xlYW5lZFVwID0gdHJ1ZTtcblxuICAgIC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gJiYgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSkgb25kcmFpbigpO1xuICB9XG5cbiAgLy8gSWYgdGhlIHVzZXIgcHVzaGVzIG1vcmUgZGF0YSB3aGlsZSB3ZSdyZSB3cml0aW5nIHRvIGRlc3QgdGhlbiB3ZSdsbCBlbmQgdXBcbiAgLy8gaW4gb25kYXRhIGFnYWluLiBIb3dldmVyLCB3ZSBvbmx5IHdhbnQgdG8gaW5jcmVhc2UgYXdhaXREcmFpbiBvbmNlIGJlY2F1c2VcbiAgLy8gZGVzdCB3aWxsIG9ubHkgZW1pdCBvbmUgJ2RyYWluJyBldmVudCBmb3IgdGhlIG11bHRpcGxlIHdyaXRlcy5cbiAgLy8gPT4gSW50cm9kdWNlIGEgZ3VhcmQgb24gaW5jcmVhc2luZyBhd2FpdERyYWluLlxuICB2YXIgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBkZWJ1Zygnb25kYXRhJyk7XG4gICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICBpZiAoZmFsc2UgPT09IHJldCAmJiAhaW5jcmVhc2VkQXdhaXREcmFpbikge1xuICAgICAgLy8gSWYgdGhlIHVzZXIgdW5waXBlZCBkdXJpbmcgYGRlc3Qud3JpdGUoKWAsIGl0IGlzIHBvc3NpYmxlXG4gICAgICAvLyB0byBnZXQgc3R1Y2sgaW4gYSBwZXJtYW5lbnRseSBwYXVzZWQgc3RhdGUgaWYgdGhhdCB3cml0ZVxuICAgICAgLy8gYWxzbyByZXR1cm5lZCBmYWxzZS5cbiAgICAgIC8vID0+IENoZWNrIHdoZXRoZXIgYGRlc3RgIGlzIHN0aWxsIGEgcGlwaW5nIGRlc3RpbmF0aW9uLlxuICAgICAgaWYgKChzdGF0ZS5waXBlc0NvdW50ID09PSAxICYmIHN0YXRlLnBpcGVzID09PSBkZXN0IHx8IHN0YXRlLnBpcGVzQ291bnQgPiAxICYmIGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpICE9PSAtMSkgJiYgIWNsZWFuZWRVcCkge1xuICAgICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJywgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4pO1xuICAgICAgICBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbisrO1xuICAgICAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRWxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApIGRlc3QuZW1pdCgnZXJyb3InLCBlcik7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIHVzZXJsYW5kIG9uZXMuXG4gIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9XG5cbiAgLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcblxuICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHVucGlwZUluZm8gPSB7IGhhc1VucGlwZWQ6IGZhbHNlIH07XG5cbiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKSByZXR1cm4gdGhpcztcblxuICAgIGlmICghZGVzdCkgZGVzdCA9IHN0YXRlLnBpcGVzO1xuXG4gICAgLy8gZ290IGEgbWF0Y2guXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdCkgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgfXJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGluZGV4ID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiB0aGlzO1xuXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpbmRleCwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG5cbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgIC8vIFN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB0aGlzLnJlc3VtZSgpO1xuICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICBwbmEubmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XG5cbmZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikge1xuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XG4gIHNlbGYucmVhZCgwKTtcbn1cblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZScpO1xuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkge1xuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKHJlc3VtZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9XG5cbiAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XG4gIGZsb3coc3RyZWFtKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpIHN0cmVhbS5yZWFkKDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xuICBpZiAoZmFsc2UgIT09IHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwYXVzZScpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcbiAgd2hpbGUgKHN0YXRlLmZsb3dpbmcgJiYgc3RyZWFtLnJlYWQoKSAhPT0gbnVsbCkge31cbn1cblxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuXG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIF90aGlzLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIF90aGlzLnB1c2gobnVsbCk7XG4gIH0pO1xuXG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcblxuICAgIC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZVxuICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSkgcmV0dXJuO2Vsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpIHJldHVybjtcblxuICAgIHZhciByZXQgPSBfdGhpcy5wdXNoKGNodW5rKTtcbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodGhpc1tpXSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0oaSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuICBmb3IgKHZhciBuID0gMDsgbiA8IGtQcm94eUV2ZW50cy5sZW5ndGg7IG4rKykge1xuICAgIHN0cmVhbS5vbihrUHJveHlFdmVudHNbbl0sIHRoaXMuZW1pdC5iaW5kKHRoaXMsIGtQcm94eUV2ZW50c1tuXSkpO1xuICB9XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgdGhpcy5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIC8vIG5vdGhpbmcgYnVmZmVyZWRcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgdmFyIHJldDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhO2Vsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpO1xuICAgIHN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgcGFydCBvZiBsaXN0XG4gICAgcmV0ID0gZnJvbUxpc3RQYXJ0aWFsKG4sIHN0YXRlLmJ1ZmZlciwgc3RhdGUuZGVjb2Rlcik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBFeHRyYWN0cyBvbmx5IGVub3VnaCBidWZmZXJlZCBkYXRhIHRvIHNhdGlzZnkgdGhlIGFtb3VudCByZXF1ZXN0ZWQuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0UGFydGlhbChuLCBsaXN0LCBoYXNTdHJpbmdzKSB7XG4gIHZhciByZXQ7XG4gIGlmIChuIDwgbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3NcbiAgICByZXQgPSBsaXN0LmhlYWQuZGF0YS5zbGljZSgwLCBuKTtcbiAgICBsaXN0LmhlYWQuZGF0YSA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKG4pO1xuICB9IGVsc2UgaWYgKG4gPT09IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIGZpcnN0IGNodW5rIGlzIGEgcGVyZmVjdCBtYXRjaFxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZXN1bHQgc3BhbnMgbW9yZSB0aGFuIG9uZSBidWZmZXJcbiAgICByZXQgPSBoYXNTdHJpbmdzID8gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkgOiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGNoYXJhY3RlcnMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhXG4vLyBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIHtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgdmFyIHJldCA9IHAuZGF0YTtcbiAgbiAtPSByZXQubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBzdHIgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IHN0ci5sZW5ndGggPyBzdHIubGVuZ3RoIDogbjtcbiAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHJldCArPSBzdHI7ZWxzZSByZXQgKz0gc3RyLnNsaWNlKDAsIG4pO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBzdHIuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YSBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpIHtcbiAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgcC5kYXRhLmNvcHkocmV0KTtcbiAgbiAtPSBwLmRhdGEubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBidWYgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogbjtcbiAgICBidWYuY29weShyZXQsIHJldC5sZW5ndGggLSBuLCAwLCBuYik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBidWYubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IGJ1Zi5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgYmVmb3JlIGNvbnN1bWluZyBhbGwgdGhlIGJ5dGVzLCB0aGVuIHRoYXQgaXMgYVxuICAvLyBidWcgaW4gbm9kZS4gIFNob3VsZCBuZXZlciBoYXBwZW4uXG4gIGlmIChzdGF0ZS5sZW5ndGggPiAwKSB0aHJvdyBuZXcgRXJyb3IoJ1wiZW5kUmVhZGFibGUoKVwiIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhlbmRSZWFkYWJsZU5ULCBzdGF0ZSwgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZU5UKHN0YXRlLCBzdHJlYW0pIHtcbiAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFwiZmlsdGVyXCIsXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxuLy9cbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXG4vL1xuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxuLy9cbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxuLy9cbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXG4vL1xuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXG4vL1xuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG5cbnZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IE9iamVjdC5jcmVhdGUocmVxdWlyZSgnY29yZS11dGlsLWlzJykpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhUcmFuc2Zvcm0sIER1cGxleCk7XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKGVyLCBkYXRhKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcblxuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmICghY2IpIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignd3JpdGUgY2FsbGJhY2sgY2FsbGVkIG11bHRpcGxlIHRpbWVzJykpO1xuICB9XG5cbiAgdHMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRzLndyaXRlY2IgPSBudWxsO1xuXG4gIGlmIChkYXRhICE9IG51bGwpIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIHRoaXMucHVzaChkYXRhKTtcblxuICBjYihlcik7XG5cbiAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcnMucmVhZGluZyA9IGZhbHNlO1xuICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHtcbiAgICB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKSByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcblxuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IHtcbiAgICBhZnRlclRyYW5zZm9ybTogYWZ0ZXJUcmFuc2Zvcm0uYmluZCh0aGlzKSxcbiAgICBuZWVkVHJhbnNmb3JtOiBmYWxzZSxcbiAgICB0cmFuc2Zvcm1pbmc6IGZhbHNlLFxuICAgIHdyaXRlY2I6IG51bGwsXG4gICAgd3JpdGVjaHVuazogbnVsbCxcbiAgICB3cml0ZWVuY29kaW5nOiBudWxsXG4gIH07XG5cbiAgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fdHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoID0gb3B0aW9ucy5mbHVzaDtcbiAgfVxuXG4gIC8vIFdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cbiAgdGhpcy5vbigncHJlZmluaXNoJywgcHJlZmluaXNoKTtcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIGlmICh0eXBlb2YgdGhpcy5fZmx1c2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLl9mbHVzaChmdW5jdGlvbiAoZXIsIGRhdGEpIHtcbiAgICAgIGRvbmUoX3RoaXMsIGVyLCBkYXRhKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBkb25lKHRoaXMsIG51bGwsIG51bGwpO1xuICB9XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07XG5cbi8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ190cmFuc2Zvcm0oKSBpcyBub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLndyaXRlY2IgPSBjYjtcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fCBycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTtcblxuLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh0cy53cml0ZWNodW5rICE9PSBudWxsICYmIHRzLndyaXRlY2IgJiYgIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XG4gIH1cbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB2YXIgX3RoaXMyID0gdGhpcztcblxuICBEdXBsZXgucHJvdG90eXBlLl9kZXN0cm95LmNhbGwodGhpcywgZXJyLCBmdW5jdGlvbiAoZXJyMikge1xuICAgIGNiKGVycjIpO1xuICAgIF90aGlzMi5lbWl0KCdjbG9zZScpO1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlciwgZGF0YSkge1xuICBpZiAoZXIpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG5cbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcbiAgaWYgKHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHdzLmxlbmd0aCAhPSAwJyk7XG5cbiAgaWYgKHN0cmVhbS5fdHJhbnNmb3JtU3RhdGUudHJhbnNmb3JtaW5nKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiBzdGlsbCB0cmFuc2Zvcm1pbmcnKTtcblxuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuXG4vKiA8cmVwbGFjZW1lbnQ+ICovXG5mdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICB0aGlzLmNhbGxiYWNrID0gY2I7XG4gIHRoaXMubmV4dCA9IG51bGw7XG59XG5cbi8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdFxuLy8gdGhlcmUgd2lsbCBiZSBvbmx5IDIgb2YgdGhlc2UgZm9yIGVhY2ggc3RyZWFtXG5mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5lbnRyeSA9IG51bGw7XG4gIHRoaXMuZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgIG9uQ29ya2VkRmluaXNoKF90aGlzLCBzdGF0ZSk7XG4gIH07XG59XG4vKiA8L3JlcGxhY2VtZW50PiAqL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGFzeW5jV3JpdGUgPSAhcHJvY2Vzcy5icm93c2VyICYmIFsndjAuMTAnLCAndjAuOS4nXS5pbmRleE9mKHByb2Nlc3MudmVyc2lvbi5zbGljZSgwLCA1KSkgPiAtMSA/IHNldEltbWVkaWF0ZSA6IHBuYS5uZXh0VGljaztcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGludGVybmFsVXRpbCA9IHtcbiAgZGVwcmVjYXRlOiByZXF1aXJlKCd1dGlsLWRlcHJlY2F0ZScpXG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cblxuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG5cbnV0aWwuaW5oZXJpdHMoV3JpdGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIG5vcCgpIHt9XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uXG4gIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLlxuICB2YXIgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXG4gIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIHdyaXRhYmxlSHdtID0gb3B0aW9ucy53cml0YWJsZUhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG5cbiAgaWYgKGh3bSB8fCBod20gPT09IDApIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bTtlbHNlIGlmIChpc0R1cGxleCAmJiAod3JpdGFibGVId20gfHwgd3JpdGFibGVId20gPT09IDApKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSB3cml0YWJsZUh3bTtlbHNlIHRoaXMuaGlnaFdhdGVyTWFyayA9IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBNYXRoLmZsb29yKHRoaXMuaGlnaFdhdGVyTWFyayk7XG5cbiAgLy8gaWYgX2ZpbmFsIGhhcyBiZWVuIGNhbGxlZFxuICB0aGlzLmZpbmFsQ2FsbGVkID0gZmFsc2U7XG5cbiAgLy8gZHJhaW4gZXZlbnQgZmxhZy5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcbiAgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlO1xuXG4gIC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcbiAgdGhpcy5jb3JrZWQgPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24gKGVyKSB7XG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcbiAgfTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcblxuICAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXG4gIHRoaXMud3JpdGVsZW4gPSAwO1xuXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcblxuICAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xuICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWRcbiAgdGhpcy5wZW5kaW5nY2IgPSAwO1xuXG4gIC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcbiAgdGhpcy5wcmVmaW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXG4gIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG5cbiAgLy8gY291bnQgYnVmZmVyZWQgcmVxdWVzdHNcbiAgdGhpcy5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG5cbiAgLy8gYWxsb2NhdGUgdGhlIGZpcnN0IENvcmtlZFJlcXVlc3QsIHRoZXJlIGlzIGFsd2F5c1xuICAvLyBvbmUgYWxsb2NhdGVkIGFuZCBmcmVlIHRvIHVzZSwgYW5kIHdlIG1haW50YWluIGF0IG1vc3QgdHdvXG4gIHRoaXMuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3QodGhpcyk7XG59XG5cbldyaXRhYmxlU3RhdGUucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uIGdldEJ1ZmZlcigpIHtcbiAgdmFyIGN1cnJlbnQgPSB0aGlzLmJ1ZmZlcmVkUmVxdWVzdDtcbiAgdmFyIG91dCA9IFtdO1xuICB3aGlsZSAoY3VycmVudCkge1xuICAgIG91dC5wdXNoKGN1cnJlbnQpO1xuICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RhdGUucHJvdG90eXBlLCAnYnVmZmVyJywge1xuICAgICAgZ2V0OiBpbnRlcm5hbFV0aWwuZGVwcmVjYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyKCk7XG4gICAgICB9LCAnX3dyaXRhYmxlU3RhdGUuYnVmZmVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBfd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIgJyArICdpbnN0ZWFkLicsICdERVAwMDAzJylcbiAgICB9KTtcbiAgfSBjYXRjaCAoXykge31cbn0pKCk7XG5cbi8vIFRlc3QgX3dyaXRhYmxlU3RhdGUgZm9yIGluaGVyaXRhbmNlIHRvIGFjY291bnQgZm9yIER1cGxleCBzdHJlYW1zLFxuLy8gd2hvc2UgcHJvdG90eXBlIGNoYWluIG9ubHkgcG9pbnRzIHRvIFJlYWRhYmxlLlxudmFyIHJlYWxIYXNJbnN0YW5jZTtcbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5oYXNJbnN0YW5jZSAmJiB0eXBlb2YgRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZSwgU3ltYm9sLmhhc0luc3RhbmNlLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIGlmIChyZWFsSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBvYmplY3QpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICh0aGlzICE9PSBXcml0YWJsZSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICByZXR1cm4gb2JqZWN0ICYmIG9iamVjdC5fd3JpdGFibGVTdGF0ZSBpbnN0YW5jZW9mIFdyaXRhYmxlU3RhdGU7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgdGhpcztcbiAgfTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdG9vLlxuICAvLyBgcmVhbEhhc0luc3RhbmNlYCBpcyBuZWNlc3NhcnkgYmVjYXVzZSB1c2luZyBwbGFpbiBgaW5zdGFuY2VvZmBcbiAgLy8gd291bGQgcmV0dXJuIGZhbHNlLCBhcyBubyBgX3dyaXRhYmxlU3RhdGVgIHByb3BlcnR5IGlzIGF0dGFjaGVkLlxuXG4gIC8vIFRyeWluZyB0byB1c2UgdGhlIGN1c3RvbSBgaW5zdGFuY2VvZmAgZm9yIFdyaXRhYmxlIGhlcmUgd2lsbCBhbHNvIGJyZWFrIHRoZVxuICAvLyBOb2RlLmpzIExhenlUcmFuc2Zvcm0gaW1wbGVtZW50YXRpb24sIHdoaWNoIGhhcyBhIG5vbi10cml2aWFsIGdldHRlciBmb3JcbiAgLy8gYF93cml0YWJsZVN0YXRlYCB0aGF0IHdvdWxkIGxlYWQgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICBpZiAoIXJlYWxIYXNJbnN0YW5jZS5jYWxsKFdyaXRhYmxlLCB0aGlzKSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSB7XG4gICAgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcbiAgfVxuXG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3kuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGV2ID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZXYgPSBvcHRpb25zLndyaXRldjtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbmFsID09PSAnZnVuY3Rpb24nKSB0aGlzLl9maW5hbCA9IG9wdGlvbnMuZmluYWw7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nhbm5vdCBwaXBlLCBub3QgcmVhZGFibGUnKSk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbn1cblxuLy8gQ2hlY2tzIHRoYXQgYSB1c2VyLXN1cHBsaWVkIGNodW5rIGlzIHZhbGlkLCBlc3BlY2lhbGx5IGZvciB0aGUgcGFydGljdWxhclxuLy8gbW9kZSB0aGUgc3RyZWFtIGlzIGluLiBDdXJyZW50bHkgdGhpcyBtZWFucyB0aGF0IGBudWxsYCBpcyBuZXZlciBhY2NlcHRlZFxuLy8gYW5kIHVuZGVmaW5lZC9ub24tc3RyaW5nIHZhbHVlcyBhcmUgb25seSBhbGxvd2VkIGluIG9iamVjdCBtb2RlLlxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIHZhbGlkID0gdHJ1ZTtcbiAgdmFyIGVyID0gZmFsc2U7XG5cbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbScpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIGlmIChlcikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbiAgICB2YWxpZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWxpZDtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuICB2YXIgaXNCdWYgPSAhc3RhdGUub2JqZWN0TW9kZSAmJiBfaXNVaW50OEFycmF5KGNodW5rKTtcblxuICBpZiAoaXNCdWYgJiYgIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIHtcbiAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGlzQnVmKSBlbmNvZGluZyA9ICdidWZmZXInO2Vsc2UgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7XG5cbiAgaWYgKHN0YXRlLmVuZGVkKSB3cml0ZUFmdGVyRW5kKHRoaXMsIGNiKTtlbHNlIGlmIChpc0J1ZiB8fCB2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIHN0YXRlLmNvcmtlZCsrO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG5cbiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XG4gIH1cbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2RpbmcgPSBmdW5jdGlvbiBzZXREZWZhdWx0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgLy8gbm9kZTo6UGFyc2VFbmNvZGluZygpIHJlcXVpcmVzIGxvd2VyIGNhc2UuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG4gIGlmICghKFsnaGV4JywgJ3V0ZjgnLCAndXRmLTgnLCAnYXNjaWknLCAnYmluYXJ5JywgJ2Jhc2U2NCcsICd1Y3MyJywgJ3Vjcy0yJywgJ3V0ZjE2bGUnLCAndXRmLTE2bGUnLCAncmF3J10uaW5kZXhPZigoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKSkgPiAtMSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVmYXVsdEVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuICByZXR1cm4gY2h1bms7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuXG4vLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBpZiAoIWlzQnVmKSB7XG4gICAgdmFyIG5ld0NodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XG4gICAgaWYgKGNodW5rICE9PSBuZXdDaHVuaykge1xuICAgICAgaXNCdWYgPSB0cnVlO1xuICAgICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgICAgIGNodW5rID0gbmV3Q2h1bms7XG4gICAgfVxuICB9XG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuXG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cbiAgaWYgKCFyZXQpIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLndyaXRpbmcgfHwgc3RhdGUuY29ya2VkKSB7XG4gICAgdmFyIGxhc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSB7XG4gICAgICBjaHVuazogY2h1bmssXG4gICAgICBlbmNvZGluZzogZW5jb2RpbmcsXG4gICAgICBpc0J1ZjogaXNCdWYsXG4gICAgICBjYWxsYmFjazogY2IsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcbiAgICBpZiAobGFzdCkge1xuICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgKz0gMTtcbiAgfSBlbHNlIHtcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIGlmICh3cml0ZXYpIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtlbHNlIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XG4gIC0tc3RhdGUucGVuZGluZ2NiO1xuXG4gIGlmIChzeW5jKSB7XG4gICAgLy8gZGVmZXIgdGhlIGNhbGxiYWNrIGlmIHdlIGFyZSBiZWluZyBjYWxsZWQgc3luY2hyb25vdXNseVxuICAgIC8vIHRvIGF2b2lkIHBpbGluZyB1cCB0aGluZ3Mgb24gdGhlIHN0YWNrXG4gICAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG4gICAgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGFuZCBpdCB3aWxsIGFsd2F5cyBoYXBwZW5cbiAgICAvLyBhZnRlciBlcnJvclxuICAgIHBuYS5uZXh0VGljayhmaW5pc2hNYXliZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBjYWxsZXIgZXhwZWN0IHRoaXMgdG8gaGFwcGVuIGJlZm9yZSBpZlxuICAgIC8vIGl0IGlzIGFzeW5jXG4gICAgY2IoZXIpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYnV0IGZpbmlzaCBtdXN0XG4gICAgLy8gYWx3YXlzIGZvbGxvdyBlcnJvclxuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuXG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XG5cbiAgaWYgKGVyKSBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuXG4gICAgaWYgKCFmaW5pc2hlZCAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkge1xuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIC8qPHJlcGxhY2VtZW50PiovXG4gICAgICBhc3luY1dyaXRlKGFmdGVyV3JpdGUsIHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgICAvKjwvcmVwbGFjZW1lbnQ+Ki9cbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKSBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIHN0YXRlLnBlbmRpbmdjYi0tO1xuICBjYigpO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59XG5cbi8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7XG5cbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHtcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgdmFyIGwgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudDtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpO1xuICAgIHZhciBob2xkZXIgPSBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7XG4gICAgaG9sZGVyLmVudHJ5ID0gZW50cnk7XG5cbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciBhbGxCdWZmZXJzID0gdHJ1ZTtcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIGJ1ZmZlcltjb3VudF0gPSBlbnRyeTtcbiAgICAgIGlmICghZW50cnkuaXNCdWYpIGFsbEJ1ZmZlcnMgPSBmYWxzZTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuICAgIGJ1ZmZlci5hbGxCdWZmZXJzID0gYWxsQnVmZmVycztcblxuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBidWZmZXIsICcnLCBob2xkZXIuZmluaXNoKTtcblxuICAgIC8vIGRvV3JpdGUgaXMgYWxtb3N0IGFsd2F5cyBhc3luYywgZGVmZXIgdGhlc2UgdG8gc2F2ZSBhIGJpdCBvZiB0aW1lXG4gICAgLy8gYXMgdGhlIGhvdCBwYXRoIGVuZHMgd2l0aCBkb1dyaXRlXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gICAgaWYgKGhvbGRlci5uZXh0KSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDtcbiAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gU2xvdyBjYXNlLCB3cml0ZSBjaHVua3Mgb25lLWJ5LW9uZVxuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XG4gICAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQtLTtcbiAgICAgIC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW50cnkgPT09IG51bGwpIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB9XG5cbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFcnJvcignX3dyaXRlKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcblxuICAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG59O1xuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7XG59XG5mdW5jdGlvbiBjYWxsRmluYWwoc3RyZWFtLCBzdGF0ZSkge1xuICBzdHJlYW0uX2ZpbmFsKGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH1cbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQgJiYgIXN0YXRlLmZpbmFsQ2FsbGVkKSB7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW0uX2ZpbmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICAgIHN0YXRlLmZpbmFsQ2FsbGVkID0gdHJ1ZTtcbiAgICAgIHBuYS5uZXh0VGljayhjYWxsRmluYWwsIHN0cmVhbSwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChjYikge1xuICAgIGlmIChzdGF0ZS5maW5pc2hlZCkgcG5hLm5leHRUaWNrKGNiKTtlbHNlIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb25Db3JrZWRGaW5pc2goY29ya1JlcSwgc3RhdGUsIGVycikge1xuICB2YXIgZW50cnkgPSBjb3JrUmVxLmVudHJ5O1xuICBjb3JrUmVxLmVudHJ5ID0gbnVsbDtcbiAgd2hpbGUgKGVudHJ5KSB7XG4gICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgY2IoZXJyKTtcbiAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gIH1cbiAgaWYgKHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSkge1xuICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gY29ya1JlcTtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBjb3JrUmVxO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcbldyaXRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5lbmQoKTtcbiAgY2IoZXJyKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuZnVuY3Rpb24gY29weUJ1ZmZlcihzcmMsIHRhcmdldCwgb2Zmc2V0KSB7XG4gIHNyYy5jb3B5KHRhcmdldCwgb2Zmc2V0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJ1ZmZlckxpc3QoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1ZmZlckxpc3QpO1xuXG4gICAgdGhpcy5oZWFkID0gbnVsbDtcbiAgICB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfVxuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoKHYpIHtcbiAgICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IG51bGwgfTtcbiAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O2Vsc2UgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgdGhpcy50YWlsID0gZW50cnk7XG4gICAgKyt0aGlzLmxlbmd0aDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gdW5zaGlmdCh2KSB7XG4gICAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiB0aGlzLmhlYWQgfTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgICsrdGhpcy5sZW5ndGg7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiBzaGlmdCgpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICB2YXIgcmV0ID0gdGhpcy5oZWFkLmRhdGE7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO2Vsc2UgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XG4gICAgLS10aGlzLmxlbmd0aDtcbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIGpvaW4ocykge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgIHZhciByZXQgPSAnJyArIHAuZGF0YTtcbiAgICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgICAgcmV0ICs9IHMgKyBwLmRhdGE7XG4gICAgfXJldHVybiByZXQ7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0KG4pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSByZXR1cm4gdGhpcy5oZWFkLmRhdGE7XG4gICAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuID4+PiAwKTtcbiAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKHApIHtcbiAgICAgIGNvcHlCdWZmZXIocC5kYXRhLCByZXQsIGkpO1xuICAgICAgaSArPSBwLmRhdGEubGVuZ3RoO1xuICAgICAgcCA9IHAubmV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICByZXR1cm4gQnVmZmVyTGlzdDtcbn0oKTtcblxuaWYgKHV0aWwgJiYgdXRpbC5pbnNwZWN0ICYmIHV0aWwuaW5zcGVjdC5jdXN0b20pIHtcbiAgbW9kdWxlLmV4cG9ydHMucHJvdG90eXBlW3V0aWwuaW5zcGVjdC5jdXN0b21dID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSB1dGlsLmluc3BlY3QoeyBsZW5ndGg6IHRoaXMubGVuZ3RoIH0pO1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgKyAnICcgKyBvYmo7XG4gIH07XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vLyB1bmRvY3VtZW50ZWQgY2IoKSBBUEksIG5lZWRlZCBmb3IgY29yZSwgbm90IGZvciBwdWJsaWMgQVBJXG5mdW5jdGlvbiBkZXN0cm95KGVyciwgY2IpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgcmVhZGFibGVEZXN0cm95ZWQgPSB0aGlzLl9yZWFkYWJsZVN0YXRlICYmIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB2YXIgd3JpdGFibGVEZXN0cm95ZWQgPSB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuXG4gIGlmIChyZWFkYWJsZURlc3Ryb3llZCB8fCB3cml0YWJsZURlc3Ryb3llZCkge1xuICAgIGlmIChjYikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9IGVsc2UgaWYgKGVyciAmJiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUgfHwgIXRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSkge1xuICAgICAgcG5hLm5leHRUaWNrKGVtaXRFcnJvck5ULCB0aGlzLCBlcnIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHdlIHNldCBkZXN0cm95ZWQgdG8gdHJ1ZSBiZWZvcmUgZmlyaW5nIGVycm9yIGNhbGxiYWNrcyBpbiBvcmRlclxuICAvLyB0byBtYWtlIGl0IHJlLWVudHJhbmNlIHNhZmUgaW4gY2FzZSBkZXN0cm95KCkgaXMgY2FsbGVkIHdpdGhpbiBjYWxsYmFja3NcblxuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGlmIHRoaXMgaXMgYSBkdXBsZXggc3RyZWFtIG1hcmsgdGhlIHdyaXRhYmxlIHBhcnQgYXMgZGVzdHJveWVkIGFzIHdlbGxcbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICB0aGlzLl9kZXN0cm95KGVyciB8fCBudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKCFjYiAmJiBlcnIpIHtcbiAgICAgIHBuYS5uZXh0VGljayhlbWl0RXJyb3JOVCwgX3RoaXMsIGVycik7XG4gICAgICBpZiAoX3RoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgX3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIHVuZGVzdHJveSgpIHtcbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0RXJyb3JOVChzZWxmLCBlcnIpIHtcbiAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZXN0cm95OiBkZXN0cm95LFxuICB1bmRlc3Ryb3k6IHVuZGVzdHJveVxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbiIsIi8qIGVzbGludC1kaXNhYmxlIG5vZGUvbm8tZGVwcmVjYXRlZC1hcGkgKi9cbnZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKVxudmFyIEJ1ZmZlciA9IGJ1ZmZlci5CdWZmZXJcblxuLy8gYWx0ZXJuYXRpdmUgdG8gdXNpbmcgT2JqZWN0LmtleXMgZm9yIG9sZCBicm93c2Vyc1xuZnVuY3Rpb24gY29weVByb3BzIChzcmMsIGRzdCkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgZHN0W2tleV0gPSBzcmNba2V5XVxuICB9XG59XG5pZiAoQnVmZmVyLmZyb20gJiYgQnVmZmVyLmFsbG9jICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZSAmJiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KSB7XG4gIG1vZHVsZS5leHBvcnRzID0gYnVmZmVyXG59IGVsc2Uge1xuICAvLyBDb3B5IHByb3BlcnRpZXMgZnJvbSByZXF1aXJlKCdidWZmZXInKVxuICBjb3B5UHJvcHMoYnVmZmVyLCBleHBvcnRzKVxuICBleHBvcnRzLkJ1ZmZlciA9IFNhZmVCdWZmZXJcbn1cblxuZnVuY3Rpb24gU2FmZUJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gQ29weSBzdGF0aWMgbWV0aG9kcyBmcm9tIEJ1ZmZlclxuY29weVByb3BzKEJ1ZmZlciwgU2FmZUJ1ZmZlcilcblxuU2FmZUJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICB2YXIgYnVmID0gQnVmZmVyKHNpemUpXG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgYnVmLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJ1Zi5maWxsKDApXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoc2l6ZSlcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlci5TbG93QnVmZmVyKHNpemUpXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcmVhZGFibGUnKS5QYXNzVGhyb3VnaFxuIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcycpO1xuZXhwb3J0cy5TdHJlYW0gPSBleHBvcnRzO1xuZXhwb3J0cy5SZWFkYWJsZSA9IGV4cG9ydHM7XG5leHBvcnRzLldyaXRhYmxlID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuZXhwb3J0cy5EdXBsZXggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuZXhwb3J0cy5UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcycpO1xuZXhwb3J0cy5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMnKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9yZWFkYWJsZScpLlRyYW5zZm9ybVxuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW07XG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmluaGVyaXRzKFN0cmVhbSwgRUUpO1xuU3RyZWFtLlJlYWRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzJyk7XG5TdHJlYW0uV3JpdGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanMnKTtcblN0cmVhbS5EdXBsZXggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzJyk7XG5TdHJlYW0uVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcycpO1xuU3RyZWFtLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzJyk7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuNC54XG5TdHJlYW0uU3RyZWFtID0gU3RyZWFtO1xuXG5cblxuLy8gb2xkLXN0eWxlIHN0cmVhbXMuICBOb3RlIHRoYXQgdGhlIHBpcGUgbWV0aG9kICh0aGUgb25seSByZWxldmFudFxuLy8gcGFydCBvZiB0aGlzIGNsYXNzKSBpcyBvdmVycmlkZGVuIGluIHRoZSBSZWFkYWJsZSBjbGFzcy5cblxuZnVuY3Rpb24gU3RyZWFtKCkge1xuICBFRS5jYWxsKHRoaXMpO1xufVxuXG5TdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBvcHRpb25zKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGlmIChkZXN0LndyaXRhYmxlKSB7XG4gICAgICBpZiAoZmFsc2UgPT09IGRlc3Qud3JpdGUoY2h1bmspICYmIHNvdXJjZS5wYXVzZSkge1xuICAgICAgICBzb3VyY2UucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2RhdGEnLCBvbmRhdGEpO1xuXG4gIGZ1bmN0aW9uIG9uZHJhaW4oKSB7XG4gICAgaWYgKHNvdXJjZS5yZWFkYWJsZSAmJiBzb3VyY2UucmVzdW1lKSB7XG4gICAgICBzb3VyY2UucmVzdW1lKCk7XG4gICAgfVxuICB9XG5cbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICAvLyBJZiB0aGUgJ2VuZCcgb3B0aW9uIGlzIG5vdCBzdXBwbGllZCwgZGVzdC5lbmQoKSB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gIC8vIHNvdXJjZSBnZXRzIHRoZSAnZW5kJyBvciAnY2xvc2UnIGV2ZW50cy4gIE9ubHkgZGVzdC5lbmQoKSBvbmNlLlxuICBpZiAoIWRlc3QuX2lzU3RkaW8gJiYgKCFvcHRpb25zIHx8IG9wdGlvbnMuZW5kICE9PSBmYWxzZSkpIHtcbiAgICBzb3VyY2Uub24oJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2Uub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH1cblxuICB2YXIgZGlkT25FbmQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBpZiAodHlwZW9mIGRlc3QuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgZGVzdC5kZXN0cm95KCk7XG4gIH1cblxuICAvLyBkb24ndCBsZWF2ZSBkYW5nbGluZyBwaXBlcyB3aGVuIHRoZXJlIGFyZSBlcnJvcnMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBjbGVhbnVwKCk7XG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQodGhpcywgJ2Vycm9yJykgPT09IDApIHtcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgc3RyZWFtIGVycm9yIGluIHBpcGUuXG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIHJlbW92ZSBhbGwgdGhlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG4gIH1cblxuICBzb3VyY2Uub24oJ2VuZCcsIGNsZWFudXApO1xuICBzb3VyY2Uub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzb3VyY2UpO1xuXG4gIC8vIEFsbG93IGZvciB1bml4LWxpa2UgdXNhZ2U6IEEucGlwZShCKS5waXBlKEMpXG4gIHJldHVybiBkZXN0O1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgaXNFbmNvZGluZyA9IEJ1ZmZlci5pc0VuY29kaW5nIHx8IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICBlbmNvZGluZyA9ICcnICsgZW5jb2Rpbmc7XG4gIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6Y2FzZSAndXRmOCc6Y2FzZSAndXRmLTgnOmNhc2UgJ2FzY2lpJzpjYXNlICdiaW5hcnknOmNhc2UgJ2Jhc2U2NCc6Y2FzZSAndWNzMic6Y2FzZSAndWNzLTInOmNhc2UgJ3V0ZjE2bGUnOmNhc2UgJ3V0Zi0xNmxlJzpjYXNlICdyYXcnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX25vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICBpZiAoIWVuYykgcmV0dXJuICd1dGY4JztcbiAgdmFyIHJldHJpZWQ7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmMpIHtcbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gJ3V0ZjgnO1xuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuICd1dGYxNmxlJztcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gJ2xhdGluMSc7XG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGVuYztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChyZXRyaWVkKSByZXR1cm47IC8vIHVuZGVmaW5lZFxuICAgICAgICBlbmMgPSAoJycgKyBlbmMpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHJpZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuLy8gRG8gbm90IGNhY2hlIGBCdWZmZXIuaXNFbmNvZGluZ2Agd2hlbiBjaGVja2luZyBlbmNvZGluZyBuYW1lcyBhcyBzb21lXG4vLyBtb2R1bGVzIG1vbmtleS1wYXRjaCBpdCB0byBzdXBwb3J0IGFkZGl0aW9uYWwgZW5jb2RpbmdzXG5mdW5jdGlvbiBub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcbiAgdmFyIG5lbmMgPSBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKTtcbiAgaWYgKHR5cGVvZiBuZW5jICE9PSAnc3RyaW5nJyAmJiAoQnVmZmVyLmlzRW5jb2RpbmcgPT09IGlzRW5jb2RpbmcgfHwgIWlzRW5jb2RpbmcoZW5jKSkpIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuYyk7XG4gIHJldHVybiBuZW5jIHx8IGVuYztcbn1cblxuLy8gU3RyaW5nRGVjb2RlciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVmZmljaWVudGx5IHNwbGl0dGluZyBhIHNlcmllcyBvZlxuLy8gYnVmZmVycyBpbnRvIGEgc2VyaWVzIG9mIEpTIHN0cmluZ3Mgd2l0aG91dCBicmVha2luZyBhcGFydCBtdWx0aS1ieXRlXG4vLyBjaGFyYWN0ZXJzLlxuZXhwb3J0cy5TdHJpbmdEZWNvZGVyID0gU3RyaW5nRGVjb2RlcjtcbmZ1bmN0aW9uIFN0cmluZ0RlY29kZXIoZW5jb2RpbmcpIHtcbiAgdGhpcy5lbmNvZGluZyA9IG5vcm1hbGl6ZUVuY29kaW5nKGVuY29kaW5nKTtcbiAgdmFyIG5iO1xuICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIHRoaXMudGV4dCA9IHV0ZjE2VGV4dDtcbiAgICAgIHRoaXMuZW5kID0gdXRmMTZFbmQ7XG4gICAgICBuYiA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1dGY4JzpcbiAgICAgIHRoaXMuZmlsbExhc3QgPSB1dGY4RmlsbExhc3Q7XG4gICAgICBuYiA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgdGhpcy50ZXh0ID0gYmFzZTY0VGV4dDtcbiAgICAgIHRoaXMuZW5kID0gYmFzZTY0RW5kO1xuICAgICAgbmIgPSAzO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMud3JpdGUgPSBzaW1wbGVXcml0ZTtcbiAgICAgIHRoaXMuZW5kID0gc2ltcGxlRW5kO1xuICAgICAgcmV0dXJuO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAwO1xuICB0aGlzLmxhc3RUb3RhbCA9IDA7XG4gIHRoaXMubGFzdENoYXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobmIpO1xufVxuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgdmFyIHI7XG4gIHZhciBpO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHIgPSB0aGlzLmZpbGxMYXN0KGJ1Zik7XG4gICAgaWYgKHIgPT09IHVuZGVmaW5lZCkgcmV0dXJuICcnO1xuICAgIGkgPSB0aGlzLmxhc3ROZWVkO1xuICAgIHRoaXMubGFzdE5lZWQgPSAwO1xuICB9IGVsc2Uge1xuICAgIGkgPSAwO1xuICB9XG4gIGlmIChpIDwgYnVmLmxlbmd0aCkgcmV0dXJuIHIgPyByICsgdGhpcy50ZXh0KGJ1ZiwgaSkgOiB0aGlzLnRleHQoYnVmLCBpKTtcbiAgcmV0dXJuIHIgfHwgJyc7XG59O1xuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSB1dGY4RW5kO1xuXG4vLyBSZXR1cm5zIG9ubHkgY29tcGxldGUgY2hhcmFjdGVycyBpbiBhIEJ1ZmZlclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUudGV4dCA9IHV0ZjhUZXh0O1xuXG4vLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIHBhcnRpYWwgbm9uLVVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5maWxsTGFzdCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgYnVmLmxlbmd0aCk7XG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcbn07XG5cbi8vIENoZWNrcyB0aGUgdHlwZSBvZiBhIFVURi04IGJ5dGUsIHdoZXRoZXIgaXQncyBBU0NJSSwgYSBsZWFkaW5nIGJ5dGUsIG9yIGFcbi8vIGNvbnRpbnVhdGlvbiBieXRlLiBJZiBhbiBpbnZhbGlkIGJ5dGUgaXMgZGV0ZWN0ZWQsIC0yIGlzIHJldHVybmVkLlxuZnVuY3Rpb24gdXRmOENoZWNrQnl0ZShieXRlKSB7XG4gIGlmIChieXRlIDw9IDB4N0YpIHJldHVybiAwO2Vsc2UgaWYgKGJ5dGUgPj4gNSA9PT0gMHgwNikgcmV0dXJuIDI7ZWxzZSBpZiAoYnl0ZSA+PiA0ID09PSAweDBFKSByZXR1cm4gMztlbHNlIGlmIChieXRlID4+IDMgPT09IDB4MUUpIHJldHVybiA0O1xuICByZXR1cm4gYnl0ZSA+PiA2ID09PSAweDAyID8gLTEgOiAtMjtcbn1cblxuLy8gQ2hlY2tzIGF0IG1vc3QgMyBieXRlcyBhdCB0aGUgZW5kIG9mIGEgQnVmZmVyIGluIG9yZGVyIHRvIGRldGVjdCBhblxuLy8gaW5jb21wbGV0ZSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3Rlci4gVGhlIHRvdGFsIG51bWJlciBvZiBieXRlcyAoMiwgMywgb3IgNClcbi8vIG5lZWRlZCB0byBjb21wbGV0ZSB0aGUgVVRGLTggY2hhcmFjdGVyIChpZiBhcHBsaWNhYmxlKSBhcmUgcmV0dXJuZWQuXG5mdW5jdGlvbiB1dGY4Q2hlY2tJbmNvbXBsZXRlKHNlbGYsIGJ1ZiwgaSkge1xuICB2YXIgaiA9IGJ1Zi5sZW5ndGggLSAxO1xuICBpZiAoaiA8IGkpIHJldHVybiAwO1xuICB2YXIgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMTtcbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgaWYgKC0taiA8IGkgfHwgbmIgPT09IC0yKSByZXR1cm4gMDtcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMjtcbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgaWYgKC0taiA8IGkgfHwgbmIgPT09IC0yKSByZXR1cm4gMDtcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkge1xuICAgICAgaWYgKG5iID09PSAyKSBuYiA9IDA7ZWxzZSBzZWxmLmxhc3ROZWVkID0gbmIgLSAzO1xuICAgIH1cbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgcmV0dXJuIDA7XG59XG5cbi8vIFZhbGlkYXRlcyBhcyBtYW55IGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciBhc1xuLy8gbmVlZGVkIG9yIGFyZSBhdmFpbGFibGUuIElmIHdlIHNlZSBhIG5vbi1jb250aW51YXRpb24gYnl0ZSB3aGVyZSB3ZSBleHBlY3Rcbi8vIG9uZSwgd2UgXCJyZXBsYWNlXCIgdGhlIHZhbGlkYXRlZCBjb250aW51YXRpb24gYnl0ZXMgd2UndmUgc2VlbiBzbyBmYXIgd2l0aFxuLy8gYSBzaW5nbGUgVVRGLTggcmVwbGFjZW1lbnQgY2hhcmFjdGVyICgnXFx1ZmZmZCcpLCB0byBtYXRjaCB2OCdzIFVURi04IGRlY29kaW5nXG4vLyBiZWhhdmlvci4gVGhlIGNvbnRpbnVhdGlvbiBieXRlIGNoZWNrIGlzIGluY2x1ZGVkIHRocmVlIHRpbWVzIGluIHRoZSBjYXNlXG4vLyB3aGVyZSBhbGwgb2YgdGhlIGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBjaGFyYWN0ZXIgZXhpc3QgaW4gdGhlIHNhbWUgYnVmZmVyLlxuLy8gSXQgaXMgYWxzbyBkb25lIHRoaXMgd2F5IGFzIGEgc2xpZ2h0IHBlcmZvcm1hbmNlIGluY3JlYXNlIGluc3RlYWQgb2YgdXNpbmcgYVxuLy8gbG9vcC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0V4dHJhQnl0ZXMoc2VsZiwgYnVmLCBwKSB7XG4gIGlmICgoYnVmWzBdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICBzZWxmLmxhc3ROZWVkID0gMDtcbiAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICB9XG4gIGlmIChzZWxmLmxhc3ROZWVkID4gMSAmJiBidWYubGVuZ3RoID4gMSkge1xuICAgIGlmICgoYnVmWzFdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgIHNlbGYubGFzdE5lZWQgPSAxO1xuICAgICAgcmV0dXJuICdcXHVmZmZkJztcbiAgICB9XG4gICAgaWYgKHNlbGYubGFzdE5lZWQgPiAyICYmIGJ1Zi5sZW5ndGggPiAyKSB7XG4gICAgICBpZiAoKGJ1ZlsyXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICAgIHNlbGYubGFzdE5lZWQgPSAyO1xuICAgICAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXIuXG5mdW5jdGlvbiB1dGY4RmlsbExhc3QoYnVmKSB7XG4gIHZhciBwID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xuICB2YXIgciA9IHV0ZjhDaGVja0V4dHJhQnl0ZXModGhpcywgYnVmLCBwKTtcbiAgaWYgKHIgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHI7XG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCB0aGlzLmxhc3ROZWVkKTtcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XG4gIH1cbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgYnVmLmxlbmd0aCk7XG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcbn1cblxuLy8gUmV0dXJucyBhbGwgY29tcGxldGUgVVRGLTggY2hhcmFjdGVycyBpbiBhIEJ1ZmZlci4gSWYgdGhlIEJ1ZmZlciBlbmRlZCBvbiBhXG4vLyBwYXJ0aWFsIGNoYXJhY3RlciwgdGhlIGNoYXJhY3RlcidzIGJ5dGVzIGFyZSBidWZmZXJlZCB1bnRpbCB0aGUgcmVxdWlyZWRcbi8vIG51bWJlciBvZiBieXRlcyBhcmUgYXZhaWxhYmxlLlxuZnVuY3Rpb24gdXRmOFRleHQoYnVmLCBpKSB7XG4gIHZhciB0b3RhbCA9IHV0ZjhDaGVja0luY29tcGxldGUodGhpcywgYnVmLCBpKTtcbiAgaWYgKCF0aGlzLmxhc3ROZWVkKSByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSk7XG4gIHRoaXMubGFzdFRvdGFsID0gdG90YWw7XG4gIHZhciBlbmQgPSBidWYubGVuZ3RoIC0gKHRvdGFsIC0gdGhpcy5sYXN0TmVlZCk7XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIDAsIGVuZCk7XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpLCBlbmQpO1xufVxuXG4vLyBGb3IgVVRGLTgsIGEgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIGlzIGFkZGVkIHdoZW4gZW5kaW5nIG9uIGEgcGFydGlhbFxuLy8gY2hhcmFjdGVyLlxuZnVuY3Rpb24gdXRmOEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyAnXFx1ZmZmZCc7XG4gIHJldHVybiByO1xufVxuXG4vLyBVVEYtMTZMRSB0eXBpY2FsbHkgbmVlZHMgdHdvIGJ5dGVzIHBlciBjaGFyYWN0ZXIsIGJ1dCBldmVuIGlmIHdlIGhhdmUgYW4gZXZlblxuLy8gbnVtYmVyIG9mIGJ5dGVzIGF2YWlsYWJsZSwgd2UgbmVlZCB0byBjaGVjayBpZiB3ZSBlbmQgb24gYSBsZWFkaW5nL2hpZ2hcbi8vIHN1cnJvZ2F0ZS4gSW4gdGhhdCBjYXNlLCB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBuZXh0IHR3byBieXRlcyBpbiBvcmRlciB0b1xuLy8gZGVjb2RlIHRoZSBsYXN0IGNoYXJhY3RlciBwcm9wZXJseS5cbmZ1bmN0aW9uIHV0ZjE2VGV4dChidWYsIGkpIHtcbiAgaWYgKChidWYubGVuZ3RoIC0gaSkgJSAyID09PSAwKSB7XG4gICAgdmFyIHIgPSBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpKTtcbiAgICBpZiAocikge1xuICAgICAgdmFyIGMgPSByLmNoYXJDb2RlQXQoci5sZW5ndGggLSAxKTtcbiAgICAgIGlmIChjID49IDB4RDgwMCAmJiBjIDw9IDB4REJGRikge1xuICAgICAgICB0aGlzLmxhc3ROZWVkID0gMjtcbiAgICAgICAgdGhpcy5sYXN0VG90YWwgPSA0O1xuICAgICAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiByLnNsaWNlKDAsIC0xKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgdGhpcy5sYXN0TmVlZCA9IDE7XG4gIHRoaXMubGFzdFRvdGFsID0gMjtcbiAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpLCBidWYubGVuZ3RoIC0gMSk7XG59XG5cbi8vIEZvciBVVEYtMTZMRSB3ZSBkbyBub3QgZXhwbGljaXRseSBhcHBlbmQgc3BlY2lhbCByZXBsYWNlbWVudCBjaGFyYWN0ZXJzIGlmIHdlXG4vLyBlbmQgb24gYSBwYXJ0aWFsIGNoYXJhY3Rlciwgd2Ugc2ltcGx5IGxldCB2OCBoYW5kbGUgdGhhdC5cbmZ1bmN0aW9uIHV0ZjE2RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XG4gICAgdmFyIGVuZCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgICByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ3V0ZjE2bGUnLCAwLCBlbmQpO1xuICB9XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRUZXh0KGJ1ZiwgaSkge1xuICB2YXIgbiA9IChidWYubGVuZ3RoIC0gaSkgJSAzO1xuICBpZiAobiA9PT0gMCkgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSk7XG4gIHRoaXMubGFzdE5lZWQgPSAzIC0gbjtcbiAgdGhpcy5sYXN0VG90YWwgPSAzO1xuICBpZiAobiA9PT0gMSkge1xuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICB9IGVsc2Uge1xuICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xuICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICB9XG4gIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGksIGJ1Zi5sZW5ndGggLSBuKTtcbn1cblxuZnVuY3Rpb24gYmFzZTY0RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ2Jhc2U2NCcsIDAsIDMgLSB0aGlzLmxhc3ROZWVkKTtcbiAgcmV0dXJuIHI7XG59XG5cbi8vIFBhc3MgYnl0ZXMgb24gdGhyb3VnaCBmb3Igc2luZ2xlLWJ5dGUgZW5jb2RpbmdzIChlLmcuIGFzY2lpLCBsYXRpbjEsIGhleClcbmZ1bmN0aW9uIHNpbXBsZVdyaXRlKGJ1Zikge1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xufVxuXG5mdW5jdGlvbiBzaW1wbGVFbmQoYnVmKSB7XG4gIHJldHVybiBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xufSIsInZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKVxuXG4vLyB0aHJvdWdoXG4vL1xuLy8gYSBzdHJlYW0gdGhhdCBkb2VzIG5vdGhpbmcgYnV0IHJlLWVtaXQgdGhlIGlucHV0LlxuLy8gdXNlZnVsIGZvciBhZ2dyZWdhdGluZyBhIHNlcmllcyBvZiBjaGFuZ2luZyBidXQgbm90IGVuZGluZyBzdHJlYW1zIGludG8gb25lIHN0cmVhbSlcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gdGhyb3VnaFxudGhyb3VnaC50aHJvdWdoID0gdGhyb3VnaFxuXG4vL2NyZWF0ZSBhIHJlYWRhYmxlIHdyaXRhYmxlIHN0cmVhbS5cblxuZnVuY3Rpb24gdGhyb3VnaCAod3JpdGUsIGVuZCwgb3B0cykge1xuICB3cml0ZSA9IHdyaXRlIHx8IGZ1bmN0aW9uIChkYXRhKSB7IHRoaXMucXVldWUoZGF0YSkgfVxuICBlbmQgPSBlbmQgfHwgZnVuY3Rpb24gKCkgeyB0aGlzLnF1ZXVlKG51bGwpIH1cblxuICB2YXIgZW5kZWQgPSBmYWxzZSwgZGVzdHJveWVkID0gZmFsc2UsIGJ1ZmZlciA9IFtdLCBfZW5kZWQgPSBmYWxzZVxuICB2YXIgc3RyZWFtID0gbmV3IFN0cmVhbSgpXG4gIHN0cmVhbS5yZWFkYWJsZSA9IHN0cmVhbS53cml0YWJsZSA9IHRydWVcbiAgc3RyZWFtLnBhdXNlZCA9IGZhbHNlXG5cbi8vICBzdHJlYW0uYXV0b1BhdXNlICAgPSAhKG9wdHMgJiYgb3B0cy5hdXRvUGF1c2UgICA9PT0gZmFsc2UpXG4gIHN0cmVhbS5hdXRvRGVzdHJveSA9ICEob3B0cyAmJiBvcHRzLmF1dG9EZXN0cm95ID09PSBmYWxzZSlcblxuICBzdHJlYW0ud3JpdGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHdyaXRlLmNhbGwodGhpcywgZGF0YSlcbiAgICByZXR1cm4gIXN0cmVhbS5wYXVzZWRcbiAgfVxuXG4gIGZ1bmN0aW9uIGRyYWluKCkge1xuICAgIHdoaWxlKGJ1ZmZlci5sZW5ndGggJiYgIXN0cmVhbS5wYXVzZWQpIHtcbiAgICAgIHZhciBkYXRhID0gYnVmZmVyLnNoaWZ0KClcbiAgICAgIGlmKG51bGwgPT09IGRhdGEpXG4gICAgICAgIHJldHVybiBzdHJlYW0uZW1pdCgnZW5kJylcbiAgICAgIGVsc2VcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBkYXRhKVxuICAgIH1cbiAgfVxuXG4gIHN0cmVhbS5xdWV1ZSA9IHN0cmVhbS5wdXNoID0gZnVuY3Rpb24gKGRhdGEpIHtcbi8vICAgIGNvbnNvbGUuZXJyb3IoZW5kZWQpXG4gICAgaWYoX2VuZGVkKSByZXR1cm4gc3RyZWFtXG4gICAgaWYoZGF0YSA9PT0gbnVsbCkgX2VuZGVkID0gdHJ1ZVxuICAgIGJ1ZmZlci5wdXNoKGRhdGEpXG4gICAgZHJhaW4oKVxuICAgIHJldHVybiBzdHJlYW1cbiAgfVxuXG4gIC8vdGhpcyB3aWxsIGJlIHJlZ2lzdGVyZWQgYXMgdGhlIGZpcnN0ICdlbmQnIGxpc3RlbmVyXG4gIC8vbXVzdCBjYWxsIGRlc3Ryb3kgbmV4dCB0aWNrLCB0byBtYWtlIHN1cmUgd2UncmUgYWZ0ZXIgYW55XG4gIC8vc3RyZWFtIHBpcGVkIGZyb20gaGVyZS5cbiAgLy90aGlzIGlzIG9ubHkgYSBwcm9ibGVtIGlmIGVuZCBpcyBub3QgZW1pdHRlZCBzeW5jaHJvbm91c2x5LlxuICAvL2EgbmljZXIgd2F5IHRvIGRvIHRoaXMgaXMgdG8gbWFrZSBzdXJlIHRoaXMgaXMgdGhlIGxhc3QgbGlzdGVuZXIgZm9yICdlbmQnXG5cbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2VcbiAgICBpZighc3RyZWFtLndyaXRhYmxlICYmIHN0cmVhbS5hdXRvRGVzdHJveSlcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBzdHJlYW0uZGVzdHJveSgpXG4gICAgICB9KVxuICB9KVxuXG4gIGZ1bmN0aW9uIF9lbmQgKCkge1xuICAgIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlXG4gICAgZW5kLmNhbGwoc3RyZWFtKVxuICAgIGlmKCFzdHJlYW0ucmVhZGFibGUgJiYgc3RyZWFtLmF1dG9EZXN0cm95KVxuICAgICAgc3RyZWFtLmRlc3Ryb3koKVxuICB9XG5cbiAgc3RyZWFtLmVuZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYoZW5kZWQpIHJldHVyblxuICAgIGVuZGVkID0gdHJ1ZVxuICAgIGlmKGFyZ3VtZW50cy5sZW5ndGgpIHN0cmVhbS53cml0ZShkYXRhKVxuICAgIF9lbmQoKSAvLyB3aWxsIGVtaXQgb3IgcXVldWVcbiAgICByZXR1cm4gc3RyZWFtXG4gIH1cblxuICBzdHJlYW0uZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZihkZXN0cm95ZWQpIHJldHVyblxuICAgIGRlc3Ryb3llZCA9IHRydWVcbiAgICBlbmRlZCA9IHRydWVcbiAgICBidWZmZXIubGVuZ3RoID0gMFxuICAgIHN0cmVhbS53cml0YWJsZSA9IHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlXG4gICAgc3RyZWFtLmVtaXQoJ2Nsb3NlJylcbiAgICByZXR1cm4gc3RyZWFtXG4gIH1cblxuICBzdHJlYW0ucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYoc3RyZWFtLnBhdXNlZCkgcmV0dXJuXG4gICAgc3RyZWFtLnBhdXNlZCA9IHRydWVcbiAgICByZXR1cm4gc3RyZWFtXG4gIH1cblxuICBzdHJlYW0ucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgIGlmKHN0cmVhbS5wYXVzZWQpIHtcbiAgICAgIHN0cmVhbS5wYXVzZWQgPSBmYWxzZVxuICAgICAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpXG4gICAgfVxuICAgIGRyYWluKClcbiAgICAvL21heSBoYXZlIGJlY29tZSBwYXVzZWQgYWdhaW4sXG4gICAgLy9hcyBkcmFpbiBlbWl0cyAnZGF0YScuXG4gICAgaWYoIXN0cmVhbS5wYXVzZWQpXG4gICAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKVxuICAgIHJldHVybiBzdHJlYW1cbiAgfVxuICByZXR1cm4gc3RyZWFtXG59XG5cbiIsInZhciBuZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MvYnJvd3Nlci5qcycpLm5leHRUaWNrO1xudmFyIGFwcGx5ID0gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5O1xudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xudmFyIGltbWVkaWF0ZUlkcyA9IHt9O1xudmFyIG5leHRJbW1lZGlhdGVJZCA9IDA7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7IHRpbWVvdXQuY2xvc2UoKTsgfTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbCh3aW5kb3csIHRoaXMuX2lkKTtcbn07XG5cbi8vIERvZXMgbm90IHN0YXJ0IHRoZSB0aW1lLCBqdXN0IHNldHMgdXAgdGhlIG1lbWJlcnMgbmVlZGVkLlxuZXhwb3J0cy5lbnJvbGwgPSBmdW5jdGlvbihpdGVtLCBtc2Vjcykge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gbXNlY3M7XG59O1xuXG5leHBvcnRzLnVuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XG59O1xuXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XG5cbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XG4gIGlmIChtc2VjcyA+PSAwKSB7XG4gICAgaXRlbS5faWRsZVRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gb25UaW1lb3V0KCkge1xuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcbiAgICAgICAgaXRlbS5fb25UaW1lb3V0KCk7XG4gICAgfSwgbXNlY3MpO1xuICB9XG59O1xuXG4vLyBUaGF0J3Mgbm90IGhvdyBub2RlLmpzIGltcGxlbWVudHMgaXQgYnV0IHRoZSBleHBvc2VkIGFwaSBpcyB0aGUgc2FtZS5cbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gdHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gc2V0SW1tZWRpYXRlIDogZnVuY3Rpb24oZm4pIHtcbiAgdmFyIGlkID0gbmV4dEltbWVkaWF0ZUlkKys7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBmYWxzZSA6IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICBpbW1lZGlhdGVJZHNbaWRdID0gdHJ1ZTtcblxuICBuZXh0VGljayhmdW5jdGlvbiBvbk5leHRUaWNrKCkge1xuICAgIGlmIChpbW1lZGlhdGVJZHNbaWRdKSB7XG4gICAgICAvLyBmbi5jYWxsKCkgaXMgZmFzdGVyIHNvIHdlIG9wdGltaXplIGZvciB0aGUgY29tbW9uIHVzZS1jYXNlXG4gICAgICAvLyBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2NhbGwtYXBwbHktc2VndVxuICAgICAgaWYgKGFyZ3MpIHtcbiAgICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbi5jYWxsKG51bGwpO1xuICAgICAgfVxuICAgICAgLy8gUHJldmVudCBpZHMgZnJvbSBsZWFraW5nXG4gICAgICBleHBvcnRzLmNsZWFySW1tZWRpYXRlKGlkKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBpZDtcbn07XG5cbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSB0eXBlb2YgY2xlYXJJbW1lZGlhdGUgPT09IFwiZnVuY3Rpb25cIiA/IGNsZWFySW1tZWRpYXRlIDogZnVuY3Rpb24oaWQpIHtcbiAgZGVsZXRlIGltbWVkaWF0ZUlkc1tpZF07XG59OyIsIid1c2Ugc3RyaWN0J1xuXG52YXIgYml0cyA9IHJlcXVpcmUoJ2JpdC10d2lkZGxlJylcbnZhciBkdXAgPSByZXF1aXJlKCdkdXAnKVxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlclxuXG4vL0xlZ2FjeSBwb29sIHN1cHBvcnRcbmlmKCFnbG9iYWwuX19UWVBFREFSUkFZX1BPT0wpIHtcbiAgZ2xvYmFsLl9fVFlQRURBUlJBWV9QT09MID0ge1xuICAgICAgVUlOVDggICAgIDogZHVwKFszMiwgMF0pXG4gICAgLCBVSU5UMTYgICAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIFVJTlQzMiAgICA6IGR1cChbMzIsIDBdKVxuICAgICwgQklHVUlOVDY0IDogZHVwKFszMiwgMF0pXG4gICAgLCBJTlQ4ICAgICAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIElOVDE2ICAgICA6IGR1cChbMzIsIDBdKVxuICAgICwgSU5UMzIgICAgIDogZHVwKFszMiwgMF0pXG4gICAgLCBCSUdJTlQ2NCAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIEZMT0FUICAgICA6IGR1cChbMzIsIDBdKVxuICAgICwgRE9VQkxFICAgIDogZHVwKFszMiwgMF0pXG4gICAgLCBEQVRBICAgICAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIFVJTlQ4QyAgICA6IGR1cChbMzIsIDBdKVxuICAgICwgQlVGRkVSICAgIDogZHVwKFszMiwgMF0pXG4gIH1cbn1cblxudmFyIGhhc1VpbnQ4QyA9ICh0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkpICE9PSAndW5kZWZpbmVkJ1xudmFyIGhhc0JpZ1VpbnQ2NCA9ICh0eXBlb2YgQmlnVWludDY0QXJyYXkpICE9PSAndW5kZWZpbmVkJ1xudmFyIGhhc0JpZ0ludDY0ID0gKHR5cGVvZiBCaWdJbnQ2NEFycmF5KSAhPT0gJ3VuZGVmaW5lZCdcbnZhciBQT09MID0gZ2xvYmFsLl9fVFlQRURBUlJBWV9QT09MXG5cbi8vVXBncmFkZSBwb29sXG5pZighUE9PTC5VSU5UOEMpIHtcbiAgUE9PTC5VSU5UOEMgPSBkdXAoWzMyLCAwXSlcbn1cbmlmKCFQT09MLkJJR1VJTlQ2NCkge1xuICBQT09MLkJJR1VJTlQ2NCA9IGR1cChbMzIsIDBdKVxufVxuaWYoIVBPT0wuQklHSU5UNjQpIHtcbiAgUE9PTC5CSUdJTlQ2NCA9IGR1cChbMzIsIDBdKVxufVxuaWYoIVBPT0wuQlVGRkVSKSB7XG4gIFBPT0wuQlVGRkVSID0gZHVwKFszMiwgMF0pXG59XG5cbi8vTmV3IHRlY2huaXF1ZTogT25seSBhbGxvY2F0ZSBmcm9tIEFycmF5QnVmZmVyVmlldyBhbmQgQnVmZmVyXG52YXIgREFUQSAgICA9IFBPT0wuREFUQVxuICAsIEJVRkZFUiAgPSBQT09MLkJVRkZFUlxuXG5leHBvcnRzLmZyZWUgPSBmdW5jdGlvbiBmcmVlKGFycmF5KSB7XG4gIGlmKEJ1ZmZlci5pc0J1ZmZlcihhcnJheSkpIHtcbiAgICBCVUZGRVJbYml0cy5sb2cyKGFycmF5Lmxlbmd0aCldLnB1c2goYXJyYXkpXG4gIH0gZWxzZSB7XG4gICAgaWYoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFycmF5KSAhPT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykge1xuICAgICAgYXJyYXkgPSBhcnJheS5idWZmZXJcbiAgICB9XG4gICAgaWYoIWFycmF5KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFyIG4gPSBhcnJheS5sZW5ndGggfHwgYXJyYXkuYnl0ZUxlbmd0aFxuICAgIHZhciBsb2dfbiA9IGJpdHMubG9nMihuKXwwXG4gICAgREFUQVtsb2dfbl0ucHVzaChhcnJheSlcbiAgfVxufVxuXG5mdW5jdGlvbiBmcmVlQXJyYXlCdWZmZXIoYnVmZmVyKSB7XG4gIGlmKCFidWZmZXIpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgbiA9IGJ1ZmZlci5sZW5ndGggfHwgYnVmZmVyLmJ5dGVMZW5ndGhcbiAgdmFyIGxvZ19uID0gYml0cy5sb2cyKG4pXG4gIERBVEFbbG9nX25dLnB1c2goYnVmZmVyKVxufVxuXG5mdW5jdGlvbiBmcmVlVHlwZWRBcnJheShhcnJheSkge1xuICBmcmVlQXJyYXlCdWZmZXIoYXJyYXkuYnVmZmVyKVxufVxuXG5leHBvcnRzLmZyZWVVaW50OCA9XG5leHBvcnRzLmZyZWVVaW50MTYgPVxuZXhwb3J0cy5mcmVlVWludDMyID1cbmV4cG9ydHMuZnJlZUJpZ1VpbnQ2NCA9XG5leHBvcnRzLmZyZWVJbnQ4ID1cbmV4cG9ydHMuZnJlZUludDE2ID1cbmV4cG9ydHMuZnJlZUludDMyID1cbmV4cG9ydHMuZnJlZUJpZ0ludDY0ID1cbmV4cG9ydHMuZnJlZUZsb2F0MzIgPSBcbmV4cG9ydHMuZnJlZUZsb2F0ID1cbmV4cG9ydHMuZnJlZUZsb2F0NjQgPSBcbmV4cG9ydHMuZnJlZURvdWJsZSA9IFxuZXhwb3J0cy5mcmVlVWludDhDbGFtcGVkID0gXG5leHBvcnRzLmZyZWVEYXRhVmlldyA9IGZyZWVUeXBlZEFycmF5XG5cbmV4cG9ydHMuZnJlZUFycmF5QnVmZmVyID0gZnJlZUFycmF5QnVmZmVyXG5cbmV4cG9ydHMuZnJlZUJ1ZmZlciA9IGZ1bmN0aW9uIGZyZWVCdWZmZXIoYXJyYXkpIHtcbiAgQlVGRkVSW2JpdHMubG9nMihhcnJheS5sZW5ndGgpXS5wdXNoKGFycmF5KVxufVxuXG5leHBvcnRzLm1hbGxvYyA9IGZ1bmN0aW9uIG1hbGxvYyhuLCBkdHlwZSkge1xuICBpZihkdHlwZSA9PT0gdW5kZWZpbmVkIHx8IGR0eXBlID09PSAnYXJyYXlidWZmZXInKSB7XG4gICAgcmV0dXJuIG1hbGxvY0FycmF5QnVmZmVyKG4pXG4gIH0gZWxzZSB7XG4gICAgc3dpdGNoKGR0eXBlKSB7XG4gICAgICBjYXNlICd1aW50OCc6XG4gICAgICAgIHJldHVybiBtYWxsb2NVaW50OChuKVxuICAgICAgY2FzZSAndWludDE2JzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY1VpbnQxNihuKVxuICAgICAgY2FzZSAndWludDMyJzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY1VpbnQzMihuKVxuICAgICAgY2FzZSAnaW50OCc6XG4gICAgICAgIHJldHVybiBtYWxsb2NJbnQ4KG4pXG4gICAgICBjYXNlICdpbnQxNic6XG4gICAgICAgIHJldHVybiBtYWxsb2NJbnQxNihuKVxuICAgICAgY2FzZSAnaW50MzInOlxuICAgICAgICByZXR1cm4gbWFsbG9jSW50MzIobilcbiAgICAgIGNhc2UgJ2Zsb2F0JzpcbiAgICAgIGNhc2UgJ2Zsb2F0MzInOlxuICAgICAgICByZXR1cm4gbWFsbG9jRmxvYXQobilcbiAgICAgIGNhc2UgJ2RvdWJsZSc6XG4gICAgICBjYXNlICdmbG9hdDY0JzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY0RvdWJsZShuKVxuICAgICAgY2FzZSAndWludDhfY2xhbXBlZCc6XG4gICAgICAgIHJldHVybiBtYWxsb2NVaW50OENsYW1wZWQobilcbiAgICAgIGNhc2UgJ2JpZ2ludDY0JzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY0JpZ0ludDY0KG4pXG4gICAgICBjYXNlICdiaWd1aW50NjQnOlxuICAgICAgICByZXR1cm4gbWFsbG9jQmlnVWludDY0KG4pXG4gICAgICBjYXNlICdidWZmZXInOlxuICAgICAgICByZXR1cm4gbWFsbG9jQnVmZmVyKG4pXG4gICAgICBjYXNlICdkYXRhJzpcbiAgICAgIGNhc2UgJ2RhdGF2aWV3JzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY0RhdGFWaWV3KG4pXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsXG59XG5cbmZ1bmN0aW9uIG1hbGxvY0FycmF5QnVmZmVyKG4pIHtcbiAgdmFyIG4gPSBiaXRzLm5leHRQb3cyKG4pXG4gIHZhciBsb2dfbiA9IGJpdHMubG9nMihuKVxuICB2YXIgZCA9IERBVEFbbG9nX25dXG4gIGlmKGQubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBkLnBvcCgpXG4gIH1cbiAgcmV0dXJuIG5ldyBBcnJheUJ1ZmZlcihuKVxufVxuZXhwb3J0cy5tYWxsb2NBcnJheUJ1ZmZlciA9IG1hbGxvY0FycmF5QnVmZmVyXG5cbmZ1bmN0aW9uIG1hbGxvY1VpbnQ4KG4pIHtcbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG1hbGxvY0FycmF5QnVmZmVyKG4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NVaW50OCA9IG1hbGxvY1VpbnQ4XG5cbmZ1bmN0aW9uIG1hbGxvY1VpbnQxNihuKSB7XG4gIHJldHVybiBuZXcgVWludDE2QXJyYXkobWFsbG9jQXJyYXlCdWZmZXIoMipuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jVWludDE2ID0gbWFsbG9jVWludDE2XG5cbmZ1bmN0aW9uIG1hbGxvY1VpbnQzMihuKSB7XG4gIHJldHVybiBuZXcgVWludDMyQXJyYXkobWFsbG9jQXJyYXlCdWZmZXIoNCpuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jVWludDMyID0gbWFsbG9jVWludDMyXG5cbmZ1bmN0aW9uIG1hbGxvY0ludDgobikge1xuICByZXR1cm4gbmV3IEludDhBcnJheShtYWxsb2NBcnJheUJ1ZmZlcihuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jSW50OCA9IG1hbGxvY0ludDhcblxuZnVuY3Rpb24gbWFsbG9jSW50MTYobikge1xuICByZXR1cm4gbmV3IEludDE2QXJyYXkobWFsbG9jQXJyYXlCdWZmZXIoMipuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jSW50MTYgPSBtYWxsb2NJbnQxNlxuXG5mdW5jdGlvbiBtYWxsb2NJbnQzMihuKSB7XG4gIHJldHVybiBuZXcgSW50MzJBcnJheShtYWxsb2NBcnJheUJ1ZmZlcig0Km4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NJbnQzMiA9IG1hbGxvY0ludDMyXG5cbmZ1bmN0aW9uIG1hbGxvY0Zsb2F0KG4pIHtcbiAgcmV0dXJuIG5ldyBGbG9hdDMyQXJyYXkobWFsbG9jQXJyYXlCdWZmZXIoNCpuKSwgMCwgbilcbn1cbmV4cG9ydHMubWFsbG9jRmxvYXQzMiA9IGV4cG9ydHMubWFsbG9jRmxvYXQgPSBtYWxsb2NGbG9hdFxuXG5mdW5jdGlvbiBtYWxsb2NEb3VibGUobikge1xuICByZXR1cm4gbmV3IEZsb2F0NjRBcnJheShtYWxsb2NBcnJheUJ1ZmZlcig4Km4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NGbG9hdDY0ID0gZXhwb3J0cy5tYWxsb2NEb3VibGUgPSBtYWxsb2NEb3VibGVcblxuZnVuY3Rpb24gbWFsbG9jVWludDhDbGFtcGVkKG4pIHtcbiAgaWYoaGFzVWludDhDKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OENsYW1wZWRBcnJheShtYWxsb2NBcnJheUJ1ZmZlcihuKSwgMCwgbilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbWFsbG9jVWludDgobilcbiAgfVxufVxuZXhwb3J0cy5tYWxsb2NVaW50OENsYW1wZWQgPSBtYWxsb2NVaW50OENsYW1wZWRcblxuZnVuY3Rpb24gbWFsbG9jQmlnVWludDY0KG4pIHtcbiAgaWYoaGFzQmlnVWludDY0KSB7XG4gICAgcmV0dXJuIG5ldyBCaWdVaW50NjRBcnJheShtYWxsb2NBcnJheUJ1ZmZlcig4Km4pLCAwLCBuKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5leHBvcnRzLm1hbGxvY0JpZ1VpbnQ2NCA9IG1hbGxvY0JpZ1VpbnQ2NFxuXG5mdW5jdGlvbiBtYWxsb2NCaWdJbnQ2NChuKSB7XG4gIGlmIChoYXNCaWdJbnQ2NCkge1xuICAgIHJldHVybiBuZXcgQmlnSW50NjRBcnJheShtYWxsb2NBcnJheUJ1ZmZlcig4Km4pLCAwLCBuKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5leHBvcnRzLm1hbGxvY0JpZ0ludDY0ID0gbWFsbG9jQmlnSW50NjRcblxuZnVuY3Rpb24gbWFsbG9jRGF0YVZpZXcobikge1xuICByZXR1cm4gbmV3IERhdGFWaWV3KG1hbGxvY0FycmF5QnVmZmVyKG4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NEYXRhVmlldyA9IG1hbGxvY0RhdGFWaWV3XG5cbmZ1bmN0aW9uIG1hbGxvY0J1ZmZlcihuKSB7XG4gIG4gPSBiaXRzLm5leHRQb3cyKG4pXG4gIHZhciBsb2dfbiA9IGJpdHMubG9nMihuKVxuICB2YXIgY2FjaGUgPSBCVUZGRVJbbG9nX25dXG4gIGlmKGNhY2hlLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gY2FjaGUucG9wKClcbiAgfVxuICByZXR1cm4gbmV3IEJ1ZmZlcihuKVxufVxuZXhwb3J0cy5tYWxsb2NCdWZmZXIgPSBtYWxsb2NCdWZmZXJcblxuZXhwb3J0cy5jbGVhckNhY2hlID0gZnVuY3Rpb24gY2xlYXJDYWNoZSgpIHtcbiAgZm9yKHZhciBpPTA7IGk8MzI7ICsraSkge1xuICAgIFBPT0wuVUlOVDhbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuVUlOVDE2W2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLlVJTlQzMltpXS5sZW5ndGggPSAwXG4gICAgUE9PTC5JTlQ4W2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLklOVDE2W2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLklOVDMyW2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLkZMT0FUW2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLkRPVUJMRVtpXS5sZW5ndGggPSAwXG4gICAgUE9PTC5CSUdVSU5UNjRbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuQklHSU5UNjRbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuVUlOVDhDW2ldLmxlbmd0aCA9IDBcbiAgICBEQVRBW2ldLmxlbmd0aCA9IDBcbiAgICBCVUZGRVJbaV0ubGVuZ3RoID0gMFxuICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIlxuXG5mdW5jdGlvbiB1bmlxdWVfcHJlZChsaXN0LCBjb21wYXJlKSB7XG4gIHZhciBwdHIgPSAxXG4gICAgLCBsZW4gPSBsaXN0Lmxlbmd0aFxuICAgICwgYT1saXN0WzBdLCBiPWxpc3RbMF1cbiAgZm9yKHZhciBpPTE7IGk8bGVuOyArK2kpIHtcbiAgICBiID0gYVxuICAgIGEgPSBsaXN0W2ldXG4gICAgaWYoY29tcGFyZShhLCBiKSkge1xuICAgICAgaWYoaSA9PT0gcHRyKSB7XG4gICAgICAgIHB0cisrXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBsaXN0W3B0cisrXSA9IGFcbiAgICB9XG4gIH1cbiAgbGlzdC5sZW5ndGggPSBwdHJcbiAgcmV0dXJuIGxpc3Rcbn1cblxuZnVuY3Rpb24gdW5pcXVlX2VxKGxpc3QpIHtcbiAgdmFyIHB0ciA9IDFcbiAgICAsIGxlbiA9IGxpc3QubGVuZ3RoXG4gICAgLCBhPWxpc3RbMF0sIGIgPSBsaXN0WzBdXG4gIGZvcih2YXIgaT0xOyBpPGxlbjsgKytpLCBiPWEpIHtcbiAgICBiID0gYVxuICAgIGEgPSBsaXN0W2ldXG4gICAgaWYoYSAhPT0gYikge1xuICAgICAgaWYoaSA9PT0gcHRyKSB7XG4gICAgICAgIHB0cisrXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBsaXN0W3B0cisrXSA9IGFcbiAgICB9XG4gIH1cbiAgbGlzdC5sZW5ndGggPSBwdHJcbiAgcmV0dXJuIGxpc3Rcbn1cblxuZnVuY3Rpb24gdW5pcXVlKGxpc3QsIGNvbXBhcmUsIHNvcnRlZCkge1xuICBpZihsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBsaXN0XG4gIH1cbiAgaWYoY29tcGFyZSkge1xuICAgIGlmKCFzb3J0ZWQpIHtcbiAgICAgIGxpc3Quc29ydChjb21wYXJlKVxuICAgIH1cbiAgICByZXR1cm4gdW5pcXVlX3ByZWQobGlzdCwgY29tcGFyZSlcbiAgfVxuICBpZighc29ydGVkKSB7XG4gICAgbGlzdC5zb3J0KClcbiAgfVxuICByZXR1cm4gdW5pcXVlX2VxKGxpc3QpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gdW5pcXVlXG4iLCJcbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBkZXByZWNhdGU7XG5cbi8qKlxuICogTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cbiAqIFJldHVybnMgYSBtb2RpZmllZCBmdW5jdGlvbiB3aGljaCB3YXJucyBvbmNlIGJ5IGRlZmF1bHQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS5ub0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50aHJvd0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIHRocm93IGFuIEVycm9yIHdoZW4gaW52b2tlZC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRyYWNlRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgaW52b2tlIGBjb25zb2xlLnRyYWNlKClgIGluc3RlYWQgb2YgYGNvbnNvbGUuZXJyb3IoKWAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSB0aGUgZnVuY3Rpb24gdG8gZGVwcmVjYXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gbXNnIC0gdGhlIHN0cmluZyB0byBwcmludCB0byB0aGUgY29uc29sZSB3aGVuIGBmbmAgaXMgaW52b2tlZFxuICogQHJldHVybnMge0Z1bmN0aW9ufSBhIG5ldyBcImRlcHJlY2F0ZWRcIiB2ZXJzaW9uIG9mIGBmbmBcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVwcmVjYXRlIChmbiwgbXNnKSB7XG4gIGlmIChjb25maWcoJ25vRGVwcmVjYXRpb24nKSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgaWYgKGNvbmZpZygndGhyb3dEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChjb25maWcoJ3RyYWNlRGVwcmVjYXRpb24nKSkge1xuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4obXNnKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9XG5cbiAgcmV0dXJuIGRlcHJlY2F0ZWQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGBsb2NhbFN0b3JhZ2VgIGZvciBib29sZWFuIHZhbHVlcyBmb3IgdGhlIGdpdmVuIGBuYW1lYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb25maWcgKG5hbWUpIHtcbiAgLy8gYWNjZXNzaW5nIGdsb2JhbC5sb2NhbFN0b3JhZ2UgY2FuIHRyaWdnZXIgYSBET01FeGNlcHRpb24gaW4gc2FuZGJveGVkIGlmcmFtZXNcbiAgdHJ5IHtcbiAgICBpZiAoIWdsb2JhbC5sb2NhbFN0b3JhZ2UpIHJldHVybiBmYWxzZTtcbiAgfSBjYXRjaCAoXykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgdmFsID0gZ2xvYmFsLmxvY2FsU3RvcmFnZVtuYW1lXTtcbiAgaWYgKG51bGwgPT0gdmFsKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiBTdHJpbmcodmFsKS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZSc7XG59XG4iXX0=
