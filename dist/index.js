(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
const SceneNode = require( './sceneNode.js' )
const { param_wrap, MaterialID } = require( './utils.js' )
const { Var, float_var_gen, vec2_var_gen, vec3_var_gen, vec4_var_gen, int_var_gen } = require( './var.js' )

const ops = { 
  Onion: {
    func( sdf,thickness ) { return `vec2( opOnion( ${sdf}.x, ${thickness} ), ${sdf}.y )` },
    variables:[['thickness', 'float', .03]]
  },
  Halve: {
    func( sdf, direction ) { return `vec2( opHalve( ${sdf}.x, p, ${direction} ), ${sdf}.y )` },
    variables:[['direction','int',0]]
  },
  Round: {
    func( sdf, amount ) { return `vec2( ${sdf}.x - ${amount}, ${sdf}.y )` },
    variables:[['amount','float',.1]]
  }
}


const Alterations= {}

for( let name in ops ) {

  // get codegen function
  let op = ops[ name ]

  // create constructor
  Alterations[ name ] = function( sdf, ...args ) {
    const __op = Object.create( Alterations[ name ].prototype )
    __op.sdf = sdf
    __op.variables = []
    __op.__desc = { parameters:[] }

    for( let i = 0; i < op.variables.length; i++ ) {
      const propArray = op.variables[ i ]
      const propName = propArray[ 0 ]
      const propType = propArray[ 1 ]
      const propValue = args[ i ] === undefined ? propArray[ 2 ] : args[ i ]

      __op.__desc.parameters.push({ name:propName, value:propValue })
      let param

      switch( propType ) {
        case 'int':
          param = int_var_gen( propValue )()
          break;
        default:
          param = float_var_gen( propValue )()
          break;
      }
      
      Object.defineProperty( __op, propName, {
        get() { return param },
        set(v) { param.set( v ) }
      })

      __op.variables.push( param )
    }
      
    __op.matId = MaterialID.alloc()

    return __op
  } 

  Alterations[ name ].prototype = SceneNode()

  Alterations[ name ].prototype.emit = function ( __name ) {
    const emitterA = this.sdf.emit( __name )
    //const emitterB = this.b.emit()

    const output = {
      out: op.func( emitterA.out, ...this.variables.map( v => v.emit() ) ), 
      preface: (emitterA.preface || '') 
    }

    return output
  }

  Alterations[name].prototype.emit_decl = function () {
    let str =  this.sdf.emit_decl() 
    for( let v of this.variables ) {
      str += v.emit_decl()
    }

    return str
  };

  Alterations[name].prototype.update_location = function(gl, program) {
    this.sdf.update_location( gl, program )
    for( let v of this.variables ) v.update_location( gl, program )
  }

  Alterations[name].prototype.upload_data = function(gl) {
    this.sdf.upload_data( gl )
    for( let v of this.variables ) v.upload_data( gl )
    
  }
}

Alterations.Halve.UP = 0
Alterations.Halve.DOWN = 1
Alterations.Halve.LEFT = 3
Alterations.Halve.RIGHT = 2

module.exports = Alterations

},{"./sceneNode.js":23,"./utils.js":28,"./var.js":29}],2:[function(require,module,exports){
const Audio = {
  __hasInput: false,
  ctx: null,

  start() {
    if( Audio.__hasInput === false ) {
      Audio.ctx = new AudioContext()
      Audio.createInput().then( input => {
        Audio.createFFT()
        input.connect( Audio.FFT )

        Audio.interval = setInterval( Audio.fftCallback, 1000/60 )
        //window.FFT = Audio.FFT
      })
    }
    Audio.__hasInput = true
  },

  createInput() {
    console.log( 'connecting audio input...' )
    
    const p = new Promise( resolve => {
      console.log( 'start?' )
      navigator.mediaDevices.getUserMedia({ audio:true, video:false })
        .then( stream => {
          console.log( 'audio input connected' )
          Audio.input = Audio.ctx.createMediaStreamSource( stream )
          //Audio.mediaStreamSource.connect( Gibberish.node )
          Audio.__hasInput = true
          resolve( Audio.input )
        })
        .catch( err => { 
          console.log( 'error opening audio input:', err )
        })
    })
    return p
  },

  createFFT() {
    Audio.FFT = Audio.ctx.createAnalyser()

    let __windowSize = 512
    Object.defineProperty( Audio, 'windowSize', {
      get() { return __windowSize },
      set(v){
        __windowSize = v
        Audio.FFT.fftSize = v 
        Audio.FFT.values = new Uint8Array( Audio.FFT.frequencyBinCount )
      }
    })

    Audio.windowSize = 512
  },

  fftCallback() {
    Audio.FFT.getByteFrequencyData( Audio.FFT.values )
    
    let lowSum, midSum, highSum, lowCount, midCount, highCount
    lowSum = midSum = highSum = lowCount = midCount = highCount = 0

    let frequencyCounter = 0

    // does this start at 0Hz? ack... can't remember... does it include DC offset?
    const hzPerBin = (Audio.ctx.sampleRate / 2) / Audio.FFT.frequencyBinCount
    const lowRange = 150, midRange = 1400, highRange = Audio.ctx.sampleRate / 2

    for( let i = 1; i < Audio.FFT.frequencyBinCount; i++ ) {
      if( frequencyCounter < lowRange ) {
        lowSum += Audio.FFT.values[ i ]
        lowCount++
      }else if( frequencyCounter < midRange ) {
        midSum += Audio.FFT.values[ i ]
        midCount++
      }else{
        highSum += Audio.FFT.values[ i ]
        highCount++
      }

      frequencyCounter += hzPerBin
    }

    Audio.low = (lowSum / lowCount) / 255
    Audio.mid = (midSum / midCount) / 255 || 0
    Audio.high = (highSum / highCount) / 255
  }
}

module.exports = Audio

},{}],3:[function(require,module,exports){
const SceneNode = require( './sceneNode.js' ),
      { param_wrap, MaterialID } = require( './utils.js' ),
      { Var, float_var_gen, vec2_var_gen, vec3_var_gen, vec4_var_gen } = require( './var.js' )

const { Vec2, Vec3, Vec4 } = require( './vec.js' )

const BG = function( Scene, SDF ) {

  const Background = function( color ) {
    if( SDF.memo.background === undefined ) {
      const bg = Object.create( Background.prototype )

      const __color = param_wrap( Vec3(color), vec3_var_gen( 0,0,0, 'bg' ), 'bg' )  
      
      Object.defineProperty( bg, 'color', {
        get() { return __color },
        set( v ) {
          __color.var.set( v )
        }
      })
      
      // this refers to the current scene via implicit binding in scene.js
      this.postprocessing.push( bg )

      SDF.memo.background = true
    }
    return this
  }

  Background.prototype = SceneNode()
 
  Object.assign( Background.prototype, {
    emit() {
      return ''//this.color.emit()
    },
   
    emit_decl() {
      let str = this.color.emit_decl()
      SDF.memo.background = true

      return str
    },

    update_location( gl, program ) {
      this.color.update_location( gl, program )
    },

    upload_data( gl ) {
      this.color.upload_data( gl )
    }
  })

  return Background
}

module.exports = BG 

},{"./sceneNode.js":23,"./utils.js":28,"./var.js":29,"./vec.js":30}],4:[function(require,module,exports){
const vec3 = require('gl-vec3')
const mat4 = require('gl-mat4')

// camera adapted from https://github.com/shama/first-person-camera
function FirstPersonCamera(opts) {
  if (!(this instanceof FirstPersonCamera)) return new FirstPersonCamera(opts)
  opts = opts || {}
  this.position = opts.position || vec3.create()
  this.rotation = opts.rotation || vec3.create()
  this.positionSpeed = opts.positionSpeed || -.5
  this.rotationSpeed = opts.rotationSpeed || .01
}
module.exports = FirstPersonCamera

FirstPersonCamera.prototype.view = function(out) {
  if (!out) out = mat4.create()
  // altered x/y ordering from original
  mat4.rotateY(out, out, this.rotation[1])
  mat4.rotateX(out, out, this.rotation[0])
  mat4.rotateZ(out, out, this.rotation[2] - Math.PI)
  mat4.translate(out, out, [-this.position[0], -this.position[1], -this.position[2]])

  return out
}

FirstPersonCamera.prototype.control = function(dt, move, mouse, prevMouse) {
  var speed = (this.positionSpeed / 1000) * dt
  var dir = [0,0,0]
  if (move[0]) dir[2] -= speed * (Marching.keys.Alt ? 4 : 1 )
  else if (move[1]) dir[2] += speed * (Marching.keys.Alt ? 4 : 1 )
  if (move[2]) dir[0] += speed * (Marching.keys.Alt ? 4 : 1 )
  else if (move[3]) dir[0] -= speed * (Marching.keys.Alt ? 4 : 1 )
  if (move[4]) dir[1] -= speed * (Marching.keys.Alt ? 4 : 1 )
  else if (move[5]) dir[1] += speed * (Marching.keys.Alt ? 4 : 1 )
  this.move(dir)
  // just use arrow keys instead of mouse
  // this.pointer(mouse, prevMouse)
}

FirstPersonCamera.prototype.move = function(dir) {
  if (dir[0] !== 0 || dir[1] !== 0 || dir[2] !== 0) {
    var cam = mat4.create()
    mat4.rotateY(cam, cam, this.rotation[1])
    mat4.rotateX(cam, cam, this.rotation[0])
    vec3.transformMat4(dir, dir, cam)
    vec3.add(this.position, this.position, dir)
    this.parent.pos.dirty = true

  }
}

//FirstPersonCamera.prototype.pointer = function(da, db) {
//  var dt = [da[0] - db[0], da[1]- db[1]]
//  var rot = this.rotation
//  rot[1] -= dt[0] * this.rotationSpeed
//  if (rot[1] < 0) rot[1] += Math.PI * 2
//  if (rot[1] >= Math.PI * 2) rot[1] -= Math.PI * 2
//  rot[0] -= dt[1] * this.rotationSpeed
//  if (rot[0] < -Math.PI * .5) rot[0] = -Math.PI*0.5
//  if (rot[0] > Math.PI * .5) rot[0] = Math.PI*0.5
//}

const Camera = {
  init( gl, program, handler ) {

    const camera = FirstPersonCamera({
      fov: 190,
      near:.01,
      far:10,
      direction:[0,0,1],
      viewport:[1,1,1,-1]
    })
    camera.rotation = [0,Math.PI,Math.PI] 
    Camera.__camera = camera
    camera.parent = this

    const camera_pos    = gl.getUniformLocation( program, 'camera_pos' )
    const camera_normal = gl.getUniformLocation( program, 'camera_normal' )
    const camera_rot    = gl.getUniformLocation( program, 'camera_rot' )
    const ucamera       = gl.getUniformLocation( program, 'camera' )

    this.pos = { dirty:false }
    this.dir = { dirty:true }
    this.__rot = { dirty:true, value:0 }

    Object.defineProperty( this, 'rotation', {
      configurable:true,
      get() { return this.__rot.value },
      set(v) { 
        this.__rot.value = v 
        this.__rot.dirty = true
      }
    })

    let px = 0, py =0, pz = 5, nx = 0, ny = 0, nz = 0
    Object.defineProperties( this.pos, {
      x: {
        get()  { return px },
        set(v) { px = camera.position[0] = v;this.dirty = true; }
      },

      y: {
        get()  { return py },
        set(v) { py = camera.position[1] = v; this.dirty = true; }
      },

      z: {
        get()  { return pz },
        set(v) { pz = camera.position[2] = v; this.dirty = true; }
      },
    })

    Object.defineProperties( this.dir, {
      x: {
        get()  { return nx },
        set(v) { nx = camera.rotation[0] = v; this.dirty = true; }
      },

      y: {
        get()  { return ny },
        set(v) { ny = camera.rotation[1] = v; this.dirty = true; }
      },

      z: {
        get()  { return nz },
        set(v) { nz = camera.rotation[2] = v; this.dirty = true; }
      },
    })

    let init = false
    gl.uniform3f( camera_normal, this.dir.x, this.dir.y, this.dir.z )
    camera.position = [this.pos.x, this.pos.y, this.pos.z ] 
    //camera.update()
    gl.uniform3f( camera_pos, this.pos.x, this.pos.y, this.pos.z )
    gl.uniformMatrix4fv( ucamera, false, camera.view() )
    gl.uniform1f( camera_rot, this.rot ) 

    Camera.move = (x,y,z) => {
      // XXX does this need to update property values?
      camera.move([x,y,z])
      Camera.update()
    }
    Camera.moveTo = (x,y,z) => {
      Camera.pos.x = x
      Camera.pos.y = y
      Camera.pos.z = z
    }
    Camera.update = ()=> {
      const pos = camera.position
      gl.uniform3f( camera_pos, pos[0], pos[1], pos[2]  )
      gl.uniformMatrix4fv( ucamera, false, camera.view() )
    }

    // determine an offset from the current camera position based
    // on the current camera rotation e.g. to always position a light
    // behind the camera.
    Camera.offset = (amt=[0,0,3]) => {
      const cam = mat4.create()
      mat4.rotateY(cam, cam, camera.rotation[1])
      mat4.rotateX(cam, cam, camera.rotation[0])
      vec3.transformMat4(amt, amt, cam)
      return amt
    }

    let prvx = 0, prvy = 0, x = 0, y = 0
    Camera.__mousemovefnc = e => {
      prvx = x
      prvy = y
      x = e.pageX
      y = e.pageY
    }

    let prevTime = 0
    let k  = Marching.keys
    Camera.__framefnc = t => {
      if( k.ArrowLeft ) camera.rotation[1] += camera.rotationSpeed
      if( k.ArrowRight ) camera.rotation[1] -= camera.rotationSpeed
      if( k.ArrowUp && !k.Shift ) camera.rotation[0] -= camera.rotationSpeed
      if( k.ArrowDown && !k.Shift) camera.rotation[0] += camera.rotationSpeed
      
      if( Marching.cameraEnabled ) { 
        camera.control( 
          t*1000 - prevTime,
          [k.w,k.s,k.d,k.a,k.ArrowUp && k.Shift, k.ArrowDown && k.Shift], 
          [x,y], [prvx,prvy] 
        )
        Camera.update()
        prvx = x
        prvy = y
        prevTime = t*1000
      }
    }

    Camera.__mousemove = null
    Camera.on = ()=> {
      if( Camera.__mousemove === null ) {
        window.addEventListener( 'mousemove', Camera.__mousemovefnc )
        Camera.__mousemove = true
      }
      if( Marching.callbacks.indexOf( Camera.__framefnc ) === -1 ) {
        Marching.callbacks.push( Camera.__framefnc )
      }
    }

    handler( ()=> {
      if( this.pos.dirty === true ) {

        //camera.position = [this.pos.x, this.pos.y, this.pos.z ]
 
        //camera.position = [this.pos.x, this.pos.y, this.pos.z ]
        //camera.update()
        const pos = camera.position
        gl.uniform3f( camera_pos, pos[0], pos[1], pos[2] )
        gl.uniformMatrix4fv( ucamera, false, camera.view() )
        this.pos.dirty = false


      }

      // XXX this is broken and needs to be fixed
      if( this.dir.dirty === true ) {
        gl.uniform3f( camera_normal, this.dir.x, this.dir.y, this.dir.z )
        gl.uniformMatrix4fv( ucamera, false, camera.view() )
        this.dir.dirty = false
      }
      if( this.__rot.dirty === true ) {
        gl.uniform1f( camera_rot, this.__rot.value )
        this.__rot.dirty = false
      }
      if( typeof this.onmove === 'function' ) {
        this.onmove( this )
      }
    })

  }
}

module.exports = Camera

},{"gl-mat4":59,"gl-vec3":93}],5:[function(require,module,exports){
const SceneNode = require( './sceneNode.js' )
const { param_wrap, MaterialID } = require( './utils.js' )
const { Var, float_var_gen, vec2_var_gen, vec3_var_gen, vec4_var_gen, int_var_gen, VarAlloc } = require( './var.js' )
const Transform = require( './transform.js' )

const ops = { 
  // this needs to create an opOut, not return a vec2
  Displace( __name ) {
    let name = __name === undefined ? 'p' : __name
    const sdf = this.sdf.emit( name );

    const sdfStr = `float d1${this.id} = ${sdf.out}.x;\n`

    let displaceString = `float d2${this.id} = sin( ${this.amount.emit()}.x * ${name}.x ) * `  
    displaceString += `sin( ${this.amount.emit()}.y * ${name}.y ) * `
    displaceString += `sin( ${this.amount.emit()}.z * ${name}.z );\n`
    displaceString += `${sdf.out}.x = (d1${this.id} + d2${this.id}*${this.size.emit()})*.5;\n`

    const output = {
      out: `${sdf.out}`, 
      preface: sdf.preface + sdfStr + displaceString 
    }

    return output
  },

  Bend( __name ) {
    let name = __name === undefined ? 'p' : __name
    const sdf = this.sdf.emit( 'q'+this.id );

    let preface=`        float c${this.id} = cos( ${this.amount.emit()}.x * ${name}.x );
        float s${this.id} = sin( ${this.amount.emit()}.x * ${name}.x );
        mat2  m${this.id} = mat2( c${this.id},-s${this.id},s${this.id},c${this.id} );
        vec4  q${this.id} = vec4( m${this.id} * ${name}.xy, ${name}.z, 1. );\n`

    if( typeof sdf.preface === 'string' ) {
      preface += sdf.preface
    }

    return { preface, out:sdf.out }
  },

  Twist( __name ) {
    let name = __name === undefined ? 'p' : __name
    const sdf = this.sdf.emit( 'q'+this.id );

    let preface=`        float c${this.id} = cos( ${this.amount.emit()}.x * ${name}.y );
        float s${this.id} = sin( ${this.amount.emit()}.x * ${name}.y );
        mat2  m${this.id} = mat2( c${this.id},-s${this.id},s${this.id},c${this.id} );
        vec4  q${this.id} = vec4( m${this.id} * ${name}.xz, ${name}.y, 1. );\n`

    if( typeof sdf.preface === 'string' ) {
      preface += sdf.preface
    }

    return { preface, out:sdf.out }
  },
  __Bump( __name ) {
    let name = __name === undefined ? 'p' : __name

    const bumpString =  `        vec4 transformBump${this.id} = ${name} * ${this.transform.emit()};\n`
    const tex = this.amount.emit( name )

    const pointString = `(transformBump${this.id} * ${this.sdf.transform.emit()})`

    const sdf = this.sdf.emit( pointString, this.transform, `tex${this.id}` ) 

    Marching.textures.addTexture( this.amount.value )

    let preface=`  vec3 tex${this.id} = getTexture( ${this.amount.value.id}, ${pointString}.xyz ) * ${this.size.emit()};\n
        //vec4 displaceBump${this.id} = vec4((${pointString} - tex${this.id}), 1.);
    `
        //${sdf.out}.x = (tex${this.id}.x + tex${this.id}.y + tex${this.id}.z ) / 3. * .5 + ${sdf.out}.x;\n`
        //vec4 ${'p'+this.id} = vec4(${pointString} + tex${this.id}, 1.);\n`

    //sdf.preface += `\n        
    //    ${sdf.out}.x -= min(tex${this.id}.x, min(tex${this.id}.y, tex${this.id}.z));\n` 

    if( typeof sdf.preface === 'string' ) {
      preface = preface + sdf.preface
    }

    preface =  bumpString + preface

    return { preface, out:sdf.out }
  },
  // XXX todo: something like https://www.shadertoy.com/view/ldSGzR
  // https://www.dropbox.com/s/l1yl164jb3rhomq/mm_sfgrad_bump.pdf?dl=0
  Bump( __name ) {
    let name = __name === undefined ? 'p' : __name

    const bumpString =  `        vec4 transformBump${this.id} = ${name} * ${this.transform.emit()};\n`
    const tex = this.amount.emit( name )

    const pointString = `(transformBump${this.id} * ${this.sdf.transform.emit()}).xyz`

    const sdf = this.sdf.emit( `transformBump${this.id}`, this.transform ) 

    Marching.textures.addTexture( this.amount.value )

    let preface=`  vec3 tex${this.id} = getTexture( ${this.amount.value.id}, ${pointString}) * ${this.size.emit()};
        ${sdf.out}.x = (tex${this.id}.x + tex${this.id}.y + tex${this.id}.z)/3. + ${sdf.out}.x;\n`

    if( typeof sdf.preface === 'string' ) {
      preface = sdf.preface + preface
    }

    preface = bumpString + preface

    return { preface, out:sdf.out }
  },
}

const DistanceOps = {}

for( let name in ops ) {

  // get codegen function
  let __op = ops[ name ]

  // create constructor
  DistanceOps[ name ] = function( a,b,c ) {
    const op = Object.create( DistanceOps[ name ].prototype )
    op.sdf = a
    op.amount = b
    op.emit = __op
    op.name = name
    op.transform = Transform()

    const defaultValues = [.5,.5,.5]

    op.id = VarAlloc.alloc()
    const isArray = true 
    
    if( typeof b === 'number' ) {
      b = [b,b,b]
      b.type = 'vec3'
    }
    
    if( name !== 'Bumpz' ) {
      let __var =  param_wrap( 
        b, 
        vec3_var_gen( ...defaultValues ) 
      )

      // for assigning entire new vectors to property
      Object.defineProperty( op, 'amount', {
        get() { return __var },
        set(v) {
          if( typeof v === 'object' ) {
            __var.set( v )
          }else{
            __var.value.x = v
            __var.value.y = v
            __var.value.z = v
            __var.value.w = v
            __var.dirty = true
          }
        }
      })

      op.params = [{ name:'amount' }]
    }else{
      op.params = []
      op.emit_decl = function() {}
      op.emit = function() {}
      op.update_data= function() {}
      op.upload_location = function() {}
    }
    op.__setMaterial = function(mat) {
      if( typeof mat === 'string' ) mat = Marching.Material[ mat ]
      this.__material = this.mat = Marching.materials.addMaterial( mat )
      op.sdf.material( this.__material )
    }
    if( name === 'Displace' || name === 'Bump' ) {
      let __var2 =  param_wrap( 
        c, 
        float_var_gen( .03 ) 
      )
      Object.defineProperty( op, 'size', {
        get() { return __var2 },
        set(v) {
          __var2.set( v )
          __var2.dirty = true
        }
      })

      op.params.push({ name:'size' })
    }
    op.__desc = { parameters:op.params }
    return op
  } 

  DistanceOps[ name ].prototype = SceneNode()

  DistanceOps[name].prototype.emit_decl = function () {
    let str =  this.sdf.emit_decl() + (this.name !== 'Bump' ? this.amount.emit_decl() : '')
    str += this.transform.emit_decl()
    if( this.name === 'Displace' || this.name === 'Bump' ) str += this.size.emit_decl()  

    return str
  };

  DistanceOps[name].prototype.update_location = function(gl, program) {
    this.sdf.update_location( gl, program )
    if( this.name !== 'Bump' ) this.amount.update_location( gl, program )
    if( this.name === 'Displace' || this.name === 'Bump') this.size.update_location( gl, program ) 
    this.transform.update_location( gl, program )
  }

  DistanceOps[name].prototype.upload_data = function(gl) {
    this.sdf.upload_data( gl )
    if( this.name !== 'Bump' ) this.amount.upload_data( gl )
    if( this.name === 'Displace' || this.name === 'Bump') this.size.upload_data( gl )
    this.transform.upload_data( gl )
  }
}

module.exports = DistanceOps


},{"./sceneNode.js":23,"./transform.js":27,"./utils.js":28,"./var.js":29}],6:[function(require,module,exports){
const SceneNode = require( './sceneNode.js' )
const { param_wrap, MaterialID } = require( './utils.js' )
const { Var, float_var_gen, vec2_var_gen, vec3_var_gen, vec4_var_gen, int_var_gen, VarAlloc } = require( './var.js' )
const Transform = require( './transform.js' )
const glslops = require( './distanceOperationsGLSL.js' )

const opslen = { 
  Union:2,
  Intersection:2,
  Difference:2,
  StairsUnion:4,
  StairsIntersection:4,
  StairsDifference:4,
  RoundUnion:3,
  RoundDifference:3,
  RoundIntersection:3,
  ChamferUnion:3,
  ChamferDifference:3,
  ChamferIntersection:3,
  Pipe:3,
  Engrave:3,
  Groove:4,
  Tongue:4,
  
  // these two do not currently have support for transforms or repeats...
  Onion:2,
  Switch:2
}

const ops = { 
  Union( ...args ) { return `opU( ${args.join(',')} )` },
  SmoothUnion( ...args  ) { return `opSmoothUnion( ${args.join(',')} )` },
  Intersection( ...args ) { return `opI( ${args.join(',')} )` },
  SmoothIntersection( ...args ) { return `opSmoothIntersection( ${args.join(',')} )` },  
  Difference( ...args ) { return `opS( ${args.join(',')} )` },  
  SmoothDifference( ...args ) { return `opSmoothSubtraction( ${args.join(',')} )` },  
  StairsUnion(  ...args ) { return `fOpUnionStairs( ${args.join(',')} )`  },
  StairsIntersection( ...args ) { return `fOpIntersectionStairs( ${args.join(',')} )` },
  StairsDifference( ...args ) { return `fOpSubstractionStairs( ${args.join(',')} )` },
  RoundUnion( ...args ) { return `fOpUnionRound( ${args.join(',')} )` },
  RoundDifference( ...args ) { return `fOpDifferenceRound( ${args.join(',')} )` },
  RoundIntersection( ...args ) { return `fOpIntersectionRound( ${args.join(',')} )` },
  ChamferUnion( ...args ) { return `fOpUnionChamfer( ${args.join(',')} )` },
  ChamferDifference( ...args ) { return `fOpDifferenceChamfer( ${args.join(',')} )` },
  ChamferIntersection( ...args ) { return `fOpIntersectionChamfer( ${args.join(',')} )` },
  Pipe( ...args ) { return `fOpPipe( ${args.join(',')} )` },
  Engrave( ...args ) { return `fOpEngrave( ${args.join(',')} )` },
  Groove( ...args ) { return `fOpGroove( ${args.join(',')} )` },
  Tongue( ...args ) { return `fOpTongue( ${args.join(',')} )` },
  
  // these two do not currently have support for transforms or repeats...
  Onion( a,b ) { return `opOnion( ${a}, ${b} )` },
  Switch( a,b,c,d,e,f ) { return `opSwitch( ${a}, ${b}, ${c} )` }
}

const emit_float = function( a ) {
	if (a % 1 === 0)
		return a.toFixed( 1 )
	else
		return a
}

const DistanceOps = {
  __glsl:[],
  __getGLSL() {
    return this.__glsl.join('\n')
  },
  __clear() { this.__glsl.length = 0 }
}


for( let name in ops ) {

  // get codegen function
  let op = ops[ name ]
  const name2 = name + '2'

  // create constructor
  DistanceOps[ name ] = function( a,b,c,d ) {
    const op = Object.create( DistanceOps[ name ].prototype )
    op.a = a
    op.b = b
    op.transform = Transform( false )
    op.id = VarAlloc.alloc()
    op.type = 'distance_op'
    op.name = name

    let __c = param_wrap( c, float_var_gen(.3) )

    op.__len = opslen[ name ]
    if( op.__len > 2 ) {
      Object.defineProperty( op, 'c', {
        get() { return __c },
        set(v) {
          __c.set( v )
        }
      })
      
      if( op.__len > 3 ) {
        let __d = param_wrap( d, float_var_gen(4) )

        Object.defineProperty( op, 'd', {
          get() { return __d },
          set(v) {
            __d.set( v )
          }
        })
      }
    }

    op.__setTexture = function(tex,props) {
      if( typeof tex === 'string' ) {
        this.texture = op.texture.bind( this )
        this.__textureObj = this.tex = Marching.Texture( tex,props,this.texture )
        this.__textureID = this.__textureObj.id
      }else{
        this.__textureObj = this.tex = Object.assign( tex, props )
        this.__textureID = this.__textureObj.id
      }
    }
    op.__setMaterial = function(mat) {
      if( typeof mat === 'string' ) mat = Marching.Material[ mat ]
      this.__material = this.mat = Marching.materials.addMaterial( mat )
    }
    op.__setBump = function(tex,props) {
      //this.bump = p.bump.bind( this )
      const b = this.bump = this.__bumpObj = Marching.Bump( this, tex, props )
      this.bump.texture = this.bump.amount.value
      this.__bumpID = this.__bumpObj.id
      this.rotate = this.bump.rotate
      this.translate = this.bump.translate
      this.scale = this.bump.scale
      Object.defineProperty( this.bump, 'strength', {
        get() { return b.size },
        set(v){ b.size = v }
      })
    }
    Object.assign( op, {
      renderingBump : false,
      emittingDecl  : false,
      uploading     : false,
      updating      : false
    })

    let repeat = null
    Object.defineProperty( op, 'repeat', {
      get() { return repeat },
      set(v){ 
        repeat = v
        this.a.repeat = v
        this.b.repeat = v
      }
    })

    op.matId = MaterialID.alloc()

    op.params = [{name:'c'},{ name:'d'}]
    op.__desc = { parameters: op.params }

    return op
  } 
  
  DistanceOps[ name2 ] = function( ...args ) {
    // accepts unlimited arguments, but the last one could be a blending coefficient
    let blend = .25, coeff=4, u

    if( typeof args[ args.length - 1 ] === 'number' ) {
      blend = args.pop()

      // if there are two non-sdf arguments to the function...
      if( typeof args[ args.length - 1 ] === 'number' ) {
        coeff = blend
        blend = args.pop()
      }

      u = args.reduce( (state,next) => DistanceOps[ name ]( state, next, blend, coeff ) )
    }else{
      u = args.reduce( (state,next) => DistanceOps[ name ]( state, next ) )
    }

    return u
  }

  DistanceOps[ name ].prototype = SceneNode()

  DistanceOps[ name ].prototype.texture = function( ...args ) {
    this.__setTexture( ...args )
    this.a.texture( this.__textureObj )
    this.b.texture( this.__textureObj )

    return this
  }
  DistanceOps[ name ].prototype.material = function( ...args ) {
    this.__setMaterial( ...args )
    this.a.material( this.__material )
    this.b.material( this.__material )

    return this
  }

  const pushString = function( name ) {
    const glslobj = glslops[ name ]
    
    // some definitions are a single string, and not split into
    // separate float and opOut functions
    if( typeof glslobj === 'string' ) {
      if( DistanceOps.__glsl.indexOf( glslobj ) === -1 ) {
        DistanceOps.__glsl.push( glslobj )
      }
    }else{
      // some distance operations are dependent on other ones...
      // if this one has dependencies add them.
      // dependencies must be added before adding other functions
      // so that they're above them in the final GLSL code.
      if( glslobj.dependencies !== undefined ) {
        for( let dname of glslobj.dependencies ) {
          const d = glslops[ dname ]
          if( DistanceOps.__glsl.indexOf( d.float ) === -1 ) {
            DistanceOps.__glsl.push( d.float )
          }
        }
      }  
      if( DistanceOps.__glsl.indexOf( glslobj.float ) === -1 ) {
        DistanceOps.__glsl.push( glslobj.float )
      }
      if( DistanceOps.__glsl.indexOf( glslobj.vec2) === -1 ) {
        DistanceOps.__glsl.push( glslobj.vec2 )
      }
    }
  }

  DistanceOps[ name ].prototype.emit = function ( pname='p', transform = null ){
    if( this.__bumpObj !== undefined && this.renderingBump === false) {
      this.renderingBump = true
      return this.__bumpObj.emit( pname, transform )
    }
    pushString( name )

    if( transform !== null ) this.transform.apply( transform, false )
    //this.transform.internal()

    // first two args are fixed, rest are variable
    let emitters = []
    const a = this.a.emit( pname, this.transform ), 
          b = this.b.emit( pname, this.transform ) 

    emitters[0] = a.out
    emitters[1] = b.out
    if( this.__len > 2 ) emitters.push( this.c.emit() )
    if( this.__len > 3 ) emitters.push( this.d.emit() )
    
    const body = `
        vec2 do${this.id} = ${op( ...emitters )};
        do${this.id}.x *= ${this.transform.emit()}_scale;
    `

    const output = {
      out: 'do'+this.id,
      preface: (a.preface || '') + (b.preface || '') + body
    }

    this.renderingBump = false
    return output
  }

  DistanceOps[name].prototype.emit_decl = function () {
    if( this.__bumpObj !== undefined && this.emittingDecl === false) {
      this.emittingDecl = true
      return this.__bumpObj.emit_decl() 
    }
    let str =  this.transform.emit_decl() + this.a.emit_decl() + this.b.emit_decl()
    if( this.c !== undefined ) str += this.c.emit_decl()
    if( this.d !== undefined ) str += this.d.emit_decl()

    if( ops[ name ].code !== undefined ) {
      //str += ops[ name ].code
      if( Marching.requiredOps.indexOf( ops[ name ].code ) === - 1 ) {
        Marching.requiredOps.push( ops[ name ].code )
      }
    }

    this.emittingDecl = false
    return str
  };

  DistanceOps[name].prototype.update_location = function(gl, program) {
    if( this.__bumpObj !== undefined && this.updating === false) {
      this.updating = true
      return this.__bumpObj.update_location( gl, program )
    }
    this.a.update_location( gl, program )
    this.transform.update_location( gl, program )
    this.b.update_location( gl, program )
    if( this.c !== undefined ) this.c.update_location( gl, program )
    if( this.d !== undefined ) this.d.update_location( gl, program )

    this.updating = false
  }

  DistanceOps[name].prototype.upload_data = function(gl) {
    if( this.__bumpObj !== undefined && this.uploading  === false ) {
      this.uploading = true
      return this.__bumpObj.upload_data( gl )
    }
    this.transform.internal()
    this.transform.upload_data( gl )
    this.a.transform.apply( this.transform )
    this.b.transform.apply( this.transform )
    this.a.upload_data( gl )
    this.b.upload_data( gl )
    if( this.c !== undefined ) this.c.upload_data( gl )
    if( this.d !== undefined ) this.d.upload_data( gl )
    this.uploading = false
    
  }
}

module.exports = DistanceOps

},{"./distanceOperationsGLSL.js":7,"./sceneNode.js":23,"./transform.js":27,"./utils.js":28,"./var.js":29}],7:[function(require,module,exports){
module.exports = {
  Union:{
    float:`
      float opU( float d1, float d2 ) {
        return min(d1,d2);
      }
      `,
    vec2:`
      vec2 opU( vec2 d1, vec2 d2 ) {
        vec2 o;

        if( d1.x < d2.x ) {
          o = d1;
        }else{
          o = d2; 
        }

        return o;
      }
      `
  },
  Intersection:{
    float:`
      float opI( float d1, float d2 ) {
        return max(d1,d2);
      }
      `,
    vec2:`
      vec2 opI( vec2 d1, vec2 d2  ) {
        vec2 o;

        if( d1.x > d2.x ) {
          o = d1; 
        }else{
          o = d2; 
        }

        return o;
      }
      `
  },

  Difference:{
    float:`
      float opS( float d1, float d2 ) { return max(d1,-d2); }
      `,
    vec2:`
      vec2 opS( vec2 d1, vec2 d2  ) {
        vec2 o;

        if( d1.x >= -d2.x ) {
          o = d1; 
        }else{
          d2.x *= -1.;
          o = d2;
        }

        return o;
      }
      `
  },

  StairsUnion:{
    float:`
      float fOpUnionStairs(float a, float b, float r, float n) {
        float s = r/n;
        float u = b-r;
        return min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));
      }`,
    vec2:`
      vec2 fOpUnionStairs( vec2 d1, vec2 d2, float r, float n  ) {
        vec2 o = vec2( 0., d1.y ); 

        if( d1.x <= d2.x ) {
          o.y = d1.y; 
        }else{
          o.y = d2.y; 
        }

        o.x = fOpUnionStairs( d1.x, d2.x, r, n );

        return o;
      }
      `
  },
  StairsIntersection:{
    dependencies: ['StairsUnion'],
    float:`
      // We can just call Union since stairs are symmetric.
      float fOpIntersectionStairs(float a, float b, float r, float n) {
        return -fOpUnionStairs(-a, -b, r, n);
      }
      `,
    vec2:`
      vec2 fOpIntersectionStairs( vec2 d1, vec2 d2, float r, float n  ) {
        vec2 o = vec2( 0., d1.y ); 
        o.x = -fOpUnionStairs( -d1.x, -d2.x, r, n );

        if( -d1.x <= -d2.x ) {
          o.y = d1.y;
        }else{
          o.y = d2.y;
        }

        return o;
      }
      `
  },
  StairsDifference:{
    dependencies: ['StairsUnion'],
    float:`
      float fOpSubstractionStairs(float a, float b, float r, float n) {
        return -fOpUnionStairs(-a, b, r, n);
      }`,
    vec2:`
      vec2 fOpSubstractionStairs( vec2 d1, vec2 d2, float r, float n  ) {
        vec2 o = vec2( 0., d1.y ); 
        o.x = -fOpUnionStairs( -d1.x, d2.x, r, n );

        if( -d1.x <= d2.x ) {
          o.y = d1.y;
        }else{
          o.y = d2.y;
        }

        return o;
      }
      `
  },

  RoundUnion:{
    float:`
      float fOpUnionRound(float a, float b, float r) {
        vec2 u = max(vec2(r - a,r - b), vec2(0));
        return max(r, min (a, b)) - length(u);
      }`,

    vec2:`
      vec2 fOpUnionRound( vec2 d1, vec2 d2, float r  ) {
        vec2 o = vec2( 0., d1.y ); 
        o.x = fOpUnionRound( d1.x, d2.x, r );

        if( d1.x <= d2.x ) {
          o.y = d1.y;
        }else{
          o.y = d2.y;
        }

        return o;
      }
      `
  },
  RoundIntersection:{
    float:`
      float fOpIntersectionRound(float a, float b, float r) {
        vec2 u = max(vec2(r + a,r + b), vec2(0));
        return min(-r, max (a, b)) + length(u);
      }`,
    vec2:`
      vec2 fOpIntersectionRound( vec2 d1, vec2 d2, float r  ) {
        vec2 o = vec2( 0., d1.y ); 
        o.x = fOpIntersectionRound( d1.x, d2.x, r );

        if( d1.x >= d2.x ) {
          o.y = d1.y;
        }else{
          o.y = d2.y;
        }

        return o;
      }
      `
  },

  RoundDifference:{
    dependencies: ['RoundIntersection'],
    float:`
      float fOpDifferenceRound (float a, float b, float r) {
        return fOpIntersectionRound(a, -b, r);
      }`,
    vec2:`
      vec2 fOpDifferenceRound( vec2 d1, vec2 d2, float r  ) {
        vec2 o = vec2( 0., d1.y ); 
        o.x = fOpDifferenceRound( d1.x, d2.x, r );

        if( d1.x >= -d2.x ) {
          o.y = d1.y; 
        }else{
          o.y = d2.y;
        }

        return o;
      }
      `
  },
  ChamferUnion:{
    float:`
      float fOpUnionChamfer(float a, float b, float r) {
        return min(min(a, b), (a - r + b)*sqrt(0.5));
      }`,
    vec2:`
      vec2 fOpUnionChamfer( vec2 d1, vec2 d2, float r  ) {
        vec2 o = vec2( 0., d1.y ); 
        o.x = fOpUnionChamfer( d1.x, d2.x, r );

        if( d1.x <= d2.x ) {
          o.y = d1.y;
        }else{
          o.y = d2.y;
        }

        return o;
      }
      `
  },
  ChamferIntersection:{
    float:`
      float fOpIntersectionChamfer(float a, float b, float r) {
        return max(max(a, b), (a + r + b)*sqrt(0.5));
      }`,
    vec2:`
      vec2 fOpIntersectionChamfer( vec2 d1, vec2 d2, float r   ) {
        vec2 o = vec2( 0., d1.y ); 
        o.x = fOpIntersectionChamfer( d1.x, d2.x, r );

        if( d1.x >= d2.x ) {
          o.y = d1.y;
        }else{
          o.y = d2.y;
        }

        return o;
      }
      `
  },

  ChamferDifference:{
    dependencies:['ChamferIntersection'],
    float:`
      float fOpDifferenceChamfer (float a, float b, float r) {
        return fOpIntersectionChamfer(a, -b, r);
      }`,
    vec2:`
      vec2 fOpDifferenceChamfer( vec2 d1, vec2 d2, float r  ) {
        vec2 o = vec2( 0., d1.y ); 
        o.x = fOpDifferenceChamfer( d1.x, d2.x, r );

        if( d1.x >= -d2.x ) {
          o.y = d1.y;
        }else{
          o.y = d2.y;
        }

        return o;
      }
      `
  },
  Pipe:`
      float fOpPipe(float a, float b, float r) {
        return length(vec2(a, b)) - r;
      }
      vec2 fOpPipe( vec2 d1, vec2 d2, float r   ) {
        vec2 o = vec2( 0., d1.y ); 
        o.x = fOpPipe( d1.x, d2.x, r );

        return o;
      }
      `,

  Engrave:`
      float fOpEngrave(float a, float b, float r) {
        return max(a, (a + r - abs(b))*sqrt(0.5));
      }
      vec2 fOpEngrave( vec2 d1, vec2 d2, float r  ) {
        vec2 o = vec2( 0., d1.y ); 
        o.x = fOpEngrave( d1.x, d2.x, r );

        return o;
      }
      `,
  Groove:`
      float fOpGroove(float a, float b, float ra, float rb) {
        return max(a, min(a + ra, rb - abs(b)));
      }
      vec2 fOpGroove( vec2 d1, vec2 d2, float r, float n  ) {
        vec2 o = vec2( 0., d1.y ); 
        o.x = fOpGroove( d1.x, d2.x, r, n );

        return o;
      }
      `,

  Tongue:`
      float fOpTongue(float a, float b, float ra, float rb) {
        return min(a, max(a - ra, abs(b) - rb));
      }
      vec2 fOpTongue( vec2 d1, vec2 d2, float r, float n  ) {
        vec2 o = vec2( 0., d1.y ); 
        o.x = fOpTongue( d1.x, d2.x, r, n );

        return o;
      }
      `,
  Onion:`
      float opOnion( in float sdf, in float thickness ){
        return abs(sdf)-thickness;
      }

      float opHalve( in float sdf, vec3 p, in int dir ){
        float _out = 0.;
        switch( dir ) {
          case 0:  
            _out = max( sdf, p.y );
            break;
          case 1:
            _out = max( sdf, -p.y );
            break;
          case 2:
            _out = max( sdf, p.x );
            break;
          case 3:
            _out = max( sdf, -p.x );
            break;
        }

        return _out;
      }
      `,

  Switch:`
      vec2 opSwitch( vec2 a, vec2 b, float c ) {
        if( c < .5 ) {
          return a;
        }else{
          return b;
        } 
      }
      `
}

},{}],8:[function(require,module,exports){
const { Var, float_var_gen, vec2_var_gen, vec3_var_gen, vec4_var_gen, int_var_gen, VarAlloc } = require( './var.js' )
const SceneNode = require( './sceneNode.js' )
const { param_wrap, MaterialID } = require( './utils.js' )
const { Vec2, Vec3, Vec4 } = require( './vec.js' )
const Transform = require( './transform.js' )

const descriptions = {
  Elongation: {
    parameters:[ { name:'distance', type:'vec3', default:Vec3(0) } ],
    func:`
      vec4 opElongate( in vec3 p, in vec3 h ) {
        //return vec4( p-clamp(p,-h,h), 0.0 ); // faster, but produces zero in the interior elongated box
        
        vec3 q = abs(p)-h;
        return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );
      }`,
    emit( name='p' ) {
      const pId = this.getID()
      const pName = 'p' + pId

      let preface =
        `        vec4 ${pName}_xyzw = opElongate( ${name}, ${this.distance.emit()} );\n
        vec3 ${pName} = ${pName}_xyzw.xyz;\n`


      const sdf = this.sdf.emit( pName )

      if( typeof sdf.preface === 'string' ) preface += sdf.preface 

      return { out:`vec2(${pName}_xyzw.w + ${sdf.out}.x, ${sdf.out}.y)`, preface }
    }
  },
  PolarRepetition: {
    parameters:[ 
      { name:'count', type:'float', default:5 },
      { name:'distance', type:'vec3', default:Vec3(.25) },

    ],
    emit( name='p', transform=null) {
      const pId = VarAlloc.alloc()
      const pName = 'p' + pId
      const pointString =  `( ${name} * ${this.transform.emit()} ).xyz`

      if( transform !== null ) this.transform.apply( transform, false )
      this.transform.invert()

      let preface =`
          vec4 ${pName} = vec4( polarRepeat( ${pointString}, ${this.__target.count.emit() } ), 1. ); 
          ${pName} -= vec4(${this.__target.distance.emit()}.x,0.,0.,0.);\n`

      const sdf = this.sdf.emit( pName )

      if( typeof sdf.preface === 'string' ) preface += sdf.preface

      return { out:sdf.out, preface }
    }
  },
  Mirror: {
    parameters: [ { name:'distance', type:'vec3', default:Vec3(0) } ],
    extra:[{ name:'dims', type:'local', default:'xyz' }],

    emit( name='p', transform=null, notused=null, scale=null ) {
      const pId = VarAlloc.alloc()
      const pName = 'p' + pId

      if( transform !== null ) {
        this.transform.apply( transform, false )
      }
      this.transform.invert()
     
      const pointString =  `( ${name} * ${this.transform.emit()} ).xyz`,
            s = scale === null ? this.transform.emit_scale() : `${this.transform.emit_scale()} * ${scale}`
 
      let preface =`
        vec4 ${pName} = vec4( ( ${pointString} ) , 1.);\n
        ${pName}.${this.dims} = abs( ${pName}.${this.dims} );\n`

      const sdf = this.sdf.emit( pName, null, null, s )

      if( typeof sdf.preface === 'string' ) preface += sdf.preface 

      return { out:sdf.out, preface }
    }
  },
  //let preface = `         vec3 ${pName} = ${name} / ${this.amount.emit()};\n`

  //let sdf = this.sdf.emit( pName )
  //let out = sdf.out 

  //sdf.preface += `      ${out}.x = ${out}.x * ${this.amount.emit()};\n`

  //if( typeof sdf.preface === 'string' ) preface += sdf.preface
  Repetition: {
    parameters: [ { name:'distance', type:'vec3', default:Vec3(0) } ],
    emit( name='p', transform=null ) {
      const pId = VarAlloc.alloc()
      const pName = 'p' + pId

      if( transform !== null ) this.transform.apply( transform, false )
      
      this.transform.invert()
     
      const pointString =  `( ${name} * ${this.transform.emit()} ).xyz`;

      let preface =`
        vec4 ${pName} = vec4( (mod( ${pointString}, ${this.__target.distance.emit()} ) - .5 * ${this.__target.distance.emit()}) * ${this.transform.emit_scale()}, 1.);\n`

      const sdf = this.sdf.emit( pName )//, this.transform )//, 1, this.__target.distance )

      if( typeof sdf.preface === 'string' ) preface += sdf.preface 

      return { out:sdf.out, preface }
    }
  },
}
  
const getDomainOps = function( SDF ) {
  const ops = {}

  for( let key in descriptions ) {
    const opDesc = descriptions[ key ]
    
    ops[ key ] = function( sdf, ...args ) {
      const op = Object.create( ops[ key ].prototype )
      op.sdf = sdf
      op.parameters = []
      op.transform = Transform()
      op.name = key
      const target = op.__target = op // sdf.__target !== undefined ? sdf.__target : op

      let count = 0
      for( let prop of opDesc.parameters ) {
        op.parameters.push( prop )

        let arg = args[ count ]
        let __var

        switch( prop.type ) {
          case 'vec2':
            if( typeof arg === 'number' ) arg = Vec2( arg )
            if( arg === undefined ) arg = prop.default.copy()

            __var = param_wrap( 
              arg, 
              vec2_var_gen( prop.default )    
            )

            Object.defineProperty( target, prop.name, {
              get() { return __var },
              set(v) {
                if( typeof v === 'object' ) {
                  __var.set( v )
                }else{
                  __var.value.x = v
                  __var.value.y = v
                  __var.dirty = true
                }
              }
            })  

            break;
          case 'vec3':
            if( typeof arg === 'number' ) arg = Vec3( arg )
            if( arg === undefined ) arg = prop.default.copy()

            __var = param_wrap( 
              arg, 
              vec3_var_gen( prop.default )
            )

            Object.defineProperty( target, prop.name, {
              get() { return __var },
              set(v) {
                if( typeof v === 'object' ) {
                  __var.set( v )
                }else{
                  __var.value.x = v
                  __var.value.y = v
                  __var.value.z = v
                  __var.dirty = true
                }
              }
            })  

            break;
          case 'vec4':
            if( typeof arg === 'number' ) arg = Vec4( arg )
              __var = param_wrap( 
              arg, 
              vec4_var_gen( prop.default )  
            )

            if( arg === undefined ) arg = prop.default.copy()

            Object.defineProperty( target, prop.name, {
              get() { return __var },
              set(v) {
                if( typeof v === 'object' ) {
                  __var.set( v )
                }else{
                  __var.value.x = v
                  __var.value.y = v
                  __var.value.z = v
                  __var.value.w = v
                  __var.dirty = true
                }
              }
            })  

            break;
          default: // float
            __var =  param_wrap( 
              arg, 
              float_var_gen( prop.default )
            )

            Object.defineProperty( target, prop.name, {
              get() { return __var },
              set(v) {
                __var.set( v ) 
              }
            })
            break;
          }
        count++
      }
      
      if( opDesc.extra !== undefined ) {
        for( let extra of opDesc.extra ) {
          op[ extra.name ] = args[ count - 1 ] || extra.default
        }
      }

      op.__setTexture = function(tex,props) {
        if( typeof tex === 'string' ) {
          this.texture = op.texture.bind( this )
          this.__textureObj = this.tex = Marching.Texture( tex,props,this.texture )
          this.__textureID = this.__textureObj.id
        }else{
          this.__textureObj = this.tex = Object.assign( tex, props )
          this.__textureID = this.__textureObj.id
        }
      }
      op.__setMaterial = function(mat) {
        if( typeof mat === 'string' ) mat = Marching.Material[ mat ]
        this.__material = this.mat = Marching.materials.addMaterial( mat )
      }
      op.__desc = opDesc

      if( key !== 'Mirror' ) op.sdf.repeat = op
      return op
    }

    ops[ key ].prototype = SceneNode()
    ops[ key ].prototype.emit = opDesc.emit
    
    ops[ key ].prototype.texture = function( ...args ) {
      this.__setTexture( ...args )
      this.sdf.texture( this.__textureObj )

      return this
    }
    ops[ key ].prototype.material = function( ...args ) {
      this.__setMaterial( ...args )
      this.sdf.material( this.__material )

      return this
    }

    ops[ key ].prototype.emit_decl = function( shouldEmitSDF=true ) {
      let decl = ''
      decl += this.transform.emit_decl()
      for( let param of this.parameters ) {
        decl += this.__target[ param.name ].emit_decl() 
      }
      if( shouldEmitSDF ) decl += this.sdf.emit_decl()
      
      // for rotation etc... any extra glsl function that needs to
      // be added to the shader
      if( opDesc.glsl !== undefined && SDF.memo[ key ] === undefined ) {
        decl += opDesc.glsl
        SDF.memo[ key ] = true
      }

      return decl
    }
    ops[ key ].prototype.update_location = function( gl, program, shouldUpdateSDF=true ) {
      for( let param of this.parameters ) this.__target[ param.name ].update_location( gl, program)
      if( shouldUpdateSDF ) this.sdf.update_location( gl, program )
      this.transform.update_location( gl, program )
    }
    ops[ key ].prototype.upload_data = function( gl, shouldUploadSDF=true ) {
      for( let param of this.parameters ) this.__target[ param.name ].upload_data( gl )
      this.transform.upload_data( gl )
      if( shouldUploadSDF ) this.sdf.upload_data( gl )
    }
  }
  
  ops.Repeat = ops.Repetition
  ops.RepeatScale = ops.RepetitionShrink
  ops.PolarRepeat = ops.PolarRepetition

  return ops
}

module.exports = getDomainOps

},{"./sceneNode.js":23,"./transform.js":27,"./utils.js":28,"./var.js":29,"./vec.js":30}],9:[function(require,module,exports){
// matrix.js - taken from https://github.com/evanw/lightgl.js/

// Represents a 4x4 matrix stored in row-major order that uses Float32Arrays
// when available. Matrix operations can either be done using convenient
// methods that return a new matrix for the result or optimized methods
// that store the result in an existing matrix to avoid generating garbage.

var hasFloat32Array = (typeof Float32Array != 'undefined');

// ### new GL.Matrix([elements])
//
// This constructor takes 16 arguments in row-major order, which can be passed
// individually, as a list, or even as four lists, one for each row. If the
// arguments are omitted then the identity matrix is constructed instead.
function Matrix() {
  var m = Array.prototype.concat.apply([], arguments);
  if (!m.length) {
    m = [
      1, 0, 0, 0,
      0, 1, 0, 0,
      0, 0, 1, 0,
      0, 0, 0, 1
    ];
  }
  this.m = hasFloat32Array ? new Float32Array(m) : m;
}

Matrix.prototype = {
  // ### .inverse()
  //
  // Returns the matrix that when multiplied with this matrix results in the
  // identity matrix.
  inverse: function() {
    return Matrix.inverse(this, new Matrix());
  },

  // ### .transpose()
  //
  // Returns this matrix, exchanging columns for rows.
  transpose: function() {
    return Matrix.transpose(this, new Matrix());
  },

  // ### .multiply(matrix)
  //
  // Returns the concatenation of the transforms for this matrix and `matrix`.
  // This emulates the OpenGL function `glMultMatrix()`.
  multiply: function(matrix) {
    return Matrix.multiply(this, matrix, new Matrix());
  },

  // ### .transformPoint(point)
  //
  // Transforms the vector as a point with a w coordinate of 1. This
  // means translations will have an effect, for example.
  transformPoint: function(v) {
    var m = this.m;
    return new Vector(
      m[0] * v.x + m[1] * v.y + m[2] * v.z + m[3],
      m[4] * v.x + m[5] * v.y + m[6] * v.z + m[7],
      m[8] * v.x + m[9] * v.y + m[10] * v.z + m[11]
    ).divide(m[12] * v.x + m[13] * v.y + m[14] * v.z + m[15]);
  },

  // ### .transformPoint(vector)
  //
  // Transforms the vector as a vector with a w coordinate of 0. This
  // means translations will have no effect, for example.
  transformVector: function(v) {
    var m = this.m;
    return new Vector(
      m[0] * v.x + m[1] * v.y + m[2] * v.z,
      m[4] * v.x + m[5] * v.y + m[6] * v.z,
      m[8] * v.x + m[9] * v.y + m[10] * v.z
    );
  }
};

// ### GL.Matrix.inverse(matrix[, result])
//
// Returns the matrix that when multiplied with `matrix` results in the
// identity matrix. You can optionally pass an existing matrix in `result`
// to avoid allocating a new matrix. This implementation is from the Mesa
// OpenGL function `__gluInvertMatrixd()` found in `project.c`.
Matrix.inverse = function(matrix, result) {
  result = result || new Matrix();
  var m = matrix.m, r = result.m;

  r[0] = m[5]*m[10]*m[15] - m[5]*m[14]*m[11] - m[6]*m[9]*m[15] + m[6]*m[13]*m[11] + m[7]*m[9]*m[14] - m[7]*m[13]*m[10];
  r[1] = -m[1]*m[10]*m[15] + m[1]*m[14]*m[11] + m[2]*m[9]*m[15] - m[2]*m[13]*m[11] - m[3]*m[9]*m[14] + m[3]*m[13]*m[10];
  r[2] = m[1]*m[6]*m[15] - m[1]*m[14]*m[7] - m[2]*m[5]*m[15] + m[2]*m[13]*m[7] + m[3]*m[5]*m[14] - m[3]*m[13]*m[6];
  r[3] = -m[1]*m[6]*m[11] + m[1]*m[10]*m[7] + m[2]*m[5]*m[11] - m[2]*m[9]*m[7] - m[3]*m[5]*m[10] + m[3]*m[9]*m[6];

  r[4] = -m[4]*m[10]*m[15] + m[4]*m[14]*m[11] + m[6]*m[8]*m[15] - m[6]*m[12]*m[11] - m[7]*m[8]*m[14] + m[7]*m[12]*m[10];
  r[5] = m[0]*m[10]*m[15] - m[0]*m[14]*m[11] - m[2]*m[8]*m[15] + m[2]*m[12]*m[11] + m[3]*m[8]*m[14] - m[3]*m[12]*m[10];
  r[6] = -m[0]*m[6]*m[15] + m[0]*m[14]*m[7] + m[2]*m[4]*m[15] - m[2]*m[12]*m[7] - m[3]*m[4]*m[14] + m[3]*m[12]*m[6];
  r[7] = m[0]*m[6]*m[11] - m[0]*m[10]*m[7] - m[2]*m[4]*m[11] + m[2]*m[8]*m[7] + m[3]*m[4]*m[10] - m[3]*m[8]*m[6];

  r[8] = m[4]*m[9]*m[15] - m[4]*m[13]*m[11] - m[5]*m[8]*m[15] + m[5]*m[12]*m[11] + m[7]*m[8]*m[13] - m[7]*m[12]*m[9];
  r[9] = -m[0]*m[9]*m[15] + m[0]*m[13]*m[11] + m[1]*m[8]*m[15] - m[1]*m[12]*m[11] - m[3]*m[8]*m[13] + m[3]*m[12]*m[9];
  r[10] = m[0]*m[5]*m[15] - m[0]*m[13]*m[7] - m[1]*m[4]*m[15] + m[1]*m[12]*m[7] + m[3]*m[4]*m[13] - m[3]*m[12]*m[5];
  r[11] = -m[0]*m[5]*m[11] + m[0]*m[9]*m[7] + m[1]*m[4]*m[11] - m[1]*m[8]*m[7] - m[3]*m[4]*m[9] + m[3]*m[8]*m[5];

  r[12] = -m[4]*m[9]*m[14] + m[4]*m[13]*m[10] + m[5]*m[8]*m[14] - m[5]*m[12]*m[10] - m[6]*m[8]*m[13] + m[6]*m[12]*m[9];
  r[13] = m[0]*m[9]*m[14] - m[0]*m[13]*m[10] - m[1]*m[8]*m[14] + m[1]*m[12]*m[10] + m[2]*m[8]*m[13] - m[2]*m[12]*m[9];
  r[14] = -m[0]*m[5]*m[14] + m[0]*m[13]*m[6] + m[1]*m[4]*m[14] - m[1]*m[12]*m[6] - m[2]*m[4]*m[13] + m[2]*m[12]*m[5];
  r[15] = m[0]*m[5]*m[10] - m[0]*m[9]*m[6] - m[1]*m[4]*m[10] + m[1]*m[8]*m[6] + m[2]*m[4]*m[9] - m[2]*m[8]*m[5];

  var det = m[0]*r[0] + m[1]*r[4] + m[2]*r[8] + m[3]*r[12];
  for (var i = 0; i < 16; i++) r[i] /= det;
  return result;
};

// ### GL.Matrix.transpose(matrix[, result])
//
// Returns `matrix`, exchanging columns for rows. You can optionally pass an
// existing matrix in `result` to avoid allocating a new matrix.
Matrix.transpose = function(matrix, result) {
  result = result || new Matrix();
  var m = matrix.m, r = result.m;
  r[0] = m[0]; r[1] = m[4]; r[2] = m[8]; r[3] = m[12];
  r[4] = m[1]; r[5] = m[5]; r[6] = m[9]; r[7] = m[13];
  r[8] = m[2]; r[9] = m[6]; r[10] = m[10]; r[11] = m[14];
  r[12] = m[3]; r[13] = m[7]; r[14] = m[11]; r[15] = m[15];
  return result;
};

// ### GL.Matrix.multiply(left, right[, result])
//
// Returns the concatenation of the transforms for `left` and `right`. You can
// optionally pass an existing matrix in `result` to avoid allocating a new
// matrix. This emulates the OpenGL function `glMultMatrix()`.
Matrix.multiply = function(left, right, result) {
  result = result || new Matrix();
  var a = left.m, b = right.m, r = result.m;

  r[0] = a[0] * b[0] + a[1] * b[4] + a[2] * b[8] + a[3] * b[12];
  r[1] = a[0] * b[1] + a[1] * b[5] + a[2] * b[9] + a[3] * b[13];
  r[2] = a[0] * b[2] + a[1] * b[6] + a[2] * b[10] + a[3] * b[14];
  r[3] = a[0] * b[3] + a[1] * b[7] + a[2] * b[11] + a[3] * b[15];

  r[4] = a[4] * b[0] + a[5] * b[4] + a[6] * b[8] + a[7] * b[12];
  r[5] = a[4] * b[1] + a[5] * b[5] + a[6] * b[9] + a[7] * b[13];
  r[6] = a[4] * b[2] + a[5] * b[6] + a[6] * b[10] + a[7] * b[14];
  r[7] = a[4] * b[3] + a[5] * b[7] + a[6] * b[11] + a[7] * b[15];

  r[8] = a[8] * b[0] + a[9] * b[4] + a[10] * b[8] + a[11] * b[12];
  r[9] = a[8] * b[1] + a[9] * b[5] + a[10] * b[9] + a[11] * b[13];
  r[10] = a[8] * b[2] + a[9] * b[6] + a[10] * b[10] + a[11] * b[14];
  r[11] = a[8] * b[3] + a[9] * b[7] + a[10] * b[11] + a[11] * b[15];

  r[12] = a[12] * b[0] + a[13] * b[4] + a[14] * b[8] + a[15] * b[12];
  r[13] = a[12] * b[1] + a[13] * b[5] + a[14] * b[9] + a[15] * b[13];
  r[14] = a[12] * b[2] + a[13] * b[6] + a[14] * b[10] + a[15] * b[14];
  r[15] = a[12] * b[3] + a[13] * b[7] + a[14] * b[11] + a[15] * b[15];

  return result;
};

// ### GL.Matrix.identity([result])
//
// Returns an identity matrix. You can optionally pass an existing matrix in
// `result` to avoid allocating a new matrix. This emulates the OpenGL function
// `glLoadIdentity()`.
Matrix.identity = function(result) {
  result = result || new Matrix();
  var m = result.m;
  m[0] = m[5] = m[10] = m[15] = 1;
  m[1] = m[2] = m[3] = m[4] = m[6] = m[7] = m[8] = m[9] = m[11] = m[12] = m[13] = m[14] = 0;
  return result;
};

// ### GL.Matrix.perspective(fov, aspect, near, far[, result])
//
// Returns a perspective transform matrix, which makes far away objects appear
// smaller than nearby objects. The `aspect` argument should be the width
// divided by the height of your viewport and `fov` is the top-to-bottom angle
// of the field of view in degrees. You can optionally pass an existing matrix
// in `result` to avoid allocating a new matrix. This emulates the OpenGL
// function `gluPerspective()`.
Matrix.perspective = function(fov, aspect, near, far, result) {
  var y = Math.tan(fov * Math.PI / 360) * near;
  var x = y * aspect;
  return Matrix.frustum(-x, x, -y, y, near, far, result);
};

// ### GL.Matrix.frustum(left, right, bottom, top, near, far[, result])
//
// Sets up a viewing frustum, which is shaped like a truncated pyramid with the
// camera where the point of the pyramid would be. You can optionally pass an
// existing matrix in `result` to avoid allocating a new matrix. This emulates
// the OpenGL function `glFrustum()`.
Matrix.frustum = function(l, r, b, t, n, f, result) {
  result = result || new Matrix();
  var m = result.m;

  m[0] = 2 * n / (r - l);
  m[1] = 0;
  m[2] = (r + l) / (r - l);
  m[3] = 0;

  m[4] = 0;
  m[5] = 2 * n / (t - b);
  m[6] = (t + b) / (t - b);
  m[7] = 0;

  m[8] = 0;
  m[9] = 0;
  m[10] = -(f + n) / (f - n);
  m[11] = -2 * f * n / (f - n);

  m[12] = 0;
  m[13] = 0;
  m[14] = -1;
  m[15] = 0;

  return result;
};

// ### GL.Matrix.ortho(left, right, bottom, top, near, far[, result])
//
// Returns an orthographic projection, in which objects are the same size no
// matter how far away or nearby they are. You can optionally pass an existing
// matrix in `result` to avoid allocating a new matrix. This emulates the OpenGL
// function `glOrtho()`.
Matrix.ortho = function(l, r, b, t, n, f, result) {
  result = result || new Matrix();
  var m = result.m;

  m[0] = 2 / (r - l);
  m[1] = 0;
  m[2] = 0;
  m[3] = -(r + l) / (r - l);

  m[4] = 0;
  m[5] = 2 / (t - b);
  m[6] = 0;
  m[7] = -(t + b) / (t - b);

  m[8] = 0;
  m[9] = 0;
  m[10] = -2 / (f - n);
  m[11] = -(f + n) / (f - n);

  m[12] = 0;
  m[13] = 0;
  m[14] = 0;
  m[15] = 1;

  return result;
};

// ### GL.Matrix.scale(x, y, z[, result])
//
// This emulates the OpenGL function `glScale()`. You can optionally pass an
// existing matrix in `result` to avoid allocating a new matrix.
Matrix.scale = function(x, y, z, result) {
  result = result || new Matrix();
  var m = result.m;

  m[0] = x;
  m[1] = 0;
  m[2] = 0;
  m[3] = 0;

  m[4] = 0;
  m[5] = y;
  m[6] = 0;
  m[7] = 0;

  m[8] = 0;
  m[9] = 0;
  m[10] = z;
  m[11] = 0;

  m[12] = 0;
  m[13] = 0;
  m[14] = 0;
  m[15] = 1;

  return result;
};

// ### GL.Matrix.translate(x, y, z[, result])
//
// This emulates the OpenGL function `glTranslate()`. You can optionally pass
// an existing matrix in `result` to avoid allocating a new matrix.
Matrix.translate = function(x, y, z, result) {
  result = result || new Matrix();
  var m = result.m;

  m[0] = 1;
  m[1] = 0;
  m[2] = 0;
  m[3] = x;

  m[4] = 0;
  m[5] = 1;
  m[6] = 0;
  m[7] = y;

  m[8] = 0;
  m[9] = 0;
  m[10] = 1;
  m[11] = z;

  m[12] = 0;
  m[13] = 0;
  m[14] = 0;
  m[15] = 1;

  return result;
};

// ### GL.Matrix.rotate(a, x, y, z[, result])
//
// Returns a matrix that rotates by `a` degrees around the vector `x, y, z`.
// You can optionally pass an existing matrix in `result` to avoid allocating
// a new matrix. This emulates the OpenGL function `glRotate()`.
Matrix.rotate = function(a, x, y, z, result) {
  if (!a || (!x && !y && !z)) {
    return Matrix.identity(result);
  }

  result = result || new Matrix();
  var m = result.m;

  var d = Math.sqrt(x*x + y*y + z*z);
  a *= Math.PI / 180; x /= d; y /= d; z /= d;
  var c = Math.cos(a), s = Math.sin(a), t = 1 - c;

  m[0] = x * x * t + c;
  m[1] = x * y * t - z * s;
  m[2] = x * z * t + y * s;
  m[3] = 0;

  m[4] = y * x * t + z * s;
  m[5] = y * y * t + c;
  m[6] = y * z * t - x * s;
  m[7] = 0;

  m[8] = z * x * t - y * s;
  m[9] = z * y * t + x * s;
  m[10] = z * z * t + c;
  m[11] = 0;

  m[12] = 0;
  m[13] = 0;
  m[14] = 0;
  m[15] = 1;

  return result;
};

// ### GL.Matrix.lookAt(ex, ey, ez, cx, cy, cz, ux, uy, uz[, result])
//
// Returns a matrix that puts the camera at the eye point `ex, ey, ez` looking
// toward the center point `cx, cy, cz` with an up direction of `ux, uy, uz`.
// You can optionally pass an existing matrix in `result` to avoid allocating
// a new matrix. This emulates the OpenGL function `gluLookAt()`.
Matrix.lookAt = function(ex, ey, ez, cx, cy, cz, ux, uy, uz, result) {
  result = result || new Matrix();
  var m = result.m;

  var e = new Vector(ex, ey, ez);
  var c = new Vector(cx, cy, cz);
  var u = new Vector(ux, uy, uz);
  var f = e.subtract(c).unit();
  var s = u.cross(f).unit();
  var t = f.cross(s).unit();

  m[0] = s.x;
  m[1] = s.y;
  m[2] = s.z;
  m[3] = -s.dot(e);

  m[4] = t.x;
  m[5] = t.y;
  m[6] = t.z;
  m[7] = -t.dot(e);

  m[8] = f.x;
  m[9] = f.y;
  m[10] = f.z;
  m[11] = -f.dot(e);

  m[12] = 0;
  m[13] = 0;
  m[14] = 0;
  m[15] = 1;

  return result;
};

module.exports = Matrix

},{}],10:[function(require,module,exports){
const emit_float = function( a ) {
	if (a % 1 === 0)
		return a.toFixed( 1 )
	else
		return a
}

const FloatPrototype = {
  type: 'float',
	emit() { return emit_float( this.x ) },
	emit_decl() { return "" }
}


const Float = function( x=0 ) {
  const f = Object.create( FloatPrototype )
  f.x = x
  return f
}

module.exports = Float

},{}],11:[function(require,module,exports){
const SceneNode = require( './sceneNode.js' ),
      { param_wrap, MaterialID } = require( './utils.js' ),
      { Var, float_var_gen, vec2_var_gen, vec3_var_gen, vec4_var_gen, int_var_gen, VarAlloc } = require( './var.js' )

const { Vec2, Vec3, Vec4 } = require( './vec.js' )

const Fogger = function( Scene, SDF ) {

  const Fog = function( amount=0.055, color ) {
    const fog = Object.create( Fog.prototype )
    const __amount = param_wrap( amount, float_var_gen( amount ) )  
    
    Object.defineProperty( fog, 'amount', {
      get() { return __amount },
      set( v ) {
        __amount.set( v )
      }
    })

    const __color = param_wrap( Vec3(color), vec3_var_gen( 0,0,0 ) )  
    
    Object.defineProperty( fog, 'color', {
      get() { return __color },
      set( v ) {
        __color.var.set( v )
      }
    })
    
    // this refers to the current scene via implicit binding in scene.js
    this.postprocessing.push( fog )

    return this
  }

  Fog.prototype = SceneNode()
 
  Object.assign( Fog.prototype, {
    emit() {
      return `  color = applyFog( color, t.x, ${this.amount.emit()} );`
    },
   
    emit_decl() {
      let str = this.amount.emit_decl() + this.color.emit_decl()
      const preface = `  vec3 applyFog( in vec3 rgb, in float distance, in float amount ) {
    float fogAmount = 1. - exp( -distance * amount );
    vec3  fogColor  = ${this.color.emit()};
    return mix( rgb, fogColor, fogAmount );
  }
  `
      if( SDF.memo.fog === undefined ) {
        str = str + preface
        SDF.memo.fog = true
      }else{
        str = ''
      }

      return str
    },

    update_location( gl, program ) {
      this.amount.update_location( gl, program )
      this.color.update_location( gl, program )
    },

    upload_data( gl ) {
      this.amount.upload_data( gl )
      this.color.upload_data( gl )
    }
  })

  return Fog
}

module.exports = Fogger

},{"./sceneNode.js":23,"./utils.js":28,"./var.js":29,"./vec.js":30}],12:[function(require,module,exports){
'use strict'

const Marching = require( './main.js' )

Marching.__export = Marching.export
Marching.export = obj => {
  obj.march = Marching.createScene.bind( Marching )
  Marching.__export( obj )
}

window.Marching = Marching

module.exports = Marching

},{"./main.js":15}],13:[function(require,module,exports){
const emit_int = function( a ) {
	if( a % 1 !== 0 )
		return Math.round( a )
	else
		return a
}

const IntPrototype = {
  type: 'int',
	emit() { return emit_int( this.x ) },
	emit_decl() { return "" }
}


const Int = function( x=0 ) {
  const f = Object.create( IntPrototype )
  f.x = x
  return f
}

module.exports = Int

},{}],14:[function(require,module,exports){
const SceneNode = require( './sceneNode.js' ),
      { param_wrap, MaterialID } = require( './utils.js' ),
      { Var, float_var_gen, vec2_var_gen, vec3_var_gen, vec4_var_gen } = require( './var.js' ),
      { Vec2, Vec3, Vec4 } = require( './vec.js' )

const glsl = require( 'glslify' )

const Lights = function( SDF ) {

  const Light = {
    lights:[],
    materials:[],

    defaultLights:`
      Light lights[2] = Light[2](
        Light( vec3( 2.,2.,3. ),  vec3(0.25,0.25,.25), 1. ),
        Light( vec3( -2.,2.,3. ), vec3(.25,0.25,0.25), 1. )
      );
    `,

    defaultMaterials:`
      Material materials[2] = Material[2](
        Material( 0, vec3( 1. ), vec3(0.,0.,0.), vec3(1.), 8., Fresnel( 0., 1., 2.), 0 ),
        Material( 0, vec3( 1. ), vec3(1.,0.,0.), vec3(1.), 8., Fresnel( 0., 1., 2.), 0 )
      );
    `,

    light( __pos=Vec3(2,2,3), __color=Vec3(0,0,1), attenuation=1 ) {
      const light = { 
        __attenuation: param_wrap( attenuation, float_var_gen( 1 ) ),
      }

      pos = typeof __pos === 'number' ? Vec3( __pos ) : __pos

      const __varpos = param_wrap( 
        pos, 
        vec3_var_gen( [2,2,3] )
      )

      Object.defineProperty( light, 'pos', {
        get() { return __varpos },
        set(v) {
          if( typeof v === 'object' ) {
            __varpos.set( v )
          }else{
            __varpos.value.x = v
            __varpos.value.y = v
            __varpos.value.z = v
            __varpos.dirty = true
          }
        }
      })  

      color = typeof __color === 'number' ? Vec3( __color ) : __color

      const __varcol = param_wrap( 
        color, 
        vec3_var_gen( [0,0,1] )
      )

      Object.defineProperty( light, 'color', {
        get() { return __varcol },
        set(v) {
          if( typeof v === 'object' ) {
            __varcol.set( v )
          }else{
            __varcol.value.x = v
            __varcol.value.y = v
            __varcol.value.z = v
            __varcol.dirty = true
          }
        }
      })  

      Object.defineProperty( light, 'attenuation', {
        get() { return light.__attenuation.value },
        set(v){
          light.__attenuation.value = v
          light.__attenuation.dirty = true
        }
      })

      return light
    },

    emit_lights() {
      if( this.lights.length === 0 ) return this.defaultLights

      let str = `Light lights[${this.lights.length}] = Light[${this.lights.length}](`

      for( let light of this.lights ) {
        str += `\n        Light( ${light.pos.emit()}, ${light.color.emit()}, ${light.__attenuation.emit()}),` 
      }
      
      str = str.slice(0,-1) // remove trailing comma

      str += '\n      );'

      return str
    },

    mode:'global',

    gen( shadows=8, geometries ) {
      //const str = this.modes[ this.mode ]( this.lights.length || 2, this.emit_lights(), SDF.materials.emit_materials(), shadows )
   
      const modeConstants = SDF.materials.modeConstants
      this.modesEmployed.length = 0

      let lightingFunctions = []

      // loop through all materials used and add corresponding lighting functions as needed
      for( let mat of SDF.materials.materials ) {
        if( this.modesEmployed.indexOf( mat.mode ) === -1 ) {
          lightingFunctions.push( this.modes[ mat.mode ]() )  

          this.modesEmployed.push( mat.mode )
        }
      }

      // check all modes to see if they're lighting function has been added to the shader,
      // if not, add their function stub
      for( let mode of modeConstants ) {
        // key is iterated as string, must use parseInt
        if( this.modesEmployed.indexOf( mode ) === -1 ) {
          lightingFunctions.push( this.defaultFunctionDeclarations[ modeConstants.indexOf( mode ) ] )
        }
      }

      const textures = Marching.textures.__emitFunction()
      const lighting = this.shell( 
        this.lights.length || 2, 
        this.emit_lights(), 
        SDF.materials.emit_materials(), 
        shadows,
        geometries, 
        textures.glsldefs,
        textures.mainfunc
      )

      let lightingFuncStr = lightingFunctions.join('\n')
      lightingFuncStr = lightingFuncStr.replace( /(MAX\_LIGHTS)/g, this.lights.length || 2 )
      return lighting[0] + lightingFuncStr + lighting[1]
    },

    emit_decl() {
      let str = ''
      for( let light of this.lights ) {
        str += light.pos.emit_decl()
        str += light.color.emit_decl()
        str += light.__attenuation.emit_decl()
      }

      return str
    },

    update_location( gl, program ) {
      for( let light of this.lights ) {
        if( light.pos.dirty === true )  light.pos.update_location( gl, program )
        if( light.color.dirty === true )  light.color.update_location( gl, program )
        if( light.__attenuation.dirty === true ) light.__attenuation.update_location( gl, program )
      }

    },

    upload_data( gl, program='' ) {
      for( let light of this.lights ) {
        if( light.pos.dirty === true )   light.pos.upload_data( gl, program )
        if( light.color.dirty === true )  light.color.upload_data( gl, program )
        if( light.__attenuation.dirty === true )  light.__attenuation.upload_data( gl, program )
      }
    },

    modesEmployed:[],

    // these stubs are placed in the shader by default as placeholders so that they can be referenced in 
    // a switch statement selecting lighting. They are overridden by actual lighting functions if any
    // material in the scene uses a corresponding function.
    defaultFunctionDeclarations: [
      '    vec3 global( vec3 surfacePosition, vec3 normal, vec3 rayOrigin, vec3 rayDirection, Material mat, Light lights[MAX_LIGHTS], vec3 textureColor ) { return vec3(0.); }',
      '    vec3 normal( vec3 surfacePosition, vec3 normal, vec3 rayOrigin, vec3 rayDirection, Material mat, Light lights[MAX_LIGHTS] ) { return vec3(0.); }',
      '    vec3 directional( vec3 surfacePosition, vec3 normal, vec3 rayOrigin, vec3 rayDirection, Material mat, Light lights[MAX_LIGHTS], vec3 textureColor ) { return vec3(0.); }',
      '    vec3 orenn( vec3 surfacePosition, vec3 normal, vec3 rayOrigin, vec3 rayDirection, Material mat, Light lights[MAX_LIGHTS] ) { return vec3(0.); }',
    ],

    shell( numlights, lights, materials, shadow=0, sdfs, texturePreface, textureBody ) {
      const __shadow = shadow > 0
        ? `diffuseCoefficient *= softshadow( surfacePosition, normalize( light.position ), 0.02, 2.5, ${shadow.toFixed(1)} );` 
        : ''


      let preface = glsl(["#define GLSLIFY 1\n  int MAX_LIGHTS = ",";\n    float ao( in vec3 pos, in vec3 nor ){\n      float occ = 0.0;\n      float sca = 1.0;\n      for( int i=0; i<5; i++ )\n      {\n          float hr = 0.01 + 0.12 * float( i ) / 4.0;\n          vec3 aopos =  nor * hr + pos;\n          float dd = scene ( aopos ).x;\n          occ += -(dd-hr)*sca;\n          sca *= 0.95;\n      }\n      return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n    }\n\n    \n    ","\n    ","\n    ",""],numlights,texturePreface,textureBody)
      let func = `

    vec3 lighting( vec3 surfacePosition, vec3 normal, vec3 rayOrigin, vec3 rayDirection, float sdfID, bool useTextureTransform ) {
      ${sdfs}
      SDF sdf = sdfs[ int( sdfID ) ];

      ${materials}
      Material mat = materials[ sdf.materialID ];

      int MAX_LIGHTS = ${numlights};     

      ${lights}
 
      vec3 tex = getTexture( int(sdf.textureID), surfacePosition, normal, sdf, useTextureTransform );

      vec3 clr;
      switch( mat.mode ) {
        case 0: clr = global( surfacePosition, normal, rayOrigin, rayDirection, mat, lights, tex ); break;
        case 1: clr = normal; break;
        case 2: clr = directional( surfacePosition, normal, rayOrigin, rayDirection, mat, lights, tex ); break;
        case 3: clr = orenn( surfacePosition, normal, rayOrigin, rayDirection, mat, lights ); break;
        default:
          clr = normal;
      }

      return clr; 
    }
`
      return [ preface, func ]
    }, 

    modes:{
      global() {
        const shadow = SDF.__scene.__shadow

        const str = glsl(["#define GLSLIFY 1\n\n\n        vec3 global( vec3 pos, vec3 nor, vec3 ro, vec3 rd, Material mat, Light lights[MAX_LIGHTS], vec3 textureColor ) {\n          Light light = lights[ 0 ];\n          vec3  ref = reflect( rd, nor ); // reflection angle\n          float occ = ao( pos, nor );\n          vec3  lig = normalize( light.position ); // light position\n          float amb = clamp( 0.5 + 0.5 * nor.y, 0.0, 1.0 );\n          float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n\n          // simulated backlight\n          float bac = clamp( dot( nor, normalize( vec3( -lig.x, 0.0 , -lig.z ))), 0.0, 1.0 ) * clamp( 1.0-pos.y, 0.0 ,1.0 );\n\n          // simulated skydome light\n          float dom = smoothstep( -0.1, 0.1, ref.y );\n          float fre = pow( clamp( 1.0 + dot( nor,rd ),0.0,1.0 ), 3.0);\n          float spe = pow( clamp( dot( ref, lig ), 0.0, 1.0 ), 8.0 );\n\n          dif *= softshadow( pos, lig, 0.02, 2.5, "," );\n          dom *= softshadow( pos, ref, 0.02, 2.5, "," );\n\n          vec3 brdf = textureColor;//vec3( 0.0 );\n          brdf += 1.20 * dif * vec3( 1.00,0.90,0.60 ) * mat.diffuse * light.color;\n          brdf += 2.20 * spe * vec3( 1.00,0.90,0.60 ) * dif * mat.specular * light.color;\n          brdf += 0.30 * amb * vec3( 0.50,0.70,1.00 ) * occ * mat.ambient * light.color;\n          brdf += 0.40 * dom * vec3( 0.50,0.70,1.00 );\n          brdf += 0.70 * bac * vec3( 0.25 );\n          brdf += 0.40 * (fre * light.color);\n\n          return brdf;\n        }\n        ",""],shadow.toFixed(1),shadow.toFixed(1))

        return str
      },

      phong( numlights, lights, materials ) {
        const shadow = SDF.__scene.__shadow

        const __shadow = shadow > 0
          ? `diffuseCoefficient *= softshadow( surfacePosition, normalize( light.position ), 0.02, 2.5, ${shadow.toFixed(1)} );` 
          : ''

        const str = glsl(["#define GLSLIFY 1\n  \n        \n        vec3 directional( vec3 surfacePosition, vec3 normal, vec3 rayOrigin, vec3 rayDirection, Material mat, Light lights[MAX_LIGHTS], vec3 textureColor ) {\n          vec3  outputColor   = textureColor;//vec3( 0. );\n   \n          // applies to all lights\n          float occlusion = ao( surfacePosition, normal );\n\n          for( int i = 0; i < 20000; i++ ) {\n            if( i >= MAX_LIGHTS ) break;\n\n            Light light = lights[ i ];\n\n            vec3 surfaceToLightDirection = normalize( light.position - surfacePosition );\n            \n            // get similarity between normal and direction to light\n            float diffuseCoefficient = dot( normal, surfaceToLightDirection ); \n\n            // get reflection angle for light striking surface\n            vec3 angleOfReflection = reflect( -surfaceToLightDirection, normal );\n\n            // see if reflected light travels to camera and generate coefficient accordingly\n            float specularAngle = clamp( dot( angleOfReflection, -rayDirection ), 0., 1. );\n            float specularCoefficient = pow( specularAngle, mat.shininess );\n\n            // lights should have an attenuation factor\n            float attenuation = 1. / ( light.attenuation * pow( length( light.position - surfacePosition ), 2. ) ); \n\n            // bias, scale, power\n            float fresnel = mat.fresnel.x + mat.fresnel.y * pow( 1.0 + dot( rayDirection, normal ), mat.fresnel.z ); \n\n            ","\n\n            vec3 color = vec3( 0. );\n            color += 1.2 * diffuseCoefficient * mat.diffuse * light.color;\n            color += 2.2 * specularCoefficient * mat.specular * light.color;\n            color += 0.3 * (mat.ambient * light.color) * occlusion;\n            color += (fresnel * light.color);\n\n            // texture\n            //color *= textureColor.xyz;\n\n            // gamma correction must occur before light attenuation\n            // which means it must be applied on a per-light basis unfortunately\n            vec3 gammaCorrectedColor = pow( color, vec3( 1./2.2 ) );\n            vec3 attenuatedColor = 2. * gammaCorrectedColor * attenuation; \n\n            outputColor += attenuatedColor;\n          }\n\n          return outputColor;\n        }\n        ",""],__shadow)

        return str
      }, 
      phongT( numlights, lights, materials ) {
        const shadow = SDF.__scene.__shadow

        const __shadow = shadow > 0
          ? `diffuseCoefficient *= softshadow( surfacePosition, normalize( light.position ), 0.02, 2.5, ${shadow.toFixed(1)} );` 
          : ''

        const str = glsl(["#define GLSLIFY 1\n  \n\n        vec3 directional( vec3 surfacePosition, vec3 normal, vec3 rayOrigin, vec3 rayDirection, Material mat, Light lights[MAX_LIGHTS] ) {\n          vec3  outputColor   = vec3( 0. );\n   \n          // applies to all lights\n          float occlusion = ao( surfacePosition, normal );\n\n          vec4 textureColor;\n          if( mat.textureID > -1 ) {\n            //textureColor = texcube( textures[ mat.textureID ], surfacePosition, normal, 1. );//texture( textures[ mat.textureID ], surfacePosition.xy - normal.xy ); \n            vec2 uv = getUVCubic( surfacePosition, vec3(0.) );//surfacePosition.xz*vec2(0.03,0.07);\n            textureColor = texture( textures[ mat.textureID ], uv );\n          }else{\n            textureColor = vec4(0.);\n          }\n\n          outputColor = 0;//textureColor.xyz;\n\n          for( int i = 0; i < 20000; i++ ) {\n            if( i >= MAX_LIGHTS ) break;\n\n            Light light = lights[ i ];\n\n            vec3 surfaceToLightDirection = normalize( light.position - surfacePosition );\n            \n            // get similarity between normal and direction to light\n            float diffuseCoefficient = dot( normal, surfaceToLightDirection ); \n\n            // get reflection angle for light striking surface\n            vec3 angleOfReflection = reflect( -surfaceToLightDirection, normal );\n\n            // see if reflected light travels to camera and generate coefficient accordingly\n            float specularAngle = clamp( dot( angleOfReflection, -rayDirection ), 0., 1. );\n            float specularCoefficient = pow( specularAngle, mat.shininess );\n\n            // lights should have an attenuation factor\n            float attenuation = 1. / ( light.attenuation * pow( length( light.position - surfacePosition ), 2. ) ); \n\n            // bias, scale, power\n            float fresnel = mat.fresnel.x + mat.fresnel.y * pow( 1.0 + dot( rayDirection, normal ), mat.fresnel.z ); \n\n            ","\n\n            vec3 color = vec3( 0. );\n            color += 1.2 * diffuseCoefficient * textureColor.xyz * light.color;\n            color += 2.2 * specularCoefficient * textureColor.xyz * light.color;\n            color += 0.3 * (mat.ambient * light.color) * occlusion;\n            color += (fresnel * light.color);\n\n            // texture\n            //color *= textureColor.xyz;\n\n            // gamma correction must occur before light attenuation\n            // which means it must be applied on a per-light basis unfortunately\n            vec3 gammaCorrectedColor = pow( color, vec3( 1./2.2 ) );\n            vec3 attenuatedColor = 2. * gammaCorrectedColor * attenuation; \n\n            outputColor += attenuatedColor;\n          }\n\n          return outputColor;\n        }\n        ",""],__shadow)

        return str
      }, 


      orenn( numlights, lights, materials ) {
        const shadow = SDF.__scene.__shadow
        const __shadow = shadow > 0
          ? `diffuseCoefficient *= softshadow( surfacePosition, normalize( light.position ), 0.02, 2.5, ${shadow.toFixed(1)} );` 
          : ''

        const str = glsl(["#define GLSLIFY 1\n  \n        float orenNayarDiffuse(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float roughness,\n  float albedo) {\n  \n  float LdotV = dot(lightDirection, viewDirection);\n  float NdotL = dot(lightDirection, surfaceNormal);\n  float NdotV = dot(surfaceNormal, viewDirection);\n\n  float s = LdotV - NdotL * NdotV;\n  float t = mix(1.0, max(NdotL, NdotV), step(0.0, s));\n\n  float sigma2 = roughness * roughness;\n  float A = 1.0 + sigma2 * (albedo / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));\n  float B = 0.45 * sigma2 / (sigma2 + 0.09);\n\n  return albedo * max(0.0, NdotL) * (A + B * s / t) / 3.14159265;\n}\n\n        float gaussianSpecular(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float shininess) {\n  vec3 H = normalize(lightDirection + viewDirection);\n  float theta = acos(dot(H, surfaceNormal));\n  float w = theta / shininess;\n  return exp(-w*w);\n}\n\n        vec3 orenn( vec3 surfacePosition, vec3 normal, vec3 rayOrigin, vec3 rayDirection, Material mat, Light lights[MAX_LIGHTS] ) {\n          vec3  outputColor   = vec3( 0. );\n   \n          // applies to all lights\n          float occlusion = ao( surfacePosition, normal );\n\n          for( int i = 0; i < 20000; i++ ) {\n            if( i >= MAX_LIGHTS ) break;\n\n            Light light = lights[ i ];\n\n            vec3 surfaceToLightDirection = normalize( light.position - surfacePosition );\n            \n            // get similarity between normal and direction to light\n            float diffuseCoefficient = orenNayarDiffuse( surfaceToLightDirection, -rayDirection, normal, 0.15, 4.0);\n\n            // get reflection angle for light striking surface\n            vec3 angleOfReflection = reflect( -surfaceToLightDirection, normal );\n\n            // see if reflected light travels to camera and generate coefficient accordingly\n            float specularAngle = clamp( dot( angleOfReflection, -rayDirection ), 0., 1. );\n            float specularCoefficient = gaussianSpecular( surfaceToLightDirection, -rayDirection, normal, .5 ); \n\n            // lights should have an attenuation factor\n            float attenuation = 1. / ( light.attenuation * pow( length( light.position - surfacePosition ), 2. ) ); \n\n            float fresnel = mat.fresnel.x + mat.fresnel.y * pow( 1.0 + dot( rayDirection, normal ), mat.fresnel.z ); \n\n            ","\n\n            vec3 color = vec3( 0. );\n            color += 1.2 * diffuseCoefficient * mat.diffuse * light.color;\n            color += 2.2 * specularCoefficient * mat.specular * light.color;\n            color += 0.3 * (mat.ambient * light.color) * occlusion;\n            color += (fresnel * light.color);\n\n            // gamma correction must occur before light attenuation\n            // which means it must be applied on a per-light basis unfortunately\n            vec3 gammaCorrectedColor = pow( color, vec3( 1./2.2 ) );\n            vec3 attenuatedColor = 2. * gammaCorrectedColor * attenuation; \n\n            outputColor += attenuatedColor;\n          }\n\n          return outputColor;\n        }",""],__shadow)

        return str
      }, 

      normal() { return '' },
      noise() { return '' }
    },
  }

  return Light
}

module.exports = Lights

// old lighting
/*
*/

},{"./sceneNode.js":23,"./utils.js":28,"./var.js":29,"./vec.js":30,"glslify":121}],15:[function(require,module,exports){
const SDF = {
  camera:           require( './camera.js' ),
  __primitives:     require( './primitives.js' ),
  vectors:          require( './vec.js' ),
  distanceOps:      require( './distanceOperations.js' ),
  alterations:      require( './alterations.js' ),
  distanceDeforms:  require( './distanceDeformations.js' ),
  __domainOps:      require( './domainOperations.js' ),
  __noise:          require( './noise.js' ),
  __scene:          require( './scene.js' ),
  __lighting:       require( './lighting.js' ),
  __materials:      require( './material.js' ),
  __textures:       require( './texture.js' ),
  Var:              require( './var.js' ).Var,
  //Color:            require( './color.js' ),
  FFT:              require( './audio.js' ),
  fx:               require( './mergepass.js' ),

  // a function that generates the fragment shader
  renderFragmentShader: require( './renderFragmentShader.js' ),

  // additional callbacks that are run once per frame
  callbacks: [],
  geometries: [],

  // the main drawing callback
  render: null,

  // the scene is a chain of Unions combining all elements together
  scene:  null,

  // a speed of 1 corresponds to 60 fps.
  delay: 0,
  __isPaused:false,

  defaultVertexSource:`    #version 300 es
    in vec2 a_pos;

		void main() {
			gl_Position = vec4( a_pos, 0., 1. );
    }`
  ,

  export( obj ) {
    Object.assign( 
      obj, 
      this.primitives,
      this.vectors,
      this.distanceOps,
      this.domainOps,
      this.distanceDeforms,
      this.alterations
    )

    this.fx.export( obj )

    obj.Light = this.Light
    obj.Material = this.Material
    obj.Texture  = this.Texture
    obj.camera = this.camera
    obj.callbacks = this.callbacks // XXX remove once API stops using callbacks
    obj.FFT = this.FFT
  },

  init( canvas, shouldInit = false ) {
    this.primitives = this.__primitives( this )
    this.Scene      = this.__scene( this )
    this.domainOps  = this.__domainOps( this )
    this.noise     = this.__noise( this )
    this.export( this )

    this.canvas = canvas//document.createElement('canvas')
    this.canvasMP = canvas

    this.lighting   = this.__lighting( this )
    this.Light = this.lighting.light
    this.materials  = this.__materials( this )
    this.Material = this.materials.material
    this.textures = this.__textures( this )
    this.Texture = this.textures.texture

    this.canvas.width = this.canvasMP.width = window.innerWidth 
    this.canvas.height = this.canvasMP.height = window.innerHeight
    this.gl = this.canvas.getContext( 'webgl2', { antialias:true, alpha:true })

    //this.glMP = this.canvasMP.getContext( 'webgl2', { antialias:true, alpha:true })
  },
  // generate shaders, initialize camera, start rendering loop 
  createScene( ...args ) {
    const scene = this.Scene( args, this.canvas )

    this.requiredGeometries = []
    this.requiredOps = []
    this.memo = {}

    return scene
  },

  start( fs, width, height, shouldAnimate ) {
    if( this.render !== null ) this.render.running = false

    this.fs = fs
    this.callbacks.length = 0

    this.render = this.initWebGL( this.defaultVertexSource, fs, width, height, shouldAnimate )
    this.render.running = true

    this.camera.init( this.gl, this.program, cb => { 
      this.callbacks.push( cb )
    })

    setTimeout( ()=> this.render( 0.0 ), 0 )
  },

  generateSDF( __scene ) {
    let scene = { preface:'' }

    /* if there is more than one object in our scene, chain pairs of objects
       in Unions. So, given objects a,b,c, and d create:

       Union( a, Union( b, Union( c,d ) ) )

       ... or something like that. If there is only a single object,
       use that object as the entire scene.
     */

    let objs = __scene.objs
    if( objs.length > 1 ) {
      // reduce objects to nested Unions
      scene.output = objs.reduce( ( current, next ) => this.Union( current, next ) )
    }else{
      scene.output = objs[0]
    }

    // create an fancy emit() function that wraps the scene
    // with an id #.

    scene.output.__emit = scene.output.emit.bind( scene.output )
    scene.output.emit = function( ...args ) {
      const emitted = scene.output.__emit(...args)
      const output = {
        out:     emitted.out,
        preface: emitted.preface || '' 
      }

      return output 
    }

    this.scene = scene.output

    let variablesDeclaration = scene.output.emit_decl()
    const sceneRendering = scene.output.emit()

    // fog etc. maybe msaa?
    let pp = ''
    for( let processor of __scene.postprocessing ) {
      pp += processor.emit()
      variablesDeclaration += processor.emit_decl()
    }
    
    this.postprocessing = __scene.postprocessing

    return [ variablesDeclaration, sceneRendering, pp ]
  },

	compile( type, source ) {
    const gl = this.gl

		const shader = this.shader = gl.createShader( type );
		gl.shaderSource( shader, source )
		gl.compileShader( shader )

		if( gl.getShaderParameter( shader, gl.COMPILE_STATUS) !== true ) {
			let log = gl.getShaderInfoLog( shader )
			gl.deleteShader( shader )

			console.log( source )
			console.log( log )

			return null
		}

		return shader
	},

  createProgram( vs_source, fs_source ) {
    const gl = this.gl
		const vs = this.compile( gl.VERTEX_SHADER, vs_source )
		const fs = this.compile( gl.FRAGMENT_SHADER, fs_source )

		if( null === vs || null === fs ) return null

		const program = gl.createProgram()
		gl.attachShader( program, vs )
		gl.attachShader( program, fs )
		gl.linkProgram( program )

		if( gl.getProgramParameter( program, gl.LINK_STATUS ) !== true ){
			const log = gl.getProgramInfoLog( program )
			gl.deleteShader(vs)
			gl.deleteShader(fs)
			gl.deleteProgram(program)

			console.error( log )
			return null
		}

    const drawProgram = gl.createProgram()
    const fragSource = ` #version 300 es
  precision mediump float;

  uniform sampler2D uSampler;
  uniform vec2 resolution;

  out vec4 col;
  void main() {
    // copy color info from texture
    col = vec4( texture( uSampler, gl_FragCoord.xy / resolution ).rgb, 1. );
  }`

    const fs_draw = this.compile( gl.FRAGMENT_SHADER, fragSource )
    const vs_draw = this.compile( gl.VERTEX_SHADER, vs_source )

    gl.attachShader( drawProgram, vs_draw )
		gl.attachShader( drawProgram, fs_draw )
		gl.linkProgram( drawProgram )

    return [ program, drawProgram ]
  },

  clear() {
    if( this.callbacks !== undefined ) this.callbacks.length = 0
    if( this.render !== null ) this.render.running = false

    // remove post-processing fx
    this.fx.clear()

    this.geometries.length = 0

    const gl = this.gl
    gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT )
  },

  pause() {
    this.__isPaused = !this.__isPaused
  },

  initBuffers( width, height, colorTexture, depthTexture ) {
    const gl = this.gl
    gl.clearColor( 0.0, 0.0, 0.0, 0.0 )
    gl.clear(gl.COLOR_BUFFER_BIT)

    const framebuffer = gl.createFramebuffer()
    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
    const vbo = gl.createBuffer()

    const vertices = new Float32Array([
      -1, -1,
      1,  -1,
      -1, 1,
      -1, 1,
      1, -1,
      1, 1
    ])

    // initialize memory for buffer and populate it. Give
    // open gl hint contents will not change dynamically.
    gl.bindBuffer( gl.ARRAY_BUFFER, vbo )
    gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW )

    gl.drawBuffers([
      gl.COLOR_ATTACHMENT0,
      gl.COLOR_ATTACHMENT1 
    ])

    return { vbo, vertices, framebuffer }
  },

  initUniforms( gl, program ) {
    const aPos = this.gl.getAttribLocation( this.program, "a_pos" )

    const uTime= this.gl.getUniformLocation( this.program, "time" )
    const uResolution = this.gl.getUniformLocation( this.program, "resolution" )

    return { aPos, uTime, uResolution } 
  },

  initTextures( gl, width, height ) {
    gl.getExtension( 'EXT_color_buffer_float' )

    const colorTexture = gl.createTexture()
    gl.bindTexture(gl.TEXTURE_2D, colorTexture)
    
    // must use linear interpolation for merge-pass integration 
    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR )
    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR )
    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE )
    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE )
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null)
    gl.myColorTexture = colorTexture

    // store depth in floating point texture
    const depthTexture = gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D, depthTexture)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA32F, width, height, 0, gl.RGBA, gl.FLOAT, null)

    return { colorTexture, depthTexture }
  },

  updateLocations() {
    this.postprocessing.forEach( pp => pp.update_location( this.gl, this.program ) )
    this.scene.update_location( this.gl, this.program )
    this.textures.update_location( this.gl, this.program )
    this.materials.update_location( this.gl, this.program )
    this.lighting.update_location( this.gl, this.program )
  },

  initShaderProgram( vs, fs, gl ) {
    const programs = this.createProgram( vs, fs )
    this.program = programs[0]

    return programs
  },

  uploadData( gl ) {
    this.materials.upload_data( gl )
    this.textures.upload_data( gl )
    this.scene.upload_data( gl )
    this.lighting.upload_data( gl )
    this.postprocessing.forEach( pp => pp.upload_data( gl ) )
  },

  uploadVertices( gl, aPos, vertices ) {
    gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW )

    gl.enableVertexAttribArray( aPos )
    gl.vertexAttribPointer( aPos, 2, gl.FLOAT, false, 0, 0)
  },

  initWebGL( vs, fs, width, height,shouldAnimate=false ) {
    const gl                                = this.gl,
          programs                          = this.initShaderProgram( vs, fs, gl ),
          { colorTexture, depthTexture }    = this.initTextures( gl, width, height ),
          { aPos, uTime, uResolution }      = this.initUniforms( gl, programs[0] ),
          { vbo, vertices, framebuffer }    = this.initBuffers( width, height, colorTexture, depthTexture )
 
    let total_time = 0.0,
        frameCount = 0

    // only init post-processing if effects have been registered
    if( this.fx.chain.length > 0 ) this.fx.init( colorTexture, depthTexture, gl )

    gl.useProgram( this.program )
    this.updateLocations( gl, this.program )
    this.uploadVertices( gl, aPos, vertices )

    gl.viewport( 0,0,width,height )
    gl.uniform2f( uResolution, width, height )
 
    const render = function( timestamp ){
      if( render.running === true && shouldAnimate === true ) {
        window.requestAnimationFrame( render )
      }else if( render.running === false ) {
        gl.clear( gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT )
        return
      }

      gl.useProgram( this.program )
      gl.bindFramebuffer( gl.FRAMEBUFFER, framebuffer )
    
      if( this.fx.merger !== null ) {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.fx.merger.tex.back.tex, 0 )
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT1, gl.TEXTURE_2D, this.fx.merger.tex.bufTextures[0].tex, 0)
      }else{
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, colorTexture, 0)
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT1, gl.TEXTURE_2D, depthTexture, 0)
      }

      gl.enableVertexAttribArray( aPos )

      if( this.__isPaused === false ) {
        this.currentTime = timestamp

        if( this.delay !== 0 && this.delay >= frameCount ) {
          frameCount++
          return
        }else if( this.delay !== 0 ) {
          frameCount = 0
        }

        total_time = timestamp / 1000.0
        gl.uniform1f( uTime, total_time )

        this.callbacks.forEach( cb => cb( total_time, this.currentTime ) )

        if( typeof window.onframe === 'function' ) window.onframe( total_time )
      }

      // transfer all data associated with uniforms in marching.js
      this.uploadData( gl )

      // draw to color and depth texturese
      gl.bindBuffer( gl.ARRAY_BUFFER, vbo )

      // if post-processing is not being used,
      // draw directly to screen
      if( this.fx.merger === null ) {
        gl.bindFramebuffer( gl.FRAMEBUFFER, null )
      }

      gl.drawArrays( gl.TRIANGLES, 0, 6 )

      /********* UNCOMMENT THIS LINE TO CHECK MARCHING.JS COLOR OUPTUT ***************/
      //this.runCopyShader( gl, width, height, aPos, programs, colorTexture, vbo )
      
      /********* UNCOMMENT THIS LINE TO CHECK MARCHING.JS DEPTH OUPTUT ***************/
      // this.runCopyShader( gl, width, height, aPos, programs, depthTexture, vbo )
 
      // conditional mergepass render
      if( this.fx.merger !== null ) this.fx.merger.draw( total_time )

    }.bind( SDF )

    render.running = true

    return render    
  },

  runCopyShader( gl, width, height, loc_a_pos, programs, colorTexture, vbo ) {
    gl.bindFramebuffer(gl.FRAMEBUFFER, null )

    gl.bindTexture(gl.TEXTURE_2D, colorTexture)
    gl.viewport(0, 0, width, height )

    gl.bindBuffer( gl.ARRAY_BUFFER, vbo )
    gl.useProgram( programs[1] )

    const u_resolution = gl.getUniformLocation(programs[1], "resolution" )
    gl.uniform2f( u_resolution, width, height )

    gl.drawArrays( gl.TRIANGLES, 0, 6 )
  }
}

module.exports = SDF

},{"./alterations.js":1,"./audio.js":2,"./camera.js":4,"./distanceDeformations.js":5,"./distanceOperations.js":6,"./domainOperations.js":8,"./lighting.js":14,"./material.js":16,"./mergepass.js":17,"./noise.js":18,"./primitives.js":20,"./renderFragmentShader.js":21,"./scene.js":22,"./texture.js":24,"./var.js":29,"./vec.js":30}],16:[function(require,module,exports){
const SceneNode = require( './sceneNode.js' ),
      { param_wrap, MaterialID } = require( './utils.js' ),
      { Var, float_var_gen, vec2_var_gen, vec3_var_gen, vec4_var_gen } = require( './var.js' ),
      { Vec2, Vec3, Vec4 } = require( './vec.js' )


const glsl = require( 'glslify' )

const __Materials = function( SDF ) {

  const Materials = {
    materials:[],
    __materials:[],
    modeConstants : [
      'global',
      'normal',
      'phong',
      'orenn',
      'noise'
    ],

    default: 'global',

    //defaultMaterials:`
    //  Material materials[2] = Material[2](
    //    Material( 0, vec3( 1. ), vec3(0.,0.,0.), vec3(1.), 8., Fresnel( 0., 1., 2.) ),
    //    Material( 0, vec3( 1. ), vec3(1.,0.,0.), vec3(1.), 8., Fresnel( 0., 1., 2.) )
    //  );
    //`,

    addMaterial( mat ) {
      if( mat === undefined ) mat = Materials.material.default

      if( Materials.materials.indexOf( mat ) === -1 ) {
        mat.id = MaterialID.alloc()

        // we have to dirty the material so that its data
        // will be uploaded to new shaders, otherwise the
        // material will only work the first time it's used, when
        // it's dirty on initialization.
        Materials.dirty( mat )

        Materials.materials.push( mat )
      } 

      return mat
    },

    material( mode='global', __ambient, __diffuse, __specular, __shininess, __fresnel, __texture=null ){
      let modeIdx = Materials.modeConstants.indexOf( mode )
      if( modeIdx === -1 ) {
        console.warn( `There is no material type named ${mode}. Using the default material, ${Materials.default}, instead.` )
        mode = Materials.default
        modeIdx = Materials.modeConstants.indexOf( mode )
      }

      if( typeof __ambient === 'number' ) __ambient = Vec3( __ambient )
      const ambient = param_wrap( __ambient, vec3_var_gen(.1,.1,.1) )
      if( typeof __diffuse=== 'number' ) __diffuse= Vec3( __diffuse )
      const diffuse = param_wrap( __diffuse, vec3_var_gen(0,0,1) )
      if( typeof __specular === 'number' ) __specular = Vec3( __specular )
      const specular = param_wrap( __specular, vec3_var_gen(1,1,1) )
      const shininess = param_wrap( __shininess, float_var_gen(8) )
      if( typeof __fresnel === 'number' ) __fresnel = Vec3( __fresnel )
      const fresnel = param_wrap( __fresnel, vec3_var_gen(0,1,2) )

      const mat = { shininess, mode, texture:__texture, type:'material' }

      Object.defineProperty( mat, 'ambient', {
        get() { return ambient },
        set(v) {
          if( typeof v === 'object' ) {
            ambient.set( v )
          }else{
            ambient.value.x = v
            ambient.value.y = v
            ambient.value.z = v
            ambient.dirty = true
          }
        }
      })  
      Object.defineProperty( mat, 'diffuse', {
        get() { return diffuse },
        set(v) {
          if( typeof v === 'object' ) {
            diffuse.set( v )
          }else{
            diffuse.value.x = v
            diffuse.value.y = v
            diffuse.value.z = v
            diffuse.dirty = true
          }
        }
      })  
      Object.defineProperty( mat, 'specular', {
        get() { return specular },
        set(v) {
          if( typeof v === 'object' ) {
            specular.set( v )
          }else{
            specular.value.x = v
            specular.value.y = v
            specular.value.z = v
            specular.dirty = true
          }
        }
      })  
      Object.defineProperty( mat, 'fresnel', {
        get() { return fresnel },
        set(v) {
          if( typeof v === 'object' ) {
            fresnel.set( v )
          }else{
            fresnel.value.x = v
            fresnel.value.y = v
            fresnel.value.z = v
            fresnel.dirty = true
          }
        }
      })  
      //Object.defineProperty( mat, 'shininess', {
      //  get() { return mat.shininess.value },
      //  set(v){
      //    mat.shininess.value = v
      //    mat.shininess.dirty = true
      //  }
      //})     //
      
      return mat 
    },

    dirty( mat ) {
      mat.ambient.dirty = true
      mat.diffuse.dirty = true
      mat.specular.dirty = true
      mat.shininess.dirty = true
      mat.fresnel.dirty = true
      if( mat.texture !== null ) mat.texture.dirty = true
    },
   
    emit_materials() {
      if( this.materials.length === 0 ) {
        console.log( 'returning undefined?', this.defaultMaterials )
        return this.defaultMaterials//this.addMaterial() 
      }

      let str = `Material materials[${this.materials.length}] = Material[${this.materials.length}](`

      this.materials.sort( (a,b) => a.id > b.id ? 1 : -1 ) 

      for( let mat of this.materials ) {
        const fresnel = `Fresnel( ${f(mat.fresnel.x)}, ${f(mat.fresnel.y)}, ${f(mat.fresnel.z)} )`

        const texid = 0//SDF.textures.textures.indexOf( mat.texture )
        str += mat.texture === null 
          ? `\n        Material( ${this.modeConstants.indexOf( mat.mode )}, ${mat.ambient.emit()}, ${mat.diffuse.emit()}, ${mat.specular.emit()}, ${mat.shininess.emit()}, ${mat.fresnel.emit()}, ${ texid } ),` 
          : `\n        Material( ${this.modeConstants.indexOf( mat.mode )}, ${mat.ambient.emit()}, ${mat.diffuse.emit()}, ${mat.specular.emit()}, ${mat.shininess.emit()}, ${mat.fresnel.emit()}, ${ texid } ),` 
      }
      
      str = str.slice(0,-1) // remove trailing comma

      str += '\n      );'

      this.__materials = this.materials.slice( 0 )
      this.materials.length = 0

      return str
    },

    emit_decl() {
      let str = ''
      for( let mat of this.__materials ) {
        str += mat.ambient.emit_decl()
        str += mat.diffuse.emit_decl()
        str += mat.specular.emit_decl()
        str += mat.shininess.emit_decl()
        str += mat.fresnel.emit_decl()
      }

      return str
    },

    update_location( gl, program ) {
      for( let mat of this.__materials ) {
        if( mat.ambient.dirty === true )   mat.ambient.update_location( gl, program )
        if( mat.diffuse.dirty === true )   mat.diffuse.update_location( gl, program )
        if( mat.specular.dirty === true )  mat.specular.update_location( gl, program )
        if( mat.shininess.dirty === true ) mat.shininess.update_location( gl, program )
        if( mat.fresnel.dirty === true )   mat.fresnel.update_location( gl, program )
      }
    },

    upload_data( gl, program='' ) {
      for( let mat of this.__materials ) {
        if( mat.ambient.dirty === true )   mat.ambient.upload_data( gl, program )
        if( mat.diffuse.dirty === true )   mat.diffuse.upload_data( gl, program )
        if( mat.specular.dirty === true )  mat.specular.upload_data( gl, program )
        if( mat.shininess.dirty === true ) mat.shininess.upload_data( gl, program )
        if( mat.fresnel.dirty === true )   mat.fresnel.upload_data( gl, program )
      }
    }

  }

  const f = value => value % 1 === 0 ? value.toFixed(1) : value 

  Object.assign( Materials.material, {
    default : Materials.material( 'global', Vec3( .15 ), Vec3(0), Vec3(1), 8, Vec3( 0, 1, .5 ) ),  
    red     : Materials.material( 'global', Vec3(.25,0,0), Vec3(1,0,0), Vec3(0), 2, Vec3(0) ),
    green   : Materials.material( 'global', Vec3(0,.25,0), Vec3(0,1,0), Vec3(0), 2, Vec3(0) ),
    blue    : Materials.material( 'global', Vec3(0,0,.25), Vec3(0,0,1), Vec3(0), 2, Vec3(0) ),
    cyan    : Materials.material( 'global', Vec3(0,.25,.25), Vec3(0,1,1), Vec3(0), 2, Vec3(0) ),
    magenta : Materials.material( 'global', Vec3(.25,0,.25), Vec3(1,0,1), Vec3(0), 2, Vec3(0) ),
    yellow  : Materials.material( 'global', Vec3(.25,.25,.0), Vec3(1,1,0), Vec3(0), 2, Vec3(0) ),
    black   : Materials.material( 'global', Vec3(0, 0, 0), Vec3(0,0,0), Vec3(0), 2, Vec3(0) ),
    white   : Materials.material( 'global', Vec3(.25), Vec3(1), Vec3(1), 2, Vec3(0) ),
    grey    : Materials.material( 'global', Vec3(.25), Vec3(.33), Vec3(1), 2, Vec3(0) ),

    'white glow' : Materials.material( 'phong',  Vec3(.015), Vec3(1), Vec3(1), 16, Vec3(0,200,5) ),
    glue    : Materials.material( 'phong',  Vec3(.015), Vec3(1), Vec3(1), 16, Vec3(0,15,-.1) ),
    inverse : Materials.material( 'phong', 1, .5, 1, 16, Vec3(1,.5,-2) ),

    normal  : Materials.material( 'normal' ),
    noise   : Materials.material( 'noise',  Vec3( .15 ), Vec3(1,0,0), Vec3(1), 8, Vec3( 0, 1, .5 ))
  })

  return Materials
}

module.exports = __Materials

},{"./sceneNode.js":23,"./utils.js":28,"./var.js":29,"./vec.js":30,"glslify":121}],17:[function(require,module,exports){
const MP   = require( '@bandaloo/merge-pass' )

const FX = {
  merger:null,
  chain: [],
  MP,
  clear() {
    if( this.merger !== null ) {
       this.merger.delete()
       this.merger = null
    }

    this.chain.length = 0
  },

  init( colorTexture, depthTexture, gl ) {
    this.merger = new MP.Merger( 
      this.chain,
      colorTexture, 
      gl, 
      { channels: [ depthTexture, null ] }
    )
  }, 

  run( time ) {
    merger.draw( time )
  },

  post( ...fx ) {
    //FX.chain = fx.map( v => v.__wrapped__ )
    FX.chain.length = 0

    fx.forEach( v => {
      if( Array.isArray( v.__wrapped__ ) ) {
        v.__wrapped__.forEach( w => FX.chain.push( w ) )
      }else{
        FX.chain.push( v.__wrapped__ )
      }
    })
  },

  export( obj ) {
    obj.Antialias  = FX.Antialias
    obj.Blur       = FX.Blur
    obj.Bloom      = FX.Bloom
    obj.Brightness = FX.Brightness
    obj.Contrast   = FX.Contrast
    obj.Edge       = FX.Edge
    obj.Focus      = FX.Focus
    obj.Glow       = FX.Glow
    obj.Godrays    = FX.Godrays
    obj.Hue        = FX.Hue
    obj.Invert     = FX.Invert
    obj.MotionBlur = FX.MotionBlur
  },

  wrapProperty( obj, name, __value, transform=null ) {
    __value = transform === null ? __value : transform( __value )
    const primitive = MP.float( MP.mut( __value ) )
    
    let value = __value 
    Object.defineProperty( obj, name, {
      get() { return value },
      set(v) {
        value = transform === null ? v : transform( v )
        primitive.setVal( value )
      }
    })

    return primitive
  },

  Bloom( __threshold=0, __boost=.01 ) {
    const fx = {},
          threshold  = FX.wrapProperty( fx, 'threshold',  __threshold ),
          boost      = FX.wrapProperty( fx, 'amount', __boost ) 

    fx.__wrapped__ = MP.bloom( threshold, boost ) 

    return fx
  },

  Blur( amount=3, reps=2, taps=5 ) {
    const fx = {}

    const __amount = FX.wrapProperty( fx, 'amount', amount )
    fx.__wrapped__ = MP.blur2d( __amount, __amount, reps, taps )

    return fx 
  },

  Brightness( __amount=.25 ) {
    const fx = {},
          amount = FX.wrapProperty( fx, 'amount', __amount )

    fx.__wrapped__ = MP.brightness( amount )

    return fx
  },

  Contrast( __amount=.5 ) {
    const fx = {},
          amount = FX.wrapProperty( fx, 'amount', __amount )

    fx.__wrapped__ = MP.contrast( amount )

    return fx
  },

  Edge() {
    const fx = {}
    fx.__wrapped__ = MP.sobel()

    return fx 
  },

  Focus( __depth=0, __radius=.01 ) {
    const fx = {},
          depth  = FX.wrapProperty( fx, 'depth',  __depth, v => 1 - v ),
          radius = FX.wrapProperty( fx, 'radius', __radius ) 

    fx.__wrapped__ = MP.dof( depth, radius ) 

    return fx
  },

  Glow( __contrast=1.2, __brightness = .15, __blur=1, __adjust=-.5, loops=5 ) {
    const fx = {},
          contrast   = FX.wrapProperty( fx, 'contrast', __contrast ),
          brightness = FX.wrapProperty( fx, 'brightness', __brightness ),
          blur       = FX.wrapProperty( fx, 'blur', __blur ),
          adjust     = FX.wrapProperty( fx, 'adjust', __adjust )

    fx.__wrapped__ = [  
      MP.loop([
        MP.gauss(MP.vec2(blur, 0)),
        MP.gauss(MP.vec2(0, blur)),
        MP.brightness( brightness ),
        MP.contrast( contrast),
      ], loops ),
      MP.brightness( adjust ),
      MP.setcolor( MP.op( MP.fcolor(), "+", MP.input() ) )
    ]

    return fx
  },


  Godrays( __decay=1, __weight=.01, __density=1, __threshold=.9, __newColor=[.5,.15,0,1] ) {
    const fx = {},
          decay   = FX.wrapProperty( fx, 'decay',   __decay   ),
          weight  = FX.wrapProperty( fx, 'weight',  __weight  ),
          density = FX.wrapProperty( fx, 'density', __density ),
          threshold = FX.wrapProperty( fx, 'threshold', __threshold, v => 1 - v )

    const newColor = MP.mut( MP.pvec4( ...__newColor ) )
    
    let value = __newColor 
    Object.defineProperty( fx, 'color', {
      get() { return value },
      set(v) {
        value = Array.isArray(v) ? v : [v,v,v,v]
        fx.__wrapped__.setNewColor( MP.pvec4( ...value ) )
      }
    })


    fx.__wrapped__ = MP.godrays({ 
      decay, weight, density,

      convertDepth: {                 
        threshold,                 
        newColor
      }
    })

    return fx
  },

  Hue( __shift=.5, __threshold = .99 )  {
    const fx = {},
          frag = MP.fcolor(), 
          depth = MP.channel(0),
          threshold = FX.wrapProperty( fx, 'threshold', __threshold, v => 1 - v ),
          shift= FX.wrapProperty( fx, 'shift', __shift )

    let control
    fx.__wrapped__ = MP.hsv2rgb( 
      MP.changecomp(
        MP.rgb2hsv( MP.fcolor() ),
        MP.cfloat( MP.tag `length(${depth}.rgb) >= ${threshold} ? ${shift} : 0.`  ),
        "r", 
        "+"
      )
    )

    return fx
  },

  Invert( __threshold = .99 )  {
    const fx = {},
          frag = MP.fcolor(), 
          depth = MP.channel(0),
          threshold = FX.wrapProperty( fx, 'threshold', __threshold, v => 1 - v )

    fx.__wrapped__ = MP.setcolor( 
      MP.cvec4( MP.tag `length(${depth}.rgb) >= ${threshold} ? (1. - vec4(${frag}.rgb, 0.)) : ${frag}`  )
    ) 

    return fx
  },

  MotionBlur( __amount = .7) {
    const fx = {},
          amount = FX.wrapProperty( fx, 'amount', __amount, v => 1-v )

    fx.__wrapped__ = MP.motionblur( 1, amount ) 

    return fx
  },

  Antialias( mult=1 ) {
    return { __wrapped: MP.loop([ MP.fxaa() ], mult ) }
  },

}

module.exports = FX

},{"@bandaloo/merge-pass":204}],18:[function(require,module,exports){
const glsl = require( 'glslify' )
const SceneNode = require( './sceneNode.js' )
const { param_wrap, MaterialID } = require( './utils.js' )
const { Var, float_var_gen, vec2_var_gen, vec3_var_gen, vec4_var_gen } = require( './var.js' )

const getNoise = function( SDF ) {
Noise = function( strength=.25, bias=1, timeMod=1 ) {
  const op = Object.create( Noise.prototype )
  op.type = 'string'
  op.isGen = true

  const defaultValues = [.5,.5,.5]

  op.matId = MaterialID.alloc()

  const __strength = param_wrap( strength, float_var_gen( strength ) )
  const __timeMod  = param_wrap( timeMod, float_var_gen( timeMod ) )

  Object.defineProperty( op, 'strength', {
    get() { return __strength },
    set(v) {
     __strength.var.set( v )
    }
  })
  Object.defineProperty( op, 'timeMod', {
    get() { return __timeMod },
    set(v) {
     __timeMod.var.set( v )
    }
  })
  const __bias  = param_wrap( bias, float_var_gen( bias ) )

  Object.defineProperty( op, 'bias', {
    get() { return __bias},
    set(v) {
     __bias.var.set( v )
    }
  })
  return op
} 

Noise.prototype = SceneNode()

Noise.prototype.emit = function ( __name ) {
  let name = __name === undefined ? 'p' : __name

  const out = `(${this.bias.emit()} + snoise( vec4( p.xyz, time * ${this.timeMod.emit()} )) * ${this.strength.emit()})`  

  const output = {
    out,
    preface:''
  }

  return output
}
Noise.prototype.glsl = glsl(["#define GLSLIFY 1\n    //\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nfloat mod289(float x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat permute(float x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat taylorInvSqrt(float r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 grad4(float j, vec4 ip)\n  {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n\n  return p;\n  }\n\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\n\nfloat snoise(vec4 v)\n  {\n  const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                        0.276393202250021,  // 2 * G4\n                        0.414589803375032,  // 3 * G4\n                       -0.447213595499958); // -1 + 4 * G4\n\n// First corner\n  vec4 i  = floor(v + dot(v, vec4(F4)) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n//  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n  //  x1 = x0 - i1  + 1.0 * C.xxxx\n  //  x2 = x0 - i2  + 2.0 * C.xxxx\n  //  x3 = x0 - i3  + 3.0 * C.xxxx\n  //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n  vec4 x1 = x0 - i1 + C.xxxx;\n  vec4 x2 = x0 - i2 + C.yyyy;\n  vec4 x3 = x0 - i3 + C.zzzz;\n  vec4 x4 = x0 + C.wwww;\n\n// Permutations\n  i = mod289(i);\n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n  }\n\n"])

Noise.prototype.emit_decl = function () {
  let str = this.strength.emit_decl() + this.timeMod.emit_decl() + this.bias.emit_decl()

  if( SDF.memo.noise === undefined ) {
    str = Noise.prototype.glsl + str
    SDF.memo.noise = true
  }

  return str
};

Noise.prototype.update_location = function(gl, program) {
  this.strength.update_location( gl, program )
  this.timeMod.update_location( gl, program )
  this.bias.update_location( gl, program )
}

Noise.prototype.upload_data = function(gl) {
  this.strength.upload_data( gl )
  this.timeMod.upload_data( gl )
  this.bias.upload_data( gl )
}

return Noise

}

module.exports = getNoise 

},{"./sceneNode.js":23,"./utils.js":28,"./var.js":29,"glslify":121}],19:[function(require,module,exports){
const glsl = require( 'glslify' )

module.exports = {
  Box: {
    parameters:[
      { name:'size', type:'vec3', default:[1,1,1], min:.001, max:5 },
    ],

    primitiveString( pName ) { 
	    return `sdBox( ${pName}, ${this.size.emit()} )`;
    },

    glslify:glsl(["#define GLSLIFY 1\n    float sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n"])
  }, 

  // XXX we should normalize dimensions in the shader... 
  Cone: {
    parameters:[
      { name:'dimensions', type:'vec3', default:[.8,.6,.3], min:.001, max:5 },
    ],

    primitiveString( pName ) { 
      return `sdCone( ${pName}, ${this.dimensions.emit()} )`
    },
    glslify:glsl(["#define GLSLIFY 1\n    float sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -p.y-c.z;\n    float d2 = max( dot(q,c.xy), p.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n"])
  }, 

	Cylinder: {
    parameters:[
      { name:'dimensions', type:'vec2', default:[.8,.6], min:.001, max:5 },
    ],

    primitiveString( pName ) { 
      return `sdCappedCylinder( ${pName}, ${this.dimensions.emit()} )`
    },

    glslify:`    float sdCappedCylinder( vec3 p, vec2 h ) {
    vec2 d = abs(vec2(length(p.xz),p.y)) - h;
    return min(max(d.x,d.y),0.0) + length(max(d,0.0));
  }`
  }, 

  Capsule: {	
    parameters:[
      { name:'start', type:'vec3', default:[0,0,0], min:0, max:.5 },
      { name:'end', type:'vec3', default:[.8,1,0], min:.5, max:1 },
      { name:'radius', type:'float', default:.5, min:.001, max:5 },
    ],

    primitiveString( pName ) { 
      return `sdCapsule( ${pName}, ${this.start.emit()}, ${this.end.emit()}, ${this.radius.emit()} )`
    },
    glslify:glsl(["#define GLSLIFY 1\n      float sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\n"])

  },

  // XXX No cylinder description
  //` #pragma glslify: sdCylinder	= require('glsl-sdf-primitives/sdCylinder')`
 	HexPrism: {
    parameters:[
      { name:'dimensions', type:'vec2', default:[.8,.6], min:.001, max:5 },
    ],

    primitiveString( pName ) { 
      return `sdHexPrism( ${pName}, ${this.dimensions.emit()} )`
    },
    glslify:glsl(["#define GLSLIFY 1\n      float sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\n"])
  },

  Julia: {
    parameters:[
      { name:'fold', type:'float', default:0, min:0, max:10 },
    ],

    primitiveString( pName ) { 
      return `julia( ${pName}, ${this.fold.emit()} )`
    },

    // https://www.shadertoy.com/view/MsfGRr
    glslify:glsl(["#define GLSLIFY 1\n  vec4 qsqr( in vec4 a ) {\n    return vec4( a.x*a.x - a.y*a.y - a.z*a.z - a.w*a.w,\n                 2.0*a.x*a.y,\n                 2.0*a.x*a.z,\n                 2.0*a.x*a.w );\n  }\n\n  float julia( in vec3 p, float atime ){\n    vec4 c = 0.45*cos( vec4(0.5,3.9,1.4,1.1) + atime * vec4(1.2,1.7,1.3,2.5) ) - vec4(0.3,0.0,0.0,0.0);\n    vec4 z = vec4(p,0.);\n    float md2 = 1.0;\n    float mz2 = dot(z,z);\n\n    for( int i=0; i<11; i++ ){\n      md2 *= 4.0*mz2;   \n      // dz -> 2zdz, meaning |dz| -> 2|z||dz| (can take the 4 out of the loop and do an exp2() afterwards)\n      z = qsqr(z) + c;  // z  -> z^2 + c\n\n      mz2 = dot(z,z);\n      if(mz2>4.0) break;\n    }\n    \n    return 0.25*sqrt(mz2/md2)*log(mz2);  // d = 0.5|z|log|z| / |dz|\n  }",""]),
  },
  KIFS: {
    parameters:[
      { name:'count', type:'float', default:8 },
      { name:'fold', type:'float', default:0 },
      { name:'radius', type:'float', default:.01 },
      { name:'threshold', type:'float', default:.004 },
      { name:'scale', type:'float', default:2 },
    ],

    primitiveString( pName ) { 
      return `kifs( ${pName}, ${this.count.emit()}, ${this.fold.emit()}, ${this.radius.emit()}, ${this.threshold.emit()}, ${this.scale.emit()} )`
    },

    // adapted from http://roy.red/folding-the-koch-snowflake-.html
    glslify:glsl(["#define GLSLIFY 1\n      float box( vec3 p, vec3 b ){\n      vec3 d = abs(p) - b;\n      return min(max(d.x,max(d.y,d.z)),0.0) +\n             length(max(d,0.0));\n    }\n    vec2 fold(vec2 p, float ang){    \n        vec2 n=vec2(cos(-ang),sin(-ang));\n        p-=2.*min(0.,dot(p,n))*n;\n        return p;\n    }\n    #define KPI 3.14159\n    vec3 tri_fold(vec3 pt, float foldamt) {\n        pt.xy = fold(pt.xy,KPI/3. + foldamt );\n        pt.xy = fold(pt.xy,-KPI/3. + foldamt );\n        pt.yz = fold(pt.yz,KPI/6.+.7 + foldamt );\n        pt.yz = fold(pt.yz,-KPI/6. + foldamt );\n        return pt;\n    }\n    vec3 tri_curve(vec3 pt, float iter, float fold, float scale ) {\n        int count = int(iter);\n        for(int i=0;i<count;i++){\n            pt*=scale;\n            pt.x-=2.6;\n            pt=tri_fold(pt,fold);\n        }\n        return pt;\n    }\n    float kifs(in vec3 p, float a, float fold, float radius, float thresh, float scale ){\n        p.x+=1.5;\n        p=tri_curve(p,a,fold,scale);\n        // uncomment below line to use spheres instead of boxes\n        return (length( p*thresh ) - radius );\n        //return box( p*thresh, vec3(radius) );\n    }\n",""]),
  },

  Mandalay: {
    parameters:[
      { name:'size', type:'float', default:5, min:1, max:10 },
      { name:'minrad', type:'float', default:1/3, min:0, max:1 },    
      { name:'iterations', type:'float', default:5, min:1, max:10, step:1 },    
    ],
    glslify:`                 
  float sr = 4.0;
  vec3 fo =vec3 (0.7,.9528,.9);
  vec3 gh = vec3 (.8,.7,0.5638);
  vec3 gw = vec3 (.3, 0.5 ,.2);
  vec4 X = vec4( .1,0.5,0.1,.3);
  vec4 Y = vec4(.1, 0.8, .1, .1);
  vec4 Z = vec4(.2,0.2,.2,.45902);
  vec4 R = vec4(0.19,.1,.1,.2);
  vec4 orbitTrap = vec4(40000.0);
  float DBFold( vec3 p, float fo, float g, float w ){
      if(p.z>p.y) p.yz=p.zy;
      float vx=p.x-2.*fo;
      float vy=p.y-4.*fo;
      float v=max(abs(vx+fo)-fo,vy);
      float v1=max(vx-g,p.y-w);
      v=min(v,v1);
      v1=max(v1,-abs(p.x));
      return min(v,p.x);
  }
   
  vec3 DBFoldParallel(vec3 p, vec3 fo, vec3 g, vec3 w){
    vec3 p1=p;
    p.x=DBFold(p1,fo.x,g.x,w.x);
    p.y=DBFold(p1.yzx,fo.y,g.y,w.y);
    p.z=DBFold(p1.zxy,fo.z,g.z,w.z);
    return p;
  }

  vec3 DBFoldSerial(vec3 p, vec3 fo, vec3 g,vec3 w){
    p.x=DBFold(p,fo.x,g.x,w.x);
    p.y=DBFold(p.yzx,fo.y,g.y,w.y);
    p.z=DBFold(p.zxy,fo.z,g.z,w.z);
    return p;
  }
  float sineSponge(vec3 p, float scale, float minrad, float iterations ) {
    vec4 JC=vec4(p,1.);
    float r2=dot(p,p);
    float dd = 1.;
    for(int i = 0; i<int(iterations); i++){
      p = p - clamp(p.xyz, -1.0, 1.0) * 2.0;  // mandelbox's box fold
   
      vec3 signs=sign(p);//Save 	the original signs
      p=abs(p);
      p=DBFoldParallel(p,fo,gh,gw);
      
      p*=signs;//resore signs: this way the mandelbrot set won't extend in negative directions
      

      r2=dot(p,p);
      float  t = clamp(1./r2, 1., 1./minrad);
      p*=t; dd*=t;
       

      p=p*scale+JC.xyz; dd=dd*scale+JC.w;
      p=vec3(1.0,1.0,.92)*p;
   
      r2=dot(p,p);
      orbitTrap = min(orbitTrap, abs(vec4(p.x,p.y,p.z,r2)));	
    }
    dd=abs(dd);
      #if 0
        return (sqrt(r2)-sr)/dd;//bounding volume is a sphere
      #else
        p=abs(p); return (max(p.x,max(p.y,p.z))-sr)/dd;//bounding volume is a cube
      #endif
    }
    `,
   
    primitiveString( pName ) { 
      return `sineSponge( ${pName}, ${this.size.emit()}, ${this.minrad.emit()}, ${this.iterations.emit()} )`
    }
  },  
  Mandelbulb: {
    parameters:[
      { name:'fold', type:'float', default:8, min:1, max:15 },
      { name:'iterations', type:'float', default:4, min:1, max:6, step:1 },    
    ],

    primitiveString( pName ) { 
      return `mandelbulb( ${pName}, ${this.fold.emit()}, ${this.iterations.emit()} )`
    },

    // adapted from: https://www.shadertoy.com/view/ltfSWn
    glslify:glsl(["#define GLSLIFY 1\n      float mandelbulb( in vec3 p, in float aa, float iterations ){\n        vec3 w = p;\n        float m = dot(w,w);\n\n        vec4 trap = vec4(abs(w),m);\n        float dz = 1.0;\n                \n        for( int i=0; i<int(iterations); i++ ) {\n          dz = aa*pow(sqrt(m),aa - 1.)*dz + 1.0;\n\n          float r = length(w);\n          float b = aa*acos( w.y /r);\n          float a = aa*atan( w.x, w.z );\n          w = p + pow(r,aa) * vec3( sin(b)*sin(a), cos(b), sin(b)*cos(a) );\n\n          trap = min( trap, vec4(abs(w),m) );\n\n          m = dot(w,w);\n          if( m > 256.0 ) {\n            break;\n          }\n        }\n\n        return 0.25*log(m)*sqrt(m)/dz;\n      }\n    ",""]),
  },

  // adapted from https://www.shadertoy.com/view/llGXDR
  Mandelbox: {
    parameters:[
      { name:'fold', type:'float', default:.1 },
      { name:'scale', type:'float', default:3., min:1, max:10 },
      { name:'iterations', type:'float', default:5, min:1, max:10, step:1 },
    ],

    glslify:`float mandelbox( float MR2, float SCALE, float ITER, vec3 position ){
      vec4 scalevec = vec4(SCALE, SCALE, SCALE, abs(SCALE)) / MR2;
      float C1 = abs(SCALE-1.0), C2 = pow(abs(SCALE), 1.-ITER); // 10 is ITERS
      vec4 p = vec4(position.xyz, 1.0), p0 = vec4(position.xyz, 1.0);  // p.w is knighty's DEfactor
      for (int i=0; i<int(ITER); i++) {
        p.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;  // box fold: min3, max3gg, mad3
        float r2 = dot(p.xyz, p.xyz);  // dp3
        p.xyzw *= clamp(max(MR2/r2, MR2), 0.0, 1.0);  // sphere fold: div1, max1.sat, mul4
        p.xyzw = p*scalevec + p0;  // mad4
      }
      return (length(p.xyz) - C1) / p.w - C2;
  }`,

    primitiveString( pName ) {
      return `mandelbox( ${this.fold.emit()}, ${this.scale.emit()}, ${this.iterations.emit()}, ${pName} )`
    }
  },

	Octahedron: {
    parameters:[
      { name:'radius', type:'float', default:1, min:0, max:4 },
    ],

    primitiveString( pName ) { 
      return `sdOctahedron( ${pName}, ${this.radius.emit()} )`
    },

    glslify:`    float sdOctahedron(vec3 p, float h) {
    p.y = p.y + h; // center vertically... is it centered on the z-axis?
    vec2 d = .5*(abs(p.xz)+p.y) - min(h,p.y);
    return length(max(d,0.)) + min(max(d.x,d.y), 0.);
  }`
  }, 

 	Plane: {
    parameters:[
      { name:'normal', type:'vec3', default:[0,1,0], min:0, max:1 },
      { name:'distance', type:'float', default:1, min:0, max:5 },
    ],

    primitiveString( pName ) { 
      return `sdPlane( ${pName}, vec4( ${this.normal.emit()}, ${this.distance.emit()} ))`
    },
    
    glslify:glsl(["#define GLSLIFY 1\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n"])
    
  },  
 	Quad: {
    parameters:[
      { name:'v1', type:'vec3', default:[-.5,-.5,0] },
      { name:'v2', type:'vec3', default:[.5,-.5,0] },
      { name:'v3', type:'vec3', default:[.5,.5,0] },
      { name:'v4', type:'vec3', default:[-.5,.5,0] },
    ],

    primitiveString( pName ) { 
      return `udQuad( ${pName}, ${this.v1.emit()}, ${this.v2.emit()}, ${this.v3.emit()}, ${this.v4.emit()} )`
    },
    glslify:glsl(["#define GLSLIFY 1\n    float dot2( in vec3 v ) { return dot(v,v); }\nfloat udQuad( vec3 p, vec3 a, vec3 b, vec3 c, vec3 d )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 dc = d - c; vec3 pc = p - c;\n    vec3 ad = a - d; vec3 pd = p - d;\n    vec3 nor = cross( ba, ad );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(dc,nor),pc)) +\n     sign(dot(cross(ad,nor),pd))<3.0)\n     ?\n     min( min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(dc*clamp(dot(dc,pc)/dot2(dc),0.0,1.0)-pc) ),\n     dot2(ad*clamp(dot(ad,pd)/dot2(ad),0.0,1.0)-pd) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n"])
  }, 

  RoundBox: {
    parameters:[
      { name:'size', type:'vec3', default:[1,1,1], min:0, max:3 },
      { name:'radius', type:'float', default:1, min:0, max:3 },
    ],

    primitiveString( pName ) { 
      return `udRoundBox( ${pName}, ${this.size.emit()},  ${this.radius.emit()} )`
    }, 
    glslify:glsl(["#define GLSLIFY 1\n    float udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\n"])
  }, 
  Sphere:{
    parameters:[
      { name:'radius', type:'float', default:1, min:0, max:3 },
    ],

    primitiveString( pName ) { 
      return `(length(${pName}) - ${this.radius.emit()})`
    },
    glslify:glsl(["#define GLSLIFY 1\n    float sdSphere( vec3 p, float s )\n{\n  return length( p ) - s;\n}\n\n"])
  },
  // phi, m, n1, n2, n3, a, b
  SuperFormula:{
    parameters:[
      { name:'m_1', type:'float',  default:1, min:-Math.PI*4, max:Math.PI*4 },
      { name:'n1_1', type:'float', default:1, min:-Math.PI*4, max:Math.PI*4 },
      { name:'n2_1', type:'float', default:1, min:-Math.PI*4, max:Math.PI*4 },
      { name:'n3_1', type:'float', default:1, min:-Math.PI*4, max:Math.PI*4 },
      { name:'a_1', type:'float',  default:1, min:-Math.PI*4, max:Math.PI*4 },
      { name:'b_1', type:'float',  default:1, min:-Math.PI*4, max:Math.PI*4 },
      { name:'m_2', type:'float',  default:1, min:-Math.PI*4, max:Math.PI*4 },
      { name:'n1_2', type:'float', default:1, min:-Math.PI*4, max:Math.PI*4 },
      { name:'n2_2', type:'float', default:1, min:-Math.PI*4, max:Math.PI*4 },
      { name:'n3_2', type:'float', default:1, min:-Math.PI*4, max:Math.PI*4 },
      { name:'a_2', type:'float',  default:1, min:-Math.PI*4, max:Math.PI*4 },
      { name:'b_2', type:'float',  default:1, min:-Math.PI*4, max:Math.PI*4 },
    ],

    primitiveString( pName ) { 
      return `superformula( ${pName}, ${this.m_1.emit()}, ${this.n1_1.emit()},${this.n2_1.emit()},${this.n3_1.emit()},${this.a_1.emit()},${this.b_1.emit()}, ${this.m_2.emit()}, ${this.n1_2.emit()},${this.n2_2.emit()},${this.n3_2.emit()},${this.a_2.emit()},${this.b_2.emit()} )`
    },
    glslify:glsl(["#define GLSLIFY 1\n    float SuperFormula( float phi, float m, float n1, float n2, float n3, float a, float b ){\n\t\n\tfloat t1 = abs((1.0 / a) * cos(m * phi / 4.0));\n\tt1 = pow(t1, n2);\n\n\tfloat t2 = abs((a / b) * sin(m * phi / 4.0));\n\tt2 = pow(t2, n3);\n\n\tfloat t3 = t1 + t2;\n\n\tfloat r = pow(t3, -1.0 / n1);\n\n\treturn r;\n}\n\n float superformula( vec3 p, float m_1, float n1_1, float n2_1, float n3_1, float a_1, float b_1, float m_2, float n1_2, float n2_2, float n3_2, float a_2, float b_2 ) {\n    float d = length( p );\n    float theta = atan(p.y, p.x);\n    float phi = d == 0. ? 0. : asin(p.z / d);\n    float r1 = SuperFormula( theta, m_1, n1_1, n2_1, n3_1, a_1, b_1 );\n    float r2 = SuperFormula( phi, m_2, n1_2, n2_2, n3_2, a_2, b_2 );\n    vec3 q = r2 * vec3(r1 * cos(theta) * cos(phi), r1 * sin(theta) * cos(phi), sin(phi));\n    d = d - length(q);\n\n    return d;\n  }    \n",""]) },
 
  Torus:{
    parameters:[
      { name:'radii',  type:'vec2', default:[.5,.1], min:0, max:3 },
    ],

    primitiveString( pname ) { 
      return `sdTorus( ${pname}, ${this.radii.emit()} )`
    },
    glslify:glsl(["#define GLSLIFY 1\n    float sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n"])

  },  
  Torus88:{
    parameters:[
      { name:'radii',  type:'vec2', default:[.5,.1], min:0, max:3 },
    ],

    primitiveString( pname ) { 
      return `sdTorus88( ${pname}, ${this.radii.emit()} )`
    },
    glslify:`float sdTorus88( vec3 p, vec2 t ) {
        vec2 q = vec2( length8( p.xz ) - t.x, p.y );
        return length8( q ) - t.y;
      }\n`,
  },
  Torus82:{
    parameters:[
      { name:'radii',  type:'vec2', default:[.5,.1], min:0, max:3 },
    ],

    primitiveString( pname ) { 
      return `sdTorus82( ${pname}, ${this.radii.emit()} )`
    },
    glslify:`float sdTorus82( vec3 p, vec2 t ) {
        vec2 q = vec2( length( p.xz ) - t.x, p.y );
        return length8( q ) - t.y;
      }\n`
  },
 	Triangle: {
    parameters:[
      { name:'v1', type:'vec3', default:[0,-.5,0] },
      { name:'v2', type:'vec3', default:[-.5,.0,0] },
      { name:'v3', type:'vec3', default:[.5,.0,0] },
    ],

    primitivestring( pname ) { 
      return `udtriangle( ${pname}, ${this.v1.emit()}, ${this.v2.emit()}, ${this.v3.emit()} )`
    },
    glslify:glsl(["#define GLSLIFY 1\n    float dot2( in vec3 v ) { return dot(v,v); }\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n"])
  }, 

  TriPrism: {
    parameters:[
      { name:'dimensions', type:'vec2', default:[.5,.5], min:0, max:3 },
    ],

    primitiveString( pName ) { 
      return `sdTriPrism( ${pName}, ${this.dimensions.emit()})`
    },
    glslify:glsl(["#define GLSLIFY 1\n      float sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\n"])

  },

}

},{"glslify":121}],20:[function(require,module,exports){
const { Var, float_var_gen, vec2_var_gen, vec3_var_gen, vec4_var_gen, int_var_gen, VarAlloc }  = require( './var.js' )
const SceneNode = require( './sceneNode.js' )
const { param_wrap, MaterialID } = require( './utils.js' )
const { Vec2, Vec3, Vec4 } = require( './vec.js' )
const Transform = require( './transform.js' )

const createPrimitives = function( SDF ) {

  const gens = { 
    int:   int_var_gen,
    float: float_var_gen,
    vec2: vec2_var_gen,
    vec3: vec3_var_gen,
    vec4: vec4_var_gen,
  }

  const vars = { 
    vec2: Vec2,
    vec3: Vec3,
    vec4: Vec4
  }

  // load descriptions of all primtives
  const descriptions = require( './primitiveDescriptions.js' )

  const Primitives = { 
    descriptions,

    textureMemo: [],

    emit_geometries() {
      const head = Array.isArray( SDF.__scene.__prerender ) ? SDF.__scene.__prerender[0] : SDF.__scene.__prerender
      const geos = Primitives.crawlNode( head, [] )

      geos.forEach( (geo,i) => {
        geo.__sdfID = i 
        if( geo.__textureObj !== undefined ) {
          SDF.textures.addTexture( geo.__textureObj )
        }
      })

      const length = geos.length
      const materials = SDF.materials.materials

      let decl = `SDF sdfs[${length}] = SDF[${length}](\n`
      geos.forEach( (geo, i) => {
        const textureID = geo.__textureObj === undefined ? 50000 : geo.__textureObj.id
        const hasRepeat = geo.repeat !== null && geo.repeat !== undefined
        decl += `        SDF( ${materials.indexOf( geo.__material )}, ${geo.transform.varName}, ${textureID}, ${hasRepeat ? geo.repeat.distance.emit() : 'vec3(0.)'}, ${hasRepeat ? geo.repeat.transform.emit() : `mat4(1.)`} )`
        if( i < geos.length - 1 ) decl += ','
        decl += '\n'
      })

      decl += `      );\n`

      this.geometries = geos

      return decl
    },

    crawlNode( node, arr ) {
      if( node.type === 'geometry' ) {
        arr.push( node )
      }else{
        if( node.a !== undefined ) Primitives.crawlNode( node.a, arr )
        if( node.b !== undefined ) Primitives.crawlNode( node.b, arr )
        if( node.sdf !== undefined ) Primitives.crawlNode( node.sdf, arr )
      }

      return arr
    }
  }

  const createPrimitive = function( name, desc ) {

    const params = desc.parameters
    // create constructor
    Primitives[ name ] = function( ...args ) {
      const p = Object.create( Primitives[ name ].prototype )
      p.params = params
      p.transform = Transform()
      p.transform.shouldInvert = true
      p.type = 'geometry'
      p.name = name
      p.repeat = null//Var( vars.vec3( 0 ), null, 'vec3' )

      p.__material = null
      p.__textureID  = 500000
      
      let count = 0

      // wrap each param in a Var object for codegen
      for( let param of params ) {
        if( param.name === 'color' ) {
          p.color = args[ count ] === undefined ? param.default : args[ count++ ]
          continue
        }
        if( param.type === 'obj' ) {
          let __value = args[ count++ ]
          p[ param.name ] = {
            get value() { return __value },
            set value(v){ __value = v },
            emit() {
              const output =  p[ param.name ].value.emit()
              return output
            },
            emit_decl() {
              return p[ param.name ].value.a.emit_decl() + p[param.name].value.b.emit_decl()
            }
          }
          continue
        }
        const defaultValues = param.default
        const isArray = Array.isArray( defaultValues )

        if( isArray ) {
          let val = args[ count++ ], __var

          if( typeof val === 'number' ) {
            __var = Var( vars[ param.type ]( val ), null, 'vec3' )
          }else{
            __var =  param_wrap(
              val,
              gens[ param.type ]( ...defaultValues ) 
            )
          }

          // for assigning entire new vectors to property
          Object.defineProperty( p, param.name, {
            configurable:true,
            get() { return __var },
            set(v) {
              if( typeof v === 'object' ) {
                __var.set( v )
              }else{
                __var.value.x = v
                __var.value.y = v
                __var.value.z = v
                __var.value.w = v
                __var.dirty = true
              }
            }
          })

        }else{
          let __var  = param_wrap( 
            args[ count++ ], 
            gens[ param.type ]( defaultValues ) 
          )

          //__var.set( defaultValues )
          Object.defineProperty( p, param.name, {
            configurable:true,
            get() { return __var },
            set(v) {
              __var.set( v )
            }
          })
        }
      }

      p.id = VarAlloc.alloc()

      p.__desc = desc
      p.__setMaterial = function(mat) {
        if( typeof mat === 'string' ) mat = SDF.Material[ mat ]
        this.__material = this.mat = SDF.materials.addMaterial( mat )
      }

      p.__setTexture = function(tex,props) {
        if( typeof tex === 'string' ) {
          this.texture = p.texture.bind( this )
          this.__textureObj = this.tex = SDF.Texture( tex,props,this.texture )
          this.__textureID = this.__textureObj.id
        }else{
          this.__textureObj = this.tex = Object.assign( tex, props )
          this.__textureID = this.__textureObj.id
        }
      }
      p.__setBump = function(tex,props) {
        //this.bump = p.bump.bind( this )
        const b = this.bump = this.__bumpObj = SDF.Bump( this, tex, props )
        this.bump.texture = this.bump.amount.value
        this.__bumpID = this.__bumpObj.id
        this.rotate = this.bump.rotate
        this.translate = this.bump.translate
        this.scale = this.bump.scale
        Object.defineProperty( this.bump, 'strength', {
          get() { return b.size },
          set(v){ b.size = v }
        })
      }

      Object.assign( p, {
        renderingBump : false,
        emittingDecl  : false,
        uploading     : false,
        updating      : false
      })

      if( p.__material === null ) p.__setMaterial()

      SDF.geometries.push( p )

      return p
    }

    // define prototype to use
    Primitives[ name ].prototype = SceneNode()
    Primitives[ name ].prototype.type = 'geometry'
    
    // create codegen string


    Primitives[ name ].prototype.emit = function ( __name, transform = null, bump=null, scale=null ) {
      if( SDF.memo[ this.id ] !== undefined ) return { preface:'', out:name+this.matId }
      if( this.__bumpObj !== undefined && this.renderingBump === false) {
        this.renderingBump = true
        return this.__bumpObj.emit( __name, transform )
      }
      
      const shaderCode = desc.glslify.indexOf('#') > -1 
        ? desc.glslify.slice(18) 
        : desc.glslify

      if( SDF.requiredGeometries.indexOf( shaderCode ) === - 1 ) {
        SDF.requiredGeometries.push( shaderCode )
      } 

      if( transform !== null ) this.transform.apply( transform, false )
      //this.transform.invert( true )
      this.transform.internal()

      const pname = typeof __name !== 'string' ? 'p' : __name,
            id = this.__sdfID,
            s = scale === null ? this.transform.emit_scale() : `${this.transform.emit_scale()} * ${scale}`,
            tstring = `( ${pname} * ${this.transform.emit()} ).xyz`
      
      const primitive = `
        vec2 ${name}${this.id} = vec2( ${desc.primitiveString.call( this, tstring, bump )} * ${s}, ${id}.);
      `
      SDF.memo[ this.id ] = name + this.id

      this.renderingBump = false
      return { preface:primitive, out:name+this.id  }
    }
    
    // declare any uniform variables
    Primitives[ name ].prototype.emit_decl = function() {
      if( this.__bumpObj !== undefined && this.emittingDecl === false) {
        this.emittingDecl = true
        return this.__bumpObj.emit_decl() 
      }
      let decl = ''
      decl += this.transform.emit_decl()

      //debugger
      if( this.__repeat !== undefined ) decl += this.__repeat.emit_decl( false )
      if( this.__polarRepeat !== undefined ) decl += this.__polarRepeat.emit_decl( false )

      for( let param of params ) {
        if( param.name !== 'material' )
          decl += this[ param.name ].emit_decl( )
      }

      this.emittingDecl = false
      return decl
    }

    Primitives[ name ].prototype.update_location = function( gl, program ) {
      if( this.__bumpObj !== undefined && this.updating === false) {
        this.updating = true
        return this.__bumpObj.update_location( gl, program )
      }

      for( let param of params ) {
        if( param.type !== 'obj' ) {
          if( param.name !== 'material' ) 
            this[ param.name ].update_location( gl,program )
        }
      }

      if( this.__repeat !== undefined ) this.__repeat.update_location( gl, program, false )
      if( this.__polarRepeat !== undefined ) this.__polarRepeat.update_location( gl, program, false )
      this.transform.update_location( gl, program )
      this.updating = false
    }

    Primitives[ name ].prototype.upload_data = function( gl ) {
      if( this.__bumpObj !== undefined && this.uploading  === false ) {
        this.uploading = true
        return this.__bumpObj.upload_data( gl )
      }
      for( let param of params ) {
        if( param.type !== 'obj' && param.name !== 'material' )
          this[ param.name ].upload_data( gl )
      }

      if( this.__polarRepeat !== undefined ) this.__polarRepeat.upload_data( gl, false )
      this.transform.upload_data( gl )
      this.uploading = false
    }
    
    return Primitives[ name ]
  }
  
  for( let name in descriptions ) {
    const desc = descriptions[ name ]
    createPrimitive( name, desc )
  }

  Primitives.create = createPrimitive

  return Primitives
}

module.exports = createPrimitives

},{"./primitiveDescriptions.js":19,"./sceneNode.js":23,"./transform.js":27,"./utils.js":28,"./var.js":29,"./vec.js":30}],21:[function(require,module,exports){
const getMainContinuous = function( steps, minDistance, maxDistance, postprocessing ) {
  const out = `
  // adapted from https://www.shadertoy.com/view/ldfSWs
  vec3 calcNormal(vec3 pos, float eps) {
    const vec3 v1 = vec3( 1.0,-1.0,-1.0);
    const vec3 v2 = vec3(-1.0,-1.0, 1.0);
    const vec3 v3 = vec3(-1.0, 1.0,-1.0);
    const vec3 v4 = vec3( 1.0, 1.0, 1.0);

    return normalize( v1 * scene ( pos + v1*eps ).x+
                      v2 * scene ( pos + v2*eps ).x+
                      v3 * scene ( pos + v3*eps ).x+
                      v4 * scene ( pos + v4*eps ).x);
  }

  vec3 calcNormal(vec3 pos) {
    return calcNormal(pos, 0.002);
  }

  // Adapted from from https://www.shadertoy.com/view/ldfSWs
  vec2 calcRayIntersection( vec3 rayOrigin, vec3 rayDir, float maxd, float precis ) {
    float latest = precis * 2.0;
    float dist   = +0.0;
    float type   = -1.0;
    vec2 result;
    vec2 res = vec2(-50000., -1.);;

    for (int i = 0; i < ${steps} ; i++) {
      if (latest < precis || dist > maxd) break;

      result = scene(rayOrigin + rayDir * dist);

      latest = result.x;
      dist  += latest;
    }

    if( dist < maxd ) {
      result.x = dist;
      res = result;
    }

    return res;
  }

  layout(location = 0) out vec4 col;
  layout(location = 1) out vec4 depth;
  void main() {
    vec2 uv = gl_FragCoord.xy / resolution;
    vec2 pos = uv * 2.0 - 1.0;

    // not sure why I need the -y axis but without it
    // everything is flipped using perspective-camera
    pos.x *= ( resolution.x / -resolution.y );

    vec3 color = bg; 
    vec3 ro = camera_pos;
    vec3 rd = normalize( mat3(camera) * vec3( pos, 2. ) ); 
    
    vec2 t = calcRayIntersection( ro, rd, ${maxDistance}, ${minDistance} );

    vec3 samplePos = vec3(100.f);
    //float zdist = 100000.;//vec3(100000.f);
    if( t.x > -0.5 ) {
      samplePos = ro + rd * t.x;
      //zdist = rd.z * t.x;
      vec3 nor = calcNormal( samplePos );

      color = lighting( samplePos, nor, ro, rd, t.y, true ); 
    }

    ${postprocessing}
    
    col = clamp( vec4( color, 1.0 ), 0., 1. );

    float normalizedDepth = t.x / ${maxDistance};  //1. - exp( -t.x );// 1. / (1. + abs(samplePos.z-ro.z) );
    depth = abs(samplePos.z - ro.z ) < ${maxDistance} ? vec4( vec3( 1.-normalizedDepth ), 1. ) : vec4(0.);
  }`

  return out
}

const getMainVoxels = function( steps, postprocessing, voxelSize = .1 ) {
  const out = `
  struct VoxelDistance {
    bvec3 mask;
    vec3  distance;
    float fogCoeff;
    int   id;
  };

  VoxelDistance calcRayIntersection( vec3 rayOrigin, vec3 rayDir ) {
    vec2 result;

    float m = ${voxelSize};
    rayOrigin *= 1./m;
    vec3 mapPos = vec3(floor(rayOrigin));
    vec3 diff = mapPos - rayOrigin;

    vec3 deltaDist = abs(vec3(length(rayDir)) / rayDir);
    vec3 rayStep = vec3(sign(rayDir));
    vec3 sideDist = (sign(rayDir) * diff + (sign(rayDir) * 0.5) + 0.5) * deltaDist; 

    bvec3 mask;
    vec3 d = vec3(-100000.);
    float fogCoeff = 0.;

    for (int i = 0; i < ${Math.round(steps*1/voxelSize)} ; i++) {
      result = scene(mapPos*m);
      if( result.x <= 0. ) {
        d = mapPos*m+result.x;
        break;
      }

      mask = bvec3( lessThanEqual(sideDist.xyz, min(sideDist.yzx, sideDist.zxy)) );
      sideDist += vec3( mask ) * deltaDist; 
      mapPos += vec3(mask) * rayStep;
      fogCoeff += result.x * m;
    }

    VoxelDistance vd = VoxelDistance( mask, d, fogCoeff, int(result.y) );
    return vd;
  }

  out vec4 col;
  void main() {
    vec2 uv = gl_FragCoord.xy / resolution;
    vec2 pos = uv * 2.0 - 1.0;

    // not sure why I need the -y axis but without it
    // everything is flipped using perspective-camera
    pos.x *= ( resolution.x / -resolution.y );
    
    vec3 color = bg; 
    vec3 ro = camera_pos;
    vec3 rd = normalize( mat3(camera) * vec3( pos, 2. ) ); 
                 
    VoxelDistance vd = calcRayIntersection( ro, rd );
    bvec3 mask = vd.mask;
    
    vec3 nor;
    if (mask.x) {
      color = vec3(0.5);
      nor = vec3(1.,0.,0.);
    }
    if (mask.y) {
      color = vec3(1.0);
      nor = vec3(0.,1.,0.);
    }
    if (mask.z) {
      color = vec3(0.75);
      nor = vec3(0.,0.,1.);
    }
    if( vd.distance.x == -100000. ) {
      color = bg;
    }
    
    float modAmount = ${(1./voxelSize).toFixed(1)};
    if( color != bg ) {
      vec3 pos = vd.distance; 
      //vec3 pos = ro + rd * vd.fogCoeff;

      color *= lighting( pos * modAmount, nor, ro, rd, float(vd.id), false ); 
      //color *= lighting( pos, nor, ro, rd, float(vd.id), false ); 
      //color = min(color,1.);
      //color = getTexture( 0, pos );
      
    }
    
    vec2 t = vec2( vd.fogCoeff, vd.id );
  ${postprocessing}; 
    col = vec4( color, 1. ); 
  }`

  return out
}

module.exports = function( variables, scene, preface, geometries, lighting, postprocessing, steps=90, minDistance=.001, maxDistance=20, ops, voxelSize=0 ) {

  const main = voxelSize === 0
    ? getMainContinuous( steps, minDistance, maxDistance, postprocessing ) 
    : getMainVoxels( steps, postprocessing, voxelSize )

    const fs_source = `     #version 300 es
      precision mediump float;

      float PI = 3.141592653589793;



      struct Light {
        vec3 position;
        vec3 color;
        float attenuation;
      };

      int rotationCount = 1;

      mat4 rotations[4] = mat4[4](
        mat4(0.), mat4(0.), mat4(0.), mat4(0.)
      );

      struct Material {
        int  mode;
        vec3 ambient;
        vec3 diffuse;
        vec3 specular;
        float shininess;
        vec3 fresnel;
        int textureID;
      };     

      struct SDF {
        int materialID;
        mat4 transform;
        int textureID;
        vec3 repeat;
        mat4 repeatTransform;
      };

      uniform float time;
      uniform vec2 resolution;
      uniform vec3 camera_pos;
      uniform vec3 camera_normal;
      uniform float camera_rot;
      uniform mat4 camera;

      

      ${variables}

      // must be before geometries!
      float length8( vec2 p ) { 
        return float( pow( pow(p.x,8.)+pow(p.y,8.), 1./8. ) ); 
      }

      ${ops}

      /* GEOMETRIES */
      ${geometries}

      vec2 scene(vec3 p);

      // XXX todo put this in domainOperations.js
      vec3 polarRepeat(vec3 p, float repetitions) {
        float angle = 2.*PI/repetitions;
        float a = atan(p.z, p.x) + angle/2.;
        float r = length(p.xz);
        float c = floor(a/angle);
        a = mod(a,angle) - angle/2.;
        vec3 _p = vec3( cos(a) * r, p.y,  sin(a) * r );
        // For an odd number of repetitions, fix cell index of the cell in -x direction
        // (cell index would be e.g. -5 and 5 in the two halves of the cell):
        if (abs(c) >= (repetitions/2.)) c = abs(c);
        return _p;
      }

      // added k value to glsl-sdf-ops/soft-shadow
      float softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, in float k ){
        float res = 1.0;
        float t = mint;

        for( int i = 0; i < 12; i++ ) {
          float h = scene( ro + rd * t ).x;
          res = min( res, k * h / t );
          t += clamp( h, 0.02, 0.10 );
          if( h<0.001 || t>tmax ) break;
        }

        return clamp( res, 0.0, 1.0 );
      }

${lighting}

    vec2 scene(vec3 _p ) {
      vec4 p = vec4( _p, 1. );
${preface}
      return ${scene};
    }
 
${main}
`

    return fs_source
  }

},{}],22:[function(require,module,exports){
const getFog = require( './fog.js' )
const vignette = require( './vignette.js' )
const { param_wrap, MaterialID } = require( './utils.js' )
const __lighting = require( './lighting.js' )
const { Var, float_var_gen, vec2_var_gen, vec3_var_gen, vec4_var_gen, int_var_gen, VarAlloc } = require('./var.js')

const getScene = function( SDF ) {

  Scene = function( objs, canvas, steps=100, minDistance=.001, maxDistance=40, size=2, shouldAnimate=false ) {
    const scene  = Object.create( Scene.prototype )

    MaterialID.clear()

    SDF.lighting.lights = []

    scene.__prerender = objs
    if( objs.length > 1 ) {
      // reduce objects to nested Unions
      scene.__prerender = objs.reduce( ( current, next ) => SDF.Union( current, next ) )
    }

    Object.assign( scene, { 
      objs, 
      canvas,
      postprocessing:[],
      __shadow:8,
      __followLight:null
    })

    scene.animate( shouldAnimate )
      .steps( steps )
      .threshold( minDistance )
      .farPlane( maxDistance )
      .resolution( 1 )

    scene.useQuality = true
    scene.useVoxels  = false

    SDF.__scene = scene

    return scene
  }

  Scene.prototype = {
    animate( v ) { this.__animate = v; return this },  
    resolution( v ) { 
      this.width = Math.floor( this.canvas.width = window.innerWidth * v )
      this.height = Math.floor( this.canvas.height = window.innerHeight * v )
      
      this.__resolution = v;
      this.useQuality = false
      return this 
    },  
    voxel( v = .1 ) { 
      this.useVoxels = true
      this.__voxelSize = v
      return this
    },
    threshold( v ) { this.__threshold = v; this.useQuality = false; return this },  
    steps( v ) { this.__steps = v; this.useQuality = false; return this },  
    farPlane( v ) { this.__farPlane = v; this.useQuality = false;  return this },  
    camera( x=0, y=0, z=5, speed=1 ) {
      SDF.camera.__camera.position[0] = x
      SDF.camera.__camera.position[1] = y
      SDF.camera.__camera.position[2] = z
      SDF.camera.__camera.rotationSpeed = speed * .01
      SDF.camera.__camera.positionSpeed = speed * -.25
      SDF.camera.update()
      return this
    },
    shadow( k=0 ) {
      this.__shadow = k;
      return this;
    },
    quality( quality=10 ) {
      this.threshold( .1 / (quality * quality * quality ) )
      this.steps( quality * 20 )
      this.farPlane( quality * 5 )
      this.resolution( Math.min( .2 * quality, 2 ) )

      return this
    },
    follow( light, distance=3 ) {
      this.__followLight = light
      SDF.camera.onmove = function( camera ) {
        const offset = SDF.camera.offset()
        light.pos.x = SDF.camera.__camera.position[0] - offset[0]
        light.pos.y = SDF.camera.__camera.position[1] - offset[1]
        light.pos.z = SDF.camera.__camera.position[2] - offset[2]
        light.dirty = true
      }
      SDF.lighting.lights = [light]
      return this
    },
    light( ...lights ) {
      SDF.lighting.lights = SDF.lighting.lights.concat( lights )
      if( this.__followLight !== null ) SDF.lighting.lights.push( this.__followLight )
      return this
    },
    fog: getFog( Scene, SDF ),
    vignette: vignette( Scene, SDF ),
    background: require( './background.js' )( Scene, SDF ),
    presets: {
      'fractal.close': {
        farPlane:1,
        resolution:1,
        steps:150,
        animated:true,
        threshold:.000125
      },
      'fractal.kindaclose': {
        farPlane:2,
        resolution:1,
        steps:250,
        animated:true,
        threshold:.000125/2
      },
      'fractal.med': {
        farPlane:5,
        resolution:.75,
        steps:80,
        animated:true,
        threshold:.001,
      },
      'fractal.low': {
        farPlane:3.0,
        resolution:.5,
        animated:true,
        steps:50,
        threshold:.005,
      },
      'fractal.high': {
        farPlane:10,
        resolution:1,
        animated:true,
        steps:100,
        threshold:.001,
      },
      'repeat.low': {
        farPlane:25,
        resolution:.5,
        animated:true,
        steps:50
      },
      'repeat.med': {
        farPlane:35,
        resolution:1,
        animated:true,
        steps:75
      },
      'repeat.high': {
        farPlane:40,
        resolution:1,
        animated:true,
        steps:100
      },
      'voxel.high': {
        resolution:1,
        animated:true,
        steps:30
      },
      'voxel.med': {
        resolution:1,
        animated:true,
        steps:20
      },
      'voxel.low': {
        resolution:.5,
        animated:true,
        steps:10
      },
      low: {
        threshold:.05,
        steps:45,
        farPlane:12,
        resolution:.4,
        animated:true
      },
      medium: {
        threshold:.01,
        steps:80,
        farPlane:18,
        resolution:.5,
        animated:true
      },
      med: {
        threshold:.01,
        steps:80,
        farPlane:18,
        resolution:.5,
        animated:true
      },
      high: {
        threshold:.005,
        steps:90,
        farPlane:20,
        resolution:1,
        animated:true
      }
    },

    applyPreset( presetName ) {
      const preset = this.presets[ presetName ]
      if( preset.farPlane !== undefined ) this.farPlane( preset.farPlane )
      this.steps( preset.steps )
      this.resolution( preset.resolution )
      this.threshold( preset.threshold || .001 )

      return preset.animated
    },

    post( ...fx ) {
      SDF.fx.post( ...fx )
      return this
    },

    render( quality=10, animate=false, useQuality=true ) {
      this.background() // adds default if none has been specified
      if( typeof quality === 'string' ) {
        animate = this.applyPreset( quality )
      }else if( this.useQuality === true ) {
        this.quality( quality )
      }
      this.animate( animate )

      SDF.distanceOps.__clear()
      SDF.textures.clear()
      const geometries = SDF.primitives.emit_geometries()

      let [ variablesDeclaration, sceneRendering, postprocessing ] = SDF.generateSDF( this )

      const lighting = SDF.lighting.gen( this.__shadow, geometries )
      variablesDeclaration += SDF.materials.emit_decl() 
      variablesDeclaration += SDF.textures.emit_decl() 
      variablesDeclaration += SDF.lighting.emit_decl() 

      this.fs = SDF.renderFragmentShader( 
        variablesDeclaration, 
        sceneRendering.out, 
        sceneRendering.preface,
        SDF.requiredGeometries.join('\n') + SDF.requiredOps.join('\n'),
        lighting,
        postprocessing, 
        this.__steps, this.__threshold, this.__farPlane.toFixed(1),
        SDF.distanceOps.__getGLSL(),
        this.useVoxels ? this.__voxelSize : 0
      )

      SDF.start( this.fs, this.width, this.height, this.__animate )

      //SDF.materials.materials.length = 0

      this.useQuality = true

      return this
    },

  }

  return Scene

}

module.exports = getScene 

},{"./background.js":3,"./fog.js":11,"./lighting.js":14,"./utils.js":28,"./var.js":29,"./vignette.js":31}],23:[function(require,module,exports){
const SceneNode = ()=> Object.create( SceneNode.prototype )
const Matrix = require( './external/matrix.js' )

SceneNode.prototype = {
	emit() { return "#NotImplemented#"; },

	emit_decl() { return ""; },

	update_location(gl, program) {},

  upload_data(gl) {},

  getID() {
    let id = this.id

    if( id === undefined && this.sdf !== undefined ) {
      id = this.sdf.getID()
    }

    return id
  },

  getCenter() {
    let center = this.center

    if( center === undefined && this.sdf !== undefined ) {
      if( this.sdf.getCenter === undefined ) {
        center = this.sdf.__wrapped.getCenter()
      }else{
        center = this.sdf.getCenter()
      }
    }

    return center
  },

  move( ...args ) {
    return this.translate( ...args )
  },

  rotate( angle, x,y,z ) {
    this.transform.rotation.angle = angle
    if( x !== undefined ) this.transform.rotation.axis.x = x
    if( y !== undefined ) this.transform.rotation.axis.y = y
    if( z !== undefined ) this.transform.rotation.axis.z = z
  
    return this
  },

  rotateBy( angle,x,y,z ) {
    this.transform.__rotations.push( Matrix.rotate( angle,x,y,z ) )
    return this
  },

  translate( x,y,z ) {
    if( x !== undefined && x !== null ) this.transform.translation.x = x
    if( y !== undefined && y !== null ) this.transform.translation.y = y
    if( z !== undefined && z !== null ) this.transform.translation.z = z
  
    return this
  },

  scale( amount ) {
    if( amount !== undefined ) this.transform.scale = amount
    return this
  },

  material( mat ) {
    this.__setMaterial( mat )
    return this
  },

  texture( tex,props ) {
    this.__setTexture( tex,props )
    return this
  },

  bump( tex,strength ) {
    this.__setBump( tex,strength )
    return this
  }
}

const ops = [ 'repeat', 'polarRepeat', 'elongation' ]

ops.forEach( op => {
  const constructorName = op[0].toUpperCase() + op.slice(1)
  SceneNode.prototype[ op ] = function( ...args ) {
    this[ op ] = this[ op ].bind( this )
    Object.assign( this[ op ], SceneNode.prototype )
    this.__target = this[ op ]
    this[ '__'+op ] = Marching[ constructorName ]( this, ...args, this[ op ] )
    this[ op ].transform = this[ '__'+op ].transform
    return this
  }
})

module.exports = SceneNode

},{"./external/matrix.js":9}],24:[function(require,module,exports){
const SceneNode = require( './sceneNode.js' ),
      getPixels = require( 'get-pixels' ),
      createTexture = require( 'gl-texture2d' ),
      { param_wrap, MaterialID } = require( './utils.js' ),
      { Var, float_var_gen, vec2_var_gen, vec3_var_gen, vec4_var_gen, int_var_gen, VarAlloc }  = require( './var.js' ), 
      { Vec2, Vec3, Vec4 } = require( './vec.js' )


const __Textures = function( SDF ) {
  const gens = { 
    int:   int_var_gen,
    float: float_var_gen,
    vec2: vec2_var_gen,
    vec3: vec3_var_gen,
    vec4: vec4_var_gen,
  }

  const vars = { 
    vec2: Vec2,
    vec3: Vec3,
    vec4: Vec4
  }

  const Textures = {
    textures:[],
    __textures:[],

    __texturePrefaces:[],
    __textureBodies:  [],

    __types: require( './textureDescriptions.js' ),
    __wrap : require( './textureWrap.js' ), 
    
    __emitFunction() {
      let pushedWrap = false

      let decl = `
      vec3 getTexture( int id, vec3 pos ) {
        vec3 tex;
        vec2 pos2;

        switch( id ) {\n`
      
      Textures.__textureBodies.length = 0

      let funcdefs = ''
      this.textures.forEach( (t,i) => {
        const mode = t.mode !== '2d' && t.glsl !== undefined ? '3d' : '2d'

        // add texture wrap function if needed
        if( mode === '2d' && pushedWrap === false ) {
          Textures.__textureBodies.push( Textures.__wrap )
          pushedWrap = true
        }

        const glsl = mode === '3d' ? t.glsl : t.glsl2d 
        if( Textures.__textureBodies.indexOf( glsl ) === -1 ) { 
          Textures.__textureBodies.push( glsl )
        }

        const args = t.parameters.map( p => t.__target[ p.name ].emit() ) 
        const functionName = mode === '2d' ? t.name + '2d' : t.name 

        //decl += `
        //  case ${i}:
        //      ${mode === '2d' 
        //      ? `    
        //      vec3 n = normalize( pos );
        //      vec4 texx =  vec4(${functionName}( .5*n.yz+.5 ${ args.length > 0 ? ',' + args.join(',') : ''} ), 1.);
        //      vec4 texy =  vec4(${functionName}( .5*n.zx+.5 ${ args.length > 0 ? ',' + args.join(',') : ''} ), 1.);
        //      vec4 texz =  vec4(${functionName}( .5*n.xy+.5 ${ args.length > 0 ? ',' + args.join(',') : ''} ), 1.);
        //      tex = triplanar( n, texx, texy,texz,false,false ).xyz;`
        //      : ` 
        //      tex = ${functionName}( pos ${ args.length > 0 ? ',' + args.join(',') : ''} );
        //   `}
        //    break;\n`


        decl +=`
          case ${i}:
            ${mode === '2d' ? `     pos2 = getUVCubic( pos );\n` : ''} 
            tex = ${functionName}( ${mode === '2d' ?'pos2':'pos'} ${ args.length > 0 ? ',' + args.join(',') : ''} );
            break;\n`            

      })

      decl += `
          default:
            tex = vec3(0.);
            break;
        }

        return tex;
      }

      vec3 getTexture( int id, vec3 pos, vec3 nor, SDF sdf, bool useTransform ) {
        vec3 tex;
        vec2 pos2;
        vec3 tpos = pos;
        if( useTransform == true ) {
          if( length(sdf.repeat) != 0. ) {
            tpos = mod( (vec4(pos,1.) * sdf.repeatTransform).xyz, sdf.repeat) - .5 * sdf.repeat;
            tpos = ( vec4(tpos, 1.) * sdf.transform).xyz;
          }else{
            tpos = (vec4(tpos,1.) * sdf.transform).xyz;
          }
        }

        return getTexture( id, tpos );
      }
      `
     
      return { glsldefs: Textures.__textureBodies.join( '\n' ), mainfunc:decl }
    },

    clear() {
      Textures.textures.length = 0
    },

    addTexture( tex ) {
      // we have to dirty the texture so that its data
      // will be uploaded to new shaders, otherwise the
      // texture will only work the first time it's used, when
      // it's dirty on initialization.
      Textures.dirty( tex )

      // if texture with same name is already found, replace it,
      // otherwise push texture
      //const oldTex = Textures.textures.find( __tex => tex.name === __tex.name )
      //if( oldTex !== undefined ) {
      //  const idx = Textures.textures.indexOf( oldTex )
      //  Textures.textures.splice( idx, 1, tex )

      //  tex.id = idx 
      //}else{
        tex.id = Textures.textures.length
        Textures.textures.push( tex )
      //}

      return tex
    },

    texture( presetName='noise', props={}, target=null ){
      //const isPreset = filenameOrPreset.indexOf( '.' ) === -1
      //const defaults = { wrap:SDF.gl.MIRRORED_REPEAT }

      if( Textures.__types[ presetName ] === undefined ) {
        console.log( `the texture type '${presetName}' does not exist.` )
      }
      const tex = Object.assign( { mode:'3d' }, Textures.__types[ presetName ], props )

      if( target === null ) target = tex
      tex.__target = target

      for( let param of tex.parameters ) {
        const defaultValues = param.default
        const isArray = Array.isArray( defaultValues )

        let count = 0
        if( isArray ) {
          let val = props[ param.name ], __var

          if( typeof val === 'number' ) {
            __var = Var( vars[ param.type ]( val ), null, 'vec3' )
          }else{
            const initvalues = val !== undefined ? val : defaultValues
            __var = Var( vars[ param.type ]( ...initvalues ), null, param.type )
          }

          // for assigning entire new vectors to property
          Object.defineProperty( target, param.name, {
            configurable:true,
            get() { return __var },
            set(v) {
              if( typeof v === 'object' ) {
                __var.set( v )
              }else{
                __var.value.x = v
                __var.value.y = v
                __var.value.z = v
                __var.value.w = v
                __var.dirty = true
              }
            }
          })

        }else{
          let __var  = param_wrap( 
            props[ param.name ], 
            gens[ param.type ]( defaultValues ) 
          )

          //__var.set( defaultValues )
          Object.defineProperty( target, param.name, {
            configurable:true,
            get() { return __var },
            set(v) {
              __var.set( v )
            }
          })
        }
      }

      if( presetName === 'image' ) {
        if( props.filename !== undefined ) {
          tex.image = getPixels( props.filename, (err,pixels) => {
            if( err !== null ) {
              console.error( err )
              return
            }
            tex.pixels = pixels
            tex.gltexture = createTexture( SDF.gl, pixels )
            tex.gltexture.wrap = props.wrap === undefined ? Marching.gl.REPEAT : props.wrap
          })
        }else{
          tex.image = null
          console.error('You must specify a filename when using the iamge preset.')
        }
      }else if( presetName === 'canvas' ) {
        if( props.canvas === undefined ) {
          tex.canvas = tex.image = document.createElement('canvas')
          tex.ctx    = tex.canvas.getContext('2d')
        }else{
          tex.image = props.canvas
        }

        tex.update = function() {
          tex.gltexture.setPixels( tex.image )
        }

        tex.gltexture = createTexture( SDF.gl, tex.image )
        tex.gltexture.wrap = props.wrap === undefined ? Marching.gl.REPEAT : props.wrap

        tex.update()
      }


      Object.defineProperty( tex, 'wrap', {
        get() { return this.gltexture.wrap },
        set(v){ this.gltexture.wrap = v }
      })

      tex.name = presetName

      return tex 
    },

    dirty( tex ) {},
   
    emit_decl() {
      if( this.textures.length === 0 ) return '' 

      let decl = ''

      const memo = []
      let imageCount = 0;
      this.textures.forEach( (tex,i) => {
        if( memo.indexOf( tex ) === -1 ) {
          for( let param of tex.parameters ) {
            if( param.name !== 'material' )
              decl += tex.__target[ param.name ].emit_decl()
          }
          memo.push( tex )
        }
        if( tex.name === 'image' || tex.name === 'canvas' ) {
          imageCount++

          // for some reason can't immediately call update... 
          // have to wait for some type of dom initialization?
          // so call here
          if( tex.update ) tex.update()
        }
      })

      if( imageCount > 0 ) {
        decl += `\n      uniform sampler2D textures[${imageCount}];\n`
      }
      return decl
    },
    
    update_location( gl, program ) {
      if( this.textures.length > 0 ) {
        this.textures.forEach( (tex,i) => {
          for( let param of tex.parameters ) {
            if( param.type !== 'obj' ) {
              if( param.name !== 'material' ) 
                tex.__target[ param.name ].update_location( gl,program )
            }
          }
          if( tex.name === 'image' || tex.name === 'canvas' ) {
            tex.loc = gl.getUniformLocation( program, `textures[${tex.id}]` )
            tex.gltexture.bind( i )
          }
        })
      }

      //if( this.textures.length > 0 ) {
      //  this.textures.sort( (a,b) => a.id > b.id ? 1 : -1 ) 

      //  for( let tex of this.textures ) {
      //    tex.loc = gl.getUniformLocation( program, `textures[${tex.id}]` )
      //    tex.gltexture.bind( tex.id )
      //  }

      //  this.__textures = this.textures.slice( 0 )
      //  this.textures.length = 0
      //}
    },

    upload_data( gl, program ) {
      if( this.textures.length > 0 ) {
        this.textures.forEach( (tex,i) => {
          for( let param of tex.parameters ) {
            if( param.type !== 'obj' && param.name !== 'material' )
              tex.__target[ param.name ].upload_data( gl )
          }
          if( tex.name === 'image' || tex.name === 'canvas' ) {
            gl.uniform1i( tex.loc, i )
          }
        })
      }
    }

  }

  Textures.texture.create = function( props ) {
    Textures.__types[ props.name ] = props
  }

  Object.defineProperties( Textures.texture, {
    'repeat': { get() { return Marching.gl.REPEAT } },
    'mirror': { get() { return Marching.gl.MIRRORED_REPEAT } },
    'clamp': { get() { return Marching.gl.CLAMP_TO_EDGE } },
  })

  const f = value => value % 1 === 0 ? value.toFixed(1) : value 

  return Textures
}

module.exports = __Textures

},{"./sceneNode.js":23,"./textureDescriptions.js":25,"./textureWrap.js":26,"./utils.js":28,"./var.js":29,"./vec.js":30,"get-pixels":43,"gl-texture2d":74}],25:[function(require,module,exports){
const glsl = require( 'glslify' )

const textures = {
  image: {
    name:'image',
    glsl2d:`
      vec3 image2d( vec2 uv, float scale, float strength ) {
        return texture( textures[ 0 ], uv*scale ).xyz * strength;
      }
    `,
    parameters:[
      { name:'scale', type:'float', default:1 },
      { name:'strength', type:'float', default:1 },   
    ]
  },
  canvas: {
    name:'canvas',
    glsl2d:`
      vec3 canvas2d( vec2 uv, float scale, float strength ) {
        return texture( textures[ 0 ], uv*scale ).xyz * strength;
      }
    `,
    parameters:[
      { name:'scale', type:'float', default:1 },
      { name:'strength', type:'float', default:1 },   
    ]
  },
  rainbow: {
    name:'rainbow',
    parameters: [
      { name:'strength', type:'float', default:1 },
      { name:'shift', type:'float', default:0 },
      { name:'scale', type:'float', default:1 },
    ],
    glsl:` 
    vec3 rainbow( vec3 pos, float strength, float shift, float scale ) {
      pos = pos * scale;
      vec3 a = vec3(0.5,0.5,0.5), b = vec3(0.5,0.5,0.5), c = vec3(1.0,1.0,1.0),d = vec3(0.0,0.33,0.67);
      return a + b * cos( 6.283818 * ( c * mod(length(pos) + shift, 1. ) + d ) ) * strength;
    }` 
  },
  checkers: {
    name:'checkers',
    glsl:`          
        vec3 checkers( vec3 pos, float size, vec3 color1, vec3 color2 ) {
          vec3 tex;
          pos  = pos * size;
          if ((int(floor(pos.x) + floor(pos.y) + floor(pos.z)) & 1) == 0) {
            tex = color1;
          }else{
            tex = color2;
          }

          return tex;
        }`,
    glsl2d:`
        vec3 checkers2d( vec2 uv, float size, vec3 color1, vec3 color2 ) {
          float fmodResult = mod(floor(size * uv.x) + floor(size * uv.y), 2.0);
          float fin = max(sign(fmodResult), 0.0); 

          return vec3(fin);
        }
    `,
    parameters: [
      { name:'scale',  type:'float', default:5 },
      { name:'color1', type:'vec3', default:[1,1,1] },
      { name:'color2', type:'vec3', default:[0,0,0] }
    ],
  },
  noise: {
    name:'noise',
    glsl:glsl(["#define GLSLIFY 1\n          \n        //\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nfloat mod289(float x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat permute(float x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat taylorInvSqrt(float r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 grad4(float j, vec4 ip)\n  {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n\n  return p;\n  }\n\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\n\nfloat snoise(vec4 v)\n  {\n  const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                        0.276393202250021,  // 2 * G4\n                        0.414589803375032,  // 3 * G4\n                       -0.447213595499958); // -1 + 4 * G4\n\n// First corner\n  vec4 i  = floor(v + dot(v, vec4(F4)) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n//  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n  //  x1 = x0 - i1  + 1.0 * C.xxxx\n  //  x2 = x0 - i2  + 2.0 * C.xxxx\n  //  x3 = x0 - i3  + 3.0 * C.xxxx\n  //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n  vec4 x1 = x0 - i1 + C.xxxx;\n  vec4 x2 = x0 - i2 + C.yyyy;\n  vec4 x3 = x0 - i3 + C.zzzz;\n  vec4 x4 = x0 + C.wwww;\n\n// Permutations\n  i = mod289(i);\n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n  }\n\n        vec3 noise( vec3 pos, float scale, float strength, float time ) {\n          float n = snoise( vec4(pos*scale, time) );\n          return vec3( n ) * strength;\n        }",""]),
    glsl2d:glsl(["#define GLSLIFY 1\n    \n        //\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i);\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n        vec3 noise2d( vec2 st, float scale, float strength, float time ) {\n          float col = snoise( vec3( st, time ) * scale );\n\n          return vec3(col) * strength;\n        }\n",""]) ,
    parameters: [
      { name:'scale', type:'float', default:2 },
      { name:'strength', type:'float', default:.1 },
      { name:'time', type:'float', default:1 }
    ],
  },
  // adapted from https://thebookofshaders.com/10/
  truchet: {
    name:'truchet',
    glsl2d:`    
        float random_truchet(in vec2 _st) {
          return fract(sin(dot(_st.xy,
                         vec2(12.9898,78.233)))*
                        43758.5453123);
        }

        vec2 truchetPattern(in vec2 _st, in float _index){
            _index = fract(((_index-0.5)*2.0));
            if (_index > 0.75) {
                _st = vec2(1.0) - _st;
            } else if (_index > 0.5) {
                _st = vec2(1.0-_st.x,_st.y);
            } else if (_index > 0.25) {
                _st = 1.0-vec2(1.0-_st.x,_st.y);
            }
            return _st;
        }

        vec3 truchet2d( vec2 st, float scale, vec3 color ) {
            st = st * scale;
            vec2 ipos = floor(st);  // integer
            vec2 fpos = fract(st);  // fraction

            vec2 tile = truchetPattern(fpos, random_truchet( ipos ));

            float col = smoothstep(tile.x-0.3,tile.x,tile.y)-smoothstep(tile.x,tile.x+.3,tile.y);
            return color * col;
        }

` ,
    parameters: [
      { name:'scale', type:'float', default:10 },
      { name:'color', type:'vec3', default:[1,1,1] }
    ],
  },
  dots: {
    name:'dots',
    glsl:`          
        vec3 dots( vec3 pos, float count, float radius, vec3 color ) {
          vec3 tex;
          tex = vec3( color - smoothstep( radius, radius+.02, length(fract(pos*(round(count/2.)+.5)) -.5 )) );
          return tex;
        }` ,
    glsl2d:`
      vec2 tile(vec2 _st, float _zoom){
        _st *= _zoom;
        return fract(_st);
      }

      float circle(vec2 _st, float _radius){
        vec2 pos = vec2(0.5)-_st;
        _radius *= 0.75;
        return 1.-smoothstep(_radius-(_radius*0.05),_radius+(_radius*0.05),dot(pos,pos)*3.14);
      }
    
      vec3 dots2d( vec2 _st, float scale, float radius, vec3 color ) {
        vec2 st = tile(_st,scale);
        vec3 fin = vec3(circle(st, radius)) * color;
        return fin;
      }
    `,
    parameters: [
      { name:'scale', type:'float', default:5 },
      { name:'radius', type:'float', default:.3 },
      { name:'color', type:'vec3', default:[1,1,1] }
    ],
  },
  stripes: {
    name:'stripes',
    glsl:`          
        vec3 stripes( vec3 pos, float scale, vec3 color ) {
          vec3 tex;
          tex = vec3( color - smoothstep(0.3, 0.32, length(fract((pos.x+pos.y+pos.z)*scale) -.5 )) );
          return tex;
        }` ,
    parameters: [
      { name:'scale', type:'float', default:5 },
      { name:'color', type:'vec3', default:[1,1,1] }
    ],
  },
  cellular: {
    name:'cellular',
    glsl:glsl(["#define GLSLIFY 1\n\n        // Permutation polynomial: (34x^2 + x) mod 289\nvec3 permute(vec3 x) {\n  return mod((34.0 * x + 1.0) * x, 289.0);\n}\n\nvec3 dist(vec3 x, vec3 y, vec3 z,  bool manhattanDistance) {\n  return manhattanDistance ?  abs(x) + abs(y) + abs(z) :  (x * x + y * y + z * z);\n}\n\nvec2 worley(vec3 P, float jitter, bool manhattanDistance) {\nfloat K = 0.142857142857; // 1/7\nfloat Ko = 0.428571428571; // 1/2-K/2\nfloat  K2 = 0.020408163265306; // 1/(7*7)\nfloat Kz = 0.166666666667; // 1/6\nfloat Kzo = 0.416666666667; // 1/2-1/6*2\n\n\tvec3 Pi = mod(floor(P), 289.0);\n \tvec3 Pf = fract(P) - 0.5;\n\n\tvec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0);\n\tvec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0);\n\tvec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0);\n\n\tvec3 p = permute(Pi.x + vec3(-1.0, 0.0, 1.0));\n\tvec3 p1 = permute(p + Pi.y - 1.0);\n\tvec3 p2 = permute(p + Pi.y);\n\tvec3 p3 = permute(p + Pi.y + 1.0);\n\n\tvec3 p11 = permute(p1 + Pi.z - 1.0);\n\tvec3 p12 = permute(p1 + Pi.z);\n\tvec3 p13 = permute(p1 + Pi.z + 1.0);\n\n\tvec3 p21 = permute(p2 + Pi.z - 1.0);\n\tvec3 p22 = permute(p2 + Pi.z);\n\tvec3 p23 = permute(p2 + Pi.z + 1.0);\n\n\tvec3 p31 = permute(p3 + Pi.z - 1.0);\n\tvec3 p32 = permute(p3 + Pi.z);\n\tvec3 p33 = permute(p3 + Pi.z + 1.0);\n\n\tvec3 ox11 = fract(p11*K) - Ko;\n\tvec3 oy11 = mod(floor(p11*K), 7.0)*K - Ko;\n\tvec3 oz11 = floor(p11*K2)*Kz - Kzo; // p11 < 289 guaranteed\n\n\tvec3 ox12 = fract(p12*K) - Ko;\n\tvec3 oy12 = mod(floor(p12*K), 7.0)*K - Ko;\n\tvec3 oz12 = floor(p12*K2)*Kz - Kzo;\n\n\tvec3 ox13 = fract(p13*K) - Ko;\n\tvec3 oy13 = mod(floor(p13*K), 7.0)*K - Ko;\n\tvec3 oz13 = floor(p13*K2)*Kz - Kzo;\n\n\tvec3 ox21 = fract(p21*K) - Ko;\n\tvec3 oy21 = mod(floor(p21*K), 7.0)*K - Ko;\n\tvec3 oz21 = floor(p21*K2)*Kz - Kzo;\n\n\tvec3 ox22 = fract(p22*K) - Ko;\n\tvec3 oy22 = mod(floor(p22*K), 7.0)*K - Ko;\n\tvec3 oz22 = floor(p22*K2)*Kz - Kzo;\n\n\tvec3 ox23 = fract(p23*K) - Ko;\n\tvec3 oy23 = mod(floor(p23*K), 7.0)*K - Ko;\n\tvec3 oz23 = floor(p23*K2)*Kz - Kzo;\n\n\tvec3 ox31 = fract(p31*K) - Ko;\n\tvec3 oy31 = mod(floor(p31*K), 7.0)*K - Ko;\n\tvec3 oz31 = floor(p31*K2)*Kz - Kzo;\n\n\tvec3 ox32 = fract(p32*K) - Ko;\n\tvec3 oy32 = mod(floor(p32*K), 7.0)*K - Ko;\n\tvec3 oz32 = floor(p32*K2)*Kz - Kzo;\n\n\tvec3 ox33 = fract(p33*K) - Ko;\n\tvec3 oy33 = mod(floor(p33*K), 7.0)*K - Ko;\n\tvec3 oz33 = floor(p33*K2)*Kz - Kzo;\n\n\tvec3 dx11 = Pfx + jitter*ox11;\n\tvec3 dy11 = Pfy.x + jitter*oy11;\n\tvec3 dz11 = Pfz.x + jitter*oz11;\n\n\tvec3 dx12 = Pfx + jitter*ox12;\n\tvec3 dy12 = Pfy.x + jitter*oy12;\n\tvec3 dz12 = Pfz.y + jitter*oz12;\n\n\tvec3 dx13 = Pfx + jitter*ox13;\n\tvec3 dy13 = Pfy.x + jitter*oy13;\n\tvec3 dz13 = Pfz.z + jitter*oz13;\n\n\tvec3 dx21 = Pfx + jitter*ox21;\n\tvec3 dy21 = Pfy.y + jitter*oy21;\n\tvec3 dz21 = Pfz.x + jitter*oz21;\n\n\tvec3 dx22 = Pfx + jitter*ox22;\n\tvec3 dy22 = Pfy.y + jitter*oy22;\n\tvec3 dz22 = Pfz.y + jitter*oz22;\n\n\tvec3 dx23 = Pfx + jitter*ox23;\n\tvec3 dy23 = Pfy.y + jitter*oy23;\n\tvec3 dz23 = Pfz.z + jitter*oz23;\n\n\tvec3 dx31 = Pfx + jitter*ox31;\n\tvec3 dy31 = Pfy.z + jitter*oy31;\n\tvec3 dz31 = Pfz.x + jitter*oz31;\n\n\tvec3 dx32 = Pfx + jitter*ox32;\n\tvec3 dy32 = Pfy.z + jitter*oy32;\n\tvec3 dz32 = Pfz.y + jitter*oz32;\n\n\tvec3 dx33 = Pfx + jitter*ox33;\n\tvec3 dy33 = Pfy.z + jitter*oy33;\n\tvec3 dz33 = Pfz.z + jitter*oz33;\n\n\tvec3 d11 = dist(dx11, dy11, dz11, manhattanDistance);\n\tvec3 d12 =dist(dx12, dy12, dz12, manhattanDistance);\n\tvec3 d13 = dist(dx13, dy13, dz13, manhattanDistance);\n\tvec3 d21 = dist(dx21, dy21, dz21, manhattanDistance);\n\tvec3 d22 = dist(dx22, dy22, dz22, manhattanDistance);\n\tvec3 d23 = dist(dx23, dy23, dz23, manhattanDistance);\n\tvec3 d31 = dist(dx31, dy31, dz31, manhattanDistance);\n\tvec3 d32 = dist(dx32, dy32, dz32, manhattanDistance);\n\tvec3 d33 = dist(dx33, dy33, dz33, manhattanDistance);\n\n\tvec3 d1a = min(d11, d12);\n\td12 = max(d11, d12);\n\td11 = min(d1a, d13); // Smallest now not in d12 or d13\n\td13 = max(d1a, d13);\n\td12 = min(d12, d13); // 2nd smallest now not in d13\n\tvec3 d2a = min(d21, d22);\n\td22 = max(d21, d22);\n\td21 = min(d2a, d23); // Smallest now not in d22 or d23\n\td23 = max(d2a, d23);\n\td22 = min(d22, d23); // 2nd smallest now not in d23\n\tvec3 d3a = min(d31, d32);\n\td32 = max(d31, d32);\n\td31 = min(d3a, d33); // Smallest now not in d32 or d33\n\td33 = max(d3a, d33);\n\td32 = min(d32, d33); // 2nd smallest now not in d33\n\tvec3 da = min(d11, d21);\n\td21 = max(d11, d21);\n\td11 = min(da, d31); // Smallest now in d11\n\td31 = max(da, d31); // 2nd smallest now not in d31\n\td11.xy = (d11.x < d11.y) ? d11.xy : d11.yx;\n\td11.xz = (d11.x < d11.z) ? d11.xz : d11.zx; // d11.x now smallest\n\td12 = min(d12, d21); // 2nd smallest now not in d21\n\td12 = min(d12, d22); // nor in d22\n\td12 = min(d12, d31); // nor in d31\n\td12 = min(d12, d32); // nor in d32\n\td11.yz = min(d11.yz,d12.xy); // nor in d12.yz\n\td11.y = min(d11.y,d12.z); // Only two more to go\n\td11.y = min(d11.y,d11.z); // Done! (Phew!)\n\treturn sqrt(d11.xy); // F1, F2\n\n}\n\n        vec3 cellular( vec3 pos, float scale, float jitter, float mode, float strength, float time ) {\n          vec2 w = worley( pos * scale + time, jitter, false );\n          vec3 o;\n          if( mode == 0. ) {\n            o = vec3( w.x );\n          } else if ( mode == 1. ) {\n            o = vec3( w.y );\n          } else{\n            o = vec3( w.y - w.x );\n          }\n\n          return o * strength;\n        }\n    ",""]),
    glsl2d:glsl(["#define GLSLIFY 1\n\n        // Permutation polynomial: (34x^2 + x) mod 289\nvec3 permute(vec3 x) {\n  return mod((34.0 * x + 1.0) * x, 289.0);\n}\n\nvec3 dist(vec3 x, vec3 y, vec3 z,  bool manhattanDistance) {\n  return manhattanDistance ?  abs(x) + abs(y) + abs(z) :  (x * x + y * y + z * z);\n}\n\nvec2 worley(vec3 P, float jitter, bool manhattanDistance) {\nfloat K = 0.142857142857; // 1/7\nfloat Ko = 0.428571428571; // 1/2-K/2\nfloat  K2 = 0.020408163265306; // 1/(7*7)\nfloat Kz = 0.166666666667; // 1/6\nfloat Kzo = 0.416666666667; // 1/2-1/6*2\n\n\tvec3 Pi = mod(floor(P), 289.0);\n \tvec3 Pf = fract(P) - 0.5;\n\n\tvec3 Pfx = Pf.x + vec3(1.0, 0.0, -1.0);\n\tvec3 Pfy = Pf.y + vec3(1.0, 0.0, -1.0);\n\tvec3 Pfz = Pf.z + vec3(1.0, 0.0, -1.0);\n\n\tvec3 p = permute(Pi.x + vec3(-1.0, 0.0, 1.0));\n\tvec3 p1 = permute(p + Pi.y - 1.0);\n\tvec3 p2 = permute(p + Pi.y);\n\tvec3 p3 = permute(p + Pi.y + 1.0);\n\n\tvec3 p11 = permute(p1 + Pi.z - 1.0);\n\tvec3 p12 = permute(p1 + Pi.z);\n\tvec3 p13 = permute(p1 + Pi.z + 1.0);\n\n\tvec3 p21 = permute(p2 + Pi.z - 1.0);\n\tvec3 p22 = permute(p2 + Pi.z);\n\tvec3 p23 = permute(p2 + Pi.z + 1.0);\n\n\tvec3 p31 = permute(p3 + Pi.z - 1.0);\n\tvec3 p32 = permute(p3 + Pi.z);\n\tvec3 p33 = permute(p3 + Pi.z + 1.0);\n\n\tvec3 ox11 = fract(p11*K) - Ko;\n\tvec3 oy11 = mod(floor(p11*K), 7.0)*K - Ko;\n\tvec3 oz11 = floor(p11*K2)*Kz - Kzo; // p11 < 289 guaranteed\n\n\tvec3 ox12 = fract(p12*K) - Ko;\n\tvec3 oy12 = mod(floor(p12*K), 7.0)*K - Ko;\n\tvec3 oz12 = floor(p12*K2)*Kz - Kzo;\n\n\tvec3 ox13 = fract(p13*K) - Ko;\n\tvec3 oy13 = mod(floor(p13*K), 7.0)*K - Ko;\n\tvec3 oz13 = floor(p13*K2)*Kz - Kzo;\n\n\tvec3 ox21 = fract(p21*K) - Ko;\n\tvec3 oy21 = mod(floor(p21*K), 7.0)*K - Ko;\n\tvec3 oz21 = floor(p21*K2)*Kz - Kzo;\n\n\tvec3 ox22 = fract(p22*K) - Ko;\n\tvec3 oy22 = mod(floor(p22*K), 7.0)*K - Ko;\n\tvec3 oz22 = floor(p22*K2)*Kz - Kzo;\n\n\tvec3 ox23 = fract(p23*K) - Ko;\n\tvec3 oy23 = mod(floor(p23*K), 7.0)*K - Ko;\n\tvec3 oz23 = floor(p23*K2)*Kz - Kzo;\n\n\tvec3 ox31 = fract(p31*K) - Ko;\n\tvec3 oy31 = mod(floor(p31*K), 7.0)*K - Ko;\n\tvec3 oz31 = floor(p31*K2)*Kz - Kzo;\n\n\tvec3 ox32 = fract(p32*K) - Ko;\n\tvec3 oy32 = mod(floor(p32*K), 7.0)*K - Ko;\n\tvec3 oz32 = floor(p32*K2)*Kz - Kzo;\n\n\tvec3 ox33 = fract(p33*K) - Ko;\n\tvec3 oy33 = mod(floor(p33*K), 7.0)*K - Ko;\n\tvec3 oz33 = floor(p33*K2)*Kz - Kzo;\n\n\tvec3 dx11 = Pfx + jitter*ox11;\n\tvec3 dy11 = Pfy.x + jitter*oy11;\n\tvec3 dz11 = Pfz.x + jitter*oz11;\n\n\tvec3 dx12 = Pfx + jitter*ox12;\n\tvec3 dy12 = Pfy.x + jitter*oy12;\n\tvec3 dz12 = Pfz.y + jitter*oz12;\n\n\tvec3 dx13 = Pfx + jitter*ox13;\n\tvec3 dy13 = Pfy.x + jitter*oy13;\n\tvec3 dz13 = Pfz.z + jitter*oz13;\n\n\tvec3 dx21 = Pfx + jitter*ox21;\n\tvec3 dy21 = Pfy.y + jitter*oy21;\n\tvec3 dz21 = Pfz.x + jitter*oz21;\n\n\tvec3 dx22 = Pfx + jitter*ox22;\n\tvec3 dy22 = Pfy.y + jitter*oy22;\n\tvec3 dz22 = Pfz.y + jitter*oz22;\n\n\tvec3 dx23 = Pfx + jitter*ox23;\n\tvec3 dy23 = Pfy.y + jitter*oy23;\n\tvec3 dz23 = Pfz.z + jitter*oz23;\n\n\tvec3 dx31 = Pfx + jitter*ox31;\n\tvec3 dy31 = Pfy.z + jitter*oy31;\n\tvec3 dz31 = Pfz.x + jitter*oz31;\n\n\tvec3 dx32 = Pfx + jitter*ox32;\n\tvec3 dy32 = Pfy.z + jitter*oy32;\n\tvec3 dz32 = Pfz.y + jitter*oz32;\n\n\tvec3 dx33 = Pfx + jitter*ox33;\n\tvec3 dy33 = Pfy.z + jitter*oy33;\n\tvec3 dz33 = Pfz.z + jitter*oz33;\n\n\tvec3 d11 = dist(dx11, dy11, dz11, manhattanDistance);\n\tvec3 d12 =dist(dx12, dy12, dz12, manhattanDistance);\n\tvec3 d13 = dist(dx13, dy13, dz13, manhattanDistance);\n\tvec3 d21 = dist(dx21, dy21, dz21, manhattanDistance);\n\tvec3 d22 = dist(dx22, dy22, dz22, manhattanDistance);\n\tvec3 d23 = dist(dx23, dy23, dz23, manhattanDistance);\n\tvec3 d31 = dist(dx31, dy31, dz31, manhattanDistance);\n\tvec3 d32 = dist(dx32, dy32, dz32, manhattanDistance);\n\tvec3 d33 = dist(dx33, dy33, dz33, manhattanDistance);\n\n\tvec3 d1a = min(d11, d12);\n\td12 = max(d11, d12);\n\td11 = min(d1a, d13); // Smallest now not in d12 or d13\n\td13 = max(d1a, d13);\n\td12 = min(d12, d13); // 2nd smallest now not in d13\n\tvec3 d2a = min(d21, d22);\n\td22 = max(d21, d22);\n\td21 = min(d2a, d23); // Smallest now not in d22 or d23\n\td23 = max(d2a, d23);\n\td22 = min(d22, d23); // 2nd smallest now not in d23\n\tvec3 d3a = min(d31, d32);\n\td32 = max(d31, d32);\n\td31 = min(d3a, d33); // Smallest now not in d32 or d33\n\td33 = max(d3a, d33);\n\td32 = min(d32, d33); // 2nd smallest now not in d33\n\tvec3 da = min(d11, d21);\n\td21 = max(d11, d21);\n\td11 = min(da, d31); // Smallest now in d11\n\td31 = max(da, d31); // 2nd smallest now not in d31\n\td11.xy = (d11.x < d11.y) ? d11.xy : d11.yx;\n\td11.xz = (d11.x < d11.z) ? d11.xz : d11.zx; // d11.x now smallest\n\td12 = min(d12, d21); // 2nd smallest now not in d21\n\td12 = min(d12, d22); // nor in d22\n\td12 = min(d12, d31); // nor in d31\n\td12 = min(d12, d32); // nor in d32\n\td11.yz = min(d11.yz,d12.xy); // nor in d12.yz\n\td11.y = min(d11.y,d12.z); // Only two more to go\n\td11.y = min(d11.y,d11.z); // Done! (Phew!)\n\treturn sqrt(d11.xy); // F1, F2\n\n}\n\n        vec3 cellular( vec3 pos, float scale, float jitter, float mode, float strength ) {\n          vec2 w = worley( pos, jitter, false );\n          vec3 o;\n          if( mode == 0. ) {\n            o = vec3( w.x );\n          } else if ( mode == 1. ) {\n            o = vec3( w.y );\n          } else{\n            o = vec3( w.y - w.x );\n          }\n\n          return o * strength;\n        }\n\n        vec3 cellular2d( vec2 st, float scale, float jitter, float mode, float strength, float time ) {\n          return cellular( vec3(st * scale, time), nor, scale, jitter, mode, strength );\n        }\n    ",""]),
    parameters: [
      { name:'scale', type:'float', default:1 },
      { name:'jitter', type:'float', default:1 },
      { name:'type',  type:'float', default: 0 },
      { name:'strength', type:'float', default:2 },
      { name:'time', type:'float', default:1 }
    ],     
  },

  voronoi: {
    name:'voronoi',
    parameters: [
      { name:'scale', type:'float', default:1 },
      { name:'res', type:'float', default:100 },
      { name:'time', type:'float', default:1 },
      { name:'mode', type:'float', default:0 }
    ],
    glsl:`
    vec3 voronoi_hash(vec3 p) {
      return fract(
          sin(vec3(dot(p, vec3(1.0, 57.0, 113.0)), dot(p, vec3(57.0, 113.0, 1.0)),
                   dot(p, vec3(113.0, 1.0, 57.0)))) *
          43758.5453);
    }

    vec3 voronoi_3d(const in vec3 x, float _res ) {
      vec3 p = floor(x);
      vec3 f = fract(x);

      float id = 0.0;
      vec2 res = vec2( _res );
      for (int k = -1; k <= 1; k++) {
        for (int j = -1; j <= 1; j++) {
          for (int i = -1; i <= 1; i++) {
            vec3 b = vec3(float(i), float(j), float(k));
            vec3 r = vec3(b) - f + voronoi_hash(p + b);
            float d = dot(r, r);

            float cond = max(sign(res.x - d), 0.0);
            float nCond = 1.0 - cond;

            float cond2 = nCond * max(sign(res.y - d), 0.0);
            float nCond2 = 1.0 - cond2;

            id = (dot(p + b, vec3(1.0, 57.0, 113.0)) * cond) + (id * nCond);
            res = vec2(d, res.x) * cond + res * nCond;

            res.y = cond2 * d + nCond2 * res.y;
          }
        }
      }

      return vec3(sqrt(res), abs(id));
    }

    vec3 voronoi( vec3 pos, float scale, float res, float time, float mode ) {
      vec3 v = voronoi_3d( pos * scale, res );
      vec3 fin;
      if( mode == 0. ) fin = vec3(v.x);
      if( mode == 1. ) fin = vec3(v.y);
      if( mode == 2. ) fin = vec3(v.y - v.x); 

      return fin;
    }
`,
    glsl2d:glsl(["#define GLSLIFY 1\n    \n    vec3 voronoi_hash(vec3 p) {\n      return fract(\n          sin(vec3(dot(p, vec3(1.0, 57.0, 113.0)), dot(p, vec3(57.0, 113.0, 1.0)),\n                   dot(p, vec3(113.0, 1.0, 57.0)))) * 43758.5453);\n    }\n\n    vec3 voronoi_3d(const in vec3 x, float _res ) {\n      vec3 p = floor(x);\n      vec3 f = fract(x);\n\n      float id = 0.0;\n      vec2 res = vec2( _res );\n      for (int k = -1; k <= 1; k++) {\n        for (int j = -1; j <= 1; j++) {\n          for (int i = -1; i <= 1; i++) {\n            vec3 b = vec3(float(i), float(j), float(k));\n            vec3 r = vec3(b) - f + voronoi_hash(p + b);\n            float d = dot(r, r);\n\n            float cond = max(sign(res.x - d), 0.0);\n            float nCond = 1.0 - cond;\n\n            float cond2 = nCond * max(sign(res.y - d), 0.0);\n            float nCond2 = 1.0 - cond2;\n\n            id = (dot(p + b, vec3(1.0, 57.0, 113.0)) * cond) + (id * nCond);\n            res = vec2(d, res.x) * cond + res * nCond;\n\n            res.y = cond2 * d + nCond2 * res.y;\n          }\n        }\n      }\n\n      return vec3(sqrt(res), abs(id));\n    }\n\n    vec3 voronoi2d( vec2 st, float scale, float res, float time, float mode ) {\n      vec3 v = voronoi_3d( vec3(st* scale, time), res );\n      vec3 fin;\n      if( mode == 0. ) fin = vec3(v.x);\n      if( mode == 1. ) fin = vec3(v.y);\n      if( mode == 2. ) fin = vec3(v.y - v.x); \n\n      return fin;\n    }\n\n",""]) ,
  },
  // adapted from https://thebookofshaders.com/edit.php#09/zigzag.frag
  zigzag: {
    name:'zigzag',
    glsl2d:`    
       vec2 mirrorTile(vec2 _st, float _zoom){
         _st *= _zoom;
         if (fract(_st.y * 0.5) > 0.5){
           _st.x = _st.x+0.5;
           _st.y = 1.0-_st.y;
         }
         return fract(_st);
       }

       float fillY(vec2 _st, float _pct,float _antia){
         return smoothstep( _pct-_antia, _pct, _st.y);
       }

       vec3 zigzag2d( vec2 st, float scale, float time ) {
         st = mirrorTile(st*vec2(1.,2.),scale);
         float x = st.x*2.;
         float a = floor(1.+sin(x*3.14));
         float b = floor(1.+sin((x+1.)*3.14));
         float f = fract(x);

         vec3 color = vec3( fillY(st,mix(a,b,f),0.01) ); 

         return vec3(color);
       }
` ,
    parameters: [
      { name:'scale', type:'float', default:5 },
      { name:'time', type:'float', default:1 }
    ],
  }
}

module.exports = textures

},{"glslify":121}],26:[function(require,module,exports){
module.exports = `
    // p = point on surface, p0 = object center
    vec2 getUVCubic(vec3 p ){
      vec3 absp = abs(p);
        
      // First conditional: If the point is in one of the sextants to the 
      // left or right of the x-axis, the uv cordinate will be (0.5*p.zy)/(p.x).
      // If you trace a line out to a zy plane that is 0.5 units from the zero origin,  
      // (0.5*p.xyz)/(p.x) will be the result, and
      // the yz components will be our uv coordinates, hence (0.5*p.zy)/(p.x).

      vec2 uv = ((absp.x>=absp.y)&&(absp.x>=absp.z)) 
        ? (0.5*p.zy)/(p.x) 
        : ((absp.y>=absp.z)&&(absp.y>=absp.x)) ? (0.5*p.xz)/(p.y) : (-0.5*p.xy)/(p.z);

      //We still need to determine which side our uv cordinates are on so
      //that the texture orients the right way. Note that there's some 
      // redundancy there, which I'll fix at some stage. For now, it works, so I'm not touching it. :)
      if( ((p.x<0.)&&(absp.x>=absp.y)&&(absp.x>=absp.z)) 
       || ((p.y<0.)&&(absp.y>=absp.z)&&(absp.y>=absp.x)) 
       || ((p.z>0.)&&(absp.z>=absp.x)&&(absp.z>=absp.y)) ) uv.y*=-1.;
             
      // Mapping the uv range from [-0.5, 0.5] to [0.0, 1.0].
      return (uv+0.5);
    }
    vec4 triplanar(vec3 n, vec4 texx, vec4 texy, vec4 texz, bool adjust3d, bool rescale) {
      //if (doflipz) n.z = -n.z;
      if (rescale) {
        texx = 2.0*texx - 1.0;
        texy = 2.0*texy - 1.0;
        texz = 2.0*texz - 1.0;
      }
      if (adjust3d) {
        texx.x *= sign(n.x);
        texy.y *= sign(n.y);
        texz.z *= sign(n.z);
      }
      //if (justtexy) return texy;
      vec3 weights = abs(n);
      //if (doweightcorrection) weights /= dot(weights,vec3(1)); // Keep spherical!
        return mat4(texx,texy,texz,vec4(0))*vec4(weights,0);
    } 
    `
/*
module.exports = `vec3 t3(sampler2D tex, vec3 p, vec3 n)
{
  mat3 R = mat3(vec3(cos(T),sin(T),0),vec3(-sin(T),cos(T),0),vec3(0,0,-1));
  p *= R/8.0;
  n *= R;
  #ifdef Smooth
  return  (texture(tex,p.xy).rgb*n.z*n.z
    +texture(tex,p.zy).rgb*n.x*n.x
    +texture(tex,p.xz).rgb*n.y*n.y);
  #else
    return (texture(tex,p.xy).rgb
      +texture(tex,p.zy).rgb
      +texture(tex,p.xz).rgb)/3.0;
    #endif
    }`
    */

},{}],27:[function(require,module,exports){
const { param_wrap, MaterialID } = require( './utils.js' )
const { Var, float_var_gen, vec2_var_gen, vec3_var_gen, vec4_var_gen, int_var_gen, VarAlloc }  = require( './var.js' )
const Matrix = require( './external/matrix.js' )
window.Matrix = Matrix
const MatrixWrap = function ( shouldInvert = false ) {
  const m = Object.create( MatrixWrap.prototype )
  m.dirty = true
  m.translation = {}
  m.scale = {}
  m.shouldInvert = shouldInvert
  m.rotation = {
    axis: {}
  }
  m.parent = null

  let tx = 0, ty = 0, tz = 0
  Object.defineProperties( m.translation, {
    x: {
      get() { return tx },
      set(v){
        tx = v
        //m.__data = m.__data.multiply( Matrix.translate( tx, ty, tz ) )
        m.dirty = true
      }
    },
    y: {
      get() { return ty },
      set(v){
        ty = v
        //m.__data = m.__data.multiply( Matrix.translate( tx, ty, tz ) )
        m.dirty = true
      }
    },
    z: {
      get() { return tz },
      set(v){
        tz = v
        //m.__data = m.__data.multiply( Matrix.translate( tx, ty, tz ) )
        m.dirty = true
      }
    },
  })

  // scaling must be sent as separate uniform to avoid sdf over estimation 
  let scale = 1
  Object.defineProperty( m,'scale', {
    get() { return scale },
    set(v){
      scale = v
      //m.__data = m.__data.multiply( Matrix.rotate( angle, rx, ry, rz ) )
      m.dirty = true
    } 
  })

  /* FOR NON-UNIFORM SCALING:
   *
   * 1. comment out scale property above
   * 2. uncomment scale property below
   * 3. change emit_decl to use a vec3 for scale
   * 4. change upload_data to upload a 3f
   * 5. In "primitives.js", replace line 155 (part of emit) to use compensated scaling
   */ 

  //let sx = 1, sy = 1, sz = 1
  //Object.defineProperties( m.scale, {
  //  x: {
  //    get() { return sx },
  //    set(v){
  //      sx = v
  //      //m.__data = m.__data.multiply( Matrix.scale( sx, sy, sz ) )
  //      m.dirty = true
  //    }
  //  },
  //  y: {
  //    get() { return sy },
  //    set(v){
  //      sy = v
  //      //m.__data = m.__data.multiply( Matrix.scale( sx, sy, sz ) )
  //      m.dirty = true
  //    }
  //  },
  //  z: {
  //    get() { return sz },
  //    set(v){
  //      sz = v
  //      //m.__data = m.__data.multiply( Matrix.scale( sx, sy, sz ) )
  //      m.dirty = true
  //    }
  //  },
  //})

  let angle = 0
  Object.defineProperty( m.rotation, 'angle', {
    get() { return angle },
    set(v){
      angle = v
      //m.__data = m.__data.multiply( Matrix.rotate( angle, rx, ry, rz ) )
      m.dirty = true
    } 
  })

  let rx = 0, ry = 0, rz = 0
  Object.defineProperties( m.rotation.axis, {
    x: {
      get() { return rx },
      set(v){
        rx = v
        //m.__data = m.__data = Matrix.rotate( angle, rx, ry, rz, m.__data )
        m.dirty = true
      }
    },
    y: {
      get() { return ry },
      set(v){
        ry = v
        //m.__data = m.__data = Matrix.rotate( angle, rx, ry, rz, m.__data )
        m.dirty = true
      }
    },
    z: {
      get() { return rz },
      set(v){
        rz = v
        //m.__data = m.__data = Matrix.rotate( angle, rx, ry, rz, m.__data )
        m.dirty = true
      }
    },
  })

  m.__rotations = []
  m.__id   = VarAlloc.alloc()  
  m.__dirty = function() {}
  m.__data = Matrix.identity()
  m.__Matrix = Matrix
  m.varName = 'transform' + m.__id

  return m
}

MatrixWrap.prototype = {
  type: 'matrix',

  emit() { return this.varName },

  emit_scale() { return this.varName + '_scale' },

  emit_decl() { 
    const decl =  `    uniform mat4 ${this.varName};
    uniform float ${this.varName}_scale;
    ` 

    return decl
  },

	update_location(gl, program) {
		this.loc = gl.getUniformLocation( program, this.varName )
		this.loc_scale = gl.getUniformLocation( program, this.varName+'_scale' )
	},	

	upload_data(gl) {
		if( !this.dirty ) return
		
    this.internal()

    if( this.shouldInvert === true ) {
      const inverse = Matrix.inverse( this.__data )
      gl.uniformMatrix4fv( this.loc, false, inverse.m )
    }else{
      gl.uniformMatrix4fv( this.loc, false, this.__data.m )
    }
    //gl.uniform3f(this.loc_scale, this.scale.x, this.scale.y, this.scale.z )
    
    // scaling must be sent as separate uniform to avoid sdf over-estimation 
    gl.uniform1f(this.loc_scale, this.scale )

		this.dirty = false
  },


  internal() {
    this.__data = Matrix.identity()
    if( this.parent != null ) this.__data = this.parent.__data

    this.__data = this.__data.multiply( Matrix.translate( this.translation.x, this.translation.y, this.translation.z ) ) 

    // handle cumulative rotations via .rotateBy() method
    this.__rotations.forEach( r => this.__data = this.__data.multiply( r ) )

    // handle absolute rotations via .rotate() method... should this be aliased to rotateTo() ?
    this.__data = this.__data.multiply( Matrix.rotate( this.rotation.angle, this.rotation.axis.x, this.rotation.axis.y, this.rotation.axis.z ) )

    this.__data = this.__data.multiply( Matrix.scale( this.scale, this.scale, this.scale ) )
  },

  invert( shouldInvert = true) {
    this.shouldInvert = shouldInvert
    this.dirty = true
  },

  apply( transform = null, shouldInvert = false ) {
    this.parent = transform
    this.dirty = true
  } 

}

module.exports = MatrixWrap

},{"./external/matrix.js":9,"./utils.js":28,"./var.js":29}],28:[function(require,module,exports){
const Var = require('./var.js').Var
const { Vec2, Vec3, Vec4 } = require( './vec.js' )

// Wrapper
function param_wrap( v, __default, name=null ) {
	if( v === undefined || v === null ) return __default()
	if( v.__isVar === true ) return v
	
	return Var( v, name )
}

const MaterialID = {
	current: 0,
	alloc() {
		return MaterialID.current++
  },
  clear() {
    MaterialID.current = 0
  }
}

const processVec2 = function( val ) {
  if( typeof val === 'number' ) 
    val = Vec2( color )
  else if( Array.isArray( val ) ) 
    val = Vec2( val[0], val[1] )

  return val
}

const processVec3 = function( val ) {
  if( typeof val === 'number' ) 
    val = Vec3( val )
  else if( Array.isArray( val ) ) 
    val = Vec3( val[0], val[1], val[2] )

  return val
}

module.exports = { param_wrap, MaterialID, processVec2, processVec3 }

},{"./var.js":29,"./vec.js":30}],29:[function(require,module,exports){
const { Vec2, Vec3, Vec4 } = require( './vec.js' )
const float = require( './float.js' )
const int   = require( './int.js' )

// Var
const VarAlloc = {
	current: 0,
  clear() {
    VarAlloc.current = 0
  },
	alloc() {
		return VarAlloc.current++
	}
}

const Var = function( value, fixedName = null, __type ) {
  const v = Object.create( Var.prototype )
	v.varName = fixedName !== null ? fixedName : 'var' + VarAlloc.alloc()
  v.value = value
  v.type = v.value.type
  if( v.type === undefined ) v.type = __type || 'float' 

  value.var = v

  if( v.type !== 'float' && v.type !== 'int' ) {
    Object.defineProperties( v, {
      x: {
        get() { return this.value.x },
        set(v){ this.value.x = v; this.dirty = true }
      },
      y: {
        get() { return this.value.y },
        set(v){ this.value.y = v; this.dirty = true }
      },
      z: {
        get() { return this.value.z },
        set(v){ this.value.z = v; this.dirty = true }
      },
      w: {
        get() { return this.value.w },
        set(v){ this.value.w = v; this.dirty = true }
      },
      r: {
        get() { return this.value.x },
        set(v){ this.value.x = v; this.dirty = true }
      },
      g: {
        get() { return this.value.y },
        set(v){ this.value.y = v; this.dirty = true }
      },
      b: {
        get() { return this.value.z },
        set(v){ this.value.z = v; this.dirty = true }
      },
    })
  }

  return v
}

Var.hardcode = false
const emit_float = function( a ) {
	if (a % 1 === 0)
		return a.toFixed( 1 )
	else
		return a
}

Var.prototype = {
	dirty: true,

	loc: -1,

  emit() { 
    let out
    if( this.value.isGen ) {
      const vecOut = this.value.emit() 
      out = vecOut.preface + vecOut.out
        
    }else{
      out = this.varName 
    } 

    return out
  },

  emit_decl() { 
    let out = ''
    if( this.value.isGen ) {
      out = this.value.emit_decl()
    }else{
      if( Var.hardcode === true ) {

        if( typeof this.value.emit !== 'function' ) {
          if( this.type === 'float' ) {
            out = `${this.type} ${this.varName} = ${emit_float(this.value)};\n`
          }else{
            out = `${this.type} ${this.varName} = ${this.value};\n`
          }
        }else{
          let val = this.value.emit()
          if( typeof val !== 'string' ) val = val.out
          out = val !== undefined ? `${this.type} ${this.varName} = ${val};\n` : ''
        }
      }else{
        out = `uniform ${this.type} ${this.varName};\n`
      }
    }
    return out
  },

	set(v) { this.value = v; this.dirty = true; },

	update_location(gl, program) {
    if( this.value.isGen ) {
      this.value.update_location( gl, program )
      return
    }
		this.loc = gl.getUniformLocation(program, this.varName)
	},	

	upload_data(gl) {
		if( !this.dirty ) return
		
    if( this.value.isGen ) {
      this.value.upload_data( gl  )
      this.dirty = false
      return
    }
		let v = this.value
		if (typeof v === 'number' ) {
			gl.uniform1f( this.loc, v )
		}else if ( v instanceof Vec2 ) {
			gl.uniform2f(this.loc, v.x, v.y )
		} else if( v instanceof Vec3 ) {
			gl.uniform3f(this.loc, v.x, v.y, v.z )
		} else if( v instanceof Vec4 ) {
			gl.uniform4f(this.loc, v.x, v.y, v.z, v.w )
    } else {
      // for color variables
      if( this.type === 'float' ) {
        gl.uniform1f( this.loc, v.x )
      }else{
        gl.uniform1i( this.loc, v.x )
      }
    }

		this.dirty = false
	}
}


function int_var_gen(x,name=null) { 
  let output = ()=> {
    let out = Var( int(x), name, 'int' ) 
    return out
  }

  return output
}
function float_var_gen(x,name=null) { return ()=> { return Var( float(x), name, 'float' ) } }

function vec2_var_gen(x, y,name=null) { 
  return ()=> Var( Vec2(x, y), name  ) 
}

function vec3_var_gen(x=0, y, z,name=null) { 
  return ()=> Var( Vec3(x, y, z), name ) 
}

function vec4_var_gen( x, y, z, w, name=null ) { 
  return Var( Vec4( x, y, z, w ), name ) 
}
//function float_var_gen(x,name=null) { return ()=> { return Var( float(x), name, 'float' ) } }

//function vec2_var_gen(x, y,name=null) { return ()=> Var( Vec2(x, y), name  ) }

//function vec3_var_gen(x, y, z,name=null) { return ()=> Var( Vec3(x, y, z), name ) }

//function vec4_var_gen( x, y, z, w, name=null ) { return Var( Vec4( x, y, z, w ), name ) }

module.exports = { Var, float_var_gen, vec2_var_gen, vec3_var_gen, vec4_var_gen, int_var_gen, VarAlloc }

/*function float_var_gen(x,name=null) { return ()=> { return Var( float(x), name, 'float' ) } }

function vec2_var_gen(x, y,name=null) { 
  if( y === undefined ) y = x
  return ()=> Var( Vec2(x, y), name  ) 
}

function vec3_var_gen(x, y, z,name=null) { 
  if( y === undefined ) y = x
  if( z === undefined ) z = x
  return ()=> Var( Vec3(x, y, z), name ) 
}

function vec4_var_gen( x, y, z, w, name=null ) { 
  if( y === undefined ) y = x
  if( z === undefined ) z = x
  if( w === undefined ) w = x
  return Var( Vec4( x, y, z, w ), name ) 
}
*/

},{"./float.js":10,"./int.js":13,"./vec.js":30}],30:[function(require,module,exports){
const Vec2 = function (x=0, y=0) {
  if( x.type === 'vec2' ) return x  
  const v = Object.create( Vec2.prototype )
  if( Array.isArray( x ) ) {
    v.x = x[0]; v.y = x[1]; 
  } else if( y === undefined ) {
    v.x = v.y = x
  }else{
    v.x = x; v.y = y; 
  }

  return v
}

Vec2.prototype = {
  type: 'vec2',
	emit() { return "vec2(" + this.x + "," + this.y + ")" },
  emit_decl() { return ""; },
  copy() {
    return Vec2( this.x, this.y )
  }
}

const Vec3 = function (x=0, y, z) {
  if( x.type === 'vec3' ) return x  
  const v = Object.create( Vec3.prototype )
  let vx =0,vy=0,vz=0
  Object.defineProperties( v, {
    x: {
      get()  { return vx },
      set(v) { vx = v; this.dirty = true; }
    },

    y: {
      get()  { return vy },
      set(v) { vy = v; this.dirty = true; }
    },

    z: {
      get()  { return vz },
      set(v) { vz = v; this.dirty = true; }
    },
    r: {
      get()  { return vx },
      set(v) { vx = v; this.dirty = true; }
    },

    g: {
      get()  { return vy },
      set(v) { vy = v; this.dirty = true; }
    },

    b: {
      get()  { return vz },
      set(v) { vz = v; this.dirty = true; }
    },

  })

  if( Array.isArray( x ) ) {
    v.x = x[0]; v.y = x[1]; v.z = x[2]; 
  } else if( y === undefined && z === undefined) {
    v.x = v.y = v.z = x
  }else{
    v.x = x; v.y = y; v.z = z;
  }
 
  v.isGen = v.x.type === 'string' || v.y.type === 'string' || v.z.type === 'string'
  return v
};

Vec3.prototype = {
  type: 'vec3',
  emit() { 
    let out = `vec3(`
    let preface = ''

    if( this.x.type === 'string' ) {
      const xout = this.x.emit()
      out += xout.out + ','
    }else{
      out += this.x + ','
    }

    if( this.y.type === 'string' ) {
      const yout = this.y.emit()
      out += yout.out + ',' 
    }else{
      out += this.y + ','
    }
    if( this.z.type === 'string' ) {
      const zout = this.z.emit()
      out += zout.out
    }else{
      out += this.z 
    }

    out += ')'

    return { out, preface }
  },
  emit_decl() { 
    let out = ''
    if( this.x.type === 'string' ) {
      out += this.x.emit_decl()
    } 
    if( this.y.type === 'string' && this.x !== this.y  ) {
      out += this.y.emit_decl()
    } 
    if( this.z.type === 'string' && this.z !== this.y && this.z !== this.x ) {
      out += this.z.emit_decl()
    } 
    return out
  },

	update_location(gl, program) {
    if( this.isGen ) {
      if( this.x.type === 'string' ) {
        this.x.update_location(gl,program)
      } 
      if( this.y.type === 'string' && this.x !== this.y  ) {
        this.y.update_location(gl,program)
      } 
      if( this.z.type === 'string' && this.z !== this.y && this.z !== this.x ) {
        this.z.update_location(gl,program)
      }      
    }
  },
  
  upload_data(gl) {
    if( this.isGen ) {
      if( this.x.type === 'string' ) {
        this.x.upload_data(gl)
      } 
      if( this.y.type === 'string' && this.x !== this.y  ) {
        this.y.upload_data(gl)
      } 
      if( this.z.type === 'string' && this.z !== this.y && this.z !== this.x ) {
        this.z.upload_data(gl)
      }      
    }
  },

  copy() {
    return Vec3( this.x, this.y, this.z )
  }

}

const Vec4 = function (x=0, y, z, w) {
  if( x.type === 'vec4' ) return x
  const v = Object.create( Vec4.prototype )

  if( Array.isArray( x ) ) {
    v.x = x[0]; v.y = x[1]; v.z = x[2]; v.w = x[3] 
  } else if( y === undefined && z === undefined) {
    v.x = v.y = v.z = v.w = x
  }else{
    v.x = x; v.y = y; v.z = z; v.w = w;;
  }

  v.isGen = v.x.type === 'string' || v.y.type === 'string' || v.z.type === 'string'

  return v
};

Vec4.prototype = {
  type: 'vec4',
  emit() { 
    let out = `vec4(`
    let preface = ''

    if( this.x.type === 'string' ) {
      const xout = this.x.emit()
      out += xout.out + ','
    }else{
      out += this.x + ','
    }

    if( this.y.type === 'string' ) {
      const yout = this.y.emit()
      out += yout.out + ',' 
    }else{
      out += this.y + ','
    }

    if( this.z.type === 'string' ) {
      const zout = this.z.emit()
      out += zout.out
    }else{
      out += this.z 
    }
    
    if( this.w.type === 'string' ) {
      const wout = this.w.emit()
      out += wout.out
    }else{
      out += this.w 
    }

    out += ')'

    return { out, preface }
  },
  emit_decl() { 
    let out = ''
    if( this.x.type === 'string' ) {
      out += this.x.emit_decl()
    } 
    if( this.y.type === 'string' && this.x !== this.y  ) {
      out += this.y.emit_decl()
    } 
    if( this.z.type === 'string' && this.z !== this.y && this.z !== this.x ) {
      out += this.z.emit_decl()
    } 
    if( this.w.type === 'string' && this.w !== this.y && this.w !== this.x && this.w !== this.z ) {
      out += this.w.emit_decl()
    }
    return out
  },

	update_location(gl, program) {
    if( this.isGen ) {
      if( this.x.type === 'string' ) {
        this.x.update_location(gl,program)
      } 
      if( this.y.type === 'string' && this.x !== this.y  ) {
        this.y.update_location(gl,program)
      } 
      if( this.z.type === 'string' && this.z !== this.y && this.z !== this.x ) {
        this.z.update_location(gl,program)
      }      
      if( this.w.type === 'string' && this.w !== this.y && this.w !== this.x && this.w !== this.z ) {
        this.w.update_location(gl,program)
      }  
    }
  },
  
  upload_data(gl) {
    if( this.isGen ) {
      if( this.x.type === 'string' ) {
        this.x.upload_data(gl)
      } 
      if( this.y.type === 'string' && this.x !== this.y  ) {
        this.y.upload_data(gl)
      } 
      if( this.z.type === 'string' && this.z !== this.y && this.z !== this.x ) {
        this.z.upload_data(gl)
      } 
      if( this.w.type === 'string' && this.w !== this.y && this.w !== this.x && this.w !== this.z ) {
        this.w.upload_data(gl)
      }      
    }
  },

  copy() {
    return Vec4( this.x, this.y, this.z, this.w )
  }
}
// Vec4

//let Vec4 = function (x, y, z, w) {
//  const v = Object.create( Vec4.prototype )
//  v.x = x; v.y = y; v.z = z; v.w = w

//  return v
//};

//Vec4.prototype = {
//  type: 'vec4',
//  emit() { return "vec4(" + this.x + "," + this.y + "," + this.z + "," + this.w + ")"; },
//  emit_decl() { return ""; }
//}





module.exports = { Vec2, Vec3, Vec4 } 

},{}],31:[function(require,module,exports){
const SceneNode = require( './sceneNode.js' ),
      { param_wrap, MaterialID } = require( './utils.js' ),
      { Var, float_var_gen, vec2_var_gen, vec3_var_gen, vec4_var_gen, int_var_gen, VarAlloc } = require( './var.js' )

const Vignette = function( Scene, SDF ) {

  const Vgn = function( radius=0.1, smoothness=.1 ) {
    const vgn = Object.create( Vgn.prototype )
    const __radius = param_wrap( radius, float_var_gen( radius ) )  
    
    Object.defineProperty( vgn, 'radius', {
      get() { return __radius },
      set( v ) {
        __radius.set( v )
      }
    })

    const __smoothness = param_wrap( smoothness, float_var_gen( smoothness ) )  
    
    Object.defineProperty( vgn, 'smoothness', {
      get() { return __smoothness },
      set( v ) {
        __smoothness.set( v )
      }
    })
    
    // this refers to the current scene via implicit binding in scene.js
    this.postprocessing.push( vgn )

    return this
  }

  Vgn.prototype = SceneNode()
 
  Object.assign( Vgn.prototype, {
    emit() {
      return `  color *= vignette( v_uv, ${this.radius.emit()}, ${this.smoothness.emit()} );`
    },
   
    emit_decl() {
      let str = this.radius.emit_decl() + this.smoothness.emit_decl()
      // taken from https://gist.github.com/r-lyeh-archived/170b53fcdc0e17afcf15
      // originally iq
      const preface = `  float vignette(vec2 uv, float radius, float smoothness) {
        return radius + 0.5*16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y); 
      }
  `
      if( SDF.memo.vgn === undefined ) {
        str = str + preface
        SDF.memo.vgn = true
      }else{
        str = ''
      }

      return str
    },

    update_location( gl, program ) {
      this.radius.update_location( gl, program )
      this.smoothness.update_location( gl, program )
    },

    upload_data( gl ) {
      this.radius.upload_data( gl )
      this.smoothness.upload_data( gl )
    }
  })

  return Vgn
}

module.exports = Vignette 

},{"./sceneNode.js":23,"./utils.js":28,"./var.js":29}],32:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],33:[function(require,module,exports){
/**
 * Bit twiddling hacks for JavaScript.
 *
 * Author: Mikola Lysenko
 *
 * Ported from Stanford bit twiddling hack library:
 *    http://graphics.stanford.edu/~seander/bithacks.html
 */

"use strict"; "use restrict";

//Number of bits in an integer
var INT_BITS = 32;

//Constants
exports.INT_BITS  = INT_BITS;
exports.INT_MAX   =  0x7fffffff;
exports.INT_MIN   = -1<<(INT_BITS-1);

//Returns -1, 0, +1 depending on sign of x
exports.sign = function(v) {
  return (v > 0) - (v < 0);
}

//Computes absolute value of integer
exports.abs = function(v) {
  var mask = v >> (INT_BITS-1);
  return (v ^ mask) - mask;
}

//Computes minimum of integers x and y
exports.min = function(x, y) {
  return y ^ ((x ^ y) & -(x < y));
}

//Computes maximum of integers x and y
exports.max = function(x, y) {
  return x ^ ((x ^ y) & -(x < y));
}

//Checks if a number is a power of two
exports.isPow2 = function(v) {
  return !(v & (v-1)) && (!!v);
}

//Computes log base 2 of v
exports.log2 = function(v) {
  var r, shift;
  r =     (v > 0xFFFF) << 4; v >>>= r;
  shift = (v > 0xFF  ) << 3; v >>>= shift; r |= shift;
  shift = (v > 0xF   ) << 2; v >>>= shift; r |= shift;
  shift = (v > 0x3   ) << 1; v >>>= shift; r |= shift;
  return r | (v >> 1);
}

//Computes log base 10 of v
exports.log10 = function(v) {
  return  (v >= 1000000000) ? 9 : (v >= 100000000) ? 8 : (v >= 10000000) ? 7 :
          (v >= 1000000) ? 6 : (v >= 100000) ? 5 : (v >= 10000) ? 4 :
          (v >= 1000) ? 3 : (v >= 100) ? 2 : (v >= 10) ? 1 : 0;
}

//Counts number of bits
exports.popCount = function(v) {
  v = v - ((v >>> 1) & 0x55555555);
  v = (v & 0x33333333) + ((v >>> 2) & 0x33333333);
  return ((v + (v >>> 4) & 0xF0F0F0F) * 0x1010101) >>> 24;
}

//Counts number of trailing zeros
function countTrailingZeros(v) {
  var c = 32;
  v &= -v;
  if (v) c--;
  if (v & 0x0000FFFF) c -= 16;
  if (v & 0x00FF00FF) c -= 8;
  if (v & 0x0F0F0F0F) c -= 4;
  if (v & 0x33333333) c -= 2;
  if (v & 0x55555555) c -= 1;
  return c;
}
exports.countTrailingZeros = countTrailingZeros;

//Rounds to next power of 2
exports.nextPow2 = function(v) {
  v += v === 0;
  --v;
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v + 1;
}

//Rounds down to previous power of 2
exports.prevPow2 = function(v) {
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v - (v>>>1);
}

//Computes parity of word
exports.parity = function(v) {
  v ^= v >>> 16;
  v ^= v >>> 8;
  v ^= v >>> 4;
  v &= 0xf;
  return (0x6996 >>> v) & 1;
}

var REVERSE_TABLE = new Array(256);

(function(tab) {
  for(var i=0; i<256; ++i) {
    var v = i, r = i, s = 7;
    for (v >>>= 1; v; v >>>= 1) {
      r <<= 1;
      r |= v & 1;
      --s;
    }
    tab[i] = (r << s) & 0xff;
  }
})(REVERSE_TABLE);

//Reverse bits in a 32 bit word
exports.reverse = function(v) {
  return  (REVERSE_TABLE[ v         & 0xff] << 24) |
          (REVERSE_TABLE[(v >>> 8)  & 0xff] << 16) |
          (REVERSE_TABLE[(v >>> 16) & 0xff] << 8)  |
           REVERSE_TABLE[(v >>> 24) & 0xff];
}

//Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes
exports.interleave2 = function(x, y) {
  x &= 0xFFFF;
  x = (x | (x << 8)) & 0x00FF00FF;
  x = (x | (x << 4)) & 0x0F0F0F0F;
  x = (x | (x << 2)) & 0x33333333;
  x = (x | (x << 1)) & 0x55555555;

  y &= 0xFFFF;
  y = (y | (y << 8)) & 0x00FF00FF;
  y = (y | (y << 4)) & 0x0F0F0F0F;
  y = (y | (y << 2)) & 0x33333333;
  y = (y | (y << 1)) & 0x55555555;

  return x | (y << 1);
}

//Extracts the nth interleaved component
exports.deinterleave2 = function(v, n) {
  v = (v >>> n) & 0x55555555;
  v = (v | (v >>> 1))  & 0x33333333;
  v = (v | (v >>> 2))  & 0x0F0F0F0F;
  v = (v | (v >>> 4))  & 0x00FF00FF;
  v = (v | (v >>> 16)) & 0x000FFFF;
  return (v << 16) >> 16;
}


//Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes
exports.interleave3 = function(x, y, z) {
  x &= 0x3FF;
  x  = (x | (x<<16)) & 4278190335;
  x  = (x | (x<<8))  & 251719695;
  x  = (x | (x<<4))  & 3272356035;
  x  = (x | (x<<2))  & 1227133513;

  y &= 0x3FF;
  y  = (y | (y<<16)) & 4278190335;
  y  = (y | (y<<8))  & 251719695;
  y  = (y | (y<<4))  & 3272356035;
  y  = (y | (y<<2))  & 1227133513;
  x |= (y << 1);
  
  z &= 0x3FF;
  z  = (z | (z<<16)) & 4278190335;
  z  = (z | (z<<8))  & 251719695;
  z  = (z | (z<<4))  & 3272356035;
  z  = (z | (z<<2))  & 1227133513;
  
  return x | (z << 2);
}

//Extracts nth interleaved component of a 3-tuple
exports.deinterleave3 = function(v, n) {
  v = (v >>> n)       & 1227133513;
  v = (v | (v>>>2))   & 3272356035;
  v = (v | (v>>>4))   & 251719695;
  v = (v | (v>>>8))   & 4278190335;
  v = (v | (v>>>16))  & 0x3FF;
  return (v<<22)>>22;
}

//Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)
exports.nextCombination = function(v) {
  var t = v | (v - 1);
  return (t + 1) | (((~t & -~t) - 1) >>> (countTrailingZeros(v) + 1));
}


},{}],34:[function(require,module,exports){

},{}],35:[function(require,module,exports){
(function (Buffer){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')
var customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol.for === 'function')
    ? Symbol.for('nodejs.util.inspect.custom')
    : null

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    var proto = { foo: function () { return 42 } }
    Object.setPrototypeOf(proto, Uint8Array.prototype)
    Object.setPrototypeOf(arr, proto)
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof SharedArrayBuffer !== 'undefined' &&
      (isInstance(value, SharedArrayBuffer) ||
      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]]
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  } else if (typeof val === 'boolean') {
    val = Number(val)
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var hexSliceLookupTable = (function () {
  var alphabet = '0123456789abcdef'
  var table = new Array(256)
  for (var i = 0; i < 16; ++i) {
    var i16 = i * 16
    for (var j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
  }
  return table
})()

}).call(this,require("buffer").Buffer)

},{"base64-js":32,"buffer":35,"ieee754":122}],36:[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this,{"isBuffer":require("../../is-buffer/index.js")})

},{"../../is-buffer/index.js":125}],37:[function(require,module,exports){
"use strict"

var createThunk = require("./lib/thunk.js")

function Procedure() {
  this.argTypes = []
  this.shimArgs = []
  this.arrayArgs = []
  this.arrayBlockIndices = []
  this.scalarArgs = []
  this.offsetArgs = []
  this.offsetArgIndex = []
  this.indexArgs = []
  this.shapeArgs = []
  this.funcName = ""
  this.pre = null
  this.body = null
  this.post = null
  this.debug = false
}

function compileCwise(user_args) {
  //Create procedure
  var proc = new Procedure()
  
  //Parse blocks
  proc.pre    = user_args.pre
  proc.body   = user_args.body
  proc.post   = user_args.post

  //Parse arguments
  var proc_args = user_args.args.slice(0)
  proc.argTypes = proc_args
  for(var i=0; i<proc_args.length; ++i) {
    var arg_type = proc_args[i]
    if(arg_type === "array" || (typeof arg_type === "object" && arg_type.blockIndices)) {
      proc.argTypes[i] = "array"
      proc.arrayArgs.push(i)
      proc.arrayBlockIndices.push(arg_type.blockIndices ? arg_type.blockIndices : 0)
      proc.shimArgs.push("array" + i)
      if(i < proc.pre.args.length && proc.pre.args[i].count>0) {
        throw new Error("cwise: pre() block may not reference array args")
      }
      if(i < proc.post.args.length && proc.post.args[i].count>0) {
        throw new Error("cwise: post() block may not reference array args")
      }
    } else if(arg_type === "scalar") {
      proc.scalarArgs.push(i)
      proc.shimArgs.push("scalar" + i)
    } else if(arg_type === "index") {
      proc.indexArgs.push(i)
      if(i < proc.pre.args.length && proc.pre.args[i].count > 0) {
        throw new Error("cwise: pre() block may not reference array index")
      }
      if(i < proc.body.args.length && proc.body.args[i].lvalue) {
        throw new Error("cwise: body() block may not write to array index")
      }
      if(i < proc.post.args.length && proc.post.args[i].count > 0) {
        throw new Error("cwise: post() block may not reference array index")
      }
    } else if(arg_type === "shape") {
      proc.shapeArgs.push(i)
      if(i < proc.pre.args.length && proc.pre.args[i].lvalue) {
        throw new Error("cwise: pre() block may not write to array shape")
      }
      if(i < proc.body.args.length && proc.body.args[i].lvalue) {
        throw new Error("cwise: body() block may not write to array shape")
      }
      if(i < proc.post.args.length && proc.post.args[i].lvalue) {
        throw new Error("cwise: post() block may not write to array shape")
      }
    } else if(typeof arg_type === "object" && arg_type.offset) {
      proc.argTypes[i] = "offset"
      proc.offsetArgs.push({ array: arg_type.array, offset:arg_type.offset })
      proc.offsetArgIndex.push(i)
    } else {
      throw new Error("cwise: Unknown argument type " + proc_args[i])
    }
  }
  
  //Make sure at least one array argument was specified
  if(proc.arrayArgs.length <= 0) {
    throw new Error("cwise: No array arguments specified")
  }
  
  //Make sure arguments are correct
  if(proc.pre.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in pre() block")
  }
  if(proc.body.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in body() block")
  }
  if(proc.post.args.length > proc_args.length) {
    throw new Error("cwise: Too many arguments in post() block")
  }

  //Check debug flag
  proc.debug = !!user_args.printCode || !!user_args.debug
  
  //Retrieve name
  proc.funcName = user_args.funcName || "cwise"
  
  //Read in block size
  proc.blockSize = user_args.blockSize || 64

  return createThunk(proc)
}

module.exports = compileCwise

},{"./lib/thunk.js":39}],38:[function(require,module,exports){
"use strict"

var uniq = require("uniq")

// This function generates very simple loops analogous to how you typically traverse arrays (the outermost loop corresponds to the slowest changing index, the innermost loop to the fastest changing index)
// TODO: If two arrays have the same strides (and offsets) there is potential for decreasing the number of "pointers" and related variables. The drawback is that the type signature would become more specific and that there would thus be less potential for caching, but it might still be worth it, especially when dealing with large numbers of arguments.
function innerFill(order, proc, body) {
  var dimension = order.length
    , nargs = proc.arrayArgs.length
    , has_index = proc.indexArgs.length>0
    , code = []
    , vars = []
    , idx=0, pidx=0, i, j
  for(i=0; i<dimension; ++i) { // Iteration variables
    vars.push(["i",i,"=0"].join(""))
  }
  //Compute scan deltas
  for(j=0; j<nargs; ++j) {
    for(i=0; i<dimension; ++i) {
      pidx = idx
      idx = order[i]
      if(i === 0) { // The innermost/fastest dimension's delta is simply its stride
        vars.push(["d",j,"s",i,"=t",j,"p",idx].join(""))
      } else { // For other dimensions the delta is basically the stride minus something which essentially "rewinds" the previous (more inner) dimension
        vars.push(["d",j,"s",i,"=(t",j,"p",idx,"-s",pidx,"*t",j,"p",pidx,")"].join(""))
      }
    }
  }
  if (vars.length > 0) {
    code.push("var " + vars.join(","))
  }  
  //Scan loop
  for(i=dimension-1; i>=0; --i) { // Start at largest stride and work your way inwards
    idx = order[i]
    code.push(["for(i",i,"=0;i",i,"<s",idx,";++i",i,"){"].join(""))
  }
  //Push body of inner loop
  code.push(body)
  //Advance scan pointers
  for(i=0; i<dimension; ++i) {
    pidx = idx
    idx = order[i]
    for(j=0; j<nargs; ++j) {
      code.push(["p",j,"+=d",j,"s",i].join(""))
    }
    if(has_index) {
      if(i > 0) {
        code.push(["index[",pidx,"]-=s",pidx].join(""))
      }
      code.push(["++index[",idx,"]"].join(""))
    }
    code.push("}")
  }
  return code.join("\n")
}

// Generate "outer" loops that loop over blocks of data, applying "inner" loops to the blocks by manipulating the local variables in such a way that the inner loop only "sees" the current block.
// TODO: If this is used, then the previous declaration (done by generateCwiseOp) of s* is essentially unnecessary.
//       I believe the s* are not used elsewhere (in particular, I don't think they're used in the pre/post parts and "shape" is defined independently), so it would be possible to make defining the s* dependent on what loop method is being used.
function outerFill(matched, order, proc, body) {
  var dimension = order.length
    , nargs = proc.arrayArgs.length
    , blockSize = proc.blockSize
    , has_index = proc.indexArgs.length > 0
    , code = []
  for(var i=0; i<nargs; ++i) {
    code.push(["var offset",i,"=p",i].join(""))
  }
  //Generate loops for unmatched dimensions
  // The order in which these dimensions are traversed is fairly arbitrary (from small stride to large stride, for the first argument)
  // TODO: It would be nice if the order in which these loops are placed would also be somehow "optimal" (at the very least we should check that it really doesn't hurt us if they're not).
  for(var i=matched; i<dimension; ++i) {
    code.push(["for(var j"+i+"=SS[", order[i], "]|0;j", i, ">0;){"].join("")) // Iterate back to front
    code.push(["if(j",i,"<",blockSize,"){"].join("")) // Either decrease j by blockSize (s = blockSize), or set it to zero (after setting s = j).
    code.push(["s",order[i],"=j",i].join(""))
    code.push(["j",i,"=0"].join(""))
    code.push(["}else{s",order[i],"=",blockSize].join(""))
    code.push(["j",i,"-=",blockSize,"}"].join(""))
    if(has_index) {
      code.push(["index[",order[i],"]=j",i].join(""))
    }
  }
  for(var i=0; i<nargs; ++i) {
    var indexStr = ["offset"+i]
    for(var j=matched; j<dimension; ++j) {
      indexStr.push(["j",j,"*t",i,"p",order[j]].join(""))
    }
    code.push(["p",i,"=(",indexStr.join("+"),")"].join(""))
  }
  code.push(innerFill(order, proc, body))
  for(var i=matched; i<dimension; ++i) {
    code.push("}")
  }
  return code.join("\n")
}

//Count the number of compatible inner orders
// This is the length of the longest common prefix of the arrays in orders.
// Each array in orders lists the dimensions of the correspond ndarray in order of increasing stride.
// This is thus the maximum number of dimensions that can be efficiently traversed by simple nested loops for all arrays.
function countMatches(orders) {
  var matched = 0, dimension = orders[0].length
  while(matched < dimension) {
    for(var j=1; j<orders.length; ++j) {
      if(orders[j][matched] !== orders[0][matched]) {
        return matched
      }
    }
    ++matched
  }
  return matched
}

//Processes a block according to the given data types
// Replaces variable names by different ones, either "local" ones (that are then ferried in and out of the given array) or ones matching the arguments that the function performing the ultimate loop will accept.
function processBlock(block, proc, dtypes) {
  var code = block.body
  var pre = []
  var post = []
  for(var i=0; i<block.args.length; ++i) {
    var carg = block.args[i]
    if(carg.count <= 0) {
      continue
    }
    var re = new RegExp(carg.name, "g")
    var ptrStr = ""
    var arrNum = proc.arrayArgs.indexOf(i)
    switch(proc.argTypes[i]) {
      case "offset":
        var offArgIndex = proc.offsetArgIndex.indexOf(i)
        var offArg = proc.offsetArgs[offArgIndex]
        arrNum = offArg.array
        ptrStr = "+q" + offArgIndex // Adds offset to the "pointer" in the array
      case "array":
        ptrStr = "p" + arrNum + ptrStr
        var localStr = "l" + i
        var arrStr = "a" + arrNum
        if (proc.arrayBlockIndices[arrNum] === 0) { // Argument to body is just a single value from this array
          if(carg.count === 1) { // Argument/array used only once(?)
            if(dtypes[arrNum] === "generic") {
              if(carg.lvalue) {
                pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)
                code = code.replace(re, localStr)
                post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
              } else {
                code = code.replace(re, [arrStr, ".get(", ptrStr, ")"].join(""))
              }
            } else {
              code = code.replace(re, [arrStr, "[", ptrStr, "]"].join(""))
            }
          } else if(dtypes[arrNum] === "generic") {
            pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")) // TODO: Could we optimize by checking for carg.rvalue?
            code = code.replace(re, localStr)
            if(carg.lvalue) {
              post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
            }
          } else {
            pre.push(["var ", localStr, "=", arrStr, "[", ptrStr, "]"].join("")) // TODO: Could we optimize by checking for carg.rvalue?
            code = code.replace(re, localStr)
            if(carg.lvalue) {
              post.push([arrStr, "[", ptrStr, "]=", localStr].join(""))
            }
          }
        } else { // Argument to body is a "block"
          var reStrArr = [carg.name], ptrStrArr = [ptrStr]
          for(var j=0; j<Math.abs(proc.arrayBlockIndices[arrNum]); j++) {
            reStrArr.push("\\s*\\[([^\\]]+)\\]")
            ptrStrArr.push("$" + (j+1) + "*t" + arrNum + "b" + j) // Matched index times stride
          }
          re = new RegExp(reStrArr.join(""), "g")
          ptrStr = ptrStrArr.join("+")
          if(dtypes[arrNum] === "generic") {
            /*if(carg.lvalue) {
              pre.push(["var ", localStr, "=", arrStr, ".get(", ptrStr, ")"].join("")) // Is this necessary if the argument is ONLY used as an lvalue? (keep in mind that we can have a += something, so we would actually need to check carg.rvalue)
              code = code.replace(re, localStr)
              post.push([arrStr, ".set(", ptrStr, ",", localStr,")"].join(""))
            } else {
              code = code.replace(re, [arrStr, ".get(", ptrStr, ")"].join(""))
            }*/
            throw new Error("cwise: Generic arrays not supported in combination with blocks!")
          } else {
            // This does not produce any local variables, even if variables are used multiple times. It would be possible to do so, but it would complicate things quite a bit.
            code = code.replace(re, [arrStr, "[", ptrStr, "]"].join(""))
          }
        }
      break
      case "scalar":
        code = code.replace(re, "Y" + proc.scalarArgs.indexOf(i))
      break
      case "index":
        code = code.replace(re, "index")
      break
      case "shape":
        code = code.replace(re, "shape")
      break
    }
  }
  return [pre.join("\n"), code, post.join("\n")].join("\n").trim()
}

function typeSummary(dtypes) {
  var summary = new Array(dtypes.length)
  var allEqual = true
  for(var i=0; i<dtypes.length; ++i) {
    var t = dtypes[i]
    var digits = t.match(/\d+/)
    if(!digits) {
      digits = ""
    } else {
      digits = digits[0]
    }
    if(t.charAt(0) === 0) {
      summary[i] = "u" + t.charAt(1) + digits
    } else {
      summary[i] = t.charAt(0) + digits
    }
    if(i > 0) {
      allEqual = allEqual && summary[i] === summary[i-1]
    }
  }
  if(allEqual) {
    return summary[0]
  }
  return summary.join("")
}

//Generates a cwise operator
function generateCWiseOp(proc, typesig) {

  //Compute dimension
  // Arrays get put first in typesig, and there are two entries per array (dtype and order), so this gets the number of dimensions in the first array arg.
  var dimension = (typesig[1].length - Math.abs(proc.arrayBlockIndices[0]))|0
  var orders = new Array(proc.arrayArgs.length)
  var dtypes = new Array(proc.arrayArgs.length)
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    dtypes[i] = typesig[2*i]
    orders[i] = typesig[2*i+1]
  }
  
  //Determine where block and loop indices start and end
  var blockBegin = [], blockEnd = [] // These indices are exposed as blocks
  var loopBegin = [], loopEnd = [] // These indices are iterated over
  var loopOrders = [] // orders restricted to the loop indices
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    if (proc.arrayBlockIndices[i]<0) {
      loopBegin.push(0)
      loopEnd.push(dimension)
      blockBegin.push(dimension)
      blockEnd.push(dimension+proc.arrayBlockIndices[i])
    } else {
      loopBegin.push(proc.arrayBlockIndices[i]) // Non-negative
      loopEnd.push(proc.arrayBlockIndices[i]+dimension)
      blockBegin.push(0)
      blockEnd.push(proc.arrayBlockIndices[i])
    }
    var newOrder = []
    for(var j=0; j<orders[i].length; j++) {
      if (loopBegin[i]<=orders[i][j] && orders[i][j]<loopEnd[i]) {
        newOrder.push(orders[i][j]-loopBegin[i]) // If this is a loop index, put it in newOrder, subtracting loopBegin, to make sure that all loopOrders are using a common set of indices.
      }
    }
    loopOrders.push(newOrder)
  }

  //First create arguments for procedure
  var arglist = ["SS"] // SS is the overall shape over which we iterate
  var code = ["'use strict'"]
  var vars = []
  
  for(var j=0; j<dimension; ++j) {
    vars.push(["s", j, "=SS[", j, "]"].join("")) // The limits for each dimension.
  }
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    arglist.push("a"+i) // Actual data array
    arglist.push("t"+i) // Strides
    arglist.push("p"+i) // Offset in the array at which the data starts (also used for iterating over the data)
    
    for(var j=0; j<dimension; ++j) { // Unpack the strides into vars for looping
      vars.push(["t",i,"p",j,"=t",i,"[",loopBegin[i]+j,"]"].join(""))
    }
    
    for(var j=0; j<Math.abs(proc.arrayBlockIndices[i]); ++j) { // Unpack the strides into vars for block iteration
      vars.push(["t",i,"b",j,"=t",i,"[",blockBegin[i]+j,"]"].join(""))
    }
  }
  for(var i=0; i<proc.scalarArgs.length; ++i) {
    arglist.push("Y" + i)
  }
  if(proc.shapeArgs.length > 0) {
    vars.push("shape=SS.slice(0)") // Makes the shape over which we iterate available to the user defined functions (so you can use width/height for example)
  }
  if(proc.indexArgs.length > 0) {
    // Prepare an array to keep track of the (logical) indices, initialized to dimension zeroes.
    var zeros = new Array(dimension)
    for(var i=0; i<dimension; ++i) {
      zeros[i] = "0"
    }
    vars.push(["index=[", zeros.join(","), "]"].join(""))
  }
  for(var i=0; i<proc.offsetArgs.length; ++i) { // Offset arguments used for stencil operations
    var off_arg = proc.offsetArgs[i]
    var init_string = []
    for(var j=0; j<off_arg.offset.length; ++j) {
      if(off_arg.offset[j] === 0) {
        continue
      } else if(off_arg.offset[j] === 1) {
        init_string.push(["t", off_arg.array, "p", j].join(""))      
      } else {
        init_string.push([off_arg.offset[j], "*t", off_arg.array, "p", j].join(""))
      }
    }
    if(init_string.length === 0) {
      vars.push("q" + i + "=0")
    } else {
      vars.push(["q", i, "=", init_string.join("+")].join(""))
    }
  }

  //Prepare this variables
  var thisVars = uniq([].concat(proc.pre.thisVars)
                      .concat(proc.body.thisVars)
                      .concat(proc.post.thisVars))
  vars = vars.concat(thisVars)
  if (vars.length > 0) {
    code.push("var " + vars.join(","))
  }
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    code.push("p"+i+"|=0")
  }
  
  //Inline prelude
  if(proc.pre.body.length > 3) {
    code.push(processBlock(proc.pre, proc, dtypes))
  }

  //Process body
  var body = processBlock(proc.body, proc, dtypes)
  var matched = countMatches(loopOrders)
  if(matched < dimension) {
    code.push(outerFill(matched, loopOrders[0], proc, body)) // TODO: Rather than passing loopOrders[0], it might be interesting to look at passing an order that represents the majority of the arguments for example.
  } else {
    code.push(innerFill(loopOrders[0], proc, body))
  }

  //Inline epilog
  if(proc.post.body.length > 3) {
    code.push(processBlock(proc.post, proc, dtypes))
  }
  
  if(proc.debug) {
    console.log("-----Generated cwise routine for ", typesig, ":\n" + code.join("\n") + "\n----------")
  }
  
  var loopName = [(proc.funcName||"unnamed"), "_cwise_loop_", orders[0].join("s"),"m",matched,typeSummary(dtypes)].join("")
  var f = new Function(["function ",loopName,"(", arglist.join(","),"){", code.join("\n"),"} return ", loopName].join(""))
  return f()
}
module.exports = generateCWiseOp

},{"uniq":155}],39:[function(require,module,exports){
"use strict"

// The function below is called when constructing a cwise function object, and does the following:
// A function object is constructed which accepts as argument a compilation function and returns another function.
// It is this other function that is eventually returned by createThunk, and this function is the one that actually
// checks whether a certain pattern of arguments has already been used before and compiles new loops as needed.
// The compilation passed to the first function object is used for compiling new functions.
// Once this function object is created, it is called with compile as argument, where the first argument of compile
// is bound to "proc" (essentially containing a preprocessed version of the user arguments to cwise).
// So createThunk roughly works like this:
// function createThunk(proc) {
//   var thunk = function(compileBound) {
//     var CACHED = {}
//     return function(arrays and scalars) {
//       if (dtype and order of arrays in CACHED) {
//         var func = CACHED[dtype and order of arrays]
//       } else {
//         var func = CACHED[dtype and order of arrays] = compileBound(dtype and order of arrays)
//       }
//       return func(arrays and scalars)
//     }
//   }
//   return thunk(compile.bind1(proc))
// }

var compile = require("./compile.js")

function createThunk(proc) {
  var code = ["'use strict'", "var CACHED={}"]
  var vars = []
  var thunkName = proc.funcName + "_cwise_thunk"
  
  //Build thunk
  code.push(["return function ", thunkName, "(", proc.shimArgs.join(","), "){"].join(""))
  var typesig = []
  var string_typesig = []
  var proc_args = [["array",proc.arrayArgs[0],".shape.slice(", // Slice shape so that we only retain the shape over which we iterate (which gets passed to the cwise operator as SS).
                    Math.max(0,proc.arrayBlockIndices[0]),proc.arrayBlockIndices[0]<0?(","+proc.arrayBlockIndices[0]+")"):")"].join("")]
  var shapeLengthConditions = [], shapeConditions = []
  // Process array arguments
  for(var i=0; i<proc.arrayArgs.length; ++i) {
    var j = proc.arrayArgs[i]
    vars.push(["t", j, "=array", j, ".dtype,",
               "r", j, "=array", j, ".order"].join(""))
    typesig.push("t" + j)
    typesig.push("r" + j)
    string_typesig.push("t"+j)
    string_typesig.push("r"+j+".join()")
    proc_args.push("array" + j + ".data")
    proc_args.push("array" + j + ".stride")
    proc_args.push("array" + j + ".offset|0")
    if (i>0) { // Gather conditions to check for shape equality (ignoring block indices)
      shapeLengthConditions.push("array" + proc.arrayArgs[0] + ".shape.length===array" + j + ".shape.length+" + (Math.abs(proc.arrayBlockIndices[0])-Math.abs(proc.arrayBlockIndices[i])))
      shapeConditions.push("array" + proc.arrayArgs[0] + ".shape[shapeIndex+" + Math.max(0,proc.arrayBlockIndices[0]) + "]===array" + j + ".shape[shapeIndex+" + Math.max(0,proc.arrayBlockIndices[i]) + "]")
    }
  }
  // Check for shape equality
  if (proc.arrayArgs.length > 1) {
    code.push("if (!(" + shapeLengthConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same dimensionality!')")
    code.push("for(var shapeIndex=array" + proc.arrayArgs[0] + ".shape.length-" + Math.abs(proc.arrayBlockIndices[0]) + "; shapeIndex-->0;) {")
    code.push("if (!(" + shapeConditions.join(" && ") + ")) throw new Error('cwise: Arrays do not all have the same shape!')")
    code.push("}")
  }
  // Process scalar arguments
  for(var i=0; i<proc.scalarArgs.length; ++i) {
    proc_args.push("scalar" + proc.scalarArgs[i])
  }
  // Check for cached function (and if not present, generate it)
  vars.push(["type=[", string_typesig.join(","), "].join()"].join(""))
  vars.push("proc=CACHED[type]")
  code.push("var " + vars.join(","))
  
  code.push(["if(!proc){",
             "CACHED[type]=proc=compile([", typesig.join(","), "])}",
             "return proc(", proc_args.join(","), ")}"].join(""))

  if(proc.debug) {
    console.log("-----Generated thunk:\n" + code.join("\n") + "\n----------")
  }
  
  //Compile thunk
  var thunk = new Function("compile", code.join("\n"))
  return thunk(compile.bind(undefined, proc))
}

module.exports = createThunk

},{"./compile.js":38}],40:[function(require,module,exports){
(function (Buffer){

/**
 * Module exports.
 */

module.exports = dataUriToBuffer;

/**
 * Returns a `Buffer` instance from the given data URI `uri`.
 *
 * @param {String} uri Data URI to turn into a Buffer instance
 * @return {Buffer} Buffer instance from Data URI
 * @api public
 */

function dataUriToBuffer (uri) {
  if (!/^data\:/i.test(uri)) {
    throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
  }

  // strip newlines
  uri = uri.replace(/\r?\n/g, '');

  // split the URI up into the "metadata" and the "data" portions
  var firstComma = uri.indexOf(',');
  if (-1 === firstComma || firstComma <= 4) throw new TypeError('malformed data: URI');

  // remove the "data:" scheme and parse the metadata
  var meta = uri.substring(5, firstComma).split(';');

  var base64 = false;
  var charset = 'US-ASCII';
  for (var i = 0; i < meta.length; i++) {
    if ('base64' == meta[i]) {
      base64 = true;
    } else if (0 == meta[i].indexOf('charset=')) {
      charset = meta[i].substring(8);
    }
  }

  // get the encoded data portion and decode URI-encoded chars
  var data = unescape(uri.substring(firstComma + 1));

  var encoding = base64 ? 'base64' : 'ascii';
  var buffer = new Buffer(data, encoding);

  // set `.type` property to MIME type
  buffer.type = meta[0] || 'text/plain';

  // set the `.charset` property
  buffer.charset = charset;

  return buffer;
}

}).call(this,require("buffer").Buffer)

},{"buffer":35}],41:[function(require,module,exports){
"use strict"

function dupe_array(count, value, i) {
  var c = count[i]|0
  if(c <= 0) {
    return []
  }
  var result = new Array(c), j
  if(i === count.length-1) {
    for(j=0; j<c; ++j) {
      result[j] = value
    }
  } else {
    for(j=0; j<c; ++j) {
      result[j] = dupe_array(count, value, i+1)
    }
  }
  return result
}

function dupe_number(count, value) {
  var result, i
  result = new Array(count)
  for(i=0; i<count; ++i) {
    result[i] = value
  }
  return result
}

function dupe(count, value) {
  if(typeof value === "undefined") {
    value = 0
  }
  switch(typeof count) {
    case "number":
      if(count > 0) {
        return dupe_number(count|0, value)
      }
    break
    case "object":
      if(typeof (count.length) === "number") {
        return dupe_array(count, value, 0)
      }
    break
  }
  return []
}

module.exports = dupe
},{}],42:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],43:[function(require,module,exports){
(function (Buffer,process){
'use strict'

var path          = require('path')
var ndarray       = require('ndarray')
var GifReader     = require('omggif').GifReader
var pack          = require('ndarray-pack')
var through       = require('through')
var parseDataURI  = require('data-uri-to-buffer')

function defaultImage(url, cb) {
  var img = new Image()
  img.crossOrigin = "Anonymous"
  img.onload = function() {
    var canvas = document.createElement('canvas')
    canvas.width = img.width
    canvas.height = img.height
    var context = canvas.getContext('2d')
    context.drawImage(img, 0, 0)
    var pixels = context.getImageData(0, 0, img.width, img.height)
    cb(null, ndarray(new Uint8Array(pixels.data), [img.width, img.height, 4], [4, 4*img.width, 1], 0))
  }
  img.onerror = function(err) {
    cb(err)
  }
  img.src = url
}

//Animated gif loading
function handleGif(data, cb) {
  var reader
  try {
    reader = new GifReader(data)
  } catch(err) {
    cb(err)
    return
  }
  if(reader.numFrames() > 0) {
    var nshape = [reader.numFrames(), reader.height, reader.width, 4]
    var ndata = new Uint8Array(nshape[0] * nshape[1] * nshape[2] * nshape[3])
    var result = ndarray(ndata, nshape)
    try {
      for(var i=0; i<reader.numFrames(); ++i) {
        reader.decodeAndBlitFrameRGBA(i, ndata.subarray(
          result.index(i, 0, 0, 0),
          result.index(i+1, 0, 0, 0)))
      }
    } catch(err) {
      cb(err)
      return
    }
    cb(null, result.transpose(0,2,1))
  } else {
    var nshape = [reader.height, reader.width, 4]
    var ndata = new Uint8Array(nshape[0] * nshape[1] * nshape[2])
    var result = ndarray(ndata, nshape)
    try {
      reader.decodeAndBlitFrameRGBA(0, ndata)
    } catch(err) {
      cb(err)
      return
    }
    cb(null, result.transpose(1,0))
  }
}

function httpGif(url, cb) {
  var xhr          = new XMLHttpRequest()
  xhr.open('GET', url, true)
  xhr.responseType = 'arraybuffer'
  if(xhr.overrideMimeType){
    xhr.overrideMimeType('application/binary')
  }
  xhr.onerror = function(err) {
    cb(err)
  }
  xhr.onload = function() {
    if(xhr.readyState !== 4) {
      return
    }
    var data = new Uint8Array(xhr.response)
    handleGif(data, cb)
    return
  }
  xhr.send()
}

function copyBuffer(buffer) {
  if(buffer[0] === undefined) {
    var n = buffer.length
    var result = new Uint8Array(n)
    for(var i=0; i<n; ++i) {
      result[i] = buffer.get(i)
    }
    return result
  } else {
    return new Uint8Array(buffer)
  }
}

function dataGif(url, cb) {
  process.nextTick(function() {
    try {
      var buffer = parseDataURI(url)
      if(buffer) {
        handleGif(copyBuffer(buffer), cb)
      } else {
        cb(new Error('Error parsing data URI'))
      }
    } catch(err) {
      cb(err)
    }
  })
}

module.exports = function getPixels(url, type, cb) {
  if(!cb) {
    cb = type
    type = ''
  }
  var ext = path.extname(url)
  switch(type || ext.toUpperCase()) {
    case '.GIF':
      httpGif(url, cb)
    break
    default:
      if(Buffer.isBuffer(url)) {
        url = 'data:' + type + ';base64,' + url.toString('base64')
      }
      if(url.indexOf('data:image/gif;') === 0) {
        dataGif(url, cb)
      } else {
        defaultImage(url, cb)
      }
  }
}
}).call(this,{"isBuffer":require("../is-buffer/index.js")},require('_process'))

},{"../is-buffer/index.js":125,"_process":134,"data-uri-to-buffer":40,"ndarray":130,"ndarray-pack":128,"omggif":131,"path":132,"through":152}],44:[function(require,module,exports){
module.exports = adjoint;

/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function adjoint(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
    out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
    out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
    out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
    out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
    out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
    out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
    out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
    out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
    out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
    out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
    out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
    out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
    return out;
};
},{}],45:[function(require,module,exports){
module.exports = clone;

/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */
function clone(a) {
    var out = new Float32Array(16);
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};
},{}],46:[function(require,module,exports){
module.exports = copy;

/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};
},{}],47:[function(require,module,exports){
module.exports = create;

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */
function create() {
    var out = new Float32Array(16);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};
},{}],48:[function(require,module,exports){
module.exports = determinant;

/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */
function determinant(a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32;

    // Calculate the determinant
    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
};
},{}],49:[function(require,module,exports){
module.exports = fromQuat;

/**
 * Creates a matrix from a quaternion rotation.
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @returns {mat4} out
 */
function fromQuat(out, q) {
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        yx = y * x2,
        yy = y * y2,
        zx = z * x2,
        zy = z * y2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;

    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;

    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;

    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;

    return out;
};
},{}],50:[function(require,module,exports){
module.exports = fromRotation

/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.rotate(dest, dest, rad, axis)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
function fromRotation(out, rad, axis) {
  var s, c, t
  var x = axis[0]
  var y = axis[1]
  var z = axis[2]
  var len = Math.sqrt(x * x + y * y + z * z)

  if (Math.abs(len) < 0.000001) {
    return null
  }

  len = 1 / len
  x *= len
  y *= len
  z *= len

  s = Math.sin(rad)
  c = Math.cos(rad)
  t = 1 - c

  // Perform rotation-specific matrix multiplication
  out[0] = x * x * t + c
  out[1] = y * x * t + z * s
  out[2] = z * x * t - y * s
  out[3] = 0
  out[4] = x * y * t - z * s
  out[5] = y * y * t + c
  out[6] = z * y * t + x * s
  out[7] = 0
  out[8] = x * z * t + y * s
  out[9] = y * z * t - x * s
  out[10] = z * z * t + c
  out[11] = 0
  out[12] = 0
  out[13] = 0
  out[14] = 0
  out[15] = 1
  return out
}

},{}],51:[function(require,module,exports){
module.exports = fromRotationTranslation;

/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     var quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
function fromRotationTranslation(out, q, v) {
    // Quaternion math
    var x = q[0], y = q[1], z = q[2], w = q[3],
        x2 = x + x,
        y2 = y + y,
        z2 = z + z,

        xx = x * x2,
        xy = x * y2,
        xz = x * z2,
        yy = y * y2,
        yz = y * z2,
        zz = z * z2,
        wx = w * x2,
        wy = w * y2,
        wz = w * z2;

    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    
    return out;
};
},{}],52:[function(require,module,exports){
module.exports = fromScaling

/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.scale(dest, dest, vec)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */
function fromScaling(out, v) {
  out[0] = v[0]
  out[1] = 0
  out[2] = 0
  out[3] = 0
  out[4] = 0
  out[5] = v[1]
  out[6] = 0
  out[7] = 0
  out[8] = 0
  out[9] = 0
  out[10] = v[2]
  out[11] = 0
  out[12] = 0
  out[13] = 0
  out[14] = 0
  out[15] = 1
  return out
}

},{}],53:[function(require,module,exports){
module.exports = fromTranslation

/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.translate(dest, dest, vec)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */
function fromTranslation(out, v) {
  out[0] = 1
  out[1] = 0
  out[2] = 0
  out[3] = 0
  out[4] = 0
  out[5] = 1
  out[6] = 0
  out[7] = 0
  out[8] = 0
  out[9] = 0
  out[10] = 1
  out[11] = 0
  out[12] = v[0]
  out[13] = v[1]
  out[14] = v[2]
  out[15] = 1
  return out
}

},{}],54:[function(require,module,exports){
module.exports = fromXRotation

/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.rotateX(dest, dest, rad)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromXRotation(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad)

    // Perform axis-specific matrix multiplication
    out[0] = 1
    out[1] = 0
    out[2] = 0
    out[3] = 0
    out[4] = 0
    out[5] = c
    out[6] = s
    out[7] = 0
    out[8] = 0
    out[9] = -s
    out[10] = c
    out[11] = 0
    out[12] = 0
    out[13] = 0
    out[14] = 0
    out[15] = 1
    return out
}
},{}],55:[function(require,module,exports){
module.exports = fromYRotation

/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.rotateY(dest, dest, rad)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromYRotation(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad)

    // Perform axis-specific matrix multiplication
    out[0] = c
    out[1] = 0
    out[2] = -s
    out[3] = 0
    out[4] = 0
    out[5] = 1
    out[6] = 0
    out[7] = 0
    out[8] = s
    out[9] = 0
    out[10] = c
    out[11] = 0
    out[12] = 0
    out[13] = 0
    out[14] = 0
    out[15] = 1
    return out
}
},{}],56:[function(require,module,exports){
module.exports = fromZRotation

/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest)
 *     mat4.rotateZ(dest, dest, rad)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function fromZRotation(out, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad)

    // Perform axis-specific matrix multiplication
    out[0] = c
    out[1] = s
    out[2] = 0
    out[3] = 0
    out[4] = -s
    out[5] = c
    out[6] = 0
    out[7] = 0
    out[8] = 0
    out[9] = 0
    out[10] = 1
    out[11] = 0
    out[12] = 0
    out[13] = 0
    out[14] = 0
    out[15] = 1
    return out
}
},{}],57:[function(require,module,exports){
module.exports = frustum;

/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */
function frustum(out, left, right, bottom, top, near, far) {
    var rl = 1 / (right - left),
        tb = 1 / (top - bottom),
        nf = 1 / (near - far);
    out[0] = (near * 2) * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = (near * 2) * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (far * near * 2) * nf;
    out[15] = 0;
    return out;
};
},{}],58:[function(require,module,exports){
module.exports = identity;

/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */
function identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
};
},{}],59:[function(require,module,exports){
module.exports = {
  create: require('./create')
  , clone: require('./clone')
  , copy: require('./copy')
  , identity: require('./identity')
  , transpose: require('./transpose')
  , invert: require('./invert')
  , adjoint: require('./adjoint')
  , determinant: require('./determinant')
  , multiply: require('./multiply')
  , translate: require('./translate')
  , scale: require('./scale')
  , rotate: require('./rotate')
  , rotateX: require('./rotateX')
  , rotateY: require('./rotateY')
  , rotateZ: require('./rotateZ')
  , fromRotation: require('./fromRotation')
  , fromRotationTranslation: require('./fromRotationTranslation')
  , fromScaling: require('./fromScaling')
  , fromTranslation: require('./fromTranslation')
  , fromXRotation: require('./fromXRotation')
  , fromYRotation: require('./fromYRotation')
  , fromZRotation: require('./fromZRotation')
  , fromQuat: require('./fromQuat')
  , frustum: require('./frustum')
  , perspective: require('./perspective')
  , perspectiveFromFieldOfView: require('./perspectiveFromFieldOfView')
  , ortho: require('./ortho')
  , lookAt: require('./lookAt')
  , str: require('./str')
}

},{"./adjoint":44,"./clone":45,"./copy":46,"./create":47,"./determinant":48,"./fromQuat":49,"./fromRotation":50,"./fromRotationTranslation":51,"./fromScaling":52,"./fromTranslation":53,"./fromXRotation":54,"./fromYRotation":55,"./fromZRotation":56,"./frustum":57,"./identity":58,"./invert":60,"./lookAt":61,"./multiply":62,"./ortho":63,"./perspective":64,"./perspectiveFromFieldOfView":65,"./rotate":66,"./rotateX":67,"./rotateY":68,"./rotateZ":69,"./scale":70,"./str":71,"./translate":72,"./transpose":73}],60:[function(require,module,exports){
module.exports = invert;

/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function invert(out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) { 
        return null; 
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
};
},{}],61:[function(require,module,exports){
var identity = require('./identity');

module.exports = lookAt;

/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */
function lookAt(out, eye, center, up) {
    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
        eyex = eye[0],
        eyey = eye[1],
        eyez = eye[2],
        upx = up[0],
        upy = up[1],
        upz = up[2],
        centerx = center[0],
        centery = center[1],
        centerz = center[2];

    if (Math.abs(eyex - centerx) < 0.000001 &&
        Math.abs(eyey - centery) < 0.000001 &&
        Math.abs(eyez - centerz) < 0.000001) {
        return identity(out);
    }

    z0 = eyex - centerx;
    z1 = eyey - centery;
    z2 = eyez - centerz;

    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;

    x0 = upy * z2 - upz * z1;
    x1 = upz * z0 - upx * z2;
    x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
        x0 = 0;
        x1 = 0;
        x2 = 0;
    } else {
        len = 1 / len;
        x0 *= len;
        x1 *= len;
        x2 *= len;
    }

    y0 = z1 * x2 - z2 * x1;
    y1 = z2 * x0 - z0 * x2;
    y2 = z0 * x1 - z1 * x0;

    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
        y0 = 0;
        y1 = 0;
        y2 = 0;
    } else {
        len = 1 / len;
        y0 *= len;
        y1 *= len;
        y2 *= len;
    }

    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;

    return out;
};
},{"./identity":58}],62:[function(require,module,exports){
module.exports = multiply;

/**
 * Multiplies two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */
function multiply(out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

    // Cache only the current line of the second matrix
    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];  
    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
    return out;
};
},{}],63:[function(require,module,exports){
module.exports = ortho;

/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function ortho(out, left, right, bottom, top, near, far) {
    var lr = 1 / (left - right),
        bt = 1 / (bottom - top),
        nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
};
},{}],64:[function(require,module,exports){
module.exports = perspective;

/**
 * Generates a perspective projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function perspective(out, fovy, aspect, near, far) {
    var f = 1.0 / Math.tan(fovy / 2),
        nf = 1 / (near - far);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) * nf;
    out[15] = 0;
    return out;
};
},{}],65:[function(require,module,exports){
module.exports = perspectiveFromFieldOfView;

/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */
function perspectiveFromFieldOfView(out, fov, near, far) {
    var upTan = Math.tan(fov.upDegrees * Math.PI/180.0),
        downTan = Math.tan(fov.downDegrees * Math.PI/180.0),
        leftTan = Math.tan(fov.leftDegrees * Math.PI/180.0),
        rightTan = Math.tan(fov.rightDegrees * Math.PI/180.0),
        xScale = 2.0 / (leftTan + rightTan),
        yScale = 2.0 / (upTan + downTan);

    out[0] = xScale;
    out[1] = 0.0;
    out[2] = 0.0;
    out[3] = 0.0;
    out[4] = 0.0;
    out[5] = yScale;
    out[6] = 0.0;
    out[7] = 0.0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = ((upTan - downTan) * yScale * 0.5);
    out[10] = far / (near - far);
    out[11] = -1.0;
    out[12] = 0.0;
    out[13] = 0.0;
    out[14] = (far * near) / (near - far);
    out[15] = 0.0;
    return out;
}


},{}],66:[function(require,module,exports){
module.exports = rotate;

/**
 * Rotates a mat4 by the given angle
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */
function rotate(out, a, rad, axis) {
    var x = axis[0], y = axis[1], z = axis[2],
        len = Math.sqrt(x * x + y * y + z * z),
        s, c, t,
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23,
        b00, b01, b02,
        b10, b11, b12,
        b20, b21, b22;

    if (Math.abs(len) < 0.000001) { return null; }
    
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;

    s = Math.sin(rad);
    c = Math.cos(rad);
    t = 1 - c;

    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

    // Construct the elements of the rotation matrix
    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

    // Perform rotation-specific matrix multiplication
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }
    return out;
};
},{}],67:[function(require,module,exports){
module.exports = rotateX;

/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateX(out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[0]  = a[0];
        out[1]  = a[1];
        out[2]  = a[2];
        out[3]  = a[3];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
};
},{}],68:[function(require,module,exports){
module.exports = rotateY;

/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateY(out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a20 = a[8],
        a21 = a[9],
        a22 = a[10],
        a23 = a[11];

    if (a !== out) { // If the source and destination differ, copy the unchanged rows
        out[4]  = a[4];
        out[5]  = a[5];
        out[6]  = a[6];
        out[7]  = a[7];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
};
},{}],69:[function(require,module,exports){
module.exports = rotateZ;

/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */
function rotateZ(out, a, rad) {
    var s = Math.sin(rad),
        c = Math.cos(rad),
        a00 = a[0],
        a01 = a[1],
        a02 = a[2],
        a03 = a[3],
        a10 = a[4],
        a11 = a[5],
        a12 = a[6],
        a13 = a[7];

    if (a !== out) { // If the source and destination differ, copy the unchanged last row
        out[8]  = a[8];
        out[9]  = a[9];
        out[10] = a[10];
        out[11] = a[11];
        out[12] = a[12];
        out[13] = a[13];
        out[14] = a[14];
        out[15] = a[15];
    }

    // Perform axis-specific matrix multiplication
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
};
},{}],70:[function(require,module,exports){
module.exports = scale;

/**
 * Scales the mat4 by the dimensions in the given vec3
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/
function scale(out, a, v) {
    var x = v[0], y = v[1], z = v[2];

    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
};
},{}],71:[function(require,module,exports){
module.exports = str;

/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} mat matrix to represent as a string
 * @returns {String} string representation of the matrix
 */
function str(a) {
    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
                    a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
                    a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + 
                    a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
};
},{}],72:[function(require,module,exports){
module.exports = translate;

/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */
function translate(out, a, v) {
    var x = v[0], y = v[1], z = v[2],
        a00, a01, a02, a03,
        a10, a11, a12, a13,
        a20, a21, a22, a23;

    if (a === out) {
        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

        out[12] = a00 * x + a10 * y + a20 * z + a[12];
        out[13] = a01 * x + a11 * y + a21 * z + a[13];
        out[14] = a02 * x + a12 * y + a22 * z + a[14];
        out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }

    return out;
};
},{}],73:[function(require,module,exports){
module.exports = transpose;

/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */
function transpose(out, a) {
    // If we are transposing ourselves we can skip a few steps but have to cache some values
    if (out === a) {
        var a01 = a[1], a02 = a[2], a03 = a[3],
            a12 = a[6], a13 = a[7],
            a23 = a[11];

        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a01;
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a02;
        out[9] = a12;
        out[11] = a[14];
        out[12] = a03;
        out[13] = a13;
        out[14] = a23;
    } else {
        out[0] = a[0];
        out[1] = a[4];
        out[2] = a[8];
        out[3] = a[12];
        out[4] = a[1];
        out[5] = a[5];
        out[6] = a[9];
        out[7] = a[13];
        out[8] = a[2];
        out[9] = a[6];
        out[10] = a[10];
        out[11] = a[14];
        out[12] = a[3];
        out[13] = a[7];
        out[14] = a[11];
        out[15] = a[15];
    }
    
    return out;
};
},{}],74:[function(require,module,exports){
'use strict'

var ndarray = require('ndarray')
var ops     = require('ndarray-ops')
var pool    = require('typedarray-pool')

module.exports = createTexture2D

var linearTypes = null
var filterTypes = null
var wrapTypes   = null

function lazyInitLinearTypes(gl) {
  linearTypes = [
    gl.LINEAR,
    gl.NEAREST_MIPMAP_LINEAR,
    gl.LINEAR_MIPMAP_NEAREST,
    gl.LINEAR_MIPMAP_NEAREST
  ]
  filterTypes = [
    gl.NEAREST,
    gl.LINEAR,
    gl.NEAREST_MIPMAP_NEAREST,
    gl.NEAREST_MIPMAP_LINEAR,
    gl.LINEAR_MIPMAP_NEAREST,
    gl.LINEAR_MIPMAP_LINEAR
  ]
  wrapTypes = [
    gl.REPEAT,
    gl.CLAMP_TO_EDGE,
    gl.MIRRORED_REPEAT
  ]
}

function acceptTextureDOM (obj) {
  return (
    ('undefined' != typeof HTMLCanvasElement && obj instanceof HTMLCanvasElement) ||
    ('undefined' != typeof HTMLImageElement && obj instanceof HTMLImageElement) ||
    ('undefined' != typeof HTMLVideoElement && obj instanceof HTMLVideoElement) ||
    ('undefined' != typeof ImageData && obj instanceof ImageData))
}

var convertFloatToUint8 = function(out, inp) {
  ops.muls(out, inp, 255.0)
}

function reshapeTexture(tex, w, h) {
  var gl = tex.gl
  var maxSize = gl.getParameter(gl.MAX_TEXTURE_SIZE)
  if(w < 0 || w > maxSize || h < 0 || h > maxSize) {
    throw new Error('gl-texture2d: Invalid texture size')
  }
  tex._shape = [w, h]
  tex.bind()
  gl.texImage2D(gl.TEXTURE_2D, 0, tex.format, w, h, 0, tex.format, tex.type, null)
  tex._mipLevels = [0]
  return tex
}

function Texture2D(gl, handle, width, height, format, type) {
  this.gl = gl
  this.handle = handle
  this.format = format
  this.type = type
  this._shape = [width, height]
  this._mipLevels = [0]
  this._magFilter = gl.NEAREST
  this._minFilter = gl.NEAREST
  this._wrapS = gl.CLAMP_TO_EDGE
  this._wrapT = gl.CLAMP_TO_EDGE
  this._anisoSamples = 1

  var parent = this
  var wrapVector = [this._wrapS, this._wrapT]
  Object.defineProperties(wrapVector, [
    {
      get: function() {
        return parent._wrapS
      },
      set: function(v) {
        return parent.wrapS = v
      }
    },
    {
      get: function() {
        return parent._wrapT
      },
      set: function(v) {
        return parent.wrapT = v
      }
    }
  ])
  this._wrapVector = wrapVector

  var shapeVector = [this._shape[0], this._shape[1]]
  Object.defineProperties(shapeVector, [
    {
      get: function() {
        return parent._shape[0]
      },
      set: function(v) {
        return parent.width = v
      }
    },
    {
      get: function() {
        return parent._shape[1]
      },
      set: function(v) {
        return parent.height = v
      }
    }
  ])
  this._shapeVector = shapeVector
}

var proto = Texture2D.prototype

Object.defineProperties(proto, {
  minFilter: {
    get: function() {
      return this._minFilter
    },
    set: function(v) {
      this.bind()
      var gl = this.gl
      if(this.type === gl.FLOAT && linearTypes.indexOf(v) >= 0) {
        if(!gl.getExtension('OES_texture_float_linear')) {
          v = gl.NEAREST
        }
      }
      if(filterTypes.indexOf(v) < 0) {
        throw new Error('gl-texture2d: Unknown filter mode ' + v)
      }
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, v)
      return this._minFilter = v
    }
  },
  magFilter: {
    get: function() {
      return this._magFilter
    },
    set: function(v) {
      this.bind()
      var gl = this.gl
      if(this.type === gl.FLOAT && linearTypes.indexOf(v) >= 0) {
        if(!gl.getExtension('OES_texture_float_linear')) {
          v = gl.NEAREST
        }
      }
      if(filterTypes.indexOf(v) < 0) {
        throw new Error('gl-texture2d: Unknown filter mode ' + v)
      }
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, v)
      return this._magFilter = v
    }
  },
  mipSamples: {
    get: function() {
      return this._anisoSamples
    },
    set: function(i) {
      var psamples = this._anisoSamples
      this._anisoSamples = Math.max(i, 1)|0
      if(psamples !== this._anisoSamples) {
        var ext = this.gl.getExtension('EXT_texture_filter_anisotropic')
        if(ext) {
          this.gl.texParameterf(this.gl.TEXTURE_2D, ext.TEXTURE_MAX_ANISOTROPY_EXT, this._anisoSamples)
        }
      }
      return this._anisoSamples
    }
  },
  wrapS: {
    get: function() {
      return this._wrapS
    },
    set: function(v) {
      this.bind()
      if(wrapTypes.indexOf(v) < 0) {
        throw new Error('gl-texture2d: Unknown wrap mode ' + v)
      }
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, v)
      return this._wrapS = v
    }
  },
  wrapT: {
    get: function() {
      return this._wrapT
    },
    set: function(v) {
      this.bind()
      if(wrapTypes.indexOf(v) < 0) {
        throw new Error('gl-texture2d: Unknown wrap mode ' + v)
      }
      this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, v)
      return this._wrapT = v
    }
  },
  wrap: {
    get: function() {
      return this._wrapVector
    },
    set: function(v) {
      if(!Array.isArray(v)) {
        v = [v,v]
      }
      if(v.length !== 2) {
        throw new Error('gl-texture2d: Must specify wrap mode for rows and columns')
      }
      for(var i=0; i<2; ++i) {
        if(wrapTypes.indexOf(v[i]) < 0) {
          throw new Error('gl-texture2d: Unknown wrap mode ' + v)
        }
      }
      this._wrapS = v[0]
      this._wrapT = v[1]

      var gl = this.gl
      this.bind()
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, this._wrapS)
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, this._wrapT)

      return v
    }
  },
  shape: {
    get: function() {
      return this._shapeVector
    },
    set: function(x) {
      if(!Array.isArray(x)) {
        x = [x|0,x|0]
      } else {
        if(x.length !== 2) {
          throw new Error('gl-texture2d: Invalid texture shape')
        }
      }
      reshapeTexture(this, x[0]|0, x[1]|0)
      return [x[0]|0, x[1]|0]
    }
  },
  width: {
    get: function() {
      return this._shape[0]
    },
    set: function(w) {
      w = w|0
      reshapeTexture(this, w, this._shape[1])
      return w
    }
  },
  height: {
    get: function() {
      return this._shape[1]
    },
    set: function(h) {
      h = h|0
      reshapeTexture(this, this._shape[0], h)
      return h
    }
  }
})

proto.bind = function(unit) {
  var gl = this.gl
  if(unit !== undefined) {
    gl.activeTexture(gl.TEXTURE0 + (unit|0))
  }
  gl.bindTexture(gl.TEXTURE_2D, this.handle)
  if(unit !== undefined) {
    return (unit|0)
  }
  return gl.getParameter(gl.ACTIVE_TEXTURE) - gl.TEXTURE0
}

proto.dispose = function() {
  this.gl.deleteTexture(this.handle)
}

proto.generateMipmap = function() {
  this.bind()
  this.gl.generateMipmap(this.gl.TEXTURE_2D)

  //Update mip levels
  var l = Math.min(this._shape[0], this._shape[1])
  for(var i=0; l>0; ++i, l>>>=1) {
    if(this._mipLevels.indexOf(i) < 0) {
      this._mipLevels.push(i)
    }
  }
}

proto.setPixels = function(data, x_off, y_off, mip_level) {
  var gl = this.gl
  this.bind()
  if(Array.isArray(x_off)) {
    mip_level = y_off
    y_off = x_off[1]|0
    x_off = x_off[0]|0
  } else {
    x_off = x_off || 0
    y_off = y_off || 0
  }
  mip_level = mip_level || 0
  var directData = acceptTextureDOM(data) ? data : data.raw
  if(directData) {
    var needsMip = this._mipLevels.indexOf(mip_level) < 0
    if(needsMip) {
      gl.texImage2D(gl.TEXTURE_2D, 0, this.format, this.format, this.type, directData)
      this._mipLevels.push(mip_level)
    } else {
      gl.texSubImage2D(gl.TEXTURE_2D, mip_level, x_off, y_off, this.format, this.type, directData)
    }
  } else if(data.shape && data.stride && data.data) {
    if(data.shape.length < 2 ||
       x_off + data.shape[1] > this._shape[1]>>>mip_level ||
       y_off + data.shape[0] > this._shape[0]>>>mip_level ||
       x_off < 0 ||
       y_off < 0) {
      throw new Error('gl-texture2d: Texture dimensions are out of bounds')
    }
    texSubImageArray(gl, x_off, y_off, mip_level, this.format, this.type, this._mipLevels, data)
  } else {
    throw new Error('gl-texture2d: Unsupported data type')
  }
}


function isPacked(shape, stride) {
  if(shape.length === 3) {
    return  (stride[2] === 1) &&
            (stride[1] === shape[0]*shape[2]) &&
            (stride[0] === shape[2])
  }
  return  (stride[0] === 1) &&
          (stride[1] === shape[0])
}

function texSubImageArray(gl, x_off, y_off, mip_level, cformat, ctype, mipLevels, array) {
  var dtype = array.dtype
  var shape = array.shape.slice()
  if(shape.length < 2 || shape.length > 3) {
    throw new Error('gl-texture2d: Invalid ndarray, must be 2d or 3d')
  }
  var type = 0, format = 0
  var packed = isPacked(shape, array.stride.slice())
  if(dtype === 'float32') {
    type = gl.FLOAT
  } else if(dtype === 'float64') {
    type = gl.FLOAT
    packed = false
    dtype = 'float32'
  } else if(dtype === 'uint8') {
    type = gl.UNSIGNED_BYTE
  } else {
    type = gl.UNSIGNED_BYTE
    packed = false
    dtype = 'uint8'
  }
  var channels = 1
  if(shape.length === 2) {
    format = gl.LUMINANCE
    shape = [shape[0], shape[1], 1]
    array = ndarray(array.data, shape, [array.stride[0], array.stride[1], 1], array.offset)
  } else if(shape.length === 3) {
    if(shape[2] === 1) {
      format = gl.ALPHA
    } else if(shape[2] === 2) {
      format = gl.LUMINANCE_ALPHA
    } else if(shape[2] === 3) {
      format = gl.RGB
    } else if(shape[2] === 4) {
      format = gl.RGBA
    } else {
      throw new Error('gl-texture2d: Invalid shape for pixel coords')
    }
    channels = shape[2]
  } else {
    throw new Error('gl-texture2d: Invalid shape for texture')
  }
  //For 1-channel textures allow conversion between formats
  if((format  === gl.LUMINANCE || format  === gl.ALPHA) &&
     (cformat === gl.LUMINANCE || cformat === gl.ALPHA)) {
    format = cformat
  }
  if(format !== cformat) {
    throw new Error('gl-texture2d: Incompatible texture format for setPixels')
  }
  var size = array.size
  var needsMip = mipLevels.indexOf(mip_level) < 0
  if(needsMip) {
    mipLevels.push(mip_level)
  }
  if(type === ctype && packed) {
    //Array data types are compatible, can directly copy into texture
    if(array.offset === 0 && array.data.length === size) {
      if(needsMip) {
        gl.texImage2D(gl.TEXTURE_2D, mip_level, cformat, shape[0], shape[1], 0, cformat, ctype, array.data)
      } else {
        gl.texSubImage2D(gl.TEXTURE_2D, mip_level, x_off, y_off, shape[0], shape[1], cformat, ctype, array.data)
      }
    } else {
      if(needsMip) {
        gl.texImage2D(gl.TEXTURE_2D, mip_level, cformat, shape[0], shape[1], 0, cformat, ctype, array.data.subarray(array.offset, array.offset+size))
      } else {
        gl.texSubImage2D(gl.TEXTURE_2D, mip_level, x_off, y_off, shape[0], shape[1], cformat, ctype, array.data.subarray(array.offset, array.offset+size))
      }
    }
  } else {
    //Need to do type conversion to pack data into buffer
    var pack_buffer
    if(ctype === gl.FLOAT) {
      pack_buffer = pool.mallocFloat32(size)
    } else {
      pack_buffer = pool.mallocUint8(size)
    }
    var pack_view = ndarray(pack_buffer, shape, [shape[2], shape[2]*shape[0], 1])
    if(type === gl.FLOAT && ctype === gl.UNSIGNED_BYTE) {
      convertFloatToUint8(pack_view, array)
    } else {
      ops.assign(pack_view, array)
    }
    if(needsMip) {
      gl.texImage2D(gl.TEXTURE_2D, mip_level, cformat, shape[0], shape[1], 0, cformat, ctype, pack_buffer.subarray(0, size))
    } else {
      gl.texSubImage2D(gl.TEXTURE_2D, mip_level, x_off, y_off, shape[0], shape[1], cformat, ctype, pack_buffer.subarray(0, size))
    }
    if(ctype === gl.FLOAT) {
      pool.freeFloat32(pack_buffer)
    } else {
      pool.freeUint8(pack_buffer)
    }
  }
}

function initTexture(gl) {
  var tex = gl.createTexture()
  gl.bindTexture(gl.TEXTURE_2D, tex)
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST)
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST)
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE)
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE)
  return tex
}

function createTextureShape(gl, width, height, format, type) {
  var maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE)
  if(width < 0 || width > maxTextureSize || height < 0 || height  > maxTextureSize) {
    throw new Error('gl-texture2d: Invalid texture shape')
  }
  if(type === gl.FLOAT && !gl.getExtension('OES_texture_float')) {
    throw new Error('gl-texture2d: Floating point textures not supported on this platform')
  }
  var tex = initTexture(gl)
  gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, 0, format, type, null)
  return new Texture2D(gl, tex, width, height, format, type)
}

function createTextureDOM(gl, directData, width, height, format, type) {
  var tex = initTexture(gl)
  gl.texImage2D(gl.TEXTURE_2D, 0, format, format, type, directData)
  return new Texture2D(gl, tex, width, height, format, type)
}

//Creates a texture from an ndarray
function createTextureArray(gl, array) {
  var dtype = array.dtype
  var shape = array.shape.slice()
  var maxSize = gl.getParameter(gl.MAX_TEXTURE_SIZE)
  if(shape[0] < 0 || shape[0] > maxSize || shape[1] < 0 || shape[1] > maxSize) {
    throw new Error('gl-texture2d: Invalid texture size')
  }
  var packed = isPacked(shape, array.stride.slice())
  var type = 0
  if(dtype === 'float32') {
    type = gl.FLOAT
  } else if(dtype === 'float64') {
    type = gl.FLOAT
    packed = false
    dtype = 'float32'
  } else if(dtype === 'uint8') {
    type = gl.UNSIGNED_BYTE
  } else {
    type = gl.UNSIGNED_BYTE
    packed = false
    dtype = 'uint8'
  }
  var format = 0
  if(shape.length === 2) {
    format = gl.LUMINANCE
    shape = [shape[0], shape[1], 1]
    array = ndarray(array.data, shape, [array.stride[0], array.stride[1], 1], array.offset)
  } else if(shape.length === 3) {
    if(shape[2] === 1) {
      format = gl.ALPHA
    } else if(shape[2] === 2) {
      format = gl.LUMINANCE_ALPHA
    } else if(shape[2] === 3) {
      format = gl.RGB
    } else if(shape[2] === 4) {
      format = gl.RGBA
    } else {
      throw new Error('gl-texture2d: Invalid shape for pixel coords')
    }
  } else {
    throw new Error('gl-texture2d: Invalid shape for texture')
  }
  if(type === gl.FLOAT && !gl.getExtension('OES_texture_float')) {
    type = gl.UNSIGNED_BYTE
    packed = false
  }
  var buffer, buf_store
  var size = array.size
  if(!packed) {
    var stride = [shape[2], shape[2]*shape[0], 1]
    buf_store = pool.malloc(size, dtype)
    var buf_array = ndarray(buf_store, shape, stride, 0)
    if((dtype === 'float32' || dtype === 'float64') && type === gl.UNSIGNED_BYTE) {
      convertFloatToUint8(buf_array, array)
    } else {
      ops.assign(buf_array, array)
    }
    buffer = buf_store.subarray(0, size)
  } else if (array.offset === 0 && array.data.length === size) {
    buffer = array.data
  } else {
    buffer = array.data.subarray(array.offset, array.offset + size)
  }
  var tex = initTexture(gl)
  gl.texImage2D(gl.TEXTURE_2D, 0, format, shape[0], shape[1], 0, format, type, buffer)
  if(!packed) {
    pool.free(buf_store)
  }
  return new Texture2D(gl, tex, shape[0], shape[1], format, type)
}

function createTexture2D(gl) {
  if(arguments.length <= 1) {
    throw new Error('gl-texture2d: Missing arguments for texture2d constructor')
  }
  if(!linearTypes) {
    lazyInitLinearTypes(gl)
  }
  if(typeof arguments[1] === 'number') {
    return createTextureShape(gl, arguments[1], arguments[2], arguments[3]||gl.RGBA, arguments[4]||gl.UNSIGNED_BYTE)
  }
  if(Array.isArray(arguments[1])) {
    return createTextureShape(gl, arguments[1][0]|0, arguments[1][1]|0, arguments[2]||gl.RGBA, arguments[3]||gl.UNSIGNED_BYTE)
  }
  if(typeof arguments[1] === 'object') {
    var obj = arguments[1]
    var directData = acceptTextureDOM(obj) ? obj : obj.raw
    if (directData) {
      return createTextureDOM(gl, directData, obj.width|0, obj.height|0, arguments[2]||gl.RGBA, arguments[3]||gl.UNSIGNED_BYTE)
    } else if(obj.shape && obj.data && obj.stride) {
      return createTextureArray(gl, obj)
    }
  }
  throw new Error('gl-texture2d: Invalid arguments for texture2d constructor')
}

},{"ndarray":130,"ndarray-ops":127,"typedarray-pool":154}],75:[function(require,module,exports){
module.exports = add;

/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function add(out, a, b) {
    out[0] = a[0] + b[0]
    out[1] = a[1] + b[1]
    out[2] = a[2] + b[2]
    return out
}
},{}],76:[function(require,module,exports){
module.exports = angle

var fromValues = require('./fromValues')
var normalize = require('./normalize')
var dot = require('./dot')

/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */
function angle(a, b) {
    var tempA = fromValues(a[0], a[1], a[2])
    var tempB = fromValues(b[0], b[1], b[2])
 
    normalize(tempA, tempA)
    normalize(tempB, tempB)
 
    var cosine = dot(tempA, tempB)

    if(cosine > 1.0){
        return 0
    } else {
        return Math.acos(cosine)
    }     
}

},{"./dot":86,"./fromValues":92,"./normalize":103}],77:[function(require,module,exports){
module.exports = ceil

/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */
function ceil(out, a) {
  out[0] = Math.ceil(a[0])
  out[1] = Math.ceil(a[1])
  out[2] = Math.ceil(a[2])
  return out
}

},{}],78:[function(require,module,exports){
module.exports = clone;

/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */
function clone(a) {
    var out = new Float32Array(3)
    out[0] = a[0]
    out[1] = a[1]
    out[2] = a[2]
    return out
}
},{}],79:[function(require,module,exports){
module.exports = copy;

/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */
function copy(out, a) {
    out[0] = a[0]
    out[1] = a[1]
    out[2] = a[2]
    return out
}
},{}],80:[function(require,module,exports){
module.exports = create;

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */
function create() {
    var out = new Float32Array(3)
    out[0] = 0
    out[1] = 0
    out[2] = 0
    return out
}
},{}],81:[function(require,module,exports){
module.exports = cross;

/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function cross(out, a, b) {
    var ax = a[0], ay = a[1], az = a[2],
        bx = b[0], by = b[1], bz = b[2]

    out[0] = ay * bz - az * by
    out[1] = az * bx - ax * bz
    out[2] = ax * by - ay * bx
    return out
}
},{}],82:[function(require,module,exports){
module.exports = require('./distance')

},{"./distance":83}],83:[function(require,module,exports){
module.exports = distance;

/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */
function distance(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2]
    return Math.sqrt(x*x + y*y + z*z)
}
},{}],84:[function(require,module,exports){
module.exports = require('./divide')

},{"./divide":85}],85:[function(require,module,exports){
module.exports = divide;

/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function divide(out, a, b) {
    out[0] = a[0] / b[0]
    out[1] = a[1] / b[1]
    out[2] = a[2] / b[2]
    return out
}
},{}],86:[function(require,module,exports){
module.exports = dot;

/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */
function dot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2]
}
},{}],87:[function(require,module,exports){
module.exports = 0.000001

},{}],88:[function(require,module,exports){
module.exports = equals

var EPSILON = require('./epsilon')

/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function equals(a, b) {
  var a0 = a[0]
  var a1 = a[1]
  var a2 = a[2]
  var b0 = b[0]
  var b1 = b[1]
  var b2 = b[2]
  return (Math.abs(a0 - b0) <= EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) &&
          Math.abs(a1 - b1) <= EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) &&
          Math.abs(a2 - b2) <= EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2)))
}

},{"./epsilon":87}],89:[function(require,module,exports){
module.exports = exactEquals

/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2]
}

},{}],90:[function(require,module,exports){
module.exports = floor

/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */
function floor(out, a) {
  out[0] = Math.floor(a[0])
  out[1] = Math.floor(a[1])
  out[2] = Math.floor(a[2])
  return out
}

},{}],91:[function(require,module,exports){
module.exports = forEach;

var vec = require('./create')()

/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */
function forEach(a, stride, offset, count, fn, arg) {
        var i, l
        if(!stride) {
            stride = 3
        }

        if(!offset) {
            offset = 0
        }
        
        if(count) {
            l = Math.min((count * stride) + offset, a.length)
        } else {
            l = a.length
        }

        for(i = offset; i < l; i += stride) {
            vec[0] = a[i] 
            vec[1] = a[i+1] 
            vec[2] = a[i+2]
            fn(vec, vec, arg)
            a[i] = vec[0] 
            a[i+1] = vec[1] 
            a[i+2] = vec[2]
        }
        
        return a
}
},{"./create":80}],92:[function(require,module,exports){
module.exports = fromValues;

/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */
function fromValues(x, y, z) {
    var out = new Float32Array(3)
    out[0] = x
    out[1] = y
    out[2] = z
    return out
}
},{}],93:[function(require,module,exports){
module.exports = {
  EPSILON: require('./epsilon')
  , create: require('./create')
  , clone: require('./clone')
  , angle: require('./angle')
  , fromValues: require('./fromValues')
  , copy: require('./copy')
  , set: require('./set')
  , equals: require('./equals')
  , exactEquals: require('./exactEquals')
  , add: require('./add')
  , subtract: require('./subtract')
  , sub: require('./sub')
  , multiply: require('./multiply')
  , mul: require('./mul')
  , divide: require('./divide')
  , div: require('./div')
  , min: require('./min')
  , max: require('./max')
  , floor: require('./floor')
  , ceil: require('./ceil')
  , round: require('./round')
  , scale: require('./scale')
  , scaleAndAdd: require('./scaleAndAdd')
  , distance: require('./distance')
  , dist: require('./dist')
  , squaredDistance: require('./squaredDistance')
  , sqrDist: require('./sqrDist')
  , length: require('./length')
  , len: require('./len')
  , squaredLength: require('./squaredLength')
  , sqrLen: require('./sqrLen')
  , negate: require('./negate')
  , inverse: require('./inverse')
  , normalize: require('./normalize')
  , dot: require('./dot')
  , cross: require('./cross')
  , lerp: require('./lerp')
  , random: require('./random')
  , transformMat4: require('./transformMat4')
  , transformMat3: require('./transformMat3')
  , transformQuat: require('./transformQuat')
  , rotateX: require('./rotateX')
  , rotateY: require('./rotateY')
  , rotateZ: require('./rotateZ')
  , forEach: require('./forEach')
}

},{"./add":75,"./angle":76,"./ceil":77,"./clone":78,"./copy":79,"./create":80,"./cross":81,"./dist":82,"./distance":83,"./div":84,"./divide":85,"./dot":86,"./epsilon":87,"./equals":88,"./exactEquals":89,"./floor":90,"./forEach":91,"./fromValues":92,"./inverse":94,"./len":95,"./length":96,"./lerp":97,"./max":98,"./min":99,"./mul":100,"./multiply":101,"./negate":102,"./normalize":103,"./random":104,"./rotateX":105,"./rotateY":106,"./rotateZ":107,"./round":108,"./scale":109,"./scaleAndAdd":110,"./set":111,"./sqrDist":112,"./sqrLen":113,"./squaredDistance":114,"./squaredLength":115,"./sub":116,"./subtract":117,"./transformMat3":118,"./transformMat4":119,"./transformQuat":120}],94:[function(require,module,exports){
module.exports = inverse;

/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */
function inverse(out, a) {
  out[0] = 1.0 / a[0]
  out[1] = 1.0 / a[1]
  out[2] = 1.0 / a[2]
  return out
}
},{}],95:[function(require,module,exports){
module.exports = require('./length')

},{"./length":96}],96:[function(require,module,exports){
module.exports = length;

/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */
function length(a) {
    var x = a[0],
        y = a[1],
        z = a[2]
    return Math.sqrt(x*x + y*y + z*z)
}
},{}],97:[function(require,module,exports){
module.exports = lerp;

/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount between the two inputs
 * @returns {vec3} out
 */
function lerp(out, a, b, t) {
    var ax = a[0],
        ay = a[1],
        az = a[2]
    out[0] = ax + t * (b[0] - ax)
    out[1] = ay + t * (b[1] - ay)
    out[2] = az + t * (b[2] - az)
    return out
}
},{}],98:[function(require,module,exports){
module.exports = max;

/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function max(out, a, b) {
    out[0] = Math.max(a[0], b[0])
    out[1] = Math.max(a[1], b[1])
    out[2] = Math.max(a[2], b[2])
    return out
}
},{}],99:[function(require,module,exports){
module.exports = min;

/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function min(out, a, b) {
    out[0] = Math.min(a[0], b[0])
    out[1] = Math.min(a[1], b[1])
    out[2] = Math.min(a[2], b[2])
    return out
}
},{}],100:[function(require,module,exports){
module.exports = require('./multiply')

},{"./multiply":101}],101:[function(require,module,exports){
module.exports = multiply;

/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function multiply(out, a, b) {
    out[0] = a[0] * b[0]
    out[1] = a[1] * b[1]
    out[2] = a[2] * b[2]
    return out
}
},{}],102:[function(require,module,exports){
module.exports = negate;

/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */
function negate(out, a) {
    out[0] = -a[0]
    out[1] = -a[1]
    out[2] = -a[2]
    return out
}
},{}],103:[function(require,module,exports){
module.exports = normalize;

/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */
function normalize(out, a) {
    var x = a[0],
        y = a[1],
        z = a[2]
    var len = x*x + y*y + z*z
    if (len > 0) {
        //TODO: evaluate use of glm_invsqrt here?
        len = 1 / Math.sqrt(len)
        out[0] = a[0] * len
        out[1] = a[1] * len
        out[2] = a[2] * len
    }
    return out
}
},{}],104:[function(require,module,exports){
module.exports = random;

/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */
function random(out, scale) {
    scale = scale || 1.0

    var r = Math.random() * 2.0 * Math.PI
    var z = (Math.random() * 2.0) - 1.0
    var zScale = Math.sqrt(1.0-z*z) * scale

    out[0] = Math.cos(r) * zScale
    out[1] = Math.sin(r) * zScale
    out[2] = z * scale
    return out
}
},{}],105:[function(require,module,exports){
module.exports = rotateX;

/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateX(out, a, b, c){
    var by = b[1]
    var bz = b[2]

    // Translate point to the origin
    var py = a[1] - by
    var pz = a[2] - bz

    var sc = Math.sin(c)
    var cc = Math.cos(c)

    // perform rotation and translate to correct position
    out[0] = a[0]
    out[1] = by + py * cc - pz * sc
    out[2] = bz + py * sc + pz * cc

    return out
}

},{}],106:[function(require,module,exports){
module.exports = rotateY;

/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateY(out, a, b, c){
    var bx = b[0]
    var bz = b[2]

    // translate point to the origin
    var px = a[0] - bx
    var pz = a[2] - bz
    
    var sc = Math.sin(c)
    var cc = Math.cos(c)
  
    // perform rotation and translate to correct position
    out[0] = bx + pz * sc + px * cc
    out[1] = a[1]
    out[2] = bz + pz * cc - px * sc
  
    return out
}

},{}],107:[function(require,module,exports){
module.exports = rotateZ;

/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */
function rotateZ(out, a, b, c){
    var bx = b[0]
    var by = b[1]

    //Translate point to the origin
    var px = a[0] - bx
    var py = a[1] - by
  
    var sc = Math.sin(c)
    var cc = Math.cos(c)

    // perform rotation and translate to correct position
    out[0] = bx + px * cc - py * sc
    out[1] = by + px * sc + py * cc
    out[2] = a[2]
  
    return out
}

},{}],108:[function(require,module,exports){
module.exports = round

/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */
function round(out, a) {
  out[0] = Math.round(a[0])
  out[1] = Math.round(a[1])
  out[2] = Math.round(a[2])
  return out
}

},{}],109:[function(require,module,exports){
module.exports = scale;

/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */
function scale(out, a, b) {
    out[0] = a[0] * b
    out[1] = a[1] * b
    out[2] = a[2] * b
    return out
}
},{}],110:[function(require,module,exports){
module.exports = scaleAndAdd;

/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */
function scaleAndAdd(out, a, b, scale) {
    out[0] = a[0] + (b[0] * scale)
    out[1] = a[1] + (b[1] * scale)
    out[2] = a[2] + (b[2] * scale)
    return out
}
},{}],111:[function(require,module,exports){
module.exports = set;

/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */
function set(out, x, y, z) {
    out[0] = x
    out[1] = y
    out[2] = z
    return out
}
},{}],112:[function(require,module,exports){
module.exports = require('./squaredDistance')

},{"./squaredDistance":114}],113:[function(require,module,exports){
module.exports = require('./squaredLength')

},{"./squaredLength":115}],114:[function(require,module,exports){
module.exports = squaredDistance;

/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */
function squaredDistance(a, b) {
    var x = b[0] - a[0],
        y = b[1] - a[1],
        z = b[2] - a[2]
    return x*x + y*y + z*z
}
},{}],115:[function(require,module,exports){
module.exports = squaredLength;

/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */
function squaredLength(a) {
    var x = a[0],
        y = a[1],
        z = a[2]
    return x*x + y*y + z*z
}
},{}],116:[function(require,module,exports){
module.exports = require('./subtract')

},{"./subtract":117}],117:[function(require,module,exports){
module.exports = subtract;

/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */
function subtract(out, a, b) {
    out[0] = a[0] - b[0]
    out[1] = a[1] - b[1]
    out[2] = a[2] - b[2]
    return out
}
},{}],118:[function(require,module,exports){
module.exports = transformMat3;

/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */
function transformMat3(out, a, m) {
    var x = a[0], y = a[1], z = a[2]
    out[0] = x * m[0] + y * m[3] + z * m[6]
    out[1] = x * m[1] + y * m[4] + z * m[7]
    out[2] = x * m[2] + y * m[5] + z * m[8]
    return out
}
},{}],119:[function(require,module,exports){
module.exports = transformMat4;

/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */
function transformMat4(out, a, m) {
    var x = a[0], y = a[1], z = a[2],
        w = m[3] * x + m[7] * y + m[11] * z + m[15]
    w = w || 1.0
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w
    return out
}
},{}],120:[function(require,module,exports){
module.exports = transformQuat;

/**
 * Transforms the vec3 with a quat
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */
function transformQuat(out, a, q) {
    // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

    var x = a[0], y = a[1], z = a[2],
        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

        // calculate quat * vec
        ix = qw * x + qy * z - qz * y,
        iy = qw * y + qz * x - qx * z,
        iz = qw * z + qx * y - qy * x,
        iw = -qx * x - qy * y - qz * z

    // calculate result * inverse quat
    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy
    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz
    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx
    return out
}
},{}],121:[function(require,module,exports){
module.exports = function(strings) {
  if (typeof strings === 'string') strings = [strings]
  var exprs = [].slice.call(arguments,1)
  var parts = []
  for (var i = 0; i < strings.length-1; i++) {
    parts.push(strings[i], exprs[i] || '')
  }
  parts.push(strings[i])
  return parts.join('')
}

},{}],122:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],123:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],124:[function(require,module,exports){
"use strict"

function iota(n) {
  var result = new Array(n)
  for(var i=0; i<n; ++i) {
    result[i] = i
  }
  return result
}

module.exports = iota
},{}],125:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],126:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],127:[function(require,module,exports){
"use strict"

var compile = require("cwise-compiler")

var EmptyProc = {
  body: "",
  args: [],
  thisVars: [],
  localVars: []
}

function fixup(x) {
  if(!x) {
    return EmptyProc
  }
  for(var i=0; i<x.args.length; ++i) {
    var a = x.args[i]
    if(i === 0) {
      x.args[i] = {name: a, lvalue:true, rvalue: !!x.rvalue, count:x.count||1 }
    } else {
      x.args[i] = {name: a, lvalue:false, rvalue:true, count: 1}
    }
  }
  if(!x.thisVars) {
    x.thisVars = []
  }
  if(!x.localVars) {
    x.localVars = []
  }
  return x
}

function pcompile(user_args) {
  return compile({
    args:     user_args.args,
    pre:      fixup(user_args.pre),
    body:     fixup(user_args.body),
    post:     fixup(user_args.proc),
    funcName: user_args.funcName
  })
}

function makeOp(user_args) {
  var args = []
  for(var i=0; i<user_args.args.length; ++i) {
    args.push("a"+i)
  }
  var wrapper = new Function("P", [
    "return function ", user_args.funcName, "_ndarrayops(", args.join(","), ") {P(", args.join(","), ");return a0}"
  ].join(""))
  return wrapper(pcompile(user_args))
}

var assign_ops = {
  add:  "+",
  sub:  "-",
  mul:  "*",
  div:  "/",
  mod:  "%",
  band: "&",
  bor:  "|",
  bxor: "^",
  lshift: "<<",
  rshift: ">>",
  rrshift: ">>>"
}
;(function(){
  for(var id in assign_ops) {
    var op = assign_ops[id]
    exports[id] = makeOp({
      args: ["array","array","array"],
      body: {args:["a","b","c"],
             body: "a=b"+op+"c"},
      funcName: id
    })
    exports[id+"eq"] = makeOp({
      args: ["array","array"],
      body: {args:["a","b"],
             body:"a"+op+"=b"},
      rvalue: true,
      funcName: id+"eq"
    })
    exports[id+"s"] = makeOp({
      args: ["array", "array", "scalar"],
      body: {args:["a","b","s"],
             body:"a=b"+op+"s"},
      funcName: id+"s"
    })
    exports[id+"seq"] = makeOp({
      args: ["array","scalar"],
      body: {args:["a","s"],
             body:"a"+op+"=s"},
      rvalue: true,
      funcName: id+"seq"
    })
  }
})();

var unary_ops = {
  not: "!",
  bnot: "~",
  neg: "-",
  recip: "1.0/"
}
;(function(){
  for(var id in unary_ops) {
    var op = unary_ops[id]
    exports[id] = makeOp({
      args: ["array", "array"],
      body: {args:["a","b"],
             body:"a="+op+"b"},
      funcName: id
    })
    exports[id+"eq"] = makeOp({
      args: ["array"],
      body: {args:["a"],
             body:"a="+op+"a"},
      rvalue: true,
      count: 2,
      funcName: id+"eq"
    })
  }
})();

var binary_ops = {
  and: "&&",
  or: "||",
  eq: "===",
  neq: "!==",
  lt: "<",
  gt: ">",
  leq: "<=",
  geq: ">="
}
;(function() {
  for(var id in binary_ops) {
    var op = binary_ops[id]
    exports[id] = makeOp({
      args: ["array","array","array"],
      body: {args:["a", "b", "c"],
             body:"a=b"+op+"c"},
      funcName: id
    })
    exports[id+"s"] = makeOp({
      args: ["array","array","scalar"],
      body: {args:["a", "b", "s"],
             body:"a=b"+op+"s"},
      funcName: id+"s"
    })
    exports[id+"eq"] = makeOp({
      args: ["array", "array"],
      body: {args:["a", "b"],
             body:"a=a"+op+"b"},
      rvalue:true,
      count:2,
      funcName: id+"eq"
    })
    exports[id+"seq"] = makeOp({
      args: ["array", "scalar"],
      body: {args:["a","s"],
             body:"a=a"+op+"s"},
      rvalue:true,
      count:2,
      funcName: id+"seq"
    })
  }
})();

var math_unary = [
  "abs",
  "acos",
  "asin",
  "atan",
  "ceil",
  "cos",
  "exp",
  "floor",
  "log",
  "round",
  "sin",
  "sqrt",
  "tan"
]
;(function() {
  for(var i=0; i<math_unary.length; ++i) {
    var f = math_unary[i]
    exports[f] = makeOp({
                    args: ["array", "array"],
                    pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                    body: {args:["a","b"], body:"a=this_f(b)", thisVars:["this_f"]},
                    funcName: f
                  })
    exports[f+"eq"] = makeOp({
                      args: ["array"],
                      pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                      body: {args: ["a"], body:"a=this_f(a)", thisVars:["this_f"]},
                      rvalue: true,
                      count: 2,
                      funcName: f+"eq"
                    })
  }
})();

var math_comm = [
  "max",
  "min",
  "atan2",
  "pow"
]
;(function(){
  for(var i=0; i<math_comm.length; ++i) {
    var f= math_comm[i]
    exports[f] = makeOp({
                  args:["array", "array", "array"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b","c"], body:"a=this_f(b,c)", thisVars:["this_f"]},
                  funcName: f
                })
    exports[f+"s"] = makeOp({
                  args:["array", "array", "scalar"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b","c"], body:"a=this_f(b,c)", thisVars:["this_f"]},
                  funcName: f+"s"
                  })
    exports[f+"eq"] = makeOp({ args:["array", "array"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b"], body:"a=this_f(a,b)", thisVars:["this_f"]},
                  rvalue: true,
                  count: 2,
                  funcName: f+"eq"
                  })
    exports[f+"seq"] = makeOp({ args:["array", "scalar"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b"], body:"a=this_f(a,b)", thisVars:["this_f"]},
                  rvalue:true,
                  count:2,
                  funcName: f+"seq"
                  })
  }
})();

var math_noncomm = [
  "atan2",
  "pow"
]
;(function(){
  for(var i=0; i<math_noncomm.length; ++i) {
    var f= math_noncomm[i]
    exports[f+"op"] = makeOp({
                  args:["array", "array", "array"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b","c"], body:"a=this_f(c,b)", thisVars:["this_f"]},
                  funcName: f+"op"
                })
    exports[f+"ops"] = makeOp({
                  args:["array", "array", "scalar"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b","c"], body:"a=this_f(c,b)", thisVars:["this_f"]},
                  funcName: f+"ops"
                  })
    exports[f+"opeq"] = makeOp({ args:["array", "array"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b"], body:"a=this_f(b,a)", thisVars:["this_f"]},
                  rvalue: true,
                  count: 2,
                  funcName: f+"opeq"
                  })
    exports[f+"opseq"] = makeOp({ args:["array", "scalar"],
                  pre: {args:[], body:"this_f=Math."+f, thisVars:["this_f"]},
                  body: {args:["a","b"], body:"a=this_f(b,a)", thisVars:["this_f"]},
                  rvalue:true,
                  count:2,
                  funcName: f+"opseq"
                  })
  }
})();

exports.any = compile({
  args:["array"],
  pre: EmptyProc,
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:1}], body: "if(a){return true}", localVars: [], thisVars: []},
  post: {args:[], localVars:[], thisVars:[], body:"return false"},
  funcName: "any"
})

exports.all = compile({
  args:["array"],
  pre: EmptyProc,
  body: {args:[{name:"x", lvalue:false, rvalue:true, count:1}], body: "if(!x){return false}", localVars: [], thisVars: []},
  post: {args:[], localVars:[], thisVars:[], body:"return true"},
  funcName: "all"
})

exports.sum = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:1}], body: "this_s+=a", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
  funcName: "sum"
})

exports.prod = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=1"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:1}], body: "this_s*=a", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
  funcName: "prod"
})

exports.norm2squared = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:2}], body: "this_s+=a*a", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
  funcName: "norm2squared"
})
  
exports.norm2 = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:2}], body: "this_s+=a*a", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return Math.sqrt(this_s)"},
  funcName: "norm2"
})
  

exports.norminf = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:4}], body:"if(-a>this_s){this_s=-a}else if(a>this_s){this_s=a}", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
  funcName: "norminf"
})

exports.norm1 = compile({
  args:["array"],
  pre: {args:[], localVars:[], thisVars:["this_s"], body:"this_s=0"},
  body: {args:[{name:"a", lvalue:false, rvalue:true, count:3}], body: "this_s+=a<0?-a:a", localVars: [], thisVars: ["this_s"]},
  post: {args:[], localVars:[], thisVars:["this_s"], body:"return this_s"},
  funcName: "norm1"
})

exports.sup = compile({
  args: [ "array" ],
  pre:
   { body: "this_h=-Infinity",
     args: [],
     thisVars: [ "this_h" ],
     localVars: [] },
  body:
   { body: "if(_inline_1_arg0_>this_h)this_h=_inline_1_arg0_",
     args: [{"name":"_inline_1_arg0_","lvalue":false,"rvalue":true,"count":2} ],
     thisVars: [ "this_h" ],
     localVars: [] },
  post:
   { body: "return this_h",
     args: [],
     thisVars: [ "this_h" ],
     localVars: [] }
 })

exports.inf = compile({
  args: [ "array" ],
  pre:
   { body: "this_h=Infinity",
     args: [],
     thisVars: [ "this_h" ],
     localVars: [] },
  body:
   { body: "if(_inline_1_arg0_<this_h)this_h=_inline_1_arg0_",
     args: [{"name":"_inline_1_arg0_","lvalue":false,"rvalue":true,"count":2} ],
     thisVars: [ "this_h" ],
     localVars: [] },
  post:
   { body: "return this_h",
     args: [],
     thisVars: [ "this_h" ],
     localVars: [] }
 })

exports.argmin = compile({
  args:["index","array","shape"],
  pre:{
    body:"{this_v=Infinity;this_i=_inline_0_arg2_.slice(0)}",
    args:[
      {name:"_inline_0_arg0_",lvalue:false,rvalue:false,count:0},
      {name:"_inline_0_arg1_",lvalue:false,rvalue:false,count:0},
      {name:"_inline_0_arg2_",lvalue:false,rvalue:true,count:1}
      ],
    thisVars:["this_i","this_v"],
    localVars:[]},
  body:{
    body:"{if(_inline_1_arg1_<this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
    args:[
      {name:"_inline_1_arg0_",lvalue:false,rvalue:true,count:2},
      {name:"_inline_1_arg1_",lvalue:false,rvalue:true,count:2}],
    thisVars:["this_i","this_v"],
    localVars:["_inline_1_k"]},
  post:{
    body:"{return this_i}",
    args:[],
    thisVars:["this_i"],
    localVars:[]}
})

exports.argmax = compile({
  args:["index","array","shape"],
  pre:{
    body:"{this_v=-Infinity;this_i=_inline_0_arg2_.slice(0)}",
    args:[
      {name:"_inline_0_arg0_",lvalue:false,rvalue:false,count:0},
      {name:"_inline_0_arg1_",lvalue:false,rvalue:false,count:0},
      {name:"_inline_0_arg2_",lvalue:false,rvalue:true,count:1}
      ],
    thisVars:["this_i","this_v"],
    localVars:[]},
  body:{
    body:"{if(_inline_1_arg1_>this_v){this_v=_inline_1_arg1_;for(var _inline_1_k=0;_inline_1_k<_inline_1_arg0_.length;++_inline_1_k){this_i[_inline_1_k]=_inline_1_arg0_[_inline_1_k]}}}",
    args:[
      {name:"_inline_1_arg0_",lvalue:false,rvalue:true,count:2},
      {name:"_inline_1_arg1_",lvalue:false,rvalue:true,count:2}],
    thisVars:["this_i","this_v"],
    localVars:["_inline_1_k"]},
  post:{
    body:"{return this_i}",
    args:[],
    thisVars:["this_i"],
    localVars:[]}
})  

exports.random = makeOp({
  args: ["array"],
  pre: {args:[], body:"this_f=Math.random", thisVars:["this_f"]},
  body: {args: ["a"], body:"a=this_f()", thisVars:["this_f"]},
  funcName: "random"
})

exports.assign = makeOp({
  args:["array", "array"],
  body: {args:["a", "b"], body:"a=b"},
  funcName: "assign" })

exports.assigns = makeOp({
  args:["array", "scalar"],
  body: {args:["a", "b"], body:"a=b"},
  funcName: "assigns" })


exports.equals = compile({
  args:["array", "array"],
  pre: EmptyProc,
  body: {args:[{name:"x", lvalue:false, rvalue:true, count:1},
               {name:"y", lvalue:false, rvalue:true, count:1}], 
        body: "if(x!==y){return false}", 
        localVars: [], 
        thisVars: []},
  post: {args:[], localVars:[], thisVars:[], body:"return true"},
  funcName: "equals"
})



},{"cwise-compiler":37}],128:[function(require,module,exports){
"use strict"

var ndarray = require("ndarray")
var do_convert = require("./doConvert.js")

module.exports = function convert(arr, result) {
  var shape = [], c = arr, sz = 1
  while(Array.isArray(c)) {
    shape.push(c.length)
    sz *= c.length
    c = c[0]
  }
  if(shape.length === 0) {
    return ndarray()
  }
  if(!result) {
    result = ndarray(new Float64Array(sz), shape)
  }
  do_convert(result, arr)
  return result
}

},{"./doConvert.js":129,"ndarray":130}],129:[function(require,module,exports){
module.exports=require('cwise-compiler')({"args":["array","scalar","index"],"pre":{"body":"{}","args":[],"thisVars":[],"localVars":[]},"body":{"body":"{\nvar _inline_1_v=_inline_1_arg1_,_inline_1_i\nfor(_inline_1_i=0;_inline_1_i<_inline_1_arg2_.length-1;++_inline_1_i) {\n_inline_1_v=_inline_1_v[_inline_1_arg2_[_inline_1_i]]\n}\n_inline_1_arg0_=_inline_1_v[_inline_1_arg2_[_inline_1_arg2_.length-1]]\n}","args":[{"name":"_inline_1_arg0_","lvalue":true,"rvalue":false,"count":1},{"name":"_inline_1_arg1_","lvalue":false,"rvalue":true,"count":1},{"name":"_inline_1_arg2_","lvalue":false,"rvalue":true,"count":4}],"thisVars":[],"localVars":["_inline_1_i","_inline_1_v"]},"post":{"body":"{}","args":[],"thisVars":[],"localVars":[]},"funcName":"convert","blockSize":64})

},{"cwise-compiler":37}],130:[function(require,module,exports){
var iota = require("iota-array")
var isBuffer = require("is-buffer")

var hasTypedArrays  = ((typeof Float64Array) !== "undefined")

function compare1st(a, b) {
  return a[0] - b[0]
}

function order() {
  var stride = this.stride
  var terms = new Array(stride.length)
  var i
  for(i=0; i<terms.length; ++i) {
    terms[i] = [Math.abs(stride[i]), i]
  }
  terms.sort(compare1st)
  var result = new Array(terms.length)
  for(i=0; i<result.length; ++i) {
    result[i] = terms[i][1]
  }
  return result
}

function compileConstructor(dtype, dimension) {
  var className = ["View", dimension, "d", dtype].join("")
  if(dimension < 0) {
    className = "View_Nil" + dtype
  }
  var useGetters = (dtype === "generic")

  if(dimension === -1) {
    //Special case for trivial arrays
    var code =
      "function "+className+"(a){this.data=a;};\
var proto="+className+".prototype;\
proto.dtype='"+dtype+"';\
proto.index=function(){return -1};\
proto.size=0;\
proto.dimension=-1;\
proto.shape=proto.stride=proto.order=[];\
proto.lo=proto.hi=proto.transpose=proto.step=\
function(){return new "+className+"(this.data);};\
proto.get=proto.set=function(){};\
proto.pick=function(){return null};\
return function construct_"+className+"(a){return new "+className+"(a);}"
    var procedure = new Function(code)
    return procedure()
  } else if(dimension === 0) {
    //Special case for 0d arrays
    var code =
      "function "+className+"(a,d) {\
this.data = a;\
this.offset = d\
};\
var proto="+className+".prototype;\
proto.dtype='"+dtype+"';\
proto.index=function(){return this.offset};\
proto.dimension=0;\
proto.size=1;\
proto.shape=\
proto.stride=\
proto.order=[];\
proto.lo=\
proto.hi=\
proto.transpose=\
proto.step=function "+className+"_copy() {\
return new "+className+"(this.data,this.offset)\
};\
proto.pick=function "+className+"_pick(){\
return TrivialArray(this.data);\
};\
proto.valueOf=proto.get=function "+className+"_get(){\
return "+(useGetters ? "this.data.get(this.offset)" : "this.data[this.offset]")+
"};\
proto.set=function "+className+"_set(v){\
return "+(useGetters ? "this.data.set(this.offset,v)" : "this.data[this.offset]=v")+"\
};\
return function construct_"+className+"(a,b,c,d){return new "+className+"(a,d)}"
    var procedure = new Function("TrivialArray", code)
    return procedure(CACHED_CONSTRUCTORS[dtype][0])
  }

  var code = ["'use strict'"]

  //Create constructor for view
  var indices = iota(dimension)
  var args = indices.map(function(i) { return "i"+i })
  var index_str = "this.offset+" + indices.map(function(i) {
        return "this.stride[" + i + "]*i" + i
      }).join("+")
  var shapeArg = indices.map(function(i) {
      return "b"+i
    }).join(",")
  var strideArg = indices.map(function(i) {
      return "c"+i
    }).join(",")
  code.push(
    "function "+className+"(a," + shapeArg + "," + strideArg + ",d){this.data=a",
      "this.shape=[" + shapeArg + "]",
      "this.stride=[" + strideArg + "]",
      "this.offset=d|0}",
    "var proto="+className+".prototype",
    "proto.dtype='"+dtype+"'",
    "proto.dimension="+dimension)

  //view.size:
  code.push("Object.defineProperty(proto,'size',{get:function "+className+"_size(){\
return "+indices.map(function(i) { return "this.shape["+i+"]" }).join("*"),
"}})")

  //view.order:
  if(dimension === 1) {
    code.push("proto.order=[0]")
  } else {
    code.push("Object.defineProperty(proto,'order',{get:")
    if(dimension < 4) {
      code.push("function "+className+"_order(){")
      if(dimension === 2) {
        code.push("return (Math.abs(this.stride[0])>Math.abs(this.stride[1]))?[1,0]:[0,1]}})")
      } else if(dimension === 3) {
        code.push(
"var s0=Math.abs(this.stride[0]),s1=Math.abs(this.stride[1]),s2=Math.abs(this.stride[2]);\
if(s0>s1){\
if(s1>s2){\
return [2,1,0];\
}else if(s0>s2){\
return [1,2,0];\
}else{\
return [1,0,2];\
}\
}else if(s0>s2){\
return [2,0,1];\
}else if(s2>s1){\
return [0,1,2];\
}else{\
return [0,2,1];\
}}})")
      }
    } else {
      code.push("ORDER})")
    }
  }

  //view.set(i0, ..., v):
  code.push(
"proto.set=function "+className+"_set("+args.join(",")+",v){")
  if(useGetters) {
    code.push("return this.data.set("+index_str+",v)}")
  } else {
    code.push("return this.data["+index_str+"]=v}")
  }

  //view.get(i0, ...):
  code.push("proto.get=function "+className+"_get("+args.join(",")+"){")
  if(useGetters) {
    code.push("return this.data.get("+index_str+")}")
  } else {
    code.push("return this.data["+index_str+"]}")
  }

  //view.index:
  code.push(
    "proto.index=function "+className+"_index(", args.join(), "){return "+index_str+"}")

  //view.hi():
  code.push("proto.hi=function "+className+"_hi("+args.join(",")+"){return new "+className+"(this.data,"+
    indices.map(function(i) {
      return ["(typeof i",i,"!=='number'||i",i,"<0)?this.shape[", i, "]:i", i,"|0"].join("")
    }).join(",")+","+
    indices.map(function(i) {
      return "this.stride["+i + "]"
    }).join(",")+",this.offset)}")

  //view.lo():
  var a_vars = indices.map(function(i) { return "a"+i+"=this.shape["+i+"]" })
  var c_vars = indices.map(function(i) { return "c"+i+"=this.stride["+i+"]" })
  code.push("proto.lo=function "+className+"_lo("+args.join(",")+"){var b=this.offset,d=0,"+a_vars.join(",")+","+c_vars.join(","))
  for(var i=0; i<dimension; ++i) {
    code.push(
"if(typeof i"+i+"==='number'&&i"+i+">=0){\
d=i"+i+"|0;\
b+=c"+i+"*d;\
a"+i+"-=d}")
  }
  code.push("return new "+className+"(this.data,"+
    indices.map(function(i) {
      return "a"+i
    }).join(",")+","+
    indices.map(function(i) {
      return "c"+i
    }).join(",")+",b)}")

  //view.step():
  code.push("proto.step=function "+className+"_step("+args.join(",")+"){var "+
    indices.map(function(i) {
      return "a"+i+"=this.shape["+i+"]"
    }).join(",")+","+
    indices.map(function(i) {
      return "b"+i+"=this.stride["+i+"]"
    }).join(",")+",c=this.offset,d=0,ceil=Math.ceil")
  for(var i=0; i<dimension; ++i) {
    code.push(
"if(typeof i"+i+"==='number'){\
d=i"+i+"|0;\
if(d<0){\
c+=b"+i+"*(a"+i+"-1);\
a"+i+"=ceil(-a"+i+"/d)\
}else{\
a"+i+"=ceil(a"+i+"/d)\
}\
b"+i+"*=d\
}")
  }
  code.push("return new "+className+"(this.data,"+
    indices.map(function(i) {
      return "a" + i
    }).join(",")+","+
    indices.map(function(i) {
      return "b" + i
    }).join(",")+",c)}")

  //view.transpose():
  var tShape = new Array(dimension)
  var tStride = new Array(dimension)
  for(var i=0; i<dimension; ++i) {
    tShape[i] = "a[i"+i+"]"
    tStride[i] = "b[i"+i+"]"
  }
  code.push("proto.transpose=function "+className+"_transpose("+args+"){"+
    args.map(function(n,idx) { return n + "=(" + n + "===undefined?" + idx + ":" + n + "|0)"}).join(";"),
    "var a=this.shape,b=this.stride;return new "+className+"(this.data,"+tShape.join(",")+","+tStride.join(",")+",this.offset)}")

  //view.pick():
  code.push("proto.pick=function "+className+"_pick("+args+"){var a=[],b=[],c=this.offset")
  for(var i=0; i<dimension; ++i) {
    code.push("if(typeof i"+i+"==='number'&&i"+i+">=0){c=(c+this.stride["+i+"]*i"+i+")|0}else{a.push(this.shape["+i+"]);b.push(this.stride["+i+"])}")
  }
  code.push("var ctor=CTOR_LIST[a.length+1];return ctor(this.data,a,b,c)}")

  //Add return statement
  code.push("return function construct_"+className+"(data,shape,stride,offset){return new "+className+"(data,"+
    indices.map(function(i) {
      return "shape["+i+"]"
    }).join(",")+","+
    indices.map(function(i) {
      return "stride["+i+"]"
    }).join(",")+",offset)}")

  //Compile procedure
  var procedure = new Function("CTOR_LIST", "ORDER", code.join("\n"))
  return procedure(CACHED_CONSTRUCTORS[dtype], order)
}

function arrayDType(data) {
  if(isBuffer(data)) {
    return "buffer"
  }
  if(hasTypedArrays) {
    switch(Object.prototype.toString.call(data)) {
      case "[object Float64Array]":
        return "float64"
      case "[object Float32Array]":
        return "float32"
      case "[object Int8Array]":
        return "int8"
      case "[object Int16Array]":
        return "int16"
      case "[object Int32Array]":
        return "int32"
      case "[object Uint8Array]":
        return "uint8"
      case "[object Uint16Array]":
        return "uint16"
      case "[object Uint32Array]":
        return "uint32"
      case "[object Uint8ClampedArray]":
        return "uint8_clamped"
      case "[object BigInt64Array]":
        return "bigint64"
      case "[object BigUint64Array]":
        return "biguint64"
    }
  }
  if(Array.isArray(data)) {
    return "array"
  }
  return "generic"
}

var CACHED_CONSTRUCTORS = {
  "float32":[],
  "float64":[],
  "int8":[],
  "int16":[],
  "int32":[],
  "uint8":[],
  "uint16":[],
  "uint32":[],
  "array":[],
  "uint8_clamped":[],
  "bigint64": [],
  "biguint64": [],
  "buffer":[],
  "generic":[]
}

;(function() {
  for(var id in CACHED_CONSTRUCTORS) {
    CACHED_CONSTRUCTORS[id].push(compileConstructor(id, -1))
  }
});

function wrappedNDArrayCtor(data, shape, stride, offset) {
  if(data === undefined) {
    var ctor = CACHED_CONSTRUCTORS.array[0]
    return ctor([])
  } else if(typeof data === "number") {
    data = [data]
  }
  if(shape === undefined) {
    shape = [ data.length ]
  }
  var d = shape.length
  if(stride === undefined) {
    stride = new Array(d)
    for(var i=d-1, sz=1; i>=0; --i) {
      stride[i] = sz
      sz *= shape[i]
    }
  }
  if(offset === undefined) {
    offset = 0
    for(var i=0; i<d; ++i) {
      if(stride[i] < 0) {
        offset -= (shape[i]-1)*stride[i]
      }
    }
  }
  var dtype = arrayDType(data)
  var ctor_list = CACHED_CONSTRUCTORS[dtype]
  while(ctor_list.length <= d+1) {
    ctor_list.push(compileConstructor(dtype, ctor_list.length-1))
  }
  var ctor = ctor_list[d+1]
  return ctor(data, shape, stride, offset)
}

module.exports = wrappedNDArrayCtor

},{"iota-array":124,"is-buffer":125}],131:[function(require,module,exports){
// (c) Dean McNamee <dean@gmail.com>, 2013.
//
// https://github.com/deanm/omggif
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
//
// omggif is a JavaScript implementation of a GIF 89a encoder and decoder,
// including animation and compression.  It does not rely on any specific
// underlying system, so should run in the browser, Node, or Plask.

"use strict";

function GifWriter(buf, width, height, gopts) {
  var p = 0;

  var gopts = gopts === undefined ? { } : gopts;
  var loop_count = gopts.loop === undefined ? null : gopts.loop;
  var global_palette = gopts.palette === undefined ? null : gopts.palette;

  if (width <= 0 || height <= 0 || width > 65535 || height > 65535)
    throw new Error("Width/Height invalid.");

  function check_palette_and_num_colors(palette) {
    var num_colors = palette.length;
    if (num_colors < 2 || num_colors > 256 ||  num_colors & (num_colors-1)) {
      throw new Error(
          "Invalid code/color length, must be power of 2 and 2 .. 256.");
    }
    return num_colors;
  }

  // - Header.
  buf[p++] = 0x47; buf[p++] = 0x49; buf[p++] = 0x46;  // GIF
  buf[p++] = 0x38; buf[p++] = 0x39; buf[p++] = 0x61;  // 89a

  // Handling of Global Color Table (palette) and background index.
  var gp_num_colors_pow2 = 0;
  var background = 0;
  if (global_palette !== null) {
    var gp_num_colors = check_palette_and_num_colors(global_palette);
    while (gp_num_colors >>= 1) ++gp_num_colors_pow2;
    gp_num_colors = 1 << gp_num_colors_pow2;
    --gp_num_colors_pow2;
    if (gopts.background !== undefined) {
      background = gopts.background;
      if (background >= gp_num_colors)
        throw new Error("Background index out of range.");
      // The GIF spec states that a background index of 0 should be ignored, so
      // this is probably a mistake and you really want to set it to another
      // slot in the palette.  But actually in the end most browsers, etc end
      // up ignoring this almost completely (including for dispose background).
      if (background === 0)
        throw new Error("Background index explicitly passed as 0.");
    }
  }

  // - Logical Screen Descriptor.
  // NOTE(deanm): w/h apparently ignored by implementations, but set anyway.
  buf[p++] = width & 0xff; buf[p++] = width >> 8 & 0xff;
  buf[p++] = height & 0xff; buf[p++] = height >> 8 & 0xff;
  // NOTE: Indicates 0-bpp original color resolution (unused?).
  buf[p++] = (global_palette !== null ? 0x80 : 0) |  // Global Color Table Flag.
             gp_num_colors_pow2;  // NOTE: No sort flag (unused?).
  buf[p++] = background;  // Background Color Index.
  buf[p++] = 0;  // Pixel aspect ratio (unused?).

  // - Global Color Table
  if (global_palette !== null) {
    for (var i = 0, il = global_palette.length; i < il; ++i) {
      var rgb = global_palette[i];
      buf[p++] = rgb >> 16 & 0xff;
      buf[p++] = rgb >> 8 & 0xff;
      buf[p++] = rgb & 0xff;
    }
  }

  if (loop_count !== null) {  // Netscape block for looping.
    if (loop_count < 0 || loop_count > 65535)
      throw new Error("Loop count invalid.")
    // Extension code, label, and length.
    buf[p++] = 0x21; buf[p++] = 0xff; buf[p++] = 0x0b;
    // NETSCAPE2.0
    buf[p++] = 0x4e; buf[p++] = 0x45; buf[p++] = 0x54; buf[p++] = 0x53;
    buf[p++] = 0x43; buf[p++] = 0x41; buf[p++] = 0x50; buf[p++] = 0x45;
    buf[p++] = 0x32; buf[p++] = 0x2e; buf[p++] = 0x30;
    // Sub-block
    buf[p++] = 0x03; buf[p++] = 0x01;
    buf[p++] = loop_count & 0xff; buf[p++] = loop_count >> 8 & 0xff;
    buf[p++] = 0x00;  // Terminator.
  }


  var ended = false;

  this.addFrame = function(x, y, w, h, indexed_pixels, opts) {
    if (ended === true) { --p; ended = false; }  // Un-end.

    opts = opts === undefined ? { } : opts;

    // TODO(deanm): Bounds check x, y.  Do they need to be within the virtual
    // canvas width/height, I imagine?
    if (x < 0 || y < 0 || x > 65535 || y > 65535)
      throw new Error("x/y invalid.")

    if (w <= 0 || h <= 0 || w > 65535 || h > 65535)
      throw new Error("Width/Height invalid.")

    if (indexed_pixels.length < w * h)
      throw new Error("Not enough pixels for the frame size.");

    var using_local_palette = true;
    var palette = opts.palette;
    if (palette === undefined || palette === null) {
      using_local_palette = false;
      palette = global_palette;
    }

    if (palette === undefined || palette === null)
      throw new Error("Must supply either a local or global palette.");

    var num_colors = check_palette_and_num_colors(palette);

    // Compute the min_code_size (power of 2), destroying num_colors.
    var min_code_size = 0;
    while (num_colors >>= 1) ++min_code_size;
    num_colors = 1 << min_code_size;  // Now we can easily get it back.

    var delay = opts.delay === undefined ? 0 : opts.delay;

    // From the spec:
    //     0 -   No disposal specified. The decoder is
    //           not required to take any action.
    //     1 -   Do not dispose. The graphic is to be left
    //           in place.
    //     2 -   Restore to background color. The area used by the
    //           graphic must be restored to the background color.
    //     3 -   Restore to previous. The decoder is required to
    //           restore the area overwritten by the graphic with
    //           what was there prior to rendering the graphic.
    //  4-7 -    To be defined.
    // NOTE(deanm): Dispose background doesn't really work, apparently most
    // browsers ignore the background palette index and clear to transparency.
    var disposal = opts.disposal === undefined ? 0 : opts.disposal;
    if (disposal < 0 || disposal > 3)  // 4-7 is reserved.
      throw new Error("Disposal out of range.");

    var use_transparency = false;
    var transparent_index = 0;
    if (opts.transparent !== undefined && opts.transparent !== null) {
      use_transparency = true;
      transparent_index = opts.transparent;
      if (transparent_index < 0 || transparent_index >= num_colors)
        throw new Error("Transparent color index.");
    }

    if (disposal !== 0 || use_transparency || delay !== 0) {
      // - Graphics Control Extension
      buf[p++] = 0x21; buf[p++] = 0xf9;  // Extension / Label.
      buf[p++] = 4;  // Byte size.

      buf[p++] = disposal << 2 | (use_transparency === true ? 1 : 0);
      buf[p++] = delay & 0xff; buf[p++] = delay >> 8 & 0xff;
      buf[p++] = transparent_index;  // Transparent color index.
      buf[p++] = 0;  // Block Terminator.
    }

    // - Image Descriptor
    buf[p++] = 0x2c;  // Image Seperator.
    buf[p++] = x & 0xff; buf[p++] = x >> 8 & 0xff;  // Left.
    buf[p++] = y & 0xff; buf[p++] = y >> 8 & 0xff;  // Top.
    buf[p++] = w & 0xff; buf[p++] = w >> 8 & 0xff;
    buf[p++] = h & 0xff; buf[p++] = h >> 8 & 0xff;
    // NOTE: No sort flag (unused?).
    // TODO(deanm): Support interlace.
    buf[p++] = using_local_palette === true ? (0x80 | (min_code_size-1)) : 0;

    // - Local Color Table
    if (using_local_palette === true) {
      for (var i = 0, il = palette.length; i < il; ++i) {
        var rgb = palette[i];
        buf[p++] = rgb >> 16 & 0xff;
        buf[p++] = rgb >> 8 & 0xff;
        buf[p++] = rgb & 0xff;
      }
    }

    p = GifWriterOutputLZWCodeStream(
            buf, p, min_code_size < 2 ? 2 : min_code_size, indexed_pixels);

    return p;
  };

  this.end = function() {
    if (ended === false) {
      buf[p++] = 0x3b;  // Trailer.
      ended = true;
    }
    return p;
  };

  this.getOutputBuffer = function() { return buf; };
  this.setOutputBuffer = function(v) { buf = v; };
  this.getOutputBufferPosition = function() { return p; };
  this.setOutputBufferPosition = function(v) { p = v; };
}

// Main compression routine, palette indexes -> LZW code stream.
// |index_stream| must have at least one entry.
function GifWriterOutputLZWCodeStream(buf, p, min_code_size, index_stream) {
  buf[p++] = min_code_size;
  var cur_subblock = p++;  // Pointing at the length field.

  var clear_code = 1 << min_code_size;
  var code_mask = clear_code - 1;
  var eoi_code = clear_code + 1;
  var next_code = eoi_code + 1;

  var cur_code_size = min_code_size + 1;  // Number of bits per code.
  var cur_shift = 0;
  // We have at most 12-bit codes, so we should have to hold a max of 19
  // bits here (and then we would write out).
  var cur = 0;

  function emit_bytes_to_buffer(bit_block_size) {
    while (cur_shift >= bit_block_size) {
      buf[p++] = cur & 0xff;
      cur >>= 8; cur_shift -= 8;
      if (p === cur_subblock + 256) {  // Finished a subblock.
        buf[cur_subblock] = 255;
        cur_subblock = p++;
      }
    }
  }

  function emit_code(c) {
    cur |= c << cur_shift;
    cur_shift += cur_code_size;
    emit_bytes_to_buffer(8);
  }

  // I am not an expert on the topic, and I don't want to write a thesis.
  // However, it is good to outline here the basic algorithm and the few data
  // structures and optimizations here that make this implementation fast.
  // The basic idea behind LZW is to build a table of previously seen runs
  // addressed by a short id (herein called output code).  All data is
  // referenced by a code, which represents one or more values from the
  // original input stream.  All input bytes can be referenced as the same
  // value as an output code.  So if you didn't want any compression, you
  // could more or less just output the original bytes as codes (there are
  // some details to this, but it is the idea).  In order to achieve
  // compression, values greater then the input range (codes can be up to
  // 12-bit while input only 8-bit) represent a sequence of previously seen
  // inputs.  The decompressor is able to build the same mapping while
  // decoding, so there is always a shared common knowledge between the
  // encoding and decoder, which is also important for "timing" aspects like
  // how to handle variable bit width code encoding.
  //
  // One obvious but very important consequence of the table system is there
  // is always a unique id (at most 12-bits) to map the runs.  'A' might be
  // 4, then 'AA' might be 10, 'AAA' 11, 'AAAA' 12, etc.  This relationship
  // can be used for an effecient lookup strategy for the code mapping.  We
  // need to know if a run has been seen before, and be able to map that run
  // to the output code.  Since we start with known unique ids (input bytes),
  // and then from those build more unique ids (table entries), we can
  // continue this chain (almost like a linked list) to always have small
  // integer values that represent the current byte chains in the encoder.
  // This means instead of tracking the input bytes (AAAABCD) to know our
  // current state, we can track the table entry for AAAABC (it is guaranteed
  // to exist by the nature of the algorithm) and the next character D.
  // Therefor the tuple of (table_entry, byte) is guaranteed to also be
  // unique.  This allows us to create a simple lookup key for mapping input
  // sequences to codes (table indices) without having to store or search
  // any of the code sequences.  So if 'AAAA' has a table entry of 12, the
  // tuple of ('AAAA', K) for any input byte K will be unique, and can be our
  // key.  This leads to a integer value at most 20-bits, which can always
  // fit in an SMI value and be used as a fast sparse array / object key.

  // Output code for the current contents of the index buffer.
  var ib_code = index_stream[0] & code_mask;  // Load first input index.
  var code_table = { };  // Key'd on our 20-bit "tuple".

  emit_code(clear_code);  // Spec says first code should be a clear code.

  // First index already loaded, process the rest of the stream.
  for (var i = 1, il = index_stream.length; i < il; ++i) {
    var k = index_stream[i] & code_mask;
    var cur_key = ib_code << 8 | k;  // (prev, k) unique tuple.
    var cur_code = code_table[cur_key];  // buffer + k.

    // Check if we have to create a new code table entry.
    if (cur_code === undefined) {  // We don't have buffer + k.
      // Emit index buffer (without k).
      // This is an inline version of emit_code, because this is the core
      // writing routine of the compressor (and V8 cannot inline emit_code
      // because it is a closure here in a different context).  Additionally
      // we can call emit_byte_to_buffer less often, because we can have
      // 30-bits (from our 31-bit signed SMI), and we know our codes will only
      // be 12-bits, so can safely have 18-bits there without overflow.
      // emit_code(ib_code);
      cur |= ib_code << cur_shift;
      cur_shift += cur_code_size;
      while (cur_shift >= 8) {
        buf[p++] = cur & 0xff;
        cur >>= 8; cur_shift -= 8;
        if (p === cur_subblock + 256) {  // Finished a subblock.
          buf[cur_subblock] = 255;
          cur_subblock = p++;
        }
      }

      if (next_code === 4096) {  // Table full, need a clear.
        emit_code(clear_code);
        next_code = eoi_code + 1;
        cur_code_size = min_code_size + 1;
        code_table = { };
      } else {  // Table not full, insert a new entry.
        // Increase our variable bit code sizes if necessary.  This is a bit
        // tricky as it is based on "timing" between the encoding and
        // decoder.  From the encoders perspective this should happen after
        // we've already emitted the index buffer and are about to create the
        // first table entry that would overflow our current code bit size.
        if (next_code >= (1 << cur_code_size)) ++cur_code_size;
        code_table[cur_key] = next_code++;  // Insert into code table.
      }

      ib_code = k;  // Index buffer to single input k.
    } else {
      ib_code = cur_code;  // Index buffer to sequence in code table.
    }
  }

  emit_code(ib_code);  // There will still be something in the index buffer.
  emit_code(eoi_code);  // End Of Information.

  // Flush / finalize the sub-blocks stream to the buffer.
  emit_bytes_to_buffer(1);

  // Finish the sub-blocks, writing out any unfinished lengths and
  // terminating with a sub-block of length 0.  If we have already started
  // but not yet used a sub-block it can just become the terminator.
  if (cur_subblock + 1 === p) {  // Started but unused.
    buf[cur_subblock] = 0;
  } else {  // Started and used, write length and additional terminator block.
    buf[cur_subblock] = p - cur_subblock - 1;
    buf[p++] = 0;
  }
  return p;
}

function GifReader(buf) {
  var p = 0;

  // - Header (GIF87a or GIF89a).
  if (buf[p++] !== 0x47 ||            buf[p++] !== 0x49 || buf[p++] !== 0x46 ||
      buf[p++] !== 0x38 || (buf[p++]+1 & 0xfd) !== 0x38 || buf[p++] !== 0x61) {
    throw new Error("Invalid GIF 87a/89a header.");
  }

  // - Logical Screen Descriptor.
  var width = buf[p++] | buf[p++] << 8;
  var height = buf[p++] | buf[p++] << 8;
  var pf0 = buf[p++];  // <Packed Fields>.
  var global_palette_flag = pf0 >> 7;
  var num_global_colors_pow2 = pf0 & 0x7;
  var num_global_colors = 1 << (num_global_colors_pow2 + 1);
  var background = buf[p++];
  buf[p++];  // Pixel aspect ratio (unused?).

  var global_palette_offset = null;
  var global_palette_size   = null;

  if (global_palette_flag) {
    global_palette_offset = p;
    global_palette_size = num_global_colors;
    p += num_global_colors * 3;  // Seek past palette.
  }

  var no_eof = true;

  var frames = [ ];

  var delay = 0;
  var transparent_index = null;
  var disposal = 0;  // 0 - No disposal specified.
  var loop_count = null;

  this.width = width;
  this.height = height;

  while (no_eof && p < buf.length) {
    switch (buf[p++]) {
      case 0x21:  // Graphics Control Extension Block
        switch (buf[p++]) {
          case 0xff:  // Application specific block
            // Try if it's a Netscape block (with animation loop counter).
            if (buf[p   ] !== 0x0b ||  // 21 FF already read, check block size.
                // NETSCAPE2.0
                buf[p+1 ] == 0x4e && buf[p+2 ] == 0x45 && buf[p+3 ] == 0x54 &&
                buf[p+4 ] == 0x53 && buf[p+5 ] == 0x43 && buf[p+6 ] == 0x41 &&
                buf[p+7 ] == 0x50 && buf[p+8 ] == 0x45 && buf[p+9 ] == 0x32 &&
                buf[p+10] == 0x2e && buf[p+11] == 0x30 &&
                // Sub-block
                buf[p+12] == 0x03 && buf[p+13] == 0x01 && buf[p+16] == 0) {
              p += 14;
              loop_count = buf[p++] | buf[p++] << 8;
              p++;  // Skip terminator.
            } else {  // We don't know what it is, just try to get past it.
              p += 12;
              while (true) {  // Seek through subblocks.
                var block_size = buf[p++];
                // Bad block size (ex: undefined from an out of bounds read).
                if (!(block_size >= 0)) throw Error("Invalid block size");
                if (block_size === 0) break;  // 0 size is terminator
                p += block_size;
              }
            }
            break;

          case 0xf9:  // Graphics Control Extension
            if (buf[p++] !== 0x4 || buf[p+4] !== 0)
              throw new Error("Invalid graphics extension block.");
            var pf1 = buf[p++];
            delay = buf[p++] | buf[p++] << 8;
            transparent_index = buf[p++];
            if ((pf1 & 1) === 0) transparent_index = null;
            disposal = pf1 >> 2 & 0x7;
            p++;  // Skip terminator.
            break;

          case 0xfe:  // Comment Extension.
            while (true) {  // Seek through subblocks.
              var block_size = buf[p++];
              // Bad block size (ex: undefined from an out of bounds read).
              if (!(block_size >= 0)) throw Error("Invalid block size");
              if (block_size === 0) break;  // 0 size is terminator
              // console.log(buf.slice(p, p+block_size).toString('ascii'));
              p += block_size;
            }
            break;

          default:
            throw new Error(
                "Unknown graphic control label: 0x" + buf[p-1].toString(16));
        }
        break;

      case 0x2c:  // Image Descriptor.
        var x = buf[p++] | buf[p++] << 8;
        var y = buf[p++] | buf[p++] << 8;
        var w = buf[p++] | buf[p++] << 8;
        var h = buf[p++] | buf[p++] << 8;
        var pf2 = buf[p++];
        var local_palette_flag = pf2 >> 7;
        var interlace_flag = pf2 >> 6 & 1;
        var num_local_colors_pow2 = pf2 & 0x7;
        var num_local_colors = 1 << (num_local_colors_pow2 + 1);
        var palette_offset = global_palette_offset;
        var palette_size = global_palette_size;
        var has_local_palette = false;
        if (local_palette_flag) {
          var has_local_palette = true;
          palette_offset = p;  // Override with local palette.
          palette_size = num_local_colors;
          p += num_local_colors * 3;  // Seek past palette.
        }

        var data_offset = p;

        p++;  // codesize
        while (true) {
          var block_size = buf[p++];
          // Bad block size (ex: undefined from an out of bounds read).
          if (!(block_size >= 0)) throw Error("Invalid block size");
          if (block_size === 0) break;  // 0 size is terminator
          p += block_size;
        }

        frames.push({x: x, y: y, width: w, height: h,
                     has_local_palette: has_local_palette,
                     palette_offset: palette_offset,
                     palette_size: palette_size,
                     data_offset: data_offset,
                     data_length: p - data_offset,
                     transparent_index: transparent_index,
                     interlaced: !!interlace_flag,
                     delay: delay,
                     disposal: disposal});
        break;

      case 0x3b:  // Trailer Marker (end of file).
        no_eof = false;
        break;

      default:
        throw new Error("Unknown gif block: 0x" + buf[p-1].toString(16));
        break;
    }
  }

  this.numFrames = function() {
    return frames.length;
  };

  this.loopCount = function() {
    return loop_count;
  };

  this.frameInfo = function(frame_num) {
    if (frame_num < 0 || frame_num >= frames.length)
      throw new Error("Frame index out of range.");
    return frames[frame_num];
  }

  this.decodeAndBlitFrameBGRA = function(frame_num, pixels) {
    var frame = this.frameInfo(frame_num);
    var num_pixels = frame.width * frame.height;
    var index_stream = new Uint8Array(num_pixels);  // At most 8-bit indices.
    GifReaderLZWOutputIndexStream(
        buf, frame.data_offset, index_stream, num_pixels);
    var palette_offset = frame.palette_offset;

    // NOTE(deanm): It seems to be much faster to compare index to 256 than
    // to === null.  Not sure why, but CompareStub_EQ_STRICT shows up high in
    // the profile, not sure if it's related to using a Uint8Array.
    var trans = frame.transparent_index;
    if (trans === null) trans = 256;

    // We are possibly just blitting to a portion of the entire frame.
    // That is a subrect within the framerect, so the additional pixels
    // must be skipped over after we finished a scanline.
    var framewidth  = frame.width;
    var framestride = width - framewidth;
    var xleft       = framewidth;  // Number of subrect pixels left in scanline.

    // Output indicies of the top left and bottom right corners of the subrect.
    var opbeg = ((frame.y * width) + frame.x) * 4;
    var opend = ((frame.y + frame.height) * width + frame.x) * 4;
    var op    = opbeg;

    var scanstride = framestride * 4;

    // Use scanstride to skip past the rows when interlacing.  This is skipping
    // 7 rows for the first two passes, then 3 then 1.
    if (frame.interlaced === true) {
      scanstride += width * 4 * 7;  // Pass 1.
    }

    var interlaceskip = 8;  // Tracking the row interval in the current pass.

    for (var i = 0, il = index_stream.length; i < il; ++i) {
      var index = index_stream[i];

      if (xleft === 0) {  // Beginning of new scan line
        op += scanstride;
        xleft = framewidth;
        if (op >= opend) { // Catch the wrap to switch passes when interlacing.
          scanstride = framestride * 4 + width * 4 * (interlaceskip-1);
          // interlaceskip / 2 * 4 is interlaceskip << 1.
          op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
          interlaceskip >>= 1;
        }
      }

      if (index === trans) {
        op += 4;
      } else {
        var r = buf[palette_offset + index * 3];
        var g = buf[palette_offset + index * 3 + 1];
        var b = buf[palette_offset + index * 3 + 2];
        pixels[op++] = b;
        pixels[op++] = g;
        pixels[op++] = r;
        pixels[op++] = 255;
      }
      --xleft;
    }
  };

  // I will go to copy and paste hell one day...
  this.decodeAndBlitFrameRGBA = function(frame_num, pixels) {
    var frame = this.frameInfo(frame_num);
    var num_pixels = frame.width * frame.height;
    var index_stream = new Uint8Array(num_pixels);  // At most 8-bit indices.
    GifReaderLZWOutputIndexStream(
        buf, frame.data_offset, index_stream, num_pixels);
    var palette_offset = frame.palette_offset;

    // NOTE(deanm): It seems to be much faster to compare index to 256 than
    // to === null.  Not sure why, but CompareStub_EQ_STRICT shows up high in
    // the profile, not sure if it's related to using a Uint8Array.
    var trans = frame.transparent_index;
    if (trans === null) trans = 256;

    // We are possibly just blitting to a portion of the entire frame.
    // That is a subrect within the framerect, so the additional pixels
    // must be skipped over after we finished a scanline.
    var framewidth  = frame.width;
    var framestride = width - framewidth;
    var xleft       = framewidth;  // Number of subrect pixels left in scanline.

    // Output indicies of the top left and bottom right corners of the subrect.
    var opbeg = ((frame.y * width) + frame.x) * 4;
    var opend = ((frame.y + frame.height) * width + frame.x) * 4;
    var op    = opbeg;

    var scanstride = framestride * 4;

    // Use scanstride to skip past the rows when interlacing.  This is skipping
    // 7 rows for the first two passes, then 3 then 1.
    if (frame.interlaced === true) {
      scanstride += width * 4 * 7;  // Pass 1.
    }

    var interlaceskip = 8;  // Tracking the row interval in the current pass.

    for (var i = 0, il = index_stream.length; i < il; ++i) {
      var index = index_stream[i];

      if (xleft === 0) {  // Beginning of new scan line
        op += scanstride;
        xleft = framewidth;
        if (op >= opend) { // Catch the wrap to switch passes when interlacing.
          scanstride = framestride * 4 + width * 4 * (interlaceskip-1);
          // interlaceskip / 2 * 4 is interlaceskip << 1.
          op = opbeg + (framewidth + framestride) * (interlaceskip << 1);
          interlaceskip >>= 1;
        }
      }

      if (index === trans) {
        op += 4;
      } else {
        var r = buf[palette_offset + index * 3];
        var g = buf[palette_offset + index * 3 + 1];
        var b = buf[palette_offset + index * 3 + 2];
        pixels[op++] = r;
        pixels[op++] = g;
        pixels[op++] = b;
        pixels[op++] = 255;
      }
      --xleft;
    }
  };
}

function GifReaderLZWOutputIndexStream(code_stream, p, output, output_length) {
  var min_code_size = code_stream[p++];

  var clear_code = 1 << min_code_size;
  var eoi_code = clear_code + 1;
  var next_code = eoi_code + 1;

  var cur_code_size = min_code_size + 1;  // Number of bits per code.
  // NOTE: This shares the same name as the encoder, but has a different
  // meaning here.  Here this masks each code coming from the code stream.
  var code_mask = (1 << cur_code_size) - 1;
  var cur_shift = 0;
  var cur = 0;

  var op = 0;  // Output pointer.

  var subblock_size = code_stream[p++];

  // TODO(deanm): Would using a TypedArray be any faster?  At least it would
  // solve the fast mode / backing store uncertainty.
  // var code_table = Array(4096);
  var code_table = new Int32Array(4096);  // Can be signed, we only use 20 bits.

  var prev_code = null;  // Track code-1.

  while (true) {
    // Read up to two bytes, making sure we always 12-bits for max sized code.
    while (cur_shift < 16) {
      if (subblock_size === 0) break;  // No more data to be read.

      cur |= code_stream[p++] << cur_shift;
      cur_shift += 8;

      if (subblock_size === 1) {  // Never let it get to 0 to hold logic above.
        subblock_size = code_stream[p++];  // Next subblock.
      } else {
        --subblock_size;
      }
    }

    // TODO(deanm): We should never really get here, we should have received
    // and EOI.
    if (cur_shift < cur_code_size)
      break;

    var code = cur & code_mask;
    cur >>= cur_code_size;
    cur_shift -= cur_code_size;

    // TODO(deanm): Maybe should check that the first code was a clear code,
    // at least this is what you're supposed to do.  But actually our encoder
    // now doesn't emit a clear code first anyway.
    if (code === clear_code) {
      // We don't actually have to clear the table.  This could be a good idea
      // for greater error checking, but we don't really do any anyway.  We
      // will just track it with next_code and overwrite old entries.

      next_code = eoi_code + 1;
      cur_code_size = min_code_size + 1;
      code_mask = (1 << cur_code_size) - 1;

      // Don't update prev_code ?
      prev_code = null;
      continue;
    } else if (code === eoi_code) {
      break;
    }

    // We have a similar situation as the decoder, where we want to store
    // variable length entries (code table entries), but we want to do in a
    // faster manner than an array of arrays.  The code below stores sort of a
    // linked list within the code table, and then "chases" through it to
    // construct the dictionary entries.  When a new entry is created, just the
    // last byte is stored, and the rest (prefix) of the entry is only
    // referenced by its table entry.  Then the code chases through the
    // prefixes until it reaches a single byte code.  We have to chase twice,
    // first to compute the length, and then to actually copy the data to the
    // output (backwards, since we know the length).  The alternative would be
    // storing something in an intermediate stack, but that doesn't make any
    // more sense.  I implemented an approach where it also stored the length
    // in the code table, although it's a bit tricky because you run out of
    // bits (12 + 12 + 8), but I didn't measure much improvements (the table
    // entries are generally not the long).  Even when I created benchmarks for
    // very long table entries the complexity did not seem worth it.
    // The code table stores the prefix entry in 12 bits and then the suffix
    // byte in 8 bits, so each entry is 20 bits.

    var chase_code = code < next_code ? code : prev_code;

    // Chase what we will output, either {CODE} or {CODE-1}.
    var chase_length = 0;
    var chase = chase_code;
    while (chase > clear_code) {
      chase = code_table[chase] >> 8;
      ++chase_length;
    }

    var k = chase;

    var op_end = op + chase_length + (chase_code !== code ? 1 : 0);
    if (op_end > output_length) {
      console.log("Warning, gif stream longer than expected.");
      return;
    }

    // Already have the first byte from the chase, might as well write it fast.
    output[op++] = k;

    op += chase_length;
    var b = op;  // Track pointer, writing backwards.

    if (chase_code !== code)  // The case of emitting {CODE-1} + k.
      output[op++] = k;

    chase = chase_code;
    while (chase_length--) {
      chase = code_table[chase];
      output[--b] = chase & 0xff;  // Write backwards.
      chase >>= 8;  // Pull down to the prefix code.
    }

    if (prev_code !== null && next_code < 4096) {
      code_table[next_code++] = prev_code << 8 | k;
      // TODO(deanm): Figure out this clearing vs code growth logic better.  I
      // have an feeling that it should just happen somewhere else, for now it
      // is awkward between when we grow past the max and then hit a clear code.
      // For now just check if we hit the max 12-bits (then a clear code should
      // follow, also of course encoded in 12-bits).
      if (next_code >= code_mask+1 && cur_code_size < 12) {
        ++cur_code_size;
        code_mask = code_mask << 1 | 1;
      }
    }

    prev_code = code;
  }

  if (op !== output_length) {
    console.log("Warning, gif stream shorter than expected.");
  }

  return output;
}

// CommonJS.
try { exports.GifWriter = GifWriter; exports.GifReader = GifReader } catch(e) {}

},{}],132:[function(require,module,exports){
(function (process){
// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47 /*/*/;
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';
  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }
  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';

  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
}

// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
exports.basename = function (path, ext) {
  var f = basename(path);
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var preDotState = 0;
  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }
    if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
    } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 ||
      // We saw a non-dot character immediately before the dot
      preDotState === 0 ||
      // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }
  return path.slice(startDot, end);
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":134}],133:[function(require,module,exports){
(function (process){
'use strict';

if (typeof process === 'undefined' ||
    !process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


}).call(this,require('_process'))

},{"_process":134}],134:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],135:[function(require,module,exports){
module.exports = require('./lib/_stream_duplex.js');

},{"./lib/_stream_duplex.js":136}],136:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};
},{"./_stream_readable":138,"./_stream_writable":140,"core-util-is":36,"inherits":123,"process-nextick-args":133}],137:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":139,"core-util-is":36,"inherits":123}],138:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var destroyImpl = require('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./_stream_duplex":136,"./internal/streams/BufferList":141,"./internal/streams/destroy":142,"./internal/streams/stream":143,"_process":134,"core-util-is":36,"events":42,"inherits":123,"isarray":126,"process-nextick-args":133,"safe-buffer":144,"string_decoder/":150,"util":34}],139:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":136,"core-util-is":36,"inherits":123}],140:[function(require,module,exports){
(function (process,global,setImmediate){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = Object.create(require('core-util-is'));
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = require('./internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("timers").setImmediate)

},{"./_stream_duplex":136,"./internal/streams/destroy":142,"./internal/streams/stream":143,"_process":134,"core-util-is":36,"inherits":123,"process-nextick-args":133,"safe-buffer":144,"timers":153,"util-deprecate":156}],141:[function(require,module,exports){
'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = require('safe-buffer').Buffer;
var util = require('util');

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}
},{"safe-buffer":144,"util":34}],142:[function(require,module,exports){
'use strict';

/*<replacement>*/

var pna = require('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
},{"process-nextick-args":133}],143:[function(require,module,exports){
module.exports = require('events').EventEmitter;

},{"events":42}],144:[function(require,module,exports){
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":35}],145:[function(require,module,exports){
module.exports = require('./readable').PassThrough

},{"./readable":146}],146:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":136,"./lib/_stream_passthrough.js":137,"./lib/_stream_readable.js":138,"./lib/_stream_transform.js":139,"./lib/_stream_writable.js":140}],147:[function(require,module,exports){
module.exports = require('./readable').Transform

},{"./readable":146}],148:[function(require,module,exports){
module.exports = require('./lib/_stream_writable.js');

},{"./lib/_stream_writable.js":140}],149:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":42,"inherits":123,"readable-stream/duplex.js":135,"readable-stream/passthrough.js":145,"readable-stream/readable.js":146,"readable-stream/transform.js":147,"readable-stream/writable.js":148}],150:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":151}],151:[function(require,module,exports){
arguments[4][144][0].apply(exports,arguments)
},{"buffer":35,"dup":144}],152:[function(require,module,exports){
(function (process){
var Stream = require('stream')

// through
//
// a stream that does nothing but re-emit the input.
// useful for aggregating a series of changing but not ending streams into one stream)

exports = module.exports = through
through.through = through

//create a readable writable stream.

function through (write, end, opts) {
  write = write || function (data) { this.queue(data) }
  end = end || function () { this.queue(null) }

  var ended = false, destroyed = false, buffer = [], _ended = false
  var stream = new Stream()
  stream.readable = stream.writable = true
  stream.paused = false

//  stream.autoPause   = !(opts && opts.autoPause   === false)
  stream.autoDestroy = !(opts && opts.autoDestroy === false)

  stream.write = function (data) {
    write.call(this, data)
    return !stream.paused
  }

  function drain() {
    while(buffer.length && !stream.paused) {
      var data = buffer.shift()
      if(null === data)
        return stream.emit('end')
      else
        stream.emit('data', data)
    }
  }

  stream.queue = stream.push = function (data) {
//    console.error(ended)
    if(_ended) return stream
    if(data === null) _ended = true
    buffer.push(data)
    drain()
    return stream
  }

  //this will be registered as the first 'end' listener
  //must call destroy next tick, to make sure we're after any
  //stream piped from here.
  //this is only a problem if end is not emitted synchronously.
  //a nicer way to do this is to make sure this is the last listener for 'end'

  stream.on('end', function () {
    stream.readable = false
    if(!stream.writable && stream.autoDestroy)
      process.nextTick(function () {
        stream.destroy()
      })
  })

  function _end () {
    stream.writable = false
    end.call(stream)
    if(!stream.readable && stream.autoDestroy)
      stream.destroy()
  }

  stream.end = function (data) {
    if(ended) return
    ended = true
    if(arguments.length) stream.write(data)
    _end() // will emit or queue
    return stream
  }

  stream.destroy = function () {
    if(destroyed) return
    destroyed = true
    ended = true
    buffer.length = 0
    stream.writable = stream.readable = false
    stream.emit('close')
    return stream
  }

  stream.pause = function () {
    if(stream.paused) return
    stream.paused = true
    return stream
  }

  stream.resume = function () {
    if(stream.paused) {
      stream.paused = false
      stream.emit('resume')
    }
    drain()
    //may have become paused again,
    //as drain emits 'data'.
    if(!stream.paused)
      stream.emit('drain')
    return stream
  }
  return stream
}


}).call(this,require('_process'))

},{"_process":134,"stream":149}],153:[function(require,module,exports){
(function (setImmediate,clearImmediate){
var nextTick = require('process/browser.js').nextTick;
var apply = Function.prototype.apply;
var slice = Array.prototype.slice;
var immediateIds = {};
var nextImmediateId = 0;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) { timeout.close(); };

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// That's not how node.js implements it but the exposed api is the same.
exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
  var id = nextImmediateId++;
  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

  immediateIds[id] = true;

  nextTick(function onNextTick() {
    if (immediateIds[id]) {
      // fn.call() is faster so we optimize for the common use-case
      // @see http://jsperf.com/call-apply-segu
      if (args) {
        fn.apply(null, args);
      } else {
        fn.call(null);
      }
      // Prevent ids from leaking
      exports.clearImmediate(id);
    }
  });

  return id;
};

exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
  delete immediateIds[id];
};
}).call(this,require("timers").setImmediate,require("timers").clearImmediate)

},{"process/browser.js":134,"timers":153}],154:[function(require,module,exports){
(function (global){
'use strict'

var bits = require('bit-twiddle')
var dup = require('dup')
var Buffer = require('buffer').Buffer

//Legacy pool support
if(!global.__TYPEDARRAY_POOL) {
  global.__TYPEDARRAY_POOL = {
      UINT8     : dup([32, 0])
    , UINT16    : dup([32, 0])
    , UINT32    : dup([32, 0])
    , BIGUINT64 : dup([32, 0])
    , INT8      : dup([32, 0])
    , INT16     : dup([32, 0])
    , INT32     : dup([32, 0])
    , BIGINT64  : dup([32, 0])
    , FLOAT     : dup([32, 0])
    , DOUBLE    : dup([32, 0])
    , DATA      : dup([32, 0])
    , UINT8C    : dup([32, 0])
    , BUFFER    : dup([32, 0])
  }
}

var hasUint8C = (typeof Uint8ClampedArray) !== 'undefined'
var hasBigUint64 = (typeof BigUint64Array) !== 'undefined'
var hasBigInt64 = (typeof BigInt64Array) !== 'undefined'
var POOL = global.__TYPEDARRAY_POOL

//Upgrade pool
if(!POOL.UINT8C) {
  POOL.UINT8C = dup([32, 0])
}
if(!POOL.BIGUINT64) {
  POOL.BIGUINT64 = dup([32, 0])
}
if(!POOL.BIGINT64) {
  POOL.BIGINT64 = dup([32, 0])
}
if(!POOL.BUFFER) {
  POOL.BUFFER = dup([32, 0])
}

//New technique: Only allocate from ArrayBufferView and Buffer
var DATA    = POOL.DATA
  , BUFFER  = POOL.BUFFER

exports.free = function free(array) {
  if(Buffer.isBuffer(array)) {
    BUFFER[bits.log2(array.length)].push(array)
  } else {
    if(Object.prototype.toString.call(array) !== '[object ArrayBuffer]') {
      array = array.buffer
    }
    if(!array) {
      return
    }
    var n = array.length || array.byteLength
    var log_n = bits.log2(n)|0
    DATA[log_n].push(array)
  }
}

function freeArrayBuffer(buffer) {
  if(!buffer) {
    return
  }
  var n = buffer.length || buffer.byteLength
  var log_n = bits.log2(n)
  DATA[log_n].push(buffer)
}

function freeTypedArray(array) {
  freeArrayBuffer(array.buffer)
}

exports.freeUint8 =
exports.freeUint16 =
exports.freeUint32 =
exports.freeBigUint64 =
exports.freeInt8 =
exports.freeInt16 =
exports.freeInt32 =
exports.freeBigInt64 =
exports.freeFloat32 = 
exports.freeFloat =
exports.freeFloat64 = 
exports.freeDouble = 
exports.freeUint8Clamped = 
exports.freeDataView = freeTypedArray

exports.freeArrayBuffer = freeArrayBuffer

exports.freeBuffer = function freeBuffer(array) {
  BUFFER[bits.log2(array.length)].push(array)
}

exports.malloc = function malloc(n, dtype) {
  if(dtype === undefined || dtype === 'arraybuffer') {
    return mallocArrayBuffer(n)
  } else {
    switch(dtype) {
      case 'uint8':
        return mallocUint8(n)
      case 'uint16':
        return mallocUint16(n)
      case 'uint32':
        return mallocUint32(n)
      case 'int8':
        return mallocInt8(n)
      case 'int16':
        return mallocInt16(n)
      case 'int32':
        return mallocInt32(n)
      case 'float':
      case 'float32':
        return mallocFloat(n)
      case 'double':
      case 'float64':
        return mallocDouble(n)
      case 'uint8_clamped':
        return mallocUint8Clamped(n)
      case 'bigint64':
        return mallocBigInt64(n)
      case 'biguint64':
        return mallocBigUint64(n)
      case 'buffer':
        return mallocBuffer(n)
      case 'data':
      case 'dataview':
        return mallocDataView(n)

      default:
        return null
    }
  }
  return null
}

function mallocArrayBuffer(n) {
  var n = bits.nextPow2(n)
  var log_n = bits.log2(n)
  var d = DATA[log_n]
  if(d.length > 0) {
    return d.pop()
  }
  return new ArrayBuffer(n)
}
exports.mallocArrayBuffer = mallocArrayBuffer

function mallocUint8(n) {
  return new Uint8Array(mallocArrayBuffer(n), 0, n)
}
exports.mallocUint8 = mallocUint8

function mallocUint16(n) {
  return new Uint16Array(mallocArrayBuffer(2*n), 0, n)
}
exports.mallocUint16 = mallocUint16

function mallocUint32(n) {
  return new Uint32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocUint32 = mallocUint32

function mallocInt8(n) {
  return new Int8Array(mallocArrayBuffer(n), 0, n)
}
exports.mallocInt8 = mallocInt8

function mallocInt16(n) {
  return new Int16Array(mallocArrayBuffer(2*n), 0, n)
}
exports.mallocInt16 = mallocInt16

function mallocInt32(n) {
  return new Int32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocInt32 = mallocInt32

function mallocFloat(n) {
  return new Float32Array(mallocArrayBuffer(4*n), 0, n)
}
exports.mallocFloat32 = exports.mallocFloat = mallocFloat

function mallocDouble(n) {
  return new Float64Array(mallocArrayBuffer(8*n), 0, n)
}
exports.mallocFloat64 = exports.mallocDouble = mallocDouble

function mallocUint8Clamped(n) {
  if(hasUint8C) {
    return new Uint8ClampedArray(mallocArrayBuffer(n), 0, n)
  } else {
    return mallocUint8(n)
  }
}
exports.mallocUint8Clamped = mallocUint8Clamped

function mallocBigUint64(n) {
  if(hasBigUint64) {
    return new BigUint64Array(mallocArrayBuffer(8*n), 0, n)
  } else {
    return null;
  }
}
exports.mallocBigUint64 = mallocBigUint64

function mallocBigInt64(n) {
  if (hasBigInt64) {
    return new BigInt64Array(mallocArrayBuffer(8*n), 0, n)
  } else {
    return null;
  }
}
exports.mallocBigInt64 = mallocBigInt64

function mallocDataView(n) {
  return new DataView(mallocArrayBuffer(n), 0, n)
}
exports.mallocDataView = mallocDataView

function mallocBuffer(n) {
  n = bits.nextPow2(n)
  var log_n = bits.log2(n)
  var cache = BUFFER[log_n]
  if(cache.length > 0) {
    return cache.pop()
  }
  return new Buffer(n)
}
exports.mallocBuffer = mallocBuffer

exports.clearCache = function clearCache() {
  for(var i=0; i<32; ++i) {
    POOL.UINT8[i].length = 0
    POOL.UINT16[i].length = 0
    POOL.UINT32[i].length = 0
    POOL.INT8[i].length = 0
    POOL.INT16[i].length = 0
    POOL.INT32[i].length = 0
    POOL.FLOAT[i].length = 0
    POOL.DOUBLE[i].length = 0
    POOL.BIGUINT64[i].length = 0
    POOL.BIGINT64[i].length = 0
    POOL.UINT8C[i].length = 0
    DATA[i].length = 0
    BUFFER[i].length = 0
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"bit-twiddle":33,"buffer":35,"dup":41}],155:[function(require,module,exports){
"use strict"

function unique_pred(list, compare) {
  var ptr = 1
    , len = list.length
    , a=list[0], b=list[0]
  for(var i=1; i<len; ++i) {
    b = a
    a = list[i]
    if(compare(a, b)) {
      if(i === ptr) {
        ptr++
        continue
      }
      list[ptr++] = a
    }
  }
  list.length = ptr
  return list
}

function unique_eq(list) {
  var ptr = 1
    , len = list.length
    , a=list[0], b = list[0]
  for(var i=1; i<len; ++i, b=a) {
    b = a
    a = list[i]
    if(a !== b) {
      if(i === ptr) {
        ptr++
        continue
      }
      list[ptr++] = a
    }
  }
  list.length = ptr
  return list
}

function unique(list, compare, sorted) {
  if(list.length === 0) {
    return list
  }
  if(compare) {
    if(!sorted) {
      list.sort(compare)
    }
    return unique_pred(list, compare)
  }
  if(!sorted) {
    list.sort()
  }
  return unique_eq(list)
}

module.exports = unique

},{}],156:[function(require,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],157:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CodeBuilder = exports.channelSamplerName = void 0;
const expr_1 = require("./exprs/expr");
const webglprogramloop_1 = require("./webglprogramloop");
/** @ignore */
const FRAG_SET = `  gl_FragColor = texture2D(uSampler, gl_FragCoord.xy / uResolution);\n`;
/** @ignore */
const SCENE_SET = `uniform sampler2D uSceneSampler;\n`;
/** @ignore */
const TIME_SET = `uniform mediump float uTime;\n`;
/** @ignore */
const MOUSE_SET = `uniform mediump vec2 uMouse;\n`;
/** @ignore */
const BOILERPLATE = `#ifdef GL_ES
precision mediump float;
#endif

uniform sampler2D uSampler;
uniform mediump vec2 uResolution;\n`;
/**
 * returns the string name of the sampler uniform for code generation purposes
 * @param num channel number to sample from
 */
function channelSamplerName(num) {
    // texture 2 sampler has number 0 (0 and 1 are used for back buffer and scene)
    return `uBufferSampler${num}`;
}
exports.channelSamplerName = channelSamplerName;
/**
 * returns the string of the declaration of the sampler for code generation
 * purposes
 * @param num channel number to sample from
 */
function channelSamplerDeclaration(num) {
    return `uniform sampler2D ${channelSamplerName(num)};`;
}
/** class that manages generation and compilation of GLSL code */
class CodeBuilder {
    constructor(effectLoop) {
        this.calls = [];
        this.externalFuncs = new Set();
        this.uniformDeclarations = new Set();
        this.counter = 0;
        this.baseLoop = effectLoop;
        const buildInfo = {
            uniformTypes: {},
            externalFuncs: new Set(),
            exprs: [],
            needs: {
                centerSample: false,
                neighborSample: false,
                sceneBuffer: false,
                timeUniform: false,
                mouseUniform: false,
                extraBuffers: new Set(),
            },
        };
        this.addEffectLoop(effectLoop, 1, buildInfo);
        // add all the types to uniform declarations from the `BuildInfo` instance
        for (const name in buildInfo.uniformTypes) {
            const typeName = buildInfo.uniformTypes[name];
            this.uniformDeclarations.add(`uniform mediump ${typeName} ${name};`);
        }
        // add all external functions from the `BuildInfo` instance
        buildInfo.externalFuncs.forEach((func) => this.externalFuncs.add(func));
        this.totalNeeds = buildInfo.needs;
        this.exprs = buildInfo.exprs;
    }
    addEffectLoop(effectLoop, indentLevel, buildInfo, topLevel = true) {
        const needsLoop = !topLevel && effectLoop.loopInfo.num > 1;
        if (needsLoop) {
            const iName = "i" + this.counter;
            indentLevel++;
            const forStart = "  ".repeat(indentLevel - 1) +
                `for (int ${iName} = 0; ${iName} < ${effectLoop.loopInfo.num}; ${iName}++) {`;
            this.calls.push(forStart);
        }
        for (const e of effectLoop.effects) {
            if (e instanceof expr_1.Expr) {
                e.parse(buildInfo);
                this.calls.push("  ".repeat(indentLevel) + "gl_FragColor = " + e.sourceCode + ";");
                this.counter++;
            }
            else {
                this.addEffectLoop(e, indentLevel, buildInfo, false);
            }
        }
        if (needsLoop) {
            this.calls.push("  ".repeat(indentLevel - 1) + "}");
        }
    }
    /** generate the code and compile the program into a loop */
    compileProgram(gl, vShader, uniformLocs, shaders = []) {
        // set up the fragment shader
        const fShader = gl.createShader(gl.FRAGMENT_SHADER);
        if (fShader === null) {
            throw new Error("problem creating fragment shader");
        }
        const fullCode = BOILERPLATE +
            (this.totalNeeds.sceneBuffer ? SCENE_SET : "") +
            (this.totalNeeds.timeUniform ? TIME_SET : "") +
            (this.totalNeeds.mouseUniform ? MOUSE_SET : "") +
            Array.from(this.totalNeeds.extraBuffers)
                .map((n) => channelSamplerDeclaration(n))
                .join("\n") +
            "\n" +
            [...this.uniformDeclarations].join("\n") +
            "\n" +
            [...this.externalFuncs].join("\n") +
            "\n" +
            "void main() {\n" +
            (this.totalNeeds.centerSample ? FRAG_SET : "") +
            this.calls.join("\n") +
            "\n}";
        console.log(fullCode);
        gl.shaderSource(fShader, fullCode);
        gl.compileShader(fShader);
        // set up the program
        const program = gl.createProgram();
        if (program === null) {
            throw new Error("problem creating program");
        }
        // TODO are we attaching the vertex shader more times than is necessary?
        gl.attachShader(program, vShader);
        gl.attachShader(program, fShader);
        shaders.push(fShader);
        const shaderLog = (name, shader) => {
            const output = gl.getShaderInfoLog(shader);
            if (output)
                console.log(`${name} shader info log\n${output}`);
        };
        shaderLog("vertex", vShader);
        shaderLog("fragment", fShader);
        gl.linkProgram(program);
        // we need to use the program here so we can get uniform locations
        gl.useProgram(program);
        // find all uniform locations and add them to the dictionary
        for (const expr of this.exprs) {
            for (const name in expr.uniformValChangeMap) {
                const location = gl.getUniformLocation(program, name);
                if (location === null) {
                    throw new Error("couldn't find uniform " + name);
                }
                // TODO enforce unique names in the same program
                if (uniformLocs[name] === undefined) {
                    uniformLocs[name] = { locs: [], counter: 0 };
                }
                // assign the name to the location
                uniformLocs[name].locs.push(location);
            }
        }
        // set the uniform resolution (every program has this uniform)
        const uResolution = gl.getUniformLocation(program, "uResolution");
        gl.uniform2f(uResolution, gl.drawingBufferWidth, gl.drawingBufferHeight);
        if (this.totalNeeds.sceneBuffer) {
            // TODO allow for texture options for scene texture
            const location = gl.getUniformLocation(program, "uSceneSampler");
            // put the scene buffer in texture 1 (0 is used for the backbuffer)
            gl.uniform1i(location, 1);
        }
        // set all sampler uniforms
        for (const b of this.totalNeeds.extraBuffers) {
            const location = gl.getUniformLocation(program, channelSamplerName(b));
            // offset the texture location by 2 (0 and 1 are used for scene and original)
            gl.uniform1i(location, b + 2);
        }
        // get attribute
        const position = gl.getAttribLocation(program, "aPosition");
        // enable the attribute
        gl.enableVertexAttribArray(position);
        // points to the vertices in the last bound array buffer
        gl.vertexAttribPointer(position, 2, gl.FLOAT, false, 0, 0);
        return new webglprogramloop_1.WebGLProgramLoop(new webglprogramloop_1.WebGLProgramLeaf(program, this.totalNeeds, this.exprs), this.baseLoop.loopInfo, gl);
    }
}
exports.CodeBuilder = CodeBuilder;

},{"./exprs/expr":169,"./webglprogramloop":206}],158:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.a1 = exports.Arity1HomogenousExpr = void 0;
const expr_1 = require("./expr");
/** @ignore */
function genArity1SourceList(name, val) {
    return {
        sections: [name + "(", ")"],
        values: [val],
    };
}
/** arity 1 homogenous function expression */
class Arity1HomogenousExpr extends expr_1.Operator {
    constructor(val, operation) {
        super(val, genArity1SourceList(operation, val), ["uVal"]);
        this.val = val;
    }
    /** set the value being passed into the arity 1 homogenous function */
    setVal(val) {
        this.setUniform("uVal" + this.id, val);
        this.val = expr_1.wrapInValue(val);
    }
}
exports.Arity1HomogenousExpr = Arity1HomogenousExpr;
/**
 * built-in functions that take in one `genType x` and return a `genType x`
 * @param name function name (see [[Arity1HomogenousName]] for valid function names)
 * @param val the `genType x` argument
 */
function a1(name, val) {
    return new Arity1HomogenousExpr(expr_1.wrapInValue(val), name);
}
exports.a1 = a1;

},{"./expr":169}],159:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.a2 = exports.Arity2HomogenousExpr = void 0;
const expr_1 = require("./expr");
/** @ignore */
function genArity1SourceList(name, val1, val2) {
    return {
        sections: [name + "(", ",", ")"],
        values: [val1, val2],
    };
}
/** arity 2 homogenous function expression */
class Arity2HomogenousExpr extends expr_1.Operator {
    constructor(name, val1, val2) {
        super(val1, genArity1SourceList(name, val1, val2), ["uVal1", "uVal2"]);
        this.val1 = val1;
        this.val2 = val2;
    }
    /** set the first value being passed into the arity 2 homogenous function */
    setFirstVal(val1) {
        this.setUniform("uVal1" + this.id, val1);
        this.val1 = expr_1.wrapInValue(val1);
    }
    /** set the second value being passed into the arity 2 homogenous function */
    setSecondVal(val2) {
        this.setUniform("uVal2" + this.id, val2);
        this.val2 = expr_1.wrapInValue(val2);
    }
}
exports.Arity2HomogenousExpr = Arity2HomogenousExpr;
// implementation
/**
 * built-in functions that take in two `genType x` arguments and return a `genType x`
 * @param name function name (see [[Arity2HomogenousName]] for valid function names)
 * @param val1 the first `genType x` argument
 * @param val2 the second `genType x` argument
 */
function a2(name, val1, val2) {
    return new Arity2HomogenousExpr(name, expr_1.wrapInValue(val1), expr_1.wrapInValue(val2));
}
exports.a2 = a2;

},{"./expr":169}],160:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bloom = exports.BloomLoop = void 0;
const mergepass_1 = require("../mergepass");
const arity2_1 = require("./arity2");
const blurexpr_1 = require("./blurexpr");
const brightnessexpr_1 = require("./brightnessexpr");
const contrastexpr_1 = require("./contrastexpr");
const expr_1 = require("./expr");
const fragcolorexpr_1 = require("./fragcolorexpr");
const opexpr_1 = require("./opexpr");
const scenesampleexpr_1 = require("./scenesampleexpr");
const setcolorexpr_1 = require("./setcolorexpr");
const vecexprs_1 = require("./vecexprs");
/** bloom loop */
class BloomLoop extends mergepass_1.EffectLoop {
    constructor(threshold = expr_1.float(expr_1.mut(0.4)), horizontal = expr_1.float(expr_1.mut(1)), vertical = expr_1.float(expr_1.mut(1)), boost = expr_1.float(expr_1.mut(1.3)), taps = 9, reps = 3) {
        //const bright = getcomp(rgb2hsv(fcolor()), "z");
        const bright = expr_1.cfloat(expr_1.tag `((${fragcolorexpr_1.fcolor()}.r + ${fragcolorexpr_1.fcolor()}.g + ${fragcolorexpr_1.fcolor()}.b) / 3.)`);
        const step = arity2_1.a2("step", bright, threshold);
        const col = expr_1.cvec4(expr_1.tag `vec4(${fragcolorexpr_1.fcolor()}.rgb * (1. - ${step}), 1.)`);
        //const contrastBoost = contrast(mut(1.3));
        const list = [
            setcolorexpr_1.setcolor(col),
            mergepass_1.loop([
                blurexpr_1.gauss(vecexprs_1.vec2(horizontal, 0), taps),
                blurexpr_1.gauss(vecexprs_1.vec2(0, vertical), taps),
                brightnessexpr_1.brightness(0.1),
                contrastexpr_1.contrast(boost),
            ], reps),
            setcolorexpr_1.setcolor(opexpr_1.op(fragcolorexpr_1.fcolor(), "+", scenesampleexpr_1.input())),
        ];
        super(list, { num: 1 });
        this.threshold = threshold;
        this.horizontal = horizontal;
        this.vertical = vertical;
        this.boost = boost;
    }
    /**
     * set the horizontal stretch of the blur effect (no greater than 1 for best
     * effect)
     */
    setHorizontal(num) {
        if (!(this.horizontal instanceof expr_1.BasicFloat))
            throw new Error("horizontal expression not basic float");
        this.horizontal.setVal(num);
    }
    /**
     * set the vertical stretch of the blur effect (no greater than 1 for best
     * effect)
     */
    setVertical(num) {
        if (!(this.vertical instanceof expr_1.BasicFloat))
            throw new Error("vertical expression not basic float");
        this.vertical.setVal(num);
    }
    /** set the treshold */
    setThreshold(num) {
        if (!(this.threshold instanceof expr_1.BasicFloat))
            throw new Error("threshold expression not basic float");
        this.threshold.setVal(num);
    }
    /** set the contrast boost */
    setBoost(num) {
        if (!(this.boost instanceof expr_1.BasicFloat))
            throw new Error("boost expression not basic float");
        this.boost.setVal(num);
    }
}
exports.BloomLoop = BloomLoop;
/**
 * creates a bloom loop
 * @param threshold values below this brightness don't get blurred (0.4 is
 * about reasonable, which is also the default)
 * @param horizontal how much to blur vertically (defaults to 1 pixel)
 * @param vertical how much to blur horizontally (defaults to 1 pixel)
 * @param taps how many taps for the blur (defaults to 9)
 * @param reps how many times to loop the blur (defaults to 3)
 */
function bloom(threshold, horizontal, vertical, boost, taps, reps) {
    return new BloomLoop(expr_1.n2e(threshold), expr_1.n2e(horizontal), expr_1.n2e(vertical), expr_1.n2e(boost), taps, reps);
}
exports.bloom = bloom;

},{"../mergepass":205,"./arity2":159,"./blurexpr":162,"./brightnessexpr":163,"./contrastexpr":166,"./expr":169,"./fragcolorexpr":170,"./opexpr":187,"./scenesampleexpr":194,"./setcolorexpr":195,"./vecexprs":201}],161:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.blur2d = exports.Blur2dLoop = void 0;
const mergepass_1 = require("../mergepass");
const blurexpr_1 = require("./blurexpr");
const expr_1 = require("./expr");
const vecexprs_1 = require("./vecexprs");
/** 2D blur loop */
class Blur2dLoop extends mergepass_1.EffectLoop {
    constructor(horizontal = expr_1.float(expr_1.mut(1)), vertical = expr_1.float(expr_1.mut(1)), reps = 2, taps, samplerNum) {
        const side = blurexpr_1.gauss(vecexprs_1.vec2(horizontal, 0), taps, samplerNum);
        const up = blurexpr_1.gauss(vecexprs_1.vec2(0, vertical), taps, samplerNum);
        super([side, up], { num: reps });
        this.horizontal = horizontal;
        this.vertical = vertical;
    }
    /**
     * set the horizontal stretch of the blur effect (no greater than 1 for best
     * effect)
     */
    setHorizontal(num) {
        if (!(this.horizontal instanceof expr_1.BasicFloat))
            throw new Error("horizontal expression not basic float");
        this.horizontal.setVal(num);
    }
    /**
     * set the vertical stretch of the blur effect (no greater than 1 for best
     * effect)
     */
    setVertical(num) {
        if (!(this.vertical instanceof expr_1.BasicFloat))
            throw new Error("vertical expression not basic float");
        this.vertical.setVal(num);
    }
}
exports.Blur2dLoop = Blur2dLoop;
/**
 * creates a loop that runs a horizontal, then vertical gaussian blur (anything
 * more than 1 pixel in the horizontal or vertical direction will create a
 * ghosting effect, which is usually not desirable)
 * @param horizontalExpr float for the horizontal blur (1 pixel default)
 * @param verticalExpr float for the vertical blur (1 pixel default)
 * @param reps how many passes (defaults to 2)
 * @param taps how many taps (defaults to 5)
 * @param samplerNum change if you want to sample from a different channel and
 * the outer loop has a different target
 */
function blur2d(horizontalExpr, verticalExpr, reps, taps, samplerNum) {
    return new Blur2dLoop(expr_1.n2e(horizontalExpr), expr_1.n2e(verticalExpr), reps, taps, samplerNum);
}
exports.blur2d = blur2d;

},{"../mergepass":205,"./blurexpr":162,"./expr":169,"./vecexprs":201}],162:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.gauss = exports.BlurExpr = void 0;
const glslfunctions_1 = require("../glslfunctions");
const expr_1 = require("./expr");
/** @ignore */
function genBlurSource(direction, taps, buffer) {
    return {
        sections: [`gauss${taps}${buffer === undefined ? "" : "_" + buffer}(`, ")"],
        values: [direction],
    };
}
/** @ignore */
function tapsToFuncSource(taps) {
    switch (taps) {
        case 5:
            return glslfunctions_1.glslFuncs.gauss5;
        case 9:
            return glslfunctions_1.glslFuncs.gauss9;
        case 13:
            return glslfunctions_1.glslFuncs.gauss13;
    }
}
/** gaussian blur expression */
class BlurExpr extends expr_1.ExprVec4 {
    constructor(direction, taps = 5, samplerNum) {
        // this is already guaranteed by typescript, but creates helpful error for
        // use in gibber or anyone just using javascript
        if (![5, 9, 13].includes(taps)) {
            throw new Error("taps for gauss blur can only be 5, 9 or 13");
        }
        // TODO make this more generic
        super(genBlurSource(direction, taps, samplerNum), ["uDirection"]);
        this.direction = direction;
        if (samplerNum === undefined) {
            this.needs.neighborSample = true;
            this.externalFuncs = [tapsToFuncSource(taps)];
        }
        else {
            this.needs.extraBuffers = new Set([samplerNum]);
            this.externalFuncs = [
                glslfunctions_1.replaceSampler(tapsToFuncSource(taps), /vec4\sgauss[0-9]+/g, samplerNum),
            ];
        }
    }
    /** set the blur direction (keep magnitude no greater than 1 for best effect) */
    setDirection(direction) {
        this.setUniform("uDirection" + this.id, direction);
        this.direction = direction;
    }
}
exports.BlurExpr = BlurExpr;
/**
 * creates expression that performs one pass of a gaussian blur
 * @param direction direction to blur (keep magnitude less than or equal to 1
 * for best effect)
 * @param taps number of taps (defaults to 5)
 * @param samplerNum which channel to sample from (default 0)
 */
function gauss(direction, taps = 5, samplerNum) {
    return new BlurExpr(direction, taps, samplerNum);
}
exports.gauss = gauss;

},{"../glslfunctions":203,"./expr":169}],163:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.brightness = exports.Brightness = void 0;
const glslfunctions_1 = require("../glslfunctions");
const expr_1 = require("./expr");
const fragcolorexpr_1 = require("./fragcolorexpr");
/** brightness expression */
class Brightness extends expr_1.ExprVec4 {
    constructor(brightness, col = fragcolorexpr_1.fcolor()) {
        super(expr_1.tag `brightness(${brightness}, ${col})`, ["uBrightness", "uColor"]);
        this.brightness = brightness;
        this.externalFuncs = [glslfunctions_1.glslFuncs.brightness];
    }
    /** set the brightness (should probably be between -1 and 1) */
    setBrightness(brightness) {
        this.setUniform("uBrightness" + this.id, brightness);
        this.brightness = expr_1.n2e(brightness);
    }
}
exports.Brightness = Brightness;
/**
 * changes the brightness of a color
 * @param val float for how much to change the brightness by (should probably be
 * between -1 and 1)
 * @param col the color to increase the brightness of (defaults to current
 * fragment color)
 */
function brightness(val, col) {
    return new Brightness(expr_1.n2e(val), col);
}
exports.brightness = brightness;

},{"../glslfunctions":203,"./expr":169,"./fragcolorexpr":170}],164:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.changecomp = exports.ChangeCompExpr = void 0;
const expr_1 = require("./expr");
const getcompexpr_1 = require("./getcompexpr");
/** @ignore */
function getChangeFunc(typ, id, setter, comps, op = "") {
    return `${typ} changecomp_${id}(${typ} col, ${setter.typeString()} setter) {
  col.${comps} ${op}= setter;
  return col;
}`;
}
/**
 * throws a runtime error if component access is not valid, and disallows
 * duplicate components because duplicate components can not be in a left
 * expression. (for example `v.xyx = vec3(1., 2., 3.)` is illegal, but `v1.xyz
 * = v2.xyx` is legal.) also checks for type errors such as `v1.xy = vec3(1.,
 * 2., 3.)`; the right hand side can only be a `vec2` if only two components
 * are supplied
 * @param comps component string
 * @param setter how the components are being changed
 * @param vec the vector where components are being accessed
 */
function checkChangeComponents(comps, setter, vec) {
    // setter has different length than components
    if (comps.length !== getcompexpr_1.typeStringToLength(setter.typeString())) {
        throw new Error("components length must be equal to the target float/vec");
    }
    // duplicate components
    if (duplicateComponents(comps)) {
        throw new Error("duplicate components not allowed on left side");
    }
    // legal components
    getcompexpr_1.checkLegalComponents(comps, vec);
}
/** @ignore */
function duplicateComponents(comps) {
    return new Set(comps.split("")).size !== comps.length;
}
/** change component expression */
class ChangeCompExpr extends expr_1.Operator {
    constructor(vec, setter, comps, op) {
        checkChangeComponents(comps, setter, vec);
        // part of name of custom function
        const suffix = `${vec.typeString()}_${setter.typeString()}_${comps}`;
        super(vec, { sections: [`changecomp_${suffix}(`, ", ", ")"], values: [vec, setter] }, ["uOriginal", "uNew"]);
        this.originalVec = vec;
        this.newVal = setter;
        this.externalFuncs = [
            getChangeFunc(vec.typeString(), suffix, setter, comps, op),
        ];
    }
    /** set the original vector */
    setOriginal(originalVec) {
        this.setUniform("uOriginal" + this.id, originalVec);
        this.originalVec = originalVec;
    }
    /** set the neww vector */
    setNew(newVal) {
        this.setUniform("uNew" + this.id, newVal);
        this.newVal = expr_1.wrapInValue(newVal);
    }
}
exports.ChangeCompExpr = ChangeCompExpr;
/**
 * change the components of a vector
 * @param vec the vector to augment components of
 * @param setter the vector (or float, if only one component is changed) for
 * how to change the components
 * @param comps string representing the components to change (e.g. `"xy"` or
 * `"r"` or `"stpq"`.)
 * @param op optionally perform an operation on the original component
 * (defaults to no operation, just assigning that component to a new value)
 */
function changecomp(vec, setter, comps, op) {
    return new ChangeCompExpr(vec, expr_1.wrapInValue(setter), comps, op);
}
exports.changecomp = changecomp;

},{"./expr":169,"./getcompexpr":174}],165:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.channel = exports.ChannelSampleExpr = void 0;
const codebuilder_1 = require("../codebuilder");
const expr_1 = require("./expr");
const normfragcoordexpr_1 = require("./normfragcoordexpr");
/** @ignore */
function genChannelSampleSource(buf, coord) {
    return {
        sections: [`texture2D(${codebuilder_1.channelSamplerName(buf)}, `, `)`],
        values: [coord],
    };
}
/** channel sample expression */
class ChannelSampleExpr extends expr_1.ExprVec4 {
    constructor(buf, coord = normfragcoordexpr_1.pos()) {
        super(genChannelSampleSource(buf, coord), ["uVec"]);
        this.coord = coord;
        this.needs.extraBuffers = new Set([buf]);
    }
    setCoord(coord) {
        this.setUniform("uVec", coord);
        this.coord = coord;
    }
}
exports.ChannelSampleExpr = ChannelSampleExpr;
/**
 * creates an expression that samples from one of the user-defined channels.
 * don't sample from the same channel that you are using [[target]] on in a
 * loop, just use [[fcolor]]
 * @param channel which channel to sample from
 * @param vec where to sample the channel texture (defaults to the normalized
 * frag coord)
 */
function channel(channel, vec) {
    return new ChannelSampleExpr(channel, vec);
}
exports.channel = channel;

},{"../codebuilder":157,"./expr":169,"./normfragcoordexpr":185}],166:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.contrast = exports.ContrastExpr = void 0;
const glslfunctions_1 = require("../glslfunctions");
const expr_1 = require("./expr");
const fragcolorexpr_1 = require("./fragcolorexpr");
class ContrastExpr extends expr_1.ExprVec4 {
    constructor(contrast, col = fragcolorexpr_1.fcolor()) {
        super(expr_1.tag `contrast(${contrast}, ${col})`, ["uVal", "uCol"]);
        this.contrast = contrast;
        this.externalFuncs = [glslfunctions_1.glslFuncs.contrast];
    }
    /** sets the contrast */
    setContrast(contrast) {
        this.setUniform("uContrast" + this.id, contrast);
        this.contrast = expr_1.n2p(contrast);
    }
}
exports.ContrastExpr = ContrastExpr;
/**
 * changes the contrast of a color
 * @param val float for how much to change the contrast by (should probably be
 * between -1 and 1)
 * @param col the color to increase the contrast of (defaults to current
 * fragment color)
 */
function contrast(val, col) {
    return new ContrastExpr(expr_1.n2e(val), col);
}
exports.contrast = contrast;

},{"../glslfunctions":203,"./expr":169,"./fragcolorexpr":170}],167:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.depth2occlusion = exports.DepthToOcclusionExpr = void 0;
const channelsampleexpr_1 = require("./channelsampleexpr");
const expr_1 = require("./expr");
const vecexprs_1 = require("./vecexprs");
/** depth info to occlussion info expression */
class DepthToOcclusionExpr extends expr_1.ExprVec4 {
    constructor(depthCol = channelsampleexpr_1.channel(0), newCol = expr_1.mut(vecexprs_1.pvec4(1, 1, 1, 1)), threshold = expr_1.mut(expr_1.pfloat(0.01))) {
        super(expr_1.tag `depth2occlusion(${depthCol}, ${newCol}, ${threshold})`, [
            "uDepth",
            "uNewCol",
            "uThreshold",
        ]);
        this.depthCol = depthCol;
        this.newCol = newCol;
        this.threshold = threshold;
    }
    setDepthColor(depthCol) {
        this.setUniform("uDepth" + this.id, depthCol);
        this.depthCol = depthCol;
    }
    setNewColor(newCol) {
        this.setUniform("uNewCol" + this.id, newCol);
        this.newCol = newCol;
    }
    setThreshold(threshold) {
        this.setUniform("uThreshold" + this.id, threshold);
        this.threshold = expr_1.n2p(threshold);
    }
}
exports.DepthToOcclusionExpr = DepthToOcclusionExpr;
/**
 * converts a `1 / distance` depth texture to an occlusion texture, with all
 * occluded geometry being rendered as black
 * @param depthCol the color representing the inverse depth (defaults to
 * sampling from channel 0)
 * @param newCol the color to replace unoccluded areas by (defaults to white
 * and is mutable by default)
 * @param threshold values below this are not occluded (set to something low,
 * like 0.1 or lower; defaults to 0.01 and is mutable by default)
 */
function depth2occlusion(depthCol, newCol, threshold) {
    return new DepthToOcclusionExpr(depthCol, newCol, expr_1.n2e(threshold));
}
exports.depth2occlusion = depth2occlusion;

},{"./channelsampleexpr":165,"./expr":169,"./vecexprs":201}],168:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.dof = exports.DoFLoop = void 0;
const mergepass_1 = require("../mergepass");
const blurexpr_1 = require("./blurexpr");
const channelsampleexpr_1 = require("./channelsampleexpr");
const expr_1 = require("./expr");
const gaussianexpr_1 = require("./gaussianexpr");
const getcompexpr_1 = require("./getcompexpr");
const opexpr_1 = require("./opexpr");
const arity2_1 = require("./arity2");
const vecexprs_1 = require("./vecexprs");
class DoFLoop extends mergepass_1.EffectLoop {
    constructor(depth = expr_1.mut(expr_1.pfloat(0.3)), rad = expr_1.mut(expr_1.pfloat(0.01)), depthInfo = getcompexpr_1.getcomp(channelsampleexpr_1.channel(0), "r"), reps = 2, taps = 13) {
        let guassianExpr = gaussianexpr_1.gaussian(depthInfo, depth, rad);
        const side = blurexpr_1.gauss(vecexprs_1.vec2(arity2_1.a2("pow", opexpr_1.op(1, "-", guassianExpr), 4), 0), taps);
        const up = blurexpr_1.gauss(vecexprs_1.vec2(0, arity2_1.a2("pow", opexpr_1.op(1, "-", guassianExpr), 4)), taps);
        super([side, up], { num: reps });
        this.gaussian = guassianExpr;
    }
    setDepth(depth) {
        // this translates the gaussian curve to the side
        this.gaussian.setA(depth);
    }
    setRadius(radius) {
        // this scales the gaussian curve to focus on a larger band of depth
        this.gaussian.setB(radius);
    }
}
exports.DoFLoop = DoFLoop;
/**
 * creates depth of field expression; all values are mutable by default
 * @param depth float for what inverse depth to focus on (1 on top of the
 * camera; 0 is infinity)
 * @param rad float for how deep the band of in-focus geometry is (a value
 * between 0.01 and 0.1 is reasonable)
 * @param depthInfo float the expression that represents the inverse depth
 * (defaults to sampling the red component from channel 0)
 * @param reps how many times to repeat the gaussian blur
 */
function dof(depth, rad, depthInfo, reps) {
    return new DoFLoop(expr_1.n2e(depth), expr_1.n2e(rad), expr_1.n2e(depthInfo), reps);
}
exports.dof = dof;

},{"../mergepass":205,"./arity2":159,"./blurexpr":162,"./channelsampleexpr":165,"./expr":169,"./gaussianexpr":173,"./getcompexpr":174,"./opexpr":187,"./vecexprs":201}],169:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tag = exports.wrapInValue = exports.pfloat = exports.n2p = exports.n2e = exports.Operator = exports.ExprVec4 = exports.ExprVec3 = exports.ExprVec2 = exports.float = exports.ExprFloat = exports.BasicFloat = exports.ExprVec = exports.BasicVec4 = exports.BasicVec3 = exports.BasicVec2 = exports.BasicVec = exports.PrimitiveVec4 = exports.PrimitiveVec3 = exports.PrimitiveVec2 = exports.PrimitiveVec = exports.PrimitiveFloat = exports.Primitive = exports.mut = exports.Mutable = exports.cvec4 = exports.cvec3 = exports.cvec2 = exports.cfloat = exports.Expr = void 0;
const mergepass_1 = require("../mergepass");
const webglprogramloop_1 = require("../webglprogramloop");
/**
 * adds a `.` after a number if needed (e.g converts `1` to `"1."` but leaves
 * `1.2` as `"1.2"`)
 * @param num number to convert
 */
function toGLSLFloatString(num) {
    let str = "" + num;
    if (!str.includes("."))
        str += ".";
    return str;
}
class Expr {
    constructor(sourceLists, defaultNames) {
        this.needs = {
            neighborSample: false,
            centerSample: false,
            sceneBuffer: false,
            timeUniform: false,
            mouseUniform: false,
            extraBuffers: new Set(),
        };
        this.uniformValChangeMap = {};
        this.defaultNameMap = {};
        this.externalFuncs = [];
        this.sourceCode = "";
        this.id = "_id_" + Expr.count;
        Expr.count++;
        if (sourceLists.sections.length - sourceLists.values.length !== 1) {
            // this cannot happen if you use `tag` to destructure a template string
            throw new Error("wrong lengths for source and values");
        }
        if (sourceLists.values.length !== defaultNames.length) {
            throw new Error("default names list length doesn't match values list length");
        }
        this.sourceLists = sourceLists;
        this.defaultNames = defaultNames;
    }
    applyUniforms(gl, uniformLocs) {
        for (const name in this.uniformValChangeMap) {
            const loc = uniformLocs[name];
            if (this.uniformValChangeMap[name].changed) {
                //this.uniformValChangeMap[name].changed = false;
                this.uniformValChangeMap[name].val.applyUniform(gl, loc.locs[loc.counter]);
            }
            // increment and reset the counter to wrap back around to first location
            loc.counter++;
            loc.counter %= loc.locs.length;
            // once we have wrapped then we know all uniforms have been changed
            if (loc.counter === 0) {
                this.uniformValChangeMap[name].changed = false;
            }
        }
    }
    getSampleNum(mult = 1) {
        return this.needs.neighborSample ? mult : 0;
    }
    /**
     * set a uniform by name directly
     * @param name uniform name in the source code
     * @param newVal value to set the uniform to
     */
    setUniform(name, newVal) {
        var _a, _b;
        newVal = wrapInValue(newVal);
        const originalName = name;
        if (typeof newVal === "number") {
            newVal = n2p(newVal);
        }
        if (!(newVal instanceof Primitive)) {
            throw new Error("cannot set a non-primitive");
        }
        // if name does not exist, try mapping default name to new name
        if (((_a = this.uniformValChangeMap[name]) === null || _a === void 0 ? void 0 : _a.val) === undefined) {
            name = this.defaultNameMap[name];
        }
        const oldVal = (_b = this.uniformValChangeMap[name]) === null || _b === void 0 ? void 0 : _b.val;
        if (oldVal === undefined) {
            // TODO get rid of this
            console.log(this.defaultNameMap);
            throw new Error("tried to set uniform " +
                name +
                " which doesn't exist. original name: " +
                originalName);
        }
        if (oldVal.typeString() !== newVal.typeString()) {
            throw new Error("tried to set uniform " + name + " to a new type");
        }
        this.uniformValChangeMap[name].val = newVal;
        this.uniformValChangeMap[name].changed = true;
    }
    /**
     * parses this expression into a string, adding info as it recurses into
     * nested expressions
     */
    parse(buildInfo) {
        this.sourceCode = "";
        buildInfo.exprs.push(this);
        buildInfo.needs = webglprogramloop_1.updateNeeds(buildInfo.needs, this.needs);
        // add each of the external funcs to the builder
        this.externalFuncs.forEach((func) => buildInfo.externalFuncs.add(func));
        // put all of the values between all of the source sections
        for (let i = 0; i < this.sourceLists.values.length; i++) {
            this.sourceCode +=
                this.sourceLists.sections[i] +
                    this.sourceLists.values[i].parse(buildInfo, this.defaultNames[i], this);
        }
        // TODO does sourceCode have to be a member?
        this.sourceCode += this.sourceLists.sections[this.sourceLists.sections.length - 1];
        return this.sourceCode;
    }
    addFuncs(funcs) {
        this.externalFuncs.push(...funcs);
        return this;
    }
}
exports.Expr = Expr;
/**
 * increments for each expression created; used to uniquely id each expression
 */
Expr.count = 0;
function genCustomNames(sourceLists) {
    const names = [];
    for (let i = 0; i < sourceLists.values.length; i++) {
        names.push("uCustomName" + i);
    }
    return names;
}
/** create a custom float function (use with [[tag]]) */
function cfloat(sourceLists, externalFuncs = []) {
    return new ExprFloat(sourceLists, genCustomNames(sourceLists)).addFuncs(externalFuncs);
}
exports.cfloat = cfloat;
/** create a custom vec2 function (use with [[tag]]) */
function cvec2(sourceLists, externalFuncs = []) {
    return new ExprVec2(sourceLists, genCustomNames(sourceLists)).addFuncs(externalFuncs);
}
exports.cvec2 = cvec2;
/** create a custom vec3 function (use with [[tag]]) */
function cvec3(sourceLists, externalFuncs = []) {
    return new ExprVec3(sourceLists, genCustomNames(sourceLists)).addFuncs(externalFuncs);
}
exports.cvec3 = cvec3;
/** create a custom vec4 function (use with [[tag]]) */
function cvec4(sourceLists, externalFuncs = []) {
    return new ExprVec4(sourceLists, genCustomNames(sourceLists)).addFuncs(externalFuncs);
}
exports.cvec4 = cvec4;
class Mutable {
    constructor(primitive, name) {
        this.primitive = primitive;
        this.name = name;
    }
    parse(buildInfo, defaultName, enc) {
        if (enc === undefined) {
            throw new Error("tried to put a mutable expression at the top level");
        }
        // accept the default name if given no name
        if (this.name === undefined)
            this.name = defaultName + enc.id;
        // set to true so they are set to their default values on first draw
        buildInfo.uniformTypes[this.name] = this.primitive.typeString();
        // add the name mapping
        enc.uniformValChangeMap[this.name] = {
            val: this.primitive,
            changed: true,
        };
        // add the new type to the map
        enc.defaultNameMap[defaultName + enc.id] = this.name;
        return this.name;
    }
    applyUniform(gl, loc) {
        this.primitive.applyUniform(gl, loc);
    }
    typeString() {
        return this.primitive.typeString();
    }
}
exports.Mutable = Mutable;
/**
 * makes a primitive value mutable. wrapping a [[PrimitiveVec]] or
 * [[PrimitiveFloat]] in [[mut]] before passing it into an expression will
 * allow you to use the setters on that expression to change those values at
 * runtime
 * @param val the primitive float or primitive vec to make mutable
 * @param name the optional name for the uniform
 */
function mut(val, name) {
    const primitive = typeof val === "number" ? n2p(val) : val;
    return new Mutable(primitive, name);
}
exports.mut = mut;
class Primitive {
    parse() {
        return this.toString();
    }
}
exports.Primitive = Primitive;
class PrimitiveFloat extends Primitive {
    constructor(num) {
        if (!isFinite(num))
            throw new Error("number not finite");
        super();
        this.value = num;
    }
    toString() {
        let str = "" + this.value;
        if (!str.includes("."))
            str += ".";
        return str;
    }
    typeString() {
        return "float";
    }
    applyUniform(gl, loc) {
        gl.uniform1f(loc, this.value);
    }
}
exports.PrimitiveFloat = PrimitiveFloat;
class PrimitiveVec extends Primitive {
    constructor(comps) {
        super();
        this.values = comps;
    }
    typeString() {
        return ("vec" + this.values.length);
    }
    toString() {
        return `${this.typeString}(${this.values
            .map((n) => toGLSLFloatString(n))
            .join(", ")})`;
    }
}
exports.PrimitiveVec = PrimitiveVec;
class PrimitiveVec2 extends PrimitiveVec {
    applyUniform(gl, loc) {
        gl.uniform2f(loc, this.values[0], this.values[1]);
    }
}
exports.PrimitiveVec2 = PrimitiveVec2;
class PrimitiveVec3 extends PrimitiveVec {
    applyUniform(gl, loc) {
        gl.uniform3f(loc, this.values[0], this.values[1], this.values[2]);
    }
}
exports.PrimitiveVec3 = PrimitiveVec3;
class PrimitiveVec4 extends PrimitiveVec {
    applyUniform(gl, loc) {
        gl.uniform4f(loc, this.values[0], this.values[1], this.values[2], this.values[3]);
    }
}
exports.PrimitiveVec4 = PrimitiveVec4;
class BasicVec extends Expr {
    constructor(sourceLists, defaultNames) {
        super(sourceLists, defaultNames);
        // this cast is fine as long as you only instantiate these with the
        // shorthand version and not the constructor
        const values = sourceLists.values;
        this.values = values;
        this.defaultNames = defaultNames;
    }
    typeString() {
        return ("vec" + this.values.length);
    }
    /** sets a component of the vector */
    setComp(index, primitive) {
        if (index < 0 || index >= this.values.length) {
            throw new Error("out of bounds of setting component");
        }
        this.setUniform(this.defaultNames[index] + this.id, n2p(primitive));
    }
}
exports.BasicVec = BasicVec;
class BasicVec2 extends BasicVec {
    constructor() {
        super(...arguments);
        this.bvec2 = undefined; // brand for nominal typing
    }
}
exports.BasicVec2 = BasicVec2;
class BasicVec3 extends BasicVec {
    constructor() {
        super(...arguments);
        this.bvec3 = undefined; // brand for nominal typing
    }
}
exports.BasicVec3 = BasicVec3;
class BasicVec4 extends BasicVec {
    constructor() {
        super(...arguments);
        this.bvec4 = undefined; // brand for nominal typing
    }
}
exports.BasicVec4 = BasicVec4;
class ExprVec extends Expr {
    constructor(sourceLists, defaultNames) {
        super(sourceLists, defaultNames);
        const values = sourceLists.values;
        this.values = values;
        this.defaultNames = defaultNames;
    }
}
exports.ExprVec = ExprVec;
class BasicFloat extends Expr {
    constructor(sourceLists, defaultNames) {
        super(sourceLists, defaultNames);
        this.float = undefined; // brand for nominal typing
    }
    setVal(primitive) {
        this.setUniform("uFloat" + this.id, n2p(primitive));
    }
    typeString() {
        return "float";
    }
}
exports.BasicFloat = BasicFloat;
class ExprFloat extends Expr {
    constructor(sourceLists, defaultNames) {
        super(sourceLists, defaultNames);
        this.float = undefined; // brand for nominal typing
    }
    setVal(primitive) {
        this.setUniform("uFloat" + this.id, n2p(primitive));
    }
    typeString() {
        return "float";
    }
}
exports.ExprFloat = ExprFloat;
function float(value) {
    if (typeof value === "number")
        value = n2p(value);
    return new BasicFloat({ sections: ["", ""], values: [value] }, ["uFloat"]);
}
exports.float = float;
class ExprVec2 extends ExprVec {
    constructor() {
        super(...arguments);
        this.vec2 = undefined; // brand for nominal typing
    }
    typeString() {
        return "vec2";
    }
}
exports.ExprVec2 = ExprVec2;
class ExprVec3 extends ExprVec {
    constructor() {
        super(...arguments);
        this.vec3 = undefined; // brand for nominal typing
    }
    typeString() {
        return "vec3";
    }
}
exports.ExprVec3 = ExprVec3;
class ExprVec4 extends ExprVec {
    constructor() {
        super(...arguments);
        this.vec4 = undefined; // brand for nominal typing
    }
    repeat(num) {
        return new mergepass_1.EffectLoop([this], { num: num });
    }
    genPrograms(gl, vShader, uniformLocs, shaders) {
        return new mergepass_1.EffectLoop([this], { num: 1 }).genPrograms(gl, vShader, uniformLocs, shaders);
    }
    typeString() {
        return "vec4";
    }
}
exports.ExprVec4 = ExprVec4;
class Operator extends Expr {
    constructor(ret, sourceLists, defaultNames) {
        super(sourceLists, defaultNames);
        this.ret = ret;
    }
    typeString() {
        return this.ret.typeString();
    }
}
exports.Operator = Operator;
function n2e(num) {
    if (num === undefined)
        return undefined;
    if (num instanceof PrimitiveFloat ||
        num instanceof ExprFloat ||
        num instanceof Operator ||
        num instanceof Mutable ||
        num instanceof BasicFloat)
        return num;
    return new PrimitiveFloat(num);
}
exports.n2e = n2e;
// TODO see if we need this
/** number to primitive float */
function n2p(num) {
    if (num instanceof PrimitiveFloat)
        return num;
    return new PrimitiveFloat(num);
}
exports.n2p = n2p;
/** creates a primitive float */
function pfloat(num) {
    return new PrimitiveFloat(num);
}
exports.pfloat = pfloat;
/** @ignore */
function wrapInValue(num) {
    if (typeof num === "number")
        return pfloat(num);
    return num;
}
exports.wrapInValue = wrapInValue;
/** @ignore */
function tag(strings, ...values) {
    return { sections: strings.concat([]), values: values };
}
exports.tag = tag;

},{"../mergepass":205,"../webglprogramloop":206}],170:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fcolor = exports.FragColorExpr = void 0;
const expr_1 = require("./expr");
/** fragment color expression */
class FragColorExpr extends expr_1.ExprVec4 {
    constructor() {
        super(expr_1.tag `gl_FragColor`, []);
        this.needs.centerSample = true;
    }
}
exports.FragColorExpr = FragColorExpr;
/** creates an expression that evaluates to the fragment color */
function fcolor() {
    return new FragColorExpr();
}
exports.fcolor = fcolor;

},{"./expr":169}],171:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pixel = exports.FragCoordExpr = void 0;
const expr_1 = require("./expr");
/** frag coord expression (xy components only) */
class FragCoordExpr extends expr_1.ExprVec2 {
    constructor() {
        super(expr_1.tag `gl_FragCoord.xy`, []);
    }
}
exports.FragCoordExpr = FragCoordExpr;
/**
 * creates an expression that evaluates to the frag coord in pixels (samplers
 * take normalized coordinates, so you might want [[nfcoord]] instead)
 */
function pixel() {
    return new FragCoordExpr();
}
exports.pixel = pixel;

},{"./expr":169}],172:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fxaa = void 0;
const expr_1 = require("./expr");
const glslfunctions_1 = require("../glslfunctions");
/** FXAA expression */
class FXAAExpr extends expr_1.ExprVec4 {
    constructor() {
        super(expr_1.tag `fxaa()`, []);
        this.externalFuncs = [glslfunctions_1.glslFuncs.fxaa];
        this.needs.neighborSample = true;
    }
}
/** FXAA antaliasing expression */
function fxaa() {
    return new FXAAExpr();
}
exports.fxaa = fxaa;

},{"../glslfunctions":203,"./expr":169}],173:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.gaussian = exports.GaussianExpr = void 0;
const glslfunctions_1 = require("../glslfunctions");
const expr_1 = require("./expr");
/** gaussian expression */
class GaussianExpr extends expr_1.ExprFloat {
    constructor(x, a, b) {
        super(expr_1.tag `gaussian(${x}, ${a}, ${b})`, ["uFloatX", "uFloatA", "uFloatB"]);
        this.x = x;
        this.a = a;
        this.b = b;
        this.externalFuncs = [glslfunctions_1.glslFuncs.gaussian];
    }
    setX(x) {
        this.setUniform("uFloatX" + this.id, x);
        this.x = expr_1.n2p(x);
    }
    setA(a) {
        this.setUniform("uFloatA" + this.id, a);
        this.a = expr_1.n2p(a);
    }
    setB(b) {
        this.setUniform("uFloatB" + this.id, b);
        this.b = expr_1.n2p(b);
    }
}
exports.GaussianExpr = GaussianExpr;
/**
 * gaussian function that defaults to normal distribution
 * @param x x position in the curve
 * @param a horizontal position of peak (defaults to 0 for normal distribution)
 * @param b horizontal stretch of the curve (defaults to 1 for normal distribution)
 */
function gaussian(x, a = 0, b = 1) {
    return new GaussianExpr(expr_1.n2e(x), expr_1.n2e(a), expr_1.n2e(b));
}
exports.gaussian = gaussian;

},{"../glslfunctions":203,"./expr":169}],174:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.get4comp = exports.get3comp = exports.get2comp = exports.getcomp = exports.Get4CompExpr = exports.Get3CompExpr = exports.Get2CompExpr = exports.GetCompExpr = exports.checkLegalComponents = exports.typeStringToLength = void 0;
const expr_1 = require("./expr");
// TODO this should probably be somewhere else
/** @ignore */
function typeStringToLength(str) {
    switch (str) {
        case "float":
            return 1;
        case "vec2":
            return 2;
        case "vec3":
            return 3;
        case "vec4":
            return 4;
    }
}
exports.typeStringToLength = typeStringToLength;
/** @ignore */
function genCompSource(vec, components) {
    return {
        sections: ["", "." + components],
        values: [vec],
    };
}
/**
 * checks if components accessing a vector are legal. components can be illegal
 * if they mix sets (e.g. `v.rgzw`) or contain characters outside of any set
 * (e.g. `v.lmno`)
 * @param comps components string
 * @param vec vector being accessed
 */
function checkLegalComponents(comps, vec) {
    const check = (range, domain) => {
        let inside = 0;
        let outside = 0;
        for (const c of range) {
            domain.includes(c) ? inside++ : outside++;
        }
        return inside === inside && !outside;
    };
    const inLen = typeStringToLength(vec.typeString());
    const rgbaCheck = check(comps, "rgba".substr(0, inLen));
    const xyzwCheck = check(comps, "xyzw".substr(0, inLen));
    const stpqCheck = check(comps, "stpq".substr(0, inLen));
    if (!(rgbaCheck || xyzwCheck || stpqCheck)) {
        throw new Error("component sets are mixed or incorrect entirely");
    }
}
exports.checkLegalComponents = checkLegalComponents;
/**
 * performs all validity checks of [[checkLegalComponents]] and checks if the
 * number of accessed components does not exceed the size of the vector being
 * assigned to
 * @param comps components string
 * @param outLen length of the resultant vector
 * @param vec vector being accessed
 */
function checkGetComponents(comps, outLen, vec) {
    if (comps.length > outLen)
        throw new Error("too many components");
    checkLegalComponents(comps, vec);
}
/** get component expression */
class GetCompExpr extends expr_1.ExprFloat {
    constructor(vec, comps) {
        checkGetComponents(comps, 1, vec);
        super(genCompSource(vec, comps), ["uVec1Min"]);
        this.vec1Min = vec;
    }
    setVec(vec) {
        this.setUniform("uVec1Min", vec);
        this.vec1Min = vec;
    }
}
exports.GetCompExpr = GetCompExpr;
/** get 2 components expression */
class Get2CompExpr extends expr_1.ExprVec2 {
    constructor(vec, comps) {
        checkGetComponents(comps, 2, vec);
        super(genCompSource(vec, comps), ["uVec2Min"]);
        this.vec2Min = vec;
    }
    setVec(vec) {
        this.setUniform("uVec2Min", vec);
        this.vec2Min = vec;
    }
}
exports.Get2CompExpr = Get2CompExpr;
/** get 3 components expression */
class Get3CompExpr extends expr_1.ExprVec3 {
    constructor(vec, comps) {
        checkGetComponents(comps, 3, vec);
        super(genCompSource(vec, comps), ["uVec3Min"]);
        this.vec3Min = vec;
    }
    setVec(vec) {
        this.setUniform("uVec3Min", vec);
        this.vec3Min = vec;
    }
}
exports.Get3CompExpr = Get3CompExpr;
/** get 3 components expression */
class Get4CompExpr extends expr_1.ExprVec4 {
    constructor(vec, comps) {
        checkGetComponents(comps, 4, vec);
        super(genCompSource(vec, comps), ["uVec4Min"]);
        this.vec4Min = vec;
    }
    setVec(vec) {
        this.setUniform("uVec4Min", vec);
        this.vec4Min = vec;
    }
}
exports.Get4CompExpr = Get4CompExpr;
/**
 * creates an expression that gets 1 component from a vector
 * @param vec the vector to get components of
 * @param comps components string
 */
function getcomp(vec, comps) {
    return new GetCompExpr(vec, comps);
}
exports.getcomp = getcomp;
/**
 * creates an expression that gets 2 components from a vector
 * @param vec the vector to get components of
 * @param comps components string
 */
function get2comp(vec, comps) {
    return new Get2CompExpr(vec, comps);
}
exports.get2comp = get2comp;
/**
 * creates an expression that gets 3 components from a vector
 * @param vec the vector to get components of
 * @param comps components string
 */
function get3comp(vec, comps) {
    return new Get3CompExpr(vec, comps);
}
exports.get3comp = get3comp;
/**
 * creates an expression that gets 4 components from a vector
 * @param vec the vector to get components of
 * @param comps components string
 */
function get4comp(vec, comps) {
    return new Get4CompExpr(vec, comps);
}
exports.get4comp = get4comp;

},{"./expr":169}],175:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.godrays = exports.GodRaysExpr = void 0;
const glslfunctions_1 = require("../glslfunctions");
const expr_1 = require("./expr");
const fragcolorexpr_1 = require("./fragcolorexpr");
const vecexprs_1 = require("./vecexprs");
/** godrays expression */
class GodRaysExpr extends expr_1.ExprVec4 {
    // sane godray defaults from https://github.com/Erkaman/glsl-godrays/blob/master/example/index.js
    constructor(col = fragcolorexpr_1.fcolor(), exposure = expr_1.mut(1.0), decay = expr_1.mut(1.0), density = expr_1.mut(1.0), weight = expr_1.mut(0.01), lightPos = expr_1.mut(vecexprs_1.pvec2(0.5, 0.5)), samplerNum = 0, convertDepth) {
        // TODO the metaprogramming here is not so good!
        // leaving off the function call section for now
        const sourceLists = expr_1.tag `${col}, ${exposure}, ${decay}, ${density}, ${weight}, ${lightPos}, ${convertDepth !== undefined ? convertDepth.threshold : expr_1.float(0)}, ${convertDepth !== undefined ? convertDepth.newColor : vecexprs_1.vec4(0, 0, 0, 0)})`;
        // TODO make this more generic
        // append the _<num> onto the function name
        // also add _depth if this is a version of the function that uses depth buffer
        sourceLists.sections[0] += `godrays_${samplerNum}${convertDepth !== undefined ? "_depth" : ""}(`;
        super(sourceLists, [
            "uCol",
            "uExposure",
            "uDecay",
            "uDensity",
            "uWeight",
            "uLightPos",
            "uThreshold",
            "uNewColor",
        ]);
        this.col = col;
        this.exposure = exposure;
        this.decay = decay;
        this.density = density;
        this.weight = weight;
        this.lightPos = lightPos;
        this.threshold = convertDepth === null || convertDepth === void 0 ? void 0 : convertDepth.threshold;
        this.newColor = convertDepth === null || convertDepth === void 0 ? void 0 : convertDepth.newColor;
        let customGodRayFunc = glslfunctions_1.replaceSampler(glslfunctions_1.glslFuncs.godrays, /vec4\sgodrays/g, samplerNum, convertDepth === undefined ? undefined : "_depth");
        if (convertDepth !== undefined) {
            // uncomment the line that does the conversion
            // TODO replace this with a more generic #ifdef and #ifndef kind of
            // like the C preprocessor
            customGodRayFunc = customGodRayFunc.replace(/\/\/uncomment\s/g, "");
            this.externalFuncs.push(glslfunctions_1.glslFuncs.depth2occlusion);
        }
        this.externalFuncs.push(customGodRayFunc);
        this.needs.extraBuffers = new Set([0]);
    }
    /** sets the light color */
    setColor(color) {
        this.setUniform("uCol" + this.id, color);
        this.col = color;
    }
    /** sets the exposure */
    setExposure(exposure) {
        this.setUniform("uExposure" + this.id, exposure);
        this.exposure = expr_1.n2p(exposure);
    }
    /** sets the decay */
    setDecay(decay) {
        this.setUniform("uDecay" + this.id, decay);
        this.decay = expr_1.n2p(decay);
    }
    /** sets the density */
    setDensity(density) {
        this.setUniform("uDensity" + this.id, density);
        this.density = expr_1.n2p(density);
    }
    /** sets the weight */
    setWeight(weight) {
        this.setUniform("uWeight" + this.id, weight);
        this.weight = expr_1.n2p(weight);
    }
    /** sets the light position */
    setLightPos(lightPos) {
        this.setUniform("uLightPos" + this.id, lightPos);
        this.lightPos = lightPos;
    }
    // these only matter when you're using a depth buffer and not an occlusion
    // buffer (although right now, you'll still be able to set them)
    setThreshold(threshold) {
        this.setUniform("uThreshold" + this.id, threshold);
        this.threshold = expr_1.n2p(threshold);
    }
    setNewColor(newColor) {
        this.setUniform("uNewColor" + this.id, newColor);
        this.newColor = newColor;
    }
}
exports.GodRaysExpr = GodRaysExpr;
/**
 * create a godrays expression which requires an occlusion map; all values are
 * mutable by default
 * @param options object that defines godrays properties (has sane defaults)
 */
function godrays(options = {}) {
    return new GodRaysExpr(options.color, expr_1.n2e(options.exposure), expr_1.n2e(options.decay), expr_1.n2e(options.density), expr_1.n2e(options.weight), options.lightPos, options.samplerNum, options.convertDepth === undefined
        ? undefined
        : {
            threshold: expr_1.n2e(options.convertDepth.threshold),
            newColor: options.convertDepth.newColor,
        });
}
exports.godrays = godrays;

},{"../glslfunctions":203,"./expr":169,"./fragcolorexpr":170,"./vecexprs":201}],176:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.grain = exports.GrainExpr = void 0;
const glslfunctions_1 = require("../glslfunctions");
const expr_1 = require("./expr");
// TODO consider getting rid of this since it's easy to make your own with `random` and `brightness`
/** grain expression */
class GrainExpr extends expr_1.ExprVec4 {
    constructor(grain) {
        super(expr_1.tag `vec4((1.0 - ${grain} * random(gl_FragCoord.xy)) * gl_FragColor.rgb, gl_FragColor.a);`, ["uGrain"]);
        this.grain = grain;
        this.externalFuncs = [glslfunctions_1.glslFuncs.random];
        this.needs.centerSample = true;
    }
    /** sets the grain level  */
    setGrain(grain) {
        this.setUniform("uGrain" + this.id, grain);
        this.grain = expr_1.n2e(grain);
    }
}
exports.GrainExpr = GrainExpr;
/**
 * creates an expression that adds random grain
 * @param val how much the grain should impact the image (0 to 1 is reasonable)
 */
function grain(val) {
    return new GrainExpr(expr_1.n2e(val));
}
exports.grain = grain;

},{"../glslfunctions":203,"./expr":169}],177:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hsv2rgb = exports.HSVToRGBExpr = void 0;
const expr_1 = require("./expr");
const glslfunctions_1 = require("../glslfunctions");
/** HSV to RGB expression */
class HSVToRGBExpr extends expr_1.ExprVec4 {
    constructor(color) {
        super(expr_1.tag `hsv2rgb(${color})`, ["uHSVCol"]);
        this.color = color;
        this.externalFuncs = [glslfunctions_1.glslFuncs.hsv2rgb];
    }
    /** sets the color to convert */
    setColor(color) {
        this.setUniform("uHSVCol", color);
        this.color = color;
    }
}
exports.HSVToRGBExpr = HSVToRGBExpr;
/**
 * converts a color (with an alpha compoment) from hsv to rgb
 * @param col the hsva color to convert to rgba
 */
function hsv2rgb(col) {
    return new HSVToRGBExpr(col);
}
exports.hsv2rgb = hsv2rgb;

},{"../glslfunctions":203,"./expr":169}],178:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.invert = exports.InvertExpr = void 0;
const expr_1 = require("./expr");
const glslfunctions_1 = require("../glslfunctions");
/** invert expression */
class InvertExpr extends expr_1.ExprVec4 {
    constructor(color) {
        super(expr_1.tag `invert(${color})`, ["uColor"]);
        this.externalFuncs = [glslfunctions_1.glslFuncs.invert];
        this.color = color;
    }
    /** sets the color */
    setColor(color) {
        this.setUniform("uColor", color);
        this.color = color;
    }
}
exports.InvertExpr = InvertExpr;
/**
 * creates an expression that inverts the color, keeping the original alpha
 */
function invert(col) {
    return new InvertExpr(col);
}
exports.invert = invert;

},{"../glslfunctions":203,"./expr":169}],179:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.len = exports.LenExpr = void 0;
const expr_1 = require("./expr");
/** length expression */
class LenExpr extends expr_1.ExprFloat {
    constructor(vec) {
        super(expr_1.tag `length(${vec})`, ["uVec"]);
        this.vec = vec;
    }
    setVec(vec) {
        this.setUniform("uVec" + this.id, vec);
        this.vec = vec;
    }
}
exports.LenExpr = LenExpr;
/** creates an expreession that calculates the length of a vector */
function len(vec) {
    return new LenExpr(vec);
}
exports.len = len;

},{"./expr":169}],180:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.monochrome = exports.MonochromeExpr = void 0;
const expr_1 = require("./expr");
const glslfunctions_1 = require("../glslfunctions");
/** monochrome expression */
class MonochromeExpr extends expr_1.ExprVec4 {
    constructor(color) {
        super(expr_1.tag `monochrome(${color})`, ["uColor"]);
        this.externalFuncs = [glslfunctions_1.glslFuncs.monochrome];
        this.color = color;
    }
    /** sets the color */
    setColor(color) {
        this.setUniform("uColor", color);
        this.color = color;
    }
}
exports.MonochromeExpr = MonochromeExpr;
/**
 * creates an expression that converts a color into grayscale, keeping the
 * original alpha
 */
function monochrome(col) {
    return new MonochromeExpr(col);
}
exports.monochrome = monochrome;

},{"../glslfunctions":203,"./expr":169}],181:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.motionblur = exports.MotionBlurLoop = void 0;
const mergepass_1 = require("../mergepass");
const channelsampleexpr_1 = require("./channelsampleexpr");
const expr_1 = require("./expr");
const fragcolorexpr_1 = require("./fragcolorexpr");
const opexpr_1 = require("./opexpr");
const setcolorexpr_1 = require("./setcolorexpr");
/** frame averaging motion blur loop */
class MotionBlurLoop extends mergepass_1.EffectLoop {
    constructor(target = 0, persistence = expr_1.float(expr_1.mut(0.3))) {
        const col1 = opexpr_1.op(channelsampleexpr_1.channel(target), "*", persistence);
        const col2 = opexpr_1.op(fragcolorexpr_1.fcolor(), "*", opexpr_1.op(1, "-", persistence));
        const effects = [
            mergepass_1.loop([setcolorexpr_1.setcolor(opexpr_1.op(col1, "+", col2))]).target(target),
            channelsampleexpr_1.channel(target),
        ];
        super(effects, { num: 1 });
        this.persistence = persistence;
    }
    /** set the persistence (keep between 0 and 1) */
    setPersistence(float) {
        if (!(this.persistence instanceof expr_1.BasicFloat))
            throw new Error("persistence expression not basic float");
        this.persistence.setVal(float);
    }
}
exports.MotionBlurLoop = MotionBlurLoop;
/**
 * creates a frame averaging motion blur effect
 * @param target the channel where your accumulation buffer is (defaults to 0,
 * which you might be using for something like the depth texture, so be sure to
 * change this to suit your needs)
 * @param persistence close to 0 is more ghostly, and close to 1 is nearly no
 * motion blur at all (defaults to 0.3)
 */
function motionblur(target, persistence) {
    return new MotionBlurLoop(target, expr_1.n2e(persistence));
}
exports.motionblur = motionblur;

},{"../mergepass":205,"./channelsampleexpr":165,"./expr":169,"./fragcolorexpr":170,"./opexpr":187,"./setcolorexpr":195}],182:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mouse = exports.MouseExpr = void 0;
const expr_1 = require("./expr");
/** mouse position expression */
class MouseExpr extends expr_1.ExprVec2 {
    constructor() {
        super(expr_1.tag `uMouse`, []);
        this.needs.mouseUniform = true;
    }
}
exports.MouseExpr = MouseExpr;
/**
 * creates an expression that evaluates to a vector representing the mouse
 * position in pixels
 */
function mouse() {
    return new MouseExpr();
}
exports.mouse = mouse;

},{"./expr":169}],183:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.center = exports.NormCenterFragCoordExpr = void 0;
const expr_1 = require("./expr");
/** normalized centered frag coord expression */
class NormCenterFragCoordExpr extends expr_1.ExprVec2 {
    constructor() {
        super(expr_1.tag `(gl_FragCoord.xy / uResolution - 0.5)`, []);
    }
}
exports.NormCenterFragCoordExpr = NormCenterFragCoordExpr;
/**
 * creates an expression that calculates the normalized centered coord
 * (coordinates range from -0.5 to 0.5)
 */
function center() {
    return new NormCenterFragCoordExpr();
}
exports.center = center;

},{"./expr":169}],184:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.norm = exports.NormExpr = void 0;
const expr_1 = require("./expr");
/** normalize expression */
class NormExpr extends expr_1.Operator {
    constructor(vec) {
        super(vec, expr_1.tag `normalize(${vec})`, ["uVec"]);
        this.vec = vec;
    }
    /** sets the vec to normalize */
    setVec(vec) {
        this.setUniform("uVec" + this.id, vec);
        this.vec = vec;
    }
}
exports.NormExpr = NormExpr;
/** creates an expression that normalizes a vector */
function norm(vec) {
    return new NormExpr(vec);
}
exports.norm = norm;

},{"./expr":169}],185:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pos = exports.NormFragCoordExpr = void 0;
const expr_1 = require("./expr");
/** normalized frag coord expression */
class NormFragCoordExpr extends expr_1.ExprVec2 {
    constructor() {
        super(expr_1.tag `gl_FragCoord.xy / uResolution`, []);
    }
}
exports.NormFragCoordExpr = NormFragCoordExpr;
/**
 * creates an expression that calculates the normalized frag coord (coordinates
 * range from 0 to 1)
 */
function pos() {
    return new NormFragCoordExpr();
}
exports.pos = pos;

},{"./expr":169}],186:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.nmouse = exports.NormMouseExpr = void 0;
const expr_1 = require("./expr");
/** normalized mouse position expression */
class NormMouseExpr extends expr_1.ExprVec2 {
    constructor() {
        super(expr_1.tag `(uMouse / uResolution.xy)`, []);
        this.needs.mouseUniform = true;
    }
}
exports.NormMouseExpr = NormMouseExpr;
/**
 * creates an expression that calculates the normalized mouse position
 * (coordinates range from 0 to 1)
 */
function nmouse() {
    return new NormMouseExpr();
}
exports.nmouse = nmouse;

},{"./expr":169}],187:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.op = exports.OpExpr = void 0;
const expr_1 = require("./expr");
function genOpSourceList(left, op, right) {
    return {
        sections: ["(", ` ${op} `, ")"],
        values: [left, right],
    };
}
class OpExpr extends expr_1.Operator {
    constructor(left, op, right) {
        super(left, genOpSourceList(left, op, right), ["uLeft", "uRight"]);
        this.left = left;
        this.right = right;
    }
    setLeft(left) {
        this.setUniform("uLeft" + this.id, left);
        this.left = expr_1.wrapInValue(left);
    }
    setRight(right) {
        this.setUniform("uRight" + this.id, right);
        this.right = expr_1.wrapInValue(right);
    }
}
exports.OpExpr = OpExpr;
// implementation
/**
 * creates an arithmetic operator expression
 * @param left expression left of operator
 * @param op string representing arithmetic operator
 * @param right expression right of operator
 */
function op(left, op, right) {
    return new OpExpr(expr_1.wrapInValue(left), op, expr_1.wrapInValue(right));
}
exports.op = op;

},{"./expr":169}],188:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.fractalize = exports.perlin = exports.PerlinExpr = void 0;
const glslfunctions_1 = require("../glslfunctions");
const expr_1 = require("./expr");
const opexpr_1 = require("./opexpr");
/** Perlin noise expression */
class PerlinExpr extends expr_1.ExprFloat {
    // TODO include a default
    constructor(pos) {
        super(expr_1.tag `gradientnoise(${pos})`, ["uPos"]);
        this.pos = pos;
        this.externalFuncs = [glslfunctions_1.glslFuncs.random2, glslfunctions_1.glslFuncs.gradientnoise];
    }
    /** sets the position to calculate noise value of */
    setPos(pos) {
        this.setUniform("uPos", pos);
        this.pos = pos;
    }
}
exports.PerlinExpr = PerlinExpr;
/**
 * creates a perlin noise expression; values range from -1 to 1 but they tend
 * to be grayer than the [[simplex]] implementation
 * @param pos position
 */
function perlin(pos) {
    return new PerlinExpr(pos);
}
exports.perlin = perlin;
/**
 * take any function from a position to a float, and repeatedly sum calls to it
 * with doubling frequency and halving amplitude (works well with [[simplex]]
 * and [[perlin]])
 * @param pos position
 * @param octaves how many layers deep to make the fractal
 * @param func the function to fractalize
 */
function fractalize(pos, octaves, func) {
    if (octaves < 0)
        throw new Error("octaves can't be < 0");
    const recurse = (pos, size, level) => {
        if (level <= 0)
            return expr_1.pfloat(0);
        return opexpr_1.op(func(opexpr_1.op(pos, "/", size * 2)), "+", recurse(pos, size / 2, level - 1));
    };
    return recurse(pos, 0.5, octaves);
}
exports.fractalize = fractalize;

},{"../glslfunctions":203,"./expr":169,"./opexpr":187}],189:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pblur = exports.PowerBlurLoop = void 0;
const mergepass_1 = require("../mergepass");
const blurexpr_1 = require("./blurexpr");
const vecexprs_1 = require("./vecexprs");
const expr_1 = require("./expr");
const baseLog = (x, y) => Math.log(y) / Math.log(x);
// TODO consider getting rid of this, as it pretty much never looks good
/** power blur loop */
class PowerBlurLoop extends mergepass_1.EffectLoop {
    constructor(size) {
        const side = blurexpr_1.gauss(expr_1.mut(vecexprs_1.pvec2(size, 0)));
        const up = blurexpr_1.gauss(expr_1.mut(vecexprs_1.pvec2(0, size)));
        const reps = Math.ceil(baseLog(2, size));
        super([side, up], {
            num: reps + 1,
        });
        this.size = size;
        this.loopInfo.func = (i) => {
            const distance = this.size / Math.pow(2, i);
            up.setDirection(vecexprs_1.pvec2(0, distance));
            side.setDirection(vecexprs_1.pvec2(distance, 0));
        };
    }
    /** sets the size of the radius */
    setSize(size) {
        this.size = size;
        this.loopInfo.num = Math.ceil(baseLog(2, size));
    }
}
exports.PowerBlurLoop = PowerBlurLoop;
/**
 * fast approximate blur for large blur radius that might look good in some cases
 * @param size the radius of the blur
 */
function pblur(size) {
    return new PowerBlurLoop(size);
}
exports.pblur = pblur;

},{"../mergepass":205,"./blurexpr":162,"./expr":169,"./vecexprs":201}],190:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.random = exports.RandomExpr = void 0;
const glslfunctions_1 = require("../glslfunctions");
const expr_1 = require("./expr");
const normfragcoordexpr_1 = require("./normfragcoordexpr");
/** psuedorandom number expression */
class RandomExpr extends expr_1.ExprFloat {
    constructor(seed = normfragcoordexpr_1.pos()) {
        super(expr_1.tag `random(${seed})`, ["uSeed"]);
        this.seed = seed;
        this.externalFuncs = [glslfunctions_1.glslFuncs.random];
    }
    /** sets the seed (vary this over time to get a moving effect) */
    setSeed(seed) {
        this.setUniform("uSeed", seed);
        this.seed = seed;
    }
}
exports.RandomExpr = RandomExpr;
/**
 * creates expression that evaluates to a pseudorandom number between 0 and 1
 * @param seed vec2 to to seed the random number (defaults to the normalized
 * frag coord)
 */
function random(seed) {
    return new RandomExpr(seed);
}
exports.random = random;

},{"../glslfunctions":203,"./expr":169,"./normfragcoordexpr":185}],191:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolution = exports.ResolutionExpr = void 0;
const expr_1 = require("./expr");
/** resolution expression */
class ResolutionExpr extends expr_1.ExprVec2 {
    constructor() {
        super(expr_1.tag `uResolution`, []);
    }
}
exports.ResolutionExpr = ResolutionExpr;
/** creates an expression that evaluates to a vector representing the resolution */
function resolution() {
    return new ResolutionExpr();
}
exports.resolution = resolution;

},{"./expr":169}],192:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.rgb2hsv = exports.RGBToHSVExpr = void 0;
const expr_1 = require("./expr");
const glslfunctions_1 = require("../glslfunctions");
/** RGB to HSV expression */
class RGBToHSVExpr extends expr_1.ExprVec4 {
    constructor(color) {
        super(expr_1.tag `rgb2hsv(${color})`, ["uRGBCol"]);
        this.color = color;
        this.externalFuncs = [glslfunctions_1.glslFuncs.rgb2hsv];
    }
    /** sets the color to convert */
    setColor(color) {
        this.setUniform("uRGBCol", color);
        this.color = color;
    }
}
exports.RGBToHSVExpr = RGBToHSVExpr;
/**
 * creates an expression that converts a color (with an alpha component) from
 * rgb to hsv
 * @param col the rgba color to convert to hsva
 */
function rgb2hsv(col) {
    return new RGBToHSVExpr(col);
}
exports.rgb2hsv = rgb2hsv;

},{"../glslfunctions":203,"./expr":169}],193:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.rotate = exports.RotateExpr = void 0;
const expr_1 = require("./expr");
const glslfunctions_1 = require("../glslfunctions");
/** rotate expression */
class RotateExpr extends expr_1.ExprVec2 {
    constructor(vec, angle) {
        super(expr_1.tag `rotate2d(${vec}, ${angle})`, ["uVec", "uAngle"]);
        this.vec = vec;
        this.angle = angle;
        this.externalFuncs = [glslfunctions_1.glslFuncs.rotate2d];
    }
    /** set the vector to rotate */
    setVec(vec) {
        this.setUniform("uVec" + this.id, vec);
        this.vec = vec;
    }
    /** set the angle to rotate by */
    setAngle(angle) {
        this.setUniform("uAngle" + this.id, expr_1.n2e(angle));
        this.angle = expr_1.n2e(angle);
    }
}
exports.RotateExpr = RotateExpr;
/**
 * creates an expression that rotates a vector by a given angle
 * @param vec the vector to rotate
 * @param angle radians to rotate vector by
 */
function rotate(vec, angle) {
    return new RotateExpr(vec, expr_1.n2e(angle));
}
exports.rotate = rotate;

},{"../glslfunctions":203,"./expr":169}],194:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.input = exports.SceneSampleExpr = void 0;
const expr_1 = require("./expr");
const normfragcoordexpr_1 = require("./normfragcoordexpr");
/** scene sample expression */
class SceneSampleExpr extends expr_1.ExprVec4 {
    constructor(coord = normfragcoordexpr_1.pos()) {
        super(expr_1.tag `texture2D(uSceneSampler, ${coord})`, ["uCoord"]);
        this.coord = coord;
        this.needs.sceneBuffer = true;
    }
    /** sets coordinate where scene is being sampled from */
    setCoord(coord) {
        this.setUniform("uCoord", coord);
        this.coord = coord;
    }
}
exports.SceneSampleExpr = SceneSampleExpr;
/**
 * creates an expression that samples the original scene
 * @param vec where to sample the original scene texture (defaults to the
 * normalized frag coord, but change this if you want to transform the
 * coordinate space of the original image)
 */
function input(vec) {
    return new SceneSampleExpr(vec);
}
exports.input = input;

},{"./expr":169,"./normfragcoordexpr":185}],195:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setcolor = exports.SetColorExpr = void 0;
const expr_1 = require("./expr");
// TODO the only reason this class exists is because `Operator<ExprVec4>` is not
// actually a subclass of ExprVec4, so it doesn't have `genPrograms`
/** set fragment color expression */
class SetColorExpr extends expr_1.ExprVec4 {
    constructor(vec) {
        super(expr_1.tag `(${vec})`, ["uVal"]);
        this.vec = vec;
    }
    /** sets the value which will be set to the color */
    setVal(vec) {
        this.setUniform("uVal", vec);
        this.vec = vec;
    }
}
exports.SetColorExpr = SetColorExpr;
/**
 * sets the frag color to a new color
 * @param val the color to set the frag color to
 */
function setcolor(val) {
    return new SetColorExpr(val);
}
exports.setcolor = setcolor;

},{"./expr":169}],196:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.simplex = exports.SimplexNoise = void 0;
const glslfunctions_1 = require("../glslfunctions");
const expr_1 = require("./expr");
/** simplex noise expression */
class SimplexNoise extends expr_1.ExprFloat {
    constructor(pos) {
        super(expr_1.tag `simplexnoise(${pos})`, ["uPos"]);
        this.pos = pos;
        this.externalFuncs = [glslfunctions_1.glslFuncs.simplexhelpers, glslfunctions_1.glslFuncs.simplexnoise];
    }
    setPos(pos) {
        this.setUniform("uPos", pos);
        this.pos = pos;
    }
}
exports.SimplexNoise = SimplexNoise;
/**
 * creates a simplex noise expression; values range from -1 to 1
 * @param pos position
 */
function simplex(pos) {
    return new SimplexNoise(pos);
}
exports.simplex = simplex;

},{"../glslfunctions":203,"./expr":169}],197:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.edge = exports.sobel = exports.SobelExpr = void 0;
const glslfunctions_1 = require("../glslfunctions");
const expr_1 = require("./expr");
const brightnessexpr_1 = require("./brightnessexpr");
const opexpr_1 = require("./opexpr");
const getcompexpr_1 = require("./getcompexpr");
const invertexpr_1 = require("./invertexpr");
const monochromeexpr_1 = require("./monochromeexpr");
/** @ignore */
function genSobelSource(samplerNum) {
    return {
        sections: [`sobel${samplerNum === undefined ? "" : "_" + samplerNum}()`],
        values: [],
    };
}
/** sobel expression */
class SobelExpr extends expr_1.ExprVec4 {
    constructor(samplerNum) {
        super(genSobelSource(samplerNum), []);
        if (samplerNum === undefined) {
            this.needs.neighborSample = true;
            this.externalFuncs = [glslfunctions_1.glslFuncs.sobel];
        }
        else {
            this.needs.extraBuffers = new Set([samplerNum]);
            this.externalFuncs = [
                glslfunctions_1.replaceSampler(glslfunctions_1.glslFuncs.sobel, /vec4\ssobel[0-9]+/g, samplerNum),
            ];
        }
    }
}
exports.SobelExpr = SobelExpr;
// TODO test sampler num
function sobel(samplerNum) {
    return new SobelExpr(samplerNum);
}
exports.sobel = sobel;
/**
 * returns an expression highlights edges where they appear
 * @param style `"dark"` for dark edges and `"light"` for light edges, or a
 * custom number (between -1 and 1) for a more gray style of edge
 * @param samplerNum where to sample from
 */
function edge(style = "dark", samplerNum) {
    const mult = style === "dark" ? -1 : style === "light" ? 1 : style;
    return brightnessexpr_1.brightness(opexpr_1.op(getcompexpr_1.getcomp(invertexpr_1.invert(monochromeexpr_1.monochrome(sobel(samplerNum))), "r"), "*", mult));
}
exports.edge = edge;
/*
export function edgecolor(color: Vec4, samplerNum?: number) {
  return cvec4(
    tag`mix(${fcolor()}, ${color}, ${monochrome(sobel(samplerNum))})`
  );
  //getcomp(monochrome(sobel(samplerNum)), "r");
}
*/

},{"../glslfunctions":203,"./brightnessexpr":163,"./expr":169,"./getcompexpr":174,"./invertexpr":178,"./monochromeexpr":180,"./opexpr":187}],198:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.time = exports.TimeExpr = void 0;
const expr_1 = require("./expr");
/** time expression */
class TimeExpr extends expr_1.ExprFloat {
    constructor() {
        super(expr_1.tag `uTime`, []);
        this.needs.timeUniform = true;
    }
}
exports.TimeExpr = TimeExpr;
/** creates a time expression that evaluates to the current time */
function time() {
    return new TimeExpr();
}
exports.time = time;

},{"./expr":169}],199:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.translate = exports.TranslateExpr = void 0;
const expr_1 = require("./expr");
// really just adding two vecs together, but it might be confusing that there's
// rotate but no translate, so this is included. also it could make some
// operations more readable
/** sets the translate expression */
class TranslateExpr extends expr_1.ExprVec2 {
    constructor(vec, pos) {
        super(expr_1.tag `(${vec} + ${pos})`, ["uVec", "uPos"]);
        this.vec = vec;
        this.pos = pos;
    }
    /** sets the starting position */
    setVec(vec) {
        this.setUniform("uVec" + this.id, vec);
        this.vec = vec;
    }
    /** sets how far the vector will be translated */
    setPos(pos) {
        this.setUniform("uPos" + this.id, pos);
        this.pos = pos;
    }
}
exports.TranslateExpr = TranslateExpr;
/** translates the position of a vector by another vector */
function translate(vec, pos) {
    return new TranslateExpr(vec, pos);
}
exports.translate = translate;

},{"./expr":169}],200:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.truedepth = exports.TrueDepthExpr = void 0;
const expr_1 = require("./expr");
const glslfunctions_1 = require("../glslfunctions");
/** true depth expression */
class TrueDepthExpr extends expr_1.ExprFloat {
    constructor(depth) {
        super(expr_1.tag `truedepth(${depth})`, ["uDist"]);
        this.depth = depth;
        this.externalFuncs = [glslfunctions_1.glslFuncs.truedepth];
    }
    /** sets the distance to convert to the true depth */
    setDist(depth) {
        this.setUniform("uDist", depth);
        this.depth = expr_1.n2e(depth);
    }
}
exports.TrueDepthExpr = TrueDepthExpr;
/** calculates the linear depth from inverse depth value `1 / distance` */
function truedepth(depth) {
    return new TrueDepthExpr(expr_1.n2e(depth));
}
exports.truedepth = truedepth;

},{"../glslfunctions":203,"./expr":169}],201:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pvec4 = exports.pvec3 = exports.pvec2 = exports.vec4 = exports.vec3 = exports.vec2 = void 0;
const expr_1 = require("./expr");
/** @ignore */
function vecSourceList(...components) {
    const sections = ["vec" + components.length + "("];
    for (let i = 0; i < components.length - 1; i++) {
        sections.push(", ");
    }
    const defaultNames = [];
    for (let i = 0; i < components.length; i++) {
        defaultNames.push("uComp" + i);
    }
    sections.push(")");
    return [{ sections: sections, values: components }, defaultNames];
}
// expression vector shorthands
/** creates a basic vec2 expression */
function vec2(comp1, comp2) {
    return new expr_1.BasicVec2(...vecSourceList(...[comp1, comp2].map((c) => expr_1.n2e(c))));
}
exports.vec2 = vec2;
/** creates a basic vec3 expression */
function vec3(comp1, comp2, comp3) {
    return new expr_1.BasicVec3(...vecSourceList(...[comp1, comp2, comp3].map((c) => expr_1.n2e(c))));
}
exports.vec3 = vec3;
/** creates a basic vec4 expression */
function vec4(comp1, comp2, comp3, comp4) {
    return new expr_1.BasicVec4(...vecSourceList(...[comp1, comp2, comp3, comp4].map((c) => expr_1.n2e(c))));
}
exports.vec4 = vec4;
// primitive vector shorthands
/** creates a primitive vec2 expression */
function pvec2(comp1, comp2) {
    return new expr_1.PrimitiveVec2([comp1, comp2]);
}
exports.pvec2 = pvec2;
/** creates a primitive vec3 expression */
function pvec3(comp1, comp2, comp3) {
    return new expr_1.PrimitiveVec3([comp1, comp2, comp3]);
}
exports.pvec3 = pvec3;
/** creates a primitive vec4 expression */
function pvec4(comp1, comp2, comp3, comp4) {
    return new expr_1.PrimitiveVec4([comp1, comp2, comp3, comp4]);
}
exports.pvec4 = pvec4;

},{"./expr":169}],202:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

},{}],203:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.replaceSampler = exports.captureAndAppend = exports.glslFuncs = void 0;
// adapted from The Book of Shaders
/** glsl source code for external functions */
exports.glslFuncs = {
    // TODO replace with a better one
    // adapted from The Book of Shaders
    random: `float random(vec2 st) {
  return fract(sin(dot(st.xy / 99., vec2(12.9898, 78.233))) * 43758.5453123);
}`,
    // adapted from The Book of Shaders
    random2: `vec2 random2(vec2 st) {
  st = vec2(dot(st,vec2(127.1,311.7)), dot(st,vec2(269.5,183.3)));
  return -1.0 + 2.0*fract(sin(st)*43758.5453123);
}`,
    rotate2d: `vec2 rotate2d(vec2 v, float angle) {
  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle)) * v;
}`,
    // adapted from The Book of Shaders
    hsv2rgb: `vec4 hsv2rgb(vec4 co){
  vec3 c = co.xyz;
  vec3 rgb = clamp(abs(mod(
    c.x * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, 0.0, 1.0);
  rgb = rgb * rgb * (3.0 - 2.0 * rgb);
  vec3 hsv = c.z * mix(vec3(1.0), rgb, c.y);
  return vec4(hsv.x, hsv.y, hsv.z, co.a);
}`,
    // adapted from The Book of Shaders
    rgb2hsv: `vec4 rgb2hsv(vec4 co){
  vec3 c = co.rgb;
  vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
  vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
  vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
  float d = q.x - min(q.w, q.y);
  float e = 1.0e-10;
  return vec4(abs(q.z + (q.w - q.y) / (6.0 * d + e)),
              d / (q.x + e),
              q.x, co.a);
}`,
    // all gaussian blurs adapted from:
    // https://github.com/Jam3/glsl-fast-gaussian-blur/blob/master/5.glsl
    gauss5: `vec4 gauss5(vec2 dir) {
  vec2 uv = gl_FragCoord.xy / uResolution;
  vec4 col = vec4(0.0);
  vec2 off1 = vec2(1.3333333333333333) * dir;
  col += texture2D(uSampler, uv) * 0.29411764705882354;
  col += texture2D(uSampler, uv + (off1 / uResolution)) * 0.35294117647058826;
  col += texture2D(uSampler, uv - (off1 / uResolution)) * 0.35294117647058826;
  return col;
}`,
    gauss9: `vec4 gauss9(vec2 dir) {
  vec2 uv = gl_FragCoord.xy / uResolution;
  vec4 col = vec4(0.0);
  vec2 off1 = vec2(1.3846153846) * dir;
  vec2 off2 = vec2(3.2307692308) * dir;
  col += texture2D(uSampler, uv) * 0.2270270270;
  col += texture2D(uSampler, uv + (off1 / uResolution)) * 0.3162162162;
  col += texture2D(uSampler, uv - (off1 / uResolution)) * 0.3162162162;
  col += texture2D(uSampler, uv + (off2 / uResolution)) * 0.0702702703;
  col += texture2D(uSampler, uv - (off2 / uResolution)) * 0.0702702703;
  return col;
}`,
    gauss13: `vec4 gauss13(vec2 dir) {
  vec2 uv = gl_FragCoord.xy / uResolution;
  vec4 col = vec4(0.0);
  vec2 off1 = vec2(1.411764705882353) * dir;
  vec2 off2 = vec2(3.2941176470588234) * dir;
  vec2 off3 = vec2(5.176470588235294) * dir;
  col += texture2D(uSampler, uv) * 0.1964825501511404;
  col += texture2D(uSampler, uv + (off1 / uResolution)) * 0.2969069646728344;
  col += texture2D(uSampler, uv - (off1 / uResolution)) * 0.2969069646728344;
  col += texture2D(uSampler, uv + (off2 / uResolution)) * 0.09447039785044732;
  col += texture2D(uSampler, uv - (off2 / uResolution)) * 0.09447039785044732;
  col += texture2D(uSampler, uv + (off3 / uResolution)) * 0.010381362401148057;
  col += texture2D(uSampler, uv - (off3 / uResolution)) * 0.010381362401148057;
  return col;
}`,
    contrast: `vec4 contrast(float val, vec4 col) {
  col.rgb /= col.a;
  col.rgb = ((col.rgb - 0.5) * val) + 0.5;
  col.rgb *= col.a;
  return col;
}`,
    brightness: `vec4 brightness(float val, vec4 col) {
  col.rgb /= col.a;
  col.rgb += val;
  col.rgb *= col.a;
  return col;
}`,
    // adapted from https://www.shadertoy.com/view/ls3GWS which was adapted from
    // http://www.geeks3d.com/20110405/fxaa-fast-approximate-anti-aliasing-demo-glsl-opengl-test-radeon-geforce/3/
    // original algorithm created by Timothy Lottes
    fxaa: `vec4 fxaa() {
  float FXAA_SPAN_MAX = 8.0;
  float FXAA_REDUCE_MUL = 1.0 / FXAA_SPAN_MAX;
  float FXAA_REDUCE_MIN = 1.0 / 128.0;
  float FXAA_SUBPIX_SHIFT = 1.0 / 4.0;

  vec2 rcpFrame = 1. / uResolution.xy;
  vec2 t_uv = gl_FragCoord.xy / uResolution.xy; 
  vec4 uv = vec4(t_uv, t_uv - (rcpFrame * (0.5 + FXAA_SUBPIX_SHIFT)));

  vec3 rgbNW = texture2D(uSampler, uv.zw).xyz;
  vec3 rgbNE = texture2D(uSampler, uv.zw + vec2(1,0) * rcpFrame.xy).xyz;
  vec3 rgbSW = texture2D(uSampler, uv.zw + vec2(0,1) * rcpFrame.xy).xyz;
  vec3 rgbSE = texture2D(uSampler, uv.zw + vec2(1,1) * rcpFrame.xy).xyz;
  vec4 rgbMfull = texture2D(uSampler, uv.xy);
  vec3 rgbM = rgbMfull.xyz;
  float alpha = rgbMfull.a;

  vec3 luma = vec3(0.299, 0.587, 0.114);
  float lumaNW = dot(rgbNW, luma);
  float lumaNE = dot(rgbNE, luma);
  float lumaSW = dot(rgbSW, luma);
  float lumaSE = dot(rgbSE, luma);
  float lumaM = dot(rgbM,  luma);

  float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
  float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

  vec2 dir;
  dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
  dir.y = ((lumaNW + lumaSW) - (lumaNE + lumaSE));

  float dirReduce = max(
    (lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);
  float rcpDirMin = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);

  dir = min(vec2(FXAA_SPAN_MAX,  FXAA_SPAN_MAX),
    max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
    dir * rcpDirMin)) * rcpFrame.xy;

  vec3 rgbA = (1.0 / 2.0) * (
    texture2D(uSampler, uv.xy + dir * (1.0 / 3.0 - 0.5)).xyz +
    texture2D(uSampler, uv.xy + dir * (2.0 / 3.0 - 0.5)).xyz);
  vec3 rgbB = rgbA * (1.0 / 2.0) + (1.0 / 4.0) * (
    texture2D(uSampler, uv.xy + dir * (0.0 / 3.0 - 0.5)).xyz +
    texture2D(uSampler, uv.xy + dir * (3.0 / 3.0 - 0.5)).xyz);

  float lumaB = dot(rgbB, luma);

  if(lumaB < lumaMin || lumaB > lumaMax) {
    return vec4(rgbA.r, rgbA.g, rgbA.b, alpha);
  }

  return vec4(rgbB.r, rgbB.g, rgbB.b, alpha);
}`,
    // normal curve is a = 0 and b = 1
    gaussian: `float gaussian(float x, float a, float b) {
  float e = 2.71828;
  return pow(e, -pow(x - a, 2.) / b);
}`,
    // for calculating the true distance from 0 to 1 depth buffer
    // the small delta is to prevent division by zero, which is undefined behavior
    truedepth: `float truedepth(float i) {
  i = max(i, 0.00000001);
  return (1. - i) / i;
}`,
    // based off of https://fabiensanglard.net/lightScattering/index.php
    godrays: `vec4 godrays(
  vec4 col,
  float exposure,
  float decay,
  float density,
  float weight,
  vec2 lightPos,
  float threshold,
  vec4 newColor
) {
  vec2 texCoord = gl_FragCoord.xy / uResolution;
  vec2 deltaTexCoord = texCoord - lightPos;

  const int NUM_SAMPLES = 100;
  deltaTexCoord *= 1. / float(NUM_SAMPLES) * density;
  float illuminationDecay = 1.0;

  for (int i=0; i < NUM_SAMPLES; i++) {
    texCoord -= deltaTexCoord;
    vec4 sample = texture2D(uSampler, texCoord);
    //uncomment sample = depth2occlusion(sample, newColor, threshold);
    sample *= illuminationDecay * weight;
    col += sample;
    illuminationDecay *= decay;
  }
  return col * exposure;
}`,
    depth2occlusion: `vec4 depth2occlusion(vec4 depthCol, vec4 newCol, float threshold) {
  float red = 1. - ceil(depthCol.r - threshold);
  return vec4(newCol.rgb * red, 1.0);
}`,
    // adapted from The Book of Shaders, which was adapted from Inigo Quilez
    // from this example: https://www.shadertoy.com/view/XdXGW8
    gradientnoise: `float gradientnoise(vec2 st) {
  vec2 i = floor(st);
  vec2 f = fract(st);

  vec2 u = f * f * (3.0 - 2.0 * f);

  return mix(mix(dot(random2(i + vec2(0.0,0.0)), f - vec2(0.0, 0.0)),
                     dot(random2(i + vec2(1.0,0.0)), f - vec2(1.0, 0.0)), u.x),
             mix(dot(random2(i + vec2(0.0,1.0)), f - vec2(0.0, 1.0)),
                 dot(random2(i + vec2(1.0,1.0)), f - vec2(1.0, 1.0)), u.x), u.y);
}`,
    // adapted from The Book of Shaders
    // https://thebookofshaders.com/edit.php#11/2d-snoise-clear.frag
    // this was adapted from this fast implementation
    // https://github.com/ashima/webgl-noise
    // simplex noise invented by Ken Perlin
    simplexnoise: `float simplexnoise(vec2 v) {
  // Precompute values for skewed triangular grid
  const vec4 C = vec4(0.211324865405187,
                      // (3.0-sqrt(3.0))/6.0
                      0.366025403784439,
                      // 0.5*(sqrt(3.0)-1.0)
                      -0.577350269189626,
                      // -1.0 + 2.0 * C.x
                      0.024390243902439);
                      // 1.0 / 41.0

  // First corner (x0)
  vec2 i  = floor(v + dot(v, C.yy));
  vec2 x0 = v - i + dot(i, C.xx);

  // Other two corners (x1, x2)
  vec2 i1 = vec2(0.0);
  i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);
  vec2 x1 = x0.xy + C.xx - i1;
  vec2 x2 = x0.xy + C.zz;

  // Do some permutations to avoid
  // truncation effects in permutation
  i = mod289_2(i);
  vec3 p = permute(
          permute( i.y + vec3(0.0, i1.y, 1.0))
              + i.x + vec3(0.0, i1.x, 1.0 ));

  vec3 m = max(0.5 - vec3(
                      dot(x0,x0),
                      dot(x1,x1),
                      dot(x2,x2)
                      ), 0.0);

  m = m*m ;
  m = m*m ;

  // Gradients:
  //  41 pts uniformly over a line, mapped onto a diamond
  //  The ring size 17*17 = 289 is close to a multiple
  //      of 41 (41*7 = 287)

  vec3 x = 2.0 * fract(p * C.www) - 1.0;
  vec3 h = abs(x) - 0.5;
  vec3 ox = floor(x + 0.5);
  vec3 a0 = x - ox;

  // Normalise gradients implicitly by scaling m
  // Approximation of: m *= inversesqrt(a0*a0 + h*h);
  m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);

  // Compute final noise value at P
  vec3 g = vec3(0.0);
  g.x  = a0.x  * x0.x  + h.x  * x0.y;
  g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y);
  return 130.0 * dot(m, g);
}`,
    // only useful for simplex noise
    simplexhelpers: `vec3 mod289_3(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec2 mod289_2(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec3 permute(vec3 x) { return mod289_3(((x*34.0)+1.0)*x); }`,
    // sobel adapted from https://gist.github.com/Hebali/6ebfc66106459aacee6a9fac029d0115
    sobel: `vec4 sobel() {
  vec2 uv = gl_FragCoord.xy / uResolution;
  vec4 k[8];

  float w = 1. / uResolution.x;
  float h = 1. / uResolution.y;

  k[0] = texture2D(uSampler, uv + vec2(-w, -h));
  k[1] = texture2D(uSampler, uv + vec2(0., -h));
  k[2] = texture2D(uSampler, uv + vec2(w, -h));
  k[3] = texture2D(uSampler, uv + vec2(-w, 0.));

  k[4] = texture2D(uSampler, uv + vec2(w, 0.));
  k[5] = texture2D(uSampler, uv + vec2(-w, h));
  k[6] = texture2D(uSampler, uv + vec2(0., h));
  k[7] = texture2D(uSampler, uv + vec2(w, h));

  vec4 edge_h = k[2] + (2. * k[4]) + k[7] - (k[0] + (2. * k[3]) + k[5]);
  vec4 edge_v = k[0] + (2. * k[1]) + k[2] - (k[5] + (2. * k[6]) + k[7]);
  vec4 sobel = sqrt(edge_h * edge_h + edge_v * edge_v);

  return vec4(1. - sobel.rgb, 1.);
}`,
    // inlining a similar function will substitute in the full expression for
    // every component, so it's more efficient to have a function
    monochrome: `vec4 monochrome(vec4 col) {
  return vec4(vec3((col.r + col.g + col.b) / 3.), col.a);
}`,
    invert: `vec4 invert(vec4 col) {
  return vec4(vec3(1., 1., 1.) - col.rgb, col.a);
}`,
};
/** @ignore */
function captureAndAppend(str, reg, suffix) {
    const matches = str.match(reg);
    if (matches === null)
        throw new Error("no match in the given string");
    return str.replace(reg, matches[0] + suffix);
}
exports.captureAndAppend = captureAndAppend;
/** @ignore */
function replaceSampler(fullString, funcRegExp, samplerNum, extra) {
    return captureAndAppend(fullString.replace(/uSampler/g, "uBufferSampler" + samplerNum), funcRegExp, "_" + samplerNum + (extra === undefined ? "" : extra));
}
exports.replaceSampler = replaceSampler;

},{}],204:[function(require,module,exports){
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
__exportStar(require("./mergepass"), exports);
__exportStar(require("./exprtypes"), exports);
__exportStar(require("./glslfunctions"), exports);
__exportStar(require("./exprs/blurexpr"), exports);
__exportStar(require("./exprs/fragcolorexpr"), exports);
__exportStar(require("./exprs/vecexprs"), exports);
__exportStar(require("./exprs/opexpr"), exports);
__exportStar(require("./exprs/powerblur"), exports);
__exportStar(require("./exprs/blur2dloop"), exports);
__exportStar(require("./exprs/lenexpr"), exports);
__exportStar(require("./exprs/normexpr"), exports);
__exportStar(require("./exprs/fragcoordexpr"), exports);
__exportStar(require("./exprs/normfragcoordexpr"), exports);
__exportStar(require("./exprs/normcenterfragcoordexpr"), exports);
__exportStar(require("./exprs/scenesampleexpr"), exports);
__exportStar(require("./exprs/brightnessexpr"), exports);
__exportStar(require("./exprs/setcolorexpr"), exports);
__exportStar(require("./exprs/contrastexpr"), exports);
__exportStar(require("./exprs/grainexpr"), exports);
__exportStar(require("./exprs/getcompexpr"), exports);
__exportStar(require("./exprs/changecompexpr"), exports);
__exportStar(require("./exprs/rgbtohsvexpr"), exports);
__exportStar(require("./exprs/hsvtorgbexpr"), exports);
__exportStar(require("./exprs/timeexpr"), exports);
__exportStar(require("./exprs/arity1"), exports);
__exportStar(require("./exprs/arity2"), exports);
__exportStar(require("./exprs/fxaaexpr"), exports);
__exportStar(require("./exprs/channelsampleexpr"), exports);
__exportStar(require("./exprs/dofloop"), exports);
__exportStar(require("./exprs/truedepthexpr"), exports);
__exportStar(require("./exprs/godraysexpr"), exports);
__exportStar(require("./exprs/depthtoocclusionexpr"), exports);
__exportStar(require("./exprs/resolutionexpr"), exports);
__exportStar(require("./exprs/mouseexpr"), exports);
__exportStar(require("./exprs/rotateexpr"), exports);
__exportStar(require("./exprs/translateexpr"), exports);
__exportStar(require("./exprs/normmouseexpr"), exports);
__exportStar(require("./exprs/perlinexpr"), exports);
__exportStar(require("./exprs/simplexexpr"), exports);
__exportStar(require("./exprs/motionblurloop"), exports);
__exportStar(require("./exprs/randomexpr"), exports);
__exportStar(require("./exprs/sobelexpr"), exports);
__exportStar(require("./exprs/bloomloop"), exports);
__exportStar(require("./exprs/monochromeexpr"), exports);
__exportStar(require("./exprs/invertexpr"), exports);
// TODO move this out of expressions
__exportStar(require("./exprs/expr"), exports);

},{"./exprs/arity1":158,"./exprs/arity2":159,"./exprs/bloomloop":160,"./exprs/blur2dloop":161,"./exprs/blurexpr":162,"./exprs/brightnessexpr":163,"./exprs/changecompexpr":164,"./exprs/channelsampleexpr":165,"./exprs/contrastexpr":166,"./exprs/depthtoocclusionexpr":167,"./exprs/dofloop":168,"./exprs/expr":169,"./exprs/fragcolorexpr":170,"./exprs/fragcoordexpr":171,"./exprs/fxaaexpr":172,"./exprs/getcompexpr":174,"./exprs/godraysexpr":175,"./exprs/grainexpr":176,"./exprs/hsvtorgbexpr":177,"./exprs/invertexpr":178,"./exprs/lenexpr":179,"./exprs/monochromeexpr":180,"./exprs/motionblurloop":181,"./exprs/mouseexpr":182,"./exprs/normcenterfragcoordexpr":183,"./exprs/normexpr":184,"./exprs/normfragcoordexpr":185,"./exprs/normmouseexpr":186,"./exprs/opexpr":187,"./exprs/perlinexpr":188,"./exprs/powerblur":189,"./exprs/randomexpr":190,"./exprs/resolutionexpr":191,"./exprs/rgbtohsvexpr":192,"./exprs/rotateexpr":193,"./exprs/scenesampleexpr":194,"./exprs/setcolorexpr":195,"./exprs/simplexexpr":196,"./exprs/sobelexpr":197,"./exprs/timeexpr":198,"./exprs/translateexpr":199,"./exprs/truedepthexpr":200,"./exprs/vecexprs":201,"./exprtypes":202,"./glslfunctions":203,"./mergepass":205}],205:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sendTexture = exports.makeTexture = exports.Merger = exports.loop = exports.EffectLoop = exports.EffectDictionary = void 0;
const codebuilder_1 = require("./codebuilder");
const webglprogramloop_1 = require("./webglprogramloop");
const _1 = require(".");
class EffectDictionary {
    constructor(effectMap) {
        this.effectMap = effectMap;
    }
    toProgramMap(gl, vShader, uniformLocs, fShaders) {
        const programMap = {};
        let needs = {
            neighborSample: false,
            centerSample: false,
            sceneBuffer: false,
            timeUniform: false,
            mouseUniform: false,
            extraBuffers: new Set(),
        };
        for (const name in this.effectMap) {
            const effects = this.effectMap[name];
            // wrap the given list of effects as a loop if need be
            const effectLoop = new EffectLoop(effects, { num: 1 });
            if (effectLoop.effects.length === 0) {
                throw new Error("list of effects was empty");
            }
            const programLoop = effectLoop.genPrograms(gl, vShader, uniformLocs, fShaders);
            // walk the tree to the final program
            let atBottom = false;
            let currProgramLoop = programLoop;
            while (!atBottom) {
                if (currProgramLoop.programElement instanceof webglprogramloop_1.WebGLProgramLeaf) {
                    // we traveled right and hit a program, so it must be the last
                    currProgramLoop.last = true;
                    atBottom = true;
                }
                else {
                    // set the current program loop to the last in the list
                    currProgramLoop =
                        currProgramLoop.programElement[currProgramLoop.programElement.length - 1];
                }
            }
            needs = webglprogramloop_1.updateNeeds(needs, programLoop.getTotalNeeds());
            programMap[name] = programLoop;
        }
        return { programMap, needs };
    }
}
exports.EffectDictionary = EffectDictionary;
/** effect loop, which can loop over other effects or effect loops */
class EffectLoop {
    constructor(effects, loopInfo) {
        this.effects = effects;
        this.loopInfo = loopInfo;
    }
    /** @ignore */
    getSampleNum(mult = 1, sliceStart = 0, sliceEnd = this.effects.length) {
        mult *= this.loopInfo.num;
        let acc = 0;
        const sliced = this.effects.slice(sliceStart, sliceEnd);
        for (const e of sliced) {
            acc += e.getSampleNum(mult);
        }
        return acc;
    }
    /**
     * @ignore
     * places effects into loops broken up by sampling effects
     */
    regroup() {
        let sampleCount = 0;
        /** number of samples in all previous */
        let prevSampleCount = 0;
        let prevEffects = [];
        const regroupedEffects = [];
        let prevTarget;
        let currTarget;
        let mustBreakCounter = 0;
        const breakOff = () => {
            mustBreakCounter--;
            if (prevEffects.length > 0) {
                // break off all previous effects into their own loop
                if (prevEffects.length === 1) {
                    // this is to prevent wrapping in another effect loop
                    regroupedEffects.push(prevEffects[0]);
                }
                else {
                    regroupedEffects.push(new EffectLoop(prevEffects, { num: 1 }));
                }
                sampleCount -= prevSampleCount;
                prevEffects = [];
            }
        };
        for (const e of this.effects) {
            const sampleNum = e.getSampleNum();
            prevSampleCount = sampleCount;
            sampleCount += sampleNum;
            if (e instanceof EffectLoop) {
                currTarget = e.loopInfo.target;
                if (e.hasTargetSwitch()) {
                    mustBreakCounter = 2;
                }
            }
            else {
                // if it's not a loop it's assumed the target is that of outer loop
                currTarget = this.loopInfo.target;
            }
            if (sampleCount > 0 ||
                currTarget !== prevTarget ||
                mustBreakCounter > 0) {
                breakOff();
            }
            prevEffects.push(e);
            prevTarget = currTarget;
        }
        // push on all the straggling effects after the grouping is done
        breakOff();
        return regroupedEffects;
    }
    genPrograms(gl, vShader, uniformLocs, shaders) {
        // validate
        const fullSampleNum = this.getSampleNum() / this.loopInfo.num;
        const firstSampleNum = this.getSampleNum(undefined, 0, 1) / this.loopInfo.num;
        const restSampleNum = this.getSampleNum(undefined, 1) / this.loopInfo.num;
        if (!this.hasTargetSwitch() &&
            (fullSampleNum === 0 || (firstSampleNum === 1 && restSampleNum === 0))) {
            const codeBuilder = new codebuilder_1.CodeBuilder(this);
            const program = codeBuilder.compileProgram(gl, vShader, uniformLocs, shaders);
            return program;
        }
        // TODO get rid of this
        /*
        console.log("!has target switch", !this.hasTargetSwitch());
        console.log(
          "samples",
          fullSampleNum === 0 || (firstSampleNum === 1 && restSampleNum === 0)
        );
        console.log("effects", this.effects);
        */
        //console.log("not valid");
        // otherwise, regroup and try again on regrouped loops
        this.effects = this.regroup();
        return new webglprogramloop_1.WebGLProgramLoop(this.effects.map((e) => e.genPrograms(gl, vShader, uniformLocs, shaders)), this.loopInfo, gl);
    }
    /**
     * changes the render target of an effect loop (-1 targest the scene texture;
     * this is used internally)
     */
    target(num) {
        this.loopInfo.target = num;
        return this;
    }
    /** @ignore */
    hasTargetSwitch() {
        for (const e of this.effects) {
            if (e instanceof EffectLoop) {
                if (e.loopInfo.target !== this.loopInfo.target || e.hasTargetSwitch())
                    return true;
            }
        }
        return false;
    }
}
exports.EffectLoop = EffectLoop;
/** creates an effect loop */
function loop(effects, rep = 1) {
    return new EffectLoop(effects, { num: rep });
}
exports.loop = loop;
/** @ignore */
const V_SOURCE = `attribute vec2 aPosition;
void main() {
  gl_Position = vec4(aPosition, 0.0, 1.0);
}\n`;
/** class that can merge effects */
class Merger {
    /**
     * constructs the object that runs the effects
     * @param effects list of effects that define the final effect
     * @param source the source image or texture
     * @param gl the target rendering context
     * @param options additional options for the texture
     */
    constructor(effects, source, gl, options) {
        this.uniformLocs = {};
        /** additional channels */
        this.channels = [];
        this.fShaders = [];
        this.textureMode = source instanceof WebGLTexture;
        // set channels if provided with channels
        if ((options === null || options === void 0 ? void 0 : options.channels) !== undefined)
            this.channels = options === null || options === void 0 ? void 0 : options.channels;
        if (!(effects instanceof EffectDictionary)) {
            effects = new EffectDictionary({ default: effects });
        }
        // add the copy to scene texture if in texture mode
        if (this.textureMode) {
            // TODO get rid of this
            console.log("we are in texture mode!");
            // TODO see if it needs scene texture before doing this
            // can we even do this? maybe just always make the scene texture
            for (const name in effects.effectMap) {
                const list = effects.effectMap[name];
                list.unshift(loop([_1.input()]).target(-1));
            }
        }
        this.source = source;
        this.gl = gl;
        this.options = options;
        // set the viewport
        this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);
        // set up the vertex buffer
        const vertexBuffer = this.gl.createBuffer();
        if (vertexBuffer === null) {
            throw new Error("problem creating vertex buffer");
        }
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, vertexBuffer);
        const vertexArray = [-1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, 1];
        const triangles = new Float32Array(vertexArray);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, triangles, this.gl.STATIC_DRAW);
        // save the vertex buffer reference just so we can delete it later
        this.vertexBuffer = vertexBuffer;
        // compile the simple vertex shader (2 big triangles)
        const vShader = this.gl.createShader(this.gl.VERTEX_SHADER);
        if (vShader === null) {
            throw new Error("problem creating the vertex shader");
        }
        // save the vertex shader reference just so we can delete it later
        this.vShader = vShader;
        this.gl.shaderSource(vShader, V_SOURCE);
        this.gl.compileShader(vShader);
        // make textures
        this.tex = {
            // make the front texture the source if we're given a texture instead of
            // an image
            back: {
                name: "orig_back",
                tex: source instanceof WebGLTexture
                    ? source
                    : makeTexture(this.gl, this.options),
            },
            front: { name: "orig_front", tex: makeTexture(this.gl, this.options) },
            scene: undefined,
            bufTextures: [],
        };
        // create the framebuffer
        const framebuffer = gl.createFramebuffer();
        if (framebuffer === null) {
            throw new Error("problem creating the framebuffer");
        }
        this.framebuffer = framebuffer;
        const { programMap, needs } = effects.toProgramMap(this.gl, this.vShader, this.uniformLocs, this.fShaders);
        this.programMap = programMap;
        if (needs.sceneBuffer || this.textureMode) {
            // we always create a scene texture if we're in texture mode
            this.tex.scene = {
                name: "scene",
                tex: makeTexture(this.gl, this.options),
            };
        }
        if (programMap["default"] === undefined) {
            throw new Error("no default program");
        }
        this.programLoop = programMap["default"];
        // create x amount of empty textures based on buffers needed
        const channelsNeeded = Math.max(...needs.extraBuffers) + 1;
        const channelsSupplied = this.channels.length;
        if (channelsNeeded > channelsSupplied) {
            throw new Error("not enough channels supplied for this effect");
        }
        for (let i = 0; i < this.channels.length; i++) {
            const texOrImage = this.channels[i];
            if (!(texOrImage instanceof WebGLTexture)) {
                // create a new texture; we will update this with the image source every draw
                const texture = makeTexture(this.gl, this.options);
                this.tex.bufTextures.push({ name: "tex_channel_" + i, tex: texture });
            }
            else {
                // this is already a texture; the user will handle updating this
                this.tex.bufTextures.push({
                    name: "img_channel_" + i,
                    tex: texOrImage,
                });
            }
        }
        console.log(this.programMap);
    }
    /**
     * use the source and channels to draw effect to target context; mouse
     * position (as with all positions) are stored from the bottom left corner as
     * this is how texture data is stored
     * @param timeVal number to set the time uniform to (supply this if you plan to
     * use [[time]])
     * @param mouseX the x position of the mouse (supply this if you plan to use
     * [[mouse]] or [[nmouse]])
     * @param mouseY the y position of the mouse (supply this if you plan to use
     * [[mouse]] or [[nmouse]])
     */
    draw(timeVal = 0, mouseX = 0, mouseY = 0) {
        // TODO double check if this is neccessary
        //const originalFront = this.tex.front;
        //const originalBack = this.tex.back;
        this.gl.activeTexture(this.gl.TEXTURE0);
        this.gl.bindTexture(this.gl.TEXTURE_2D, this.tex.back.tex);
        sendTexture(this.gl, this.source);
        // TODO see if we need to unbind
        this.gl.bindTexture(this.gl.TEXTURE_2D, null);
        // bind the scene buffer
        if (this.programLoop.getTotalNeeds().sceneBuffer &&
            this.tex.scene !== undefined) {
            this.gl.activeTexture(this.gl.TEXTURE1);
            this.gl.bindTexture(this.gl.TEXTURE_2D, this.tex.scene.tex);
            sendTexture(this.gl, this.source);
            // TODO see if we need to unbind
            this.gl.bindTexture(this.gl.TEXTURE_2D, null);
        }
        // bind the additional buffers
        let counter = 0;
        for (const b of this.channels) {
            // TODO check for texture limit
            this.gl.activeTexture(this.gl.TEXTURE2 + counter);
            this.gl.bindTexture(this.gl.TEXTURE_2D, this.tex.bufTextures[counter].tex);
            sendTexture(this.gl, b);
            // TODO see if we need to unbind (this gets rid of the error)
            this.gl.bindTexture(this.gl.TEXTURE_2D, null);
            counter++;
        }
        this.programLoop.run(this.gl, this.tex, this.framebuffer, this.uniformLocs, this.programLoop.last, { timeVal: timeVal, mouseX: mouseX, mouseY: mouseY });
        // make sure front and back are in same order
        //this.tex.front = originalFront;
        //this.tex.back = originalBack;
    }
    /**
     * delete all resources created by construction of this [[Merger]]; use right before
     * intentionally losing a reference to this merger object. this is useful if you want
     * to construct another [[Merger]] to use new effects
     */
    delete() {
        // call bind with null on all textures
        for (let i = 0; i < 2 + this.tex.bufTextures.length; i++) {
            // this gets rid of final texture, scene texture and channels
            this.gl.activeTexture(this.gl.TEXTURE0 + i);
            this.gl.bindTexture(this.gl.TEXTURE_2D, null);
        }
        // call bind with null on all vertex buffers (just 1)
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, null);
        // call bind with null on all frame buffers (just 1)
        // (this might be redundant because this happens at end of draw call)
        this.gl.bindFramebuffer(this.gl.FRAMEBUFFER, null);
        // delete all programs
        this.programLoop.delete(this.gl);
        // delete all textures
        this.gl.deleteTexture(this.tex.front.tex);
        this.gl.deleteTexture(this.tex.back.tex);
        for (const c of this.tex.bufTextures) {
            this.gl.deleteTexture(c.tex);
        }
        // delete all vertex buffers (just 1)
        this.gl.deleteBuffer(this.vertexBuffer);
        // delete all frame buffers (just 1)
        this.gl.deleteFramebuffer(this.framebuffer);
        // delete all vertex shaders (just 1)
        this.gl.deleteShader(this.vShader);
        // delete all fragment shaders
        for (const f of this.fShaders) {
            this.gl.deleteShader(f);
        }
    }
    /**
     * changes the current program loop
     * @param str key in the program map
     */
    changeProgram(str) {
        if (this.programMap[str] === undefined) {
            throw new Error(`program "${str}" doesn't exist on this merger`);
        }
        this.programLoop = this.programMap[str];
    }
}
exports.Merger = Merger;
/** creates a texture given a context and options */
function makeTexture(gl, options) {
    const texture = gl.createTexture();
    if (texture === null) {
        throw new Error("problem creating texture");
    }
    // flip the order of the pixels, or else it displays upside down
    gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
    // bind the texture after creating it
    gl.bindTexture(gl.TEXTURE_2D, texture);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.drawingBufferWidth, gl.drawingBufferHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
    const filterMode = (f) => f === undefined || f === "linear" ? gl.LINEAR : gl.NEAREST;
    // how to map texture element
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filterMode(options === null || options === void 0 ? void 0 : options.minFilterMode));
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filterMode(options === null || options === void 0 ? void 0 : options.maxFilterMode));
    if ((options === null || options === void 0 ? void 0 : options.edgeMode) !== "wrap") {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
    }
    return texture;
}
exports.makeTexture = makeTexture;
/** copies onto texture */
function sendTexture(gl, src) {
    // if you are using textures instead of images, the user is responsible for
    // updating that texture, so just return
    if (src instanceof WebGLTexture || src === null)
        return;
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, src);
}
exports.sendTexture = sendTexture;

},{".":204,"./codebuilder":157,"./webglprogramloop":206}],206:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WebGLProgramLoop = exports.WebGLProgramLeaf = exports.updateNeeds = void 0;
let textureDebug = false;
// update me on change to needs
function updateNeeds(acc, curr) {
    return {
        neighborSample: acc.neighborSample || curr.neighborSample,
        centerSample: acc.centerSample || curr.centerSample,
        sceneBuffer: acc.sceneBuffer || curr.sceneBuffer,
        timeUniform: acc.timeUniform || curr.timeUniform,
        mouseUniform: acc.mouseUniform || curr.mouseUniform,
        extraBuffers: new Set([...acc.extraBuffers, ...curr.extraBuffers]),
    };
}
exports.updateNeeds = updateNeeds;
class WebGLProgramLeaf {
    constructor(program, totalNeeds, effects) {
        this.program = program;
        this.totalNeeds = totalNeeds;
        this.effects = effects;
    }
}
exports.WebGLProgramLeaf = WebGLProgramLeaf;
/** recursive data structure of compiled programs */
class WebGLProgramLoop {
    constructor(programElement, loopInfo, gl) {
        //effects: Expr[];
        this.last = false;
        this.programElement = programElement;
        this.loopInfo = loopInfo;
        if (this.programElement instanceof WebGLProgramLeaf) {
            if (gl === undefined) {
                throw new Error("program element is a program but context is undefined");
            }
            // get the time uniform location
            if (this.programElement.totalNeeds.timeUniform) {
                gl.useProgram(this.programElement.program);
                const timeLoc = gl.getUniformLocation(this.programElement.program, "uTime");
                if (timeLoc === null) {
                    throw new Error("could not get the time uniform location");
                }
                this.timeLoc = timeLoc;
            }
            // get the mouse uniform location
            if (this.programElement.totalNeeds.mouseUniform) {
                gl.useProgram(this.programElement.program);
                const mouseLoc = gl.getUniformLocation(this.programElement.program, "uMouse");
                if (mouseLoc === null) {
                    throw new Error("could not get the mouse uniform location");
                }
                this.mouseLoc = mouseLoc;
            }
        }
    }
    /** get all needs from all programs */
    getTotalNeeds() {
        // go through needs of program loop
        if (!(this.programElement instanceof WebGLProgramLeaf)) {
            const allNeeds = [];
            for (const p of this.programElement) {
                allNeeds.push(p.getTotalNeeds());
            }
            return allNeeds.reduce(updateNeeds);
        }
        return this.programElement.totalNeeds;
    }
    /**
     * recursively uses all programs in the loop, binding the appropriate
     * textures and setting the appropriate uniforms; the user should only have
     * to call [[draw]] on [[Merger]] and never this function directly
     */
    run(gl, tex, framebuffer, uniformLocs, last, defaultUniforms, outerLoop) {
        let savedTexture;
        if (this.loopInfo.target !== undefined &&
            // if there is a target switch:
            (outerLoop === null || outerLoop === void 0 ? void 0 : outerLoop.loopInfo.target) !== this.loopInfo.target) {
            // swap out the back texture for the channel texture if this loop has
            // an alternate render target
            savedTexture = tex.back;
            if (this.loopInfo.target !== -1) {
                tex.back = tex.bufTextures[this.loopInfo.target];
            }
            else {
                if (tex.scene === undefined) {
                    throw new Error("tried to target -1 but scene texture was undefined");
                }
                tex.back = tex.scene;
                // TODO get rid of this
                /*
                console.log("render target is -1");
                console.log("tex.back", tex.back);
                console.log("saved texture", savedTexture);
                */
            }
            tex.bufTextures[this.loopInfo.target] = savedTexture;
            if (textureDebug)
                console.log("saved texture: " + savedTexture.name);
        }
        // setup for program leaf
        if (this.programElement instanceof WebGLProgramLeaf) {
            // bind the scene texture if needed
            if (this.programElement.totalNeeds.sceneBuffer) {
                if (tex.scene === undefined) {
                    throw new Error("needs scene buffer, but scene texture is somehow undefined");
                }
                gl.activeTexture(gl.TEXTURE1);
                if (this.loopInfo.target === -1) {
                    //console.log("binding scene to the saved texture", savedTexture);
                    gl.bindTexture(gl.TEXTURE_2D, savedTexture.tex);
                }
                else {
                    gl.bindTexture(gl.TEXTURE_2D, tex.scene.tex);
                }
            }
            // bind all extra channel textures if needed
            for (const n of this.programElement.totalNeeds.extraBuffers) {
                gl.activeTexture(gl.TEXTURE2 + n);
                gl.bindTexture(gl.TEXTURE_2D, tex.bufTextures[n].tex);
            }
            // use the current program
            gl.useProgram(this.programElement.program);
            // apply all uniforms
            for (const effect of this.programElement.effects) {
                effect.applyUniforms(gl, uniformLocs);
            }
            // set time uniform if needed
            if (this.programElement.totalNeeds.timeUniform) {
                if (this.timeLoc === undefined ||
                    defaultUniforms.timeVal === undefined) {
                    throw new Error("time or location is undefined");
                }
                gl.uniform1f(this.timeLoc, defaultUniforms.timeVal);
            }
            // set mouse uniforms if needed
            if (this.programElement.totalNeeds.mouseUniform) {
                if (this.mouseLoc === undefined ||
                    defaultUniforms.mouseX === undefined ||
                    defaultUniforms.mouseY === undefined) {
                    throw new Error("mouse uniform or location is undefined");
                }
                gl.uniform2f(this.mouseLoc, defaultUniforms.mouseX, defaultUniforms.mouseY);
            }
        }
        for (let i = 0; i < this.loopInfo.num; i++) {
            const newLast = i === this.loopInfo.num - 1;
            if (this.programElement instanceof WebGLProgramLeaf) {
                if (newLast && last && this.last) {
                    // we are on the final pass of the final loop, so draw screen by
                    // setting to the default framebuffer
                    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                }
                else {
                    // we have to bounce between two textures
                    gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
                    // use the framebuffer to write to front texture
                    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex.front.tex, 0);
                }
                // allows us to read from `texBack`
                // default sampler is 0, so `uSampler` uniform will always sample from texture 0
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, tex.back.tex);
                // use our last program as the draw program
                gl.drawArrays(gl.TRIANGLES, 0, 6);
                if (textureDebug) {
                    console.log("intermediate back", tex.back.name);
                    console.log("intermediate front", tex.front.name);
                }
                // swap back and front
                [tex.back, tex.front] = [tex.front, tex.back];
                // deactivate and unbind all the channel textures needed
                for (const n of this.programElement.totalNeeds.extraBuffers) {
                    gl.activeTexture(gl.TEXTURE2 + n);
                    gl.bindTexture(gl.TEXTURE_2D, null);
                }
                gl.activeTexture(gl.TEXTURE1);
                gl.bindTexture(gl.TEXTURE_2D, null);
            }
            else {
                if (this.loopInfo.func !== undefined) {
                    this.loopInfo.func(i);
                }
                for (const p of this.programElement) {
                    p.run(gl, tex, framebuffer, uniformLocs, newLast, defaultUniforms, this // this is now the outer loop
                    );
                }
            }
        }
        // swap the textures back if we were temporarily using a channel texture
        if (savedTexture !== undefined) {
            const target = this.loopInfo.target;
            if (textureDebug) {
                console.log("pre final back", tex.back.name);
                console.log("pre final front", tex.front.name);
            }
            // back texture is really the front texture because it was just swapped
            if (this.loopInfo.target !== -1) {
                tex.bufTextures[target] = tex.back;
            }
            else {
                if (tex.scene === undefined) {
                    throw new Error("tried to replace -1 but scene texture was undefined");
                }
                tex.scene = tex.back;
            }
            tex.back = savedTexture;
            if (textureDebug) {
                console.log("post final back", tex.back.name);
                console.log("post final front", tex.front.name);
                console.log("channel texture", tex.bufTextures[target].name);
            }
        }
    }
    delete(gl) {
        if (this.programElement instanceof WebGLProgramLeaf) {
            gl.deleteProgram(this.programElement.program);
        }
        else {
            for (const p of this.programElement) {
                p.delete(gl);
            }
        }
    }
}
exports.WebGLProgramLoop = WebGLProgramLoop;

},{}]},{},[12])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJqcy9hbHRlcmF0aW9ucy5qcyIsImpzL2F1ZGlvLmpzIiwianMvYmFja2dyb3VuZC5qcyIsImpzL2NhbWVyYS5qcyIsImpzL2Rpc3RhbmNlRGVmb3JtYXRpb25zLmpzIiwianMvZGlzdGFuY2VPcGVyYXRpb25zLmpzIiwianMvZGlzdGFuY2VPcGVyYXRpb25zR0xTTC5qcyIsImpzL2RvbWFpbk9wZXJhdGlvbnMuanMiLCJqcy9leHRlcm5hbC9tYXRyaXguanMiLCJqcy9mbG9hdC5qcyIsImpzL2ZvZy5qcyIsImpzL2luZGV4LmpzIiwianMvaW50LmpzIiwianMvbGlnaHRpbmcuanMiLCJqcy9tYWluLmpzIiwianMvbWF0ZXJpYWwuanMiLCJqcy9tZXJnZXBhc3MuanMiLCJqcy9ub2lzZS5qcyIsImpzL3ByaW1pdGl2ZURlc2NyaXB0aW9ucy5qcyIsImpzL3ByaW1pdGl2ZXMuanMiLCJqcy9yZW5kZXJGcmFnbWVudFNoYWRlci5qcyIsImpzL3NjZW5lLmpzIiwianMvc2NlbmVOb2RlLmpzIiwianMvdGV4dHVyZS5qcyIsImpzL3RleHR1cmVEZXNjcmlwdGlvbnMuanMiLCJqcy90ZXh0dXJlV3JhcC5qcyIsImpzL3RyYW5zZm9ybS5qcyIsImpzL3V0aWxzLmpzIiwianMvdmFyLmpzIiwianMvdmVjLmpzIiwianMvdmlnbmV0dGUuanMiLCJub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2JpdC10d2lkZGxlL3R3aWRkbGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLXV0aWwtaXMvbGliL3V0aWwuanMiLCJub2RlX21vZHVsZXMvY3dpc2UtY29tcGlsZXIvY29tcGlsZXIuanMiLCJub2RlX21vZHVsZXMvY3dpc2UtY29tcGlsZXIvbGliL2NvbXBpbGUuanMiLCJub2RlX21vZHVsZXMvY3dpc2UtY29tcGlsZXIvbGliL3RodW5rLmpzIiwibm9kZV9tb2R1bGVzL2RhdGEtdXJpLXRvLWJ1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9kdXAvZHVwLmpzIiwibm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJub2RlX21vZHVsZXMvZ2V0LXBpeGVscy9kb20tcGl4ZWxzLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvYWRqb2ludC5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L2Nsb25lLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvY29weS5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L2NyZWF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L2RldGVybWluYW50LmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvZnJvbVF1YXQuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9mcm9tUm90YXRpb24uanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9mcm9tUm90YXRpb25UcmFuc2xhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L2Zyb21TY2FsaW5nLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvZnJvbVRyYW5zbGF0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvZnJvbVhSb3RhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L2Zyb21ZUm90YXRpb24uanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9mcm9tWlJvdGF0aW9uLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvZnJ1c3R1bS5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L2lkZW50aXR5LmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9pbnZlcnQuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9sb29rQXQuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9tdWx0aXBseS5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L29ydGhvLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvcGVyc3BlY3RpdmUuanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9wZXJzcGVjdGl2ZUZyb21GaWVsZE9mVmlldy5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L3JvdGF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L3JvdGF0ZVguanMiLCJub2RlX21vZHVsZXMvZ2wtbWF0NC9yb3RhdGVZLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvcm90YXRlWi5qcyIsIm5vZGVfbW9kdWxlcy9nbC1tYXQ0L3NjYWxlLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvc3RyLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvdHJhbnNsYXRlLmpzIiwibm9kZV9tb2R1bGVzL2dsLW1hdDQvdHJhbnNwb3NlLmpzIiwibm9kZV9tb2R1bGVzL2dsLXRleHR1cmUyZC90ZXh0dXJlLmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvYWRkLmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvYW5nbGUuanMiLCJub2RlX21vZHVsZXMvZ2wtdmVjMy9jZWlsLmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvY2xvbmUuanMiLCJub2RlX21vZHVsZXMvZ2wtdmVjMy9jb3B5LmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvY3JlYXRlLmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvY3Jvc3MuanMiLCJub2RlX21vZHVsZXMvZ2wtdmVjMy9kaXN0LmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvZGlzdGFuY2UuanMiLCJub2RlX21vZHVsZXMvZ2wtdmVjMy9kaXYuanMiLCJub2RlX21vZHVsZXMvZ2wtdmVjMy9kaXZpZGUuanMiLCJub2RlX21vZHVsZXMvZ2wtdmVjMy9kb3QuanMiLCJub2RlX21vZHVsZXMvZ2wtdmVjMy9lcHNpbG9uLmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvZXF1YWxzLmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvZXhhY3RFcXVhbHMuanMiLCJub2RlX21vZHVsZXMvZ2wtdmVjMy9mbG9vci5qcyIsIm5vZGVfbW9kdWxlcy9nbC12ZWMzL2ZvckVhY2guanMiLCJub2RlX21vZHVsZXMvZ2wtdmVjMy9mcm9tVmFsdWVzLmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZ2wtdmVjMy9pbnZlcnNlLmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvbGVuLmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvbGVuZ3RoLmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvbGVycC5qcyIsIm5vZGVfbW9kdWxlcy9nbC12ZWMzL21heC5qcyIsIm5vZGVfbW9kdWxlcy9nbC12ZWMzL21pbi5qcyIsIm5vZGVfbW9kdWxlcy9nbC12ZWMzL211bC5qcyIsIm5vZGVfbW9kdWxlcy9nbC12ZWMzL211bHRpcGx5LmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvbmVnYXRlLmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvbm9ybWFsaXplLmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvcmFuZG9tLmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvcm90YXRlWC5qcyIsIm5vZGVfbW9kdWxlcy9nbC12ZWMzL3JvdGF0ZVkuanMiLCJub2RlX21vZHVsZXMvZ2wtdmVjMy9yb3RhdGVaLmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvcm91bmQuanMiLCJub2RlX21vZHVsZXMvZ2wtdmVjMy9zY2FsZS5qcyIsIm5vZGVfbW9kdWxlcy9nbC12ZWMzL3NjYWxlQW5kQWRkLmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvc2V0LmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvc3FyRGlzdC5qcyIsIm5vZGVfbW9kdWxlcy9nbC12ZWMzL3Nxckxlbi5qcyIsIm5vZGVfbW9kdWxlcy9nbC12ZWMzL3NxdWFyZWREaXN0YW5jZS5qcyIsIm5vZGVfbW9kdWxlcy9nbC12ZWMzL3NxdWFyZWRMZW5ndGguanMiLCJub2RlX21vZHVsZXMvZ2wtdmVjMy9zdWIuanMiLCJub2RlX21vZHVsZXMvZ2wtdmVjMy9zdWJ0cmFjdC5qcyIsIm5vZGVfbW9kdWxlcy9nbC12ZWMzL3RyYW5zZm9ybU1hdDMuanMiLCJub2RlX21vZHVsZXMvZ2wtdmVjMy90cmFuc2Zvcm1NYXQ0LmpzIiwibm9kZV9tb2R1bGVzL2dsLXZlYzMvdHJhbnNmb3JtUXVhdC5qcyIsIm5vZGVfbW9kdWxlcy9nbHNsaWZ5L2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2lvdGEtYXJyYXkvaW90YS5qcyIsIm5vZGVfbW9kdWxlcy9pcy1idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9uZGFycmF5LW9wcy9uZGFycmF5LW9wcy5qcyIsIm5vZGVfbW9kdWxlcy9uZGFycmF5LXBhY2svY29udmVydC5qcyIsIm5vZGVfbW9kdWxlcy9uZGFycmF5LXBhY2svZG9Db252ZXJ0LmpzIiwibm9kZV9tb2R1bGVzL25kYXJyYXkvbmRhcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9vbWdnaWYvb21nZ2lmLmpzIiwibm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzLW5leHRpY2stYXJncy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2R1cGxleC1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzIiwibm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL25vZGVfbW9kdWxlcy9zYWZlLWJ1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zdHJpbmdfZGVjb2Rlci9saWIvc3RyaW5nX2RlY29kZXIuanMiLCJub2RlX21vZHVsZXMvdGhyb3VnaC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwibm9kZV9tb2R1bGVzL3R5cGVkYXJyYXktcG9vbC9wb29sLmpzIiwibm9kZV9tb2R1bGVzL3VuaXEvdW5pcS5qcyIsIm5vZGVfbW9kdWxlcy91dGlsLWRlcHJlY2F0ZS9icm93c2VyLmpzIiwiLi4vbWVyZ2UtcGFzcy9kaXN0L2NvZGVidWlsZGVyLmpzIiwiLi4vbWVyZ2UtcGFzcy9kaXN0L2V4cHJzL2FyaXR5MS5qcyIsIi4uL21lcmdlLXBhc3MvZGlzdC9leHBycy9hcml0eTIuanMiLCIuLi9tZXJnZS1wYXNzL2Rpc3QvZXhwcnMvYmxvb21sb29wLmpzIiwiLi4vbWVyZ2UtcGFzcy9kaXN0L2V4cHJzL2JsdXIyZGxvb3AuanMiLCIuLi9tZXJnZS1wYXNzL2Rpc3QvZXhwcnMvYmx1cmV4cHIuanMiLCIuLi9tZXJnZS1wYXNzL2Rpc3QvZXhwcnMvYnJpZ2h0bmVzc2V4cHIuanMiLCIuLi9tZXJnZS1wYXNzL2Rpc3QvZXhwcnMvY2hhbmdlY29tcGV4cHIuanMiLCIuLi9tZXJnZS1wYXNzL2Rpc3QvZXhwcnMvY2hhbm5lbHNhbXBsZWV4cHIuanMiLCIuLi9tZXJnZS1wYXNzL2Rpc3QvZXhwcnMvY29udHJhc3RleHByLmpzIiwiLi4vbWVyZ2UtcGFzcy9kaXN0L2V4cHJzL2RlcHRodG9vY2NsdXNpb25leHByLmpzIiwiLi4vbWVyZ2UtcGFzcy9kaXN0L2V4cHJzL2RvZmxvb3AuanMiLCIuLi9tZXJnZS1wYXNzL2Rpc3QvZXhwcnMvZXhwci5qcyIsIi4uL21lcmdlLXBhc3MvZGlzdC9leHBycy9mcmFnY29sb3JleHByLmpzIiwiLi4vbWVyZ2UtcGFzcy9kaXN0L2V4cHJzL2ZyYWdjb29yZGV4cHIuanMiLCIuLi9tZXJnZS1wYXNzL2Rpc3QvZXhwcnMvZnhhYWV4cHIuanMiLCIuLi9tZXJnZS1wYXNzL2Rpc3QvZXhwcnMvZ2F1c3NpYW5leHByLmpzIiwiLi4vbWVyZ2UtcGFzcy9kaXN0L2V4cHJzL2dldGNvbXBleHByLmpzIiwiLi4vbWVyZ2UtcGFzcy9kaXN0L2V4cHJzL2dvZHJheXNleHByLmpzIiwiLi4vbWVyZ2UtcGFzcy9kaXN0L2V4cHJzL2dyYWluZXhwci5qcyIsIi4uL21lcmdlLXBhc3MvZGlzdC9leHBycy9oc3Z0b3JnYmV4cHIuanMiLCIuLi9tZXJnZS1wYXNzL2Rpc3QvZXhwcnMvaW52ZXJ0ZXhwci5qcyIsIi4uL21lcmdlLXBhc3MvZGlzdC9leHBycy9sZW5leHByLmpzIiwiLi4vbWVyZ2UtcGFzcy9kaXN0L2V4cHJzL21vbm9jaHJvbWVleHByLmpzIiwiLi4vbWVyZ2UtcGFzcy9kaXN0L2V4cHJzL21vdGlvbmJsdXJsb29wLmpzIiwiLi4vbWVyZ2UtcGFzcy9kaXN0L2V4cHJzL21vdXNlZXhwci5qcyIsIi4uL21lcmdlLXBhc3MvZGlzdC9leHBycy9ub3JtY2VudGVyZnJhZ2Nvb3JkZXhwci5qcyIsIi4uL21lcmdlLXBhc3MvZGlzdC9leHBycy9ub3JtZXhwci5qcyIsIi4uL21lcmdlLXBhc3MvZGlzdC9leHBycy9ub3JtZnJhZ2Nvb3JkZXhwci5qcyIsIi4uL21lcmdlLXBhc3MvZGlzdC9leHBycy9ub3JtbW91c2VleHByLmpzIiwiLi4vbWVyZ2UtcGFzcy9kaXN0L2V4cHJzL29wZXhwci5qcyIsIi4uL21lcmdlLXBhc3MvZGlzdC9leHBycy9wZXJsaW5leHByLmpzIiwiLi4vbWVyZ2UtcGFzcy9kaXN0L2V4cHJzL3Bvd2VyYmx1ci5qcyIsIi4uL21lcmdlLXBhc3MvZGlzdC9leHBycy9yYW5kb21leHByLmpzIiwiLi4vbWVyZ2UtcGFzcy9kaXN0L2V4cHJzL3Jlc29sdXRpb25leHByLmpzIiwiLi4vbWVyZ2UtcGFzcy9kaXN0L2V4cHJzL3JnYnRvaHN2ZXhwci5qcyIsIi4uL21lcmdlLXBhc3MvZGlzdC9leHBycy9yb3RhdGVleHByLmpzIiwiLi4vbWVyZ2UtcGFzcy9kaXN0L2V4cHJzL3NjZW5lc2FtcGxlZXhwci5qcyIsIi4uL21lcmdlLXBhc3MvZGlzdC9leHBycy9zZXRjb2xvcmV4cHIuanMiLCIuLi9tZXJnZS1wYXNzL2Rpc3QvZXhwcnMvc2ltcGxleGV4cHIuanMiLCIuLi9tZXJnZS1wYXNzL2Rpc3QvZXhwcnMvc29iZWxleHByLmpzIiwiLi4vbWVyZ2UtcGFzcy9kaXN0L2V4cHJzL3RpbWVleHByLmpzIiwiLi4vbWVyZ2UtcGFzcy9kaXN0L2V4cHJzL3RyYW5zbGF0ZWV4cHIuanMiLCIuLi9tZXJnZS1wYXNzL2Rpc3QvZXhwcnMvdHJ1ZWRlcHRoZXhwci5qcyIsIi4uL21lcmdlLXBhc3MvZGlzdC9leHBycy92ZWNleHBycy5qcyIsIi4uL21lcmdlLXBhc3MvZGlzdC9leHBydHlwZXMuanMiLCIuLi9tZXJnZS1wYXNzL2Rpc3QvZ2xzbGZ1bmN0aW9ucy5qcyIsIi4uL21lcmdlLXBhc3MvZGlzdC9pbmRleC5qcyIsIi4uL21lcmdlLXBhc3MvZGlzdC9tZXJnZXBhc3MuanMiLCIuLi9tZXJnZS1wYXNzL2Rpc3Qvd2ViZ2xwcm9ncmFtbG9vcC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25WQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNZQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDamNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcE9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1UkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9RQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL01BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdlJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVNQTs7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDbHdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0V0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3RJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNkQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN2NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2eUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM5U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzEvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5cUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pFQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7O0FDREE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ3ZTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM1R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDekRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNuRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdGFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNVpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24oKXtmdW5jdGlvbiByKGUsbix0KXtmdW5jdGlvbiBvKGksZil7aWYoIW5baV0pe2lmKCFlW2ldKXt2YXIgYz1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFmJiZjKXJldHVybiBjKGksITApO2lmKHUpcmV0dXJuIHUoaSwhMCk7dmFyIGE9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitpK1wiJ1wiKTt0aHJvdyBhLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsYX12YXIgcD1uW2ldPXtleHBvcnRzOnt9fTtlW2ldWzBdLmNhbGwocC5leHBvcnRzLGZ1bmN0aW9uKHIpe3ZhciBuPWVbaV1bMV1bcl07cmV0dXJuIG8obnx8cil9LHAscC5leHBvcnRzLHIsZSxuLHQpfXJldHVybiBuW2ldLmV4cG9ydHN9Zm9yKHZhciB1PVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsaT0wO2k8dC5sZW5ndGg7aSsrKW8odFtpXSk7cmV0dXJuIG99cmV0dXJuIHJ9KSgpIiwiY29uc3QgU2NlbmVOb2RlID0gcmVxdWlyZSggJy4vc2NlbmVOb2RlLmpzJyApXG5jb25zdCB7IHBhcmFtX3dyYXAsIE1hdGVyaWFsSUQgfSA9IHJlcXVpcmUoICcuL3V0aWxzLmpzJyApXG5jb25zdCB7IFZhciwgZmxvYXRfdmFyX2dlbiwgdmVjMl92YXJfZ2VuLCB2ZWMzX3Zhcl9nZW4sIHZlYzRfdmFyX2dlbiwgaW50X3Zhcl9nZW4gfSA9IHJlcXVpcmUoICcuL3Zhci5qcycgKVxuXG5jb25zdCBvcHMgPSB7IFxuICBPbmlvbjoge1xuICAgIGZ1bmMoIHNkZix0aGlja25lc3MgKSB7IHJldHVybiBgdmVjMiggb3BPbmlvbiggJHtzZGZ9LngsICR7dGhpY2tuZXNzfSApLCAke3NkZn0ueSApYCB9LFxuICAgIHZhcmlhYmxlczpbWyd0aGlja25lc3MnLCAnZmxvYXQnLCAuMDNdXVxuICB9LFxuICBIYWx2ZToge1xuICAgIGZ1bmMoIHNkZiwgZGlyZWN0aW9uICkgeyByZXR1cm4gYHZlYzIoIG9wSGFsdmUoICR7c2RmfS54LCBwLCAke2RpcmVjdGlvbn0gKSwgJHtzZGZ9LnkgKWAgfSxcbiAgICB2YXJpYWJsZXM6W1snZGlyZWN0aW9uJywnaW50JywwXV1cbiAgfSxcbiAgUm91bmQ6IHtcbiAgICBmdW5jKCBzZGYsIGFtb3VudCApIHsgcmV0dXJuIGB2ZWMyKCAke3NkZn0ueCAtICR7YW1vdW50fSwgJHtzZGZ9LnkgKWAgfSxcbiAgICB2YXJpYWJsZXM6W1snYW1vdW50JywnZmxvYXQnLC4xXV1cbiAgfVxufVxuXG5cbmNvbnN0IEFsdGVyYXRpb25zPSB7fVxuXG5mb3IoIGxldCBuYW1lIGluIG9wcyApIHtcblxuICAvLyBnZXQgY29kZWdlbiBmdW5jdGlvblxuICBsZXQgb3AgPSBvcHNbIG5hbWUgXVxuXG4gIC8vIGNyZWF0ZSBjb25zdHJ1Y3RvclxuICBBbHRlcmF0aW9uc1sgbmFtZSBdID0gZnVuY3Rpb24oIHNkZiwgLi4uYXJncyApIHtcbiAgICBjb25zdCBfX29wID0gT2JqZWN0LmNyZWF0ZSggQWx0ZXJhdGlvbnNbIG5hbWUgXS5wcm90b3R5cGUgKVxuICAgIF9fb3Auc2RmID0gc2RmXG4gICAgX19vcC52YXJpYWJsZXMgPSBbXVxuICAgIF9fb3AuX19kZXNjID0geyBwYXJhbWV0ZXJzOltdIH1cblxuICAgIGZvciggbGV0IGkgPSAwOyBpIDwgb3AudmFyaWFibGVzLmxlbmd0aDsgaSsrICkge1xuICAgICAgY29uc3QgcHJvcEFycmF5ID0gb3AudmFyaWFibGVzWyBpIF1cbiAgICAgIGNvbnN0IHByb3BOYW1lID0gcHJvcEFycmF5WyAwIF1cbiAgICAgIGNvbnN0IHByb3BUeXBlID0gcHJvcEFycmF5WyAxIF1cbiAgICAgIGNvbnN0IHByb3BWYWx1ZSA9IGFyZ3NbIGkgXSA9PT0gdW5kZWZpbmVkID8gcHJvcEFycmF5WyAyIF0gOiBhcmdzWyBpIF1cblxuICAgICAgX19vcC5fX2Rlc2MucGFyYW1ldGVycy5wdXNoKHsgbmFtZTpwcm9wTmFtZSwgdmFsdWU6cHJvcFZhbHVlIH0pXG4gICAgICBsZXQgcGFyYW1cblxuICAgICAgc3dpdGNoKCBwcm9wVHlwZSApIHtcbiAgICAgICAgY2FzZSAnaW50JzpcbiAgICAgICAgICBwYXJhbSA9IGludF92YXJfZ2VuKCBwcm9wVmFsdWUgKSgpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcGFyYW0gPSBmbG9hdF92YXJfZ2VuKCBwcm9wVmFsdWUgKSgpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggX19vcCwgcHJvcE5hbWUsIHtcbiAgICAgICAgZ2V0KCkgeyByZXR1cm4gcGFyYW0gfSxcbiAgICAgICAgc2V0KHYpIHsgcGFyYW0uc2V0KCB2ICkgfVxuICAgICAgfSlcblxuICAgICAgX19vcC52YXJpYWJsZXMucHVzaCggcGFyYW0gKVxuICAgIH1cbiAgICAgIFxuICAgIF9fb3AubWF0SWQgPSBNYXRlcmlhbElELmFsbG9jKClcblxuICAgIHJldHVybiBfX29wXG4gIH0gXG5cbiAgQWx0ZXJhdGlvbnNbIG5hbWUgXS5wcm90b3R5cGUgPSBTY2VuZU5vZGUoKVxuXG4gIEFsdGVyYXRpb25zWyBuYW1lIF0ucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAoIF9fbmFtZSApIHtcbiAgICBjb25zdCBlbWl0dGVyQSA9IHRoaXMuc2RmLmVtaXQoIF9fbmFtZSApXG4gICAgLy9jb25zdCBlbWl0dGVyQiA9IHRoaXMuYi5lbWl0KClcblxuICAgIGNvbnN0IG91dHB1dCA9IHtcbiAgICAgIG91dDogb3AuZnVuYyggZW1pdHRlckEub3V0LCAuLi50aGlzLnZhcmlhYmxlcy5tYXAoIHYgPT4gdi5lbWl0KCkgKSApLCBcbiAgICAgIHByZWZhY2U6IChlbWl0dGVyQS5wcmVmYWNlIHx8ICcnKSBcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0cHV0XG4gIH1cblxuICBBbHRlcmF0aW9uc1tuYW1lXS5wcm90b3R5cGUuZW1pdF9kZWNsID0gZnVuY3Rpb24gKCkge1xuICAgIGxldCBzdHIgPSAgdGhpcy5zZGYuZW1pdF9kZWNsKCkgXG4gICAgZm9yKCBsZXQgdiBvZiB0aGlzLnZhcmlhYmxlcyApIHtcbiAgICAgIHN0ciArPSB2LmVtaXRfZGVjbCgpXG4gICAgfVxuXG4gICAgcmV0dXJuIHN0clxuICB9O1xuXG4gIEFsdGVyYXRpb25zW25hbWVdLnByb3RvdHlwZS51cGRhdGVfbG9jYXRpb24gPSBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgIHRoaXMuc2RmLnVwZGF0ZV9sb2NhdGlvbiggZ2wsIHByb2dyYW0gKVxuICAgIGZvciggbGV0IHYgb2YgdGhpcy52YXJpYWJsZXMgKSB2LnVwZGF0ZV9sb2NhdGlvbiggZ2wsIHByb2dyYW0gKVxuICB9XG5cbiAgQWx0ZXJhdGlvbnNbbmFtZV0ucHJvdG90eXBlLnVwbG9hZF9kYXRhID0gZnVuY3Rpb24oZ2wpIHtcbiAgICB0aGlzLnNkZi51cGxvYWRfZGF0YSggZ2wgKVxuICAgIGZvciggbGV0IHYgb2YgdGhpcy52YXJpYWJsZXMgKSB2LnVwbG9hZF9kYXRhKCBnbCApXG4gICAgXG4gIH1cbn1cblxuQWx0ZXJhdGlvbnMuSGFsdmUuVVAgPSAwXG5BbHRlcmF0aW9ucy5IYWx2ZS5ET1dOID0gMVxuQWx0ZXJhdGlvbnMuSGFsdmUuTEVGVCA9IDNcbkFsdGVyYXRpb25zLkhhbHZlLlJJR0hUID0gMlxuXG5tb2R1bGUuZXhwb3J0cyA9IEFsdGVyYXRpb25zXG4iLCJjb25zdCBBdWRpbyA9IHtcbiAgX19oYXNJbnB1dDogZmFsc2UsXG4gIGN0eDogbnVsbCxcblxuICBzdGFydCgpIHtcbiAgICBpZiggQXVkaW8uX19oYXNJbnB1dCA9PT0gZmFsc2UgKSB7XG4gICAgICBBdWRpby5jdHggPSBuZXcgQXVkaW9Db250ZXh0KClcbiAgICAgIEF1ZGlvLmNyZWF0ZUlucHV0KCkudGhlbiggaW5wdXQgPT4ge1xuICAgICAgICBBdWRpby5jcmVhdGVGRlQoKVxuICAgICAgICBpbnB1dC5jb25uZWN0KCBBdWRpby5GRlQgKVxuXG4gICAgICAgIEF1ZGlvLmludGVydmFsID0gc2V0SW50ZXJ2YWwoIEF1ZGlvLmZmdENhbGxiYWNrLCAxMDAwLzYwIClcbiAgICAgICAgLy93aW5kb3cuRkZUID0gQXVkaW8uRkZUXG4gICAgICB9KVxuICAgIH1cbiAgICBBdWRpby5fX2hhc0lucHV0ID0gdHJ1ZVxuICB9LFxuXG4gIGNyZWF0ZUlucHV0KCkge1xuICAgIGNvbnNvbGUubG9nKCAnY29ubmVjdGluZyBhdWRpbyBpbnB1dC4uLicgKVxuICAgIFxuICAgIGNvbnN0IHAgPSBuZXcgUHJvbWlzZSggcmVzb2x2ZSA9PiB7XG4gICAgICBjb25zb2xlLmxvZyggJ3N0YXJ0PycgKVxuICAgICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoeyBhdWRpbzp0cnVlLCB2aWRlbzpmYWxzZSB9KVxuICAgICAgICAudGhlbiggc3RyZWFtID0+IHtcbiAgICAgICAgICBjb25zb2xlLmxvZyggJ2F1ZGlvIGlucHV0IGNvbm5lY3RlZCcgKVxuICAgICAgICAgIEF1ZGlvLmlucHV0ID0gQXVkaW8uY3R4LmNyZWF0ZU1lZGlhU3RyZWFtU291cmNlKCBzdHJlYW0gKVxuICAgICAgICAgIC8vQXVkaW8ubWVkaWFTdHJlYW1Tb3VyY2UuY29ubmVjdCggR2liYmVyaXNoLm5vZGUgKVxuICAgICAgICAgIEF1ZGlvLl9faGFzSW5wdXQgPSB0cnVlXG4gICAgICAgICAgcmVzb2x2ZSggQXVkaW8uaW5wdXQgKVxuICAgICAgICB9KVxuICAgICAgICAuY2F0Y2goIGVyciA9PiB7IFxuICAgICAgICAgIGNvbnNvbGUubG9nKCAnZXJyb3Igb3BlbmluZyBhdWRpbyBpbnB1dDonLCBlcnIgKVxuICAgICAgICB9KVxuICAgIH0pXG4gICAgcmV0dXJuIHBcbiAgfSxcblxuICBjcmVhdGVGRlQoKSB7XG4gICAgQXVkaW8uRkZUID0gQXVkaW8uY3R4LmNyZWF0ZUFuYWx5c2VyKClcblxuICAgIGxldCBfX3dpbmRvd1NpemUgPSA1MTJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIEF1ZGlvLCAnd2luZG93U2l6ZScsIHtcbiAgICAgIGdldCgpIHsgcmV0dXJuIF9fd2luZG93U2l6ZSB9LFxuICAgICAgc2V0KHYpe1xuICAgICAgICBfX3dpbmRvd1NpemUgPSB2XG4gICAgICAgIEF1ZGlvLkZGVC5mZnRTaXplID0gdiBcbiAgICAgICAgQXVkaW8uRkZULnZhbHVlcyA9IG5ldyBVaW50OEFycmF5KCBBdWRpby5GRlQuZnJlcXVlbmN5QmluQ291bnQgKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBBdWRpby53aW5kb3dTaXplID0gNTEyXG4gIH0sXG5cbiAgZmZ0Q2FsbGJhY2soKSB7XG4gICAgQXVkaW8uRkZULmdldEJ5dGVGcmVxdWVuY3lEYXRhKCBBdWRpby5GRlQudmFsdWVzIClcbiAgICBcbiAgICBsZXQgbG93U3VtLCBtaWRTdW0sIGhpZ2hTdW0sIGxvd0NvdW50LCBtaWRDb3VudCwgaGlnaENvdW50XG4gICAgbG93U3VtID0gbWlkU3VtID0gaGlnaFN1bSA9IGxvd0NvdW50ID0gbWlkQ291bnQgPSBoaWdoQ291bnQgPSAwXG5cbiAgICBsZXQgZnJlcXVlbmN5Q291bnRlciA9IDBcblxuICAgIC8vIGRvZXMgdGhpcyBzdGFydCBhdCAwSHo/IGFjay4uLiBjYW4ndCByZW1lbWJlci4uLiBkb2VzIGl0IGluY2x1ZGUgREMgb2Zmc2V0P1xuICAgIGNvbnN0IGh6UGVyQmluID0gKEF1ZGlvLmN0eC5zYW1wbGVSYXRlIC8gMikgLyBBdWRpby5GRlQuZnJlcXVlbmN5QmluQ291bnRcbiAgICBjb25zdCBsb3dSYW5nZSA9IDE1MCwgbWlkUmFuZ2UgPSAxNDAwLCBoaWdoUmFuZ2UgPSBBdWRpby5jdHguc2FtcGxlUmF0ZSAvIDJcblxuICAgIGZvciggbGV0IGkgPSAxOyBpIDwgQXVkaW8uRkZULmZyZXF1ZW5jeUJpbkNvdW50OyBpKysgKSB7XG4gICAgICBpZiggZnJlcXVlbmN5Q291bnRlciA8IGxvd1JhbmdlICkge1xuICAgICAgICBsb3dTdW0gKz0gQXVkaW8uRkZULnZhbHVlc1sgaSBdXG4gICAgICAgIGxvd0NvdW50KytcbiAgICAgIH1lbHNlIGlmKCBmcmVxdWVuY3lDb3VudGVyIDwgbWlkUmFuZ2UgKSB7XG4gICAgICAgIG1pZFN1bSArPSBBdWRpby5GRlQudmFsdWVzWyBpIF1cbiAgICAgICAgbWlkQ291bnQrK1xuICAgICAgfWVsc2V7XG4gICAgICAgIGhpZ2hTdW0gKz0gQXVkaW8uRkZULnZhbHVlc1sgaSBdXG4gICAgICAgIGhpZ2hDb3VudCsrXG4gICAgICB9XG5cbiAgICAgIGZyZXF1ZW5jeUNvdW50ZXIgKz0gaHpQZXJCaW5cbiAgICB9XG5cbiAgICBBdWRpby5sb3cgPSAobG93U3VtIC8gbG93Q291bnQpIC8gMjU1XG4gICAgQXVkaW8ubWlkID0gKG1pZFN1bSAvIG1pZENvdW50KSAvIDI1NSB8fCAwXG4gICAgQXVkaW8uaGlnaCA9IChoaWdoU3VtIC8gaGlnaENvdW50KSAvIDI1NVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQXVkaW9cbiIsImNvbnN0IFNjZW5lTm9kZSA9IHJlcXVpcmUoICcuL3NjZW5lTm9kZS5qcycgKSxcbiAgICAgIHsgcGFyYW1fd3JhcCwgTWF0ZXJpYWxJRCB9ID0gcmVxdWlyZSggJy4vdXRpbHMuanMnICksXG4gICAgICB7IFZhciwgZmxvYXRfdmFyX2dlbiwgdmVjMl92YXJfZ2VuLCB2ZWMzX3Zhcl9nZW4sIHZlYzRfdmFyX2dlbiB9ID0gcmVxdWlyZSggJy4vdmFyLmpzJyApXG5cbmNvbnN0IHsgVmVjMiwgVmVjMywgVmVjNCB9ID0gcmVxdWlyZSggJy4vdmVjLmpzJyApXG5cbmNvbnN0IEJHID0gZnVuY3Rpb24oIFNjZW5lLCBTREYgKSB7XG5cbiAgY29uc3QgQmFja2dyb3VuZCA9IGZ1bmN0aW9uKCBjb2xvciApIHtcbiAgICBpZiggU0RGLm1lbW8uYmFja2dyb3VuZCA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgY29uc3QgYmcgPSBPYmplY3QuY3JlYXRlKCBCYWNrZ3JvdW5kLnByb3RvdHlwZSApXG5cbiAgICAgIGNvbnN0IF9fY29sb3IgPSBwYXJhbV93cmFwKCBWZWMzKGNvbG9yKSwgdmVjM192YXJfZ2VuKCAwLDAsMCwgJ2JnJyApLCAnYmcnICkgIFxuICAgICAgXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIGJnLCAnY29sb3InLCB7XG4gICAgICAgIGdldCgpIHsgcmV0dXJuIF9fY29sb3IgfSxcbiAgICAgICAgc2V0KCB2ICkge1xuICAgICAgICAgIF9fY29sb3IudmFyLnNldCggdiApXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBcbiAgICAgIC8vIHRoaXMgcmVmZXJzIHRvIHRoZSBjdXJyZW50IHNjZW5lIHZpYSBpbXBsaWNpdCBiaW5kaW5nIGluIHNjZW5lLmpzXG4gICAgICB0aGlzLnBvc3Rwcm9jZXNzaW5nLnB1c2goIGJnIClcblxuICAgICAgU0RGLm1lbW8uYmFja2dyb3VuZCA9IHRydWVcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIEJhY2tncm91bmQucHJvdG90eXBlID0gU2NlbmVOb2RlKClcbiBcbiAgT2JqZWN0LmFzc2lnbiggQmFja2dyb3VuZC5wcm90b3R5cGUsIHtcbiAgICBlbWl0KCkge1xuICAgICAgcmV0dXJuICcnLy90aGlzLmNvbG9yLmVtaXQoKVxuICAgIH0sXG4gICBcbiAgICBlbWl0X2RlY2woKSB7XG4gICAgICBsZXQgc3RyID0gdGhpcy5jb2xvci5lbWl0X2RlY2woKVxuICAgICAgU0RGLm1lbW8uYmFja2dyb3VuZCA9IHRydWVcblxuICAgICAgcmV0dXJuIHN0clxuICAgIH0sXG5cbiAgICB1cGRhdGVfbG9jYXRpb24oIGdsLCBwcm9ncmFtICkge1xuICAgICAgdGhpcy5jb2xvci51cGRhdGVfbG9jYXRpb24oIGdsLCBwcm9ncmFtIClcbiAgICB9LFxuXG4gICAgdXBsb2FkX2RhdGEoIGdsICkge1xuICAgICAgdGhpcy5jb2xvci51cGxvYWRfZGF0YSggZ2wgKVxuICAgIH1cbiAgfSlcblxuICByZXR1cm4gQmFja2dyb3VuZFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJHIFxuIiwiY29uc3QgdmVjMyA9IHJlcXVpcmUoJ2dsLXZlYzMnKVxuY29uc3QgbWF0NCA9IHJlcXVpcmUoJ2dsLW1hdDQnKVxuXG4vLyBjYW1lcmEgYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9zaGFtYS9maXJzdC1wZXJzb24tY2FtZXJhXG5mdW5jdGlvbiBGaXJzdFBlcnNvbkNhbWVyYShvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBGaXJzdFBlcnNvbkNhbWVyYSkpIHJldHVybiBuZXcgRmlyc3RQZXJzb25DYW1lcmEob3B0cylcbiAgb3B0cyA9IG9wdHMgfHwge31cbiAgdGhpcy5wb3NpdGlvbiA9IG9wdHMucG9zaXRpb24gfHwgdmVjMy5jcmVhdGUoKVxuICB0aGlzLnJvdGF0aW9uID0gb3B0cy5yb3RhdGlvbiB8fCB2ZWMzLmNyZWF0ZSgpXG4gIHRoaXMucG9zaXRpb25TcGVlZCA9IG9wdHMucG9zaXRpb25TcGVlZCB8fCAtLjVcbiAgdGhpcy5yb3RhdGlvblNwZWVkID0gb3B0cy5yb3RhdGlvblNwZWVkIHx8IC4wMVxufVxubW9kdWxlLmV4cG9ydHMgPSBGaXJzdFBlcnNvbkNhbWVyYVxuXG5GaXJzdFBlcnNvbkNhbWVyYS5wcm90b3R5cGUudmlldyA9IGZ1bmN0aW9uKG91dCkge1xuICBpZiAoIW91dCkgb3V0ID0gbWF0NC5jcmVhdGUoKVxuICAvLyBhbHRlcmVkIHgveSBvcmRlcmluZyBmcm9tIG9yaWdpbmFsXG4gIG1hdDQucm90YXRlWShvdXQsIG91dCwgdGhpcy5yb3RhdGlvblsxXSlcbiAgbWF0NC5yb3RhdGVYKG91dCwgb3V0LCB0aGlzLnJvdGF0aW9uWzBdKVxuICBtYXQ0LnJvdGF0ZVoob3V0LCBvdXQsIHRoaXMucm90YXRpb25bMl0gLSBNYXRoLlBJKVxuICBtYXQ0LnRyYW5zbGF0ZShvdXQsIG91dCwgWy10aGlzLnBvc2l0aW9uWzBdLCAtdGhpcy5wb3NpdGlvblsxXSwgLXRoaXMucG9zaXRpb25bMl1dKVxuXG4gIHJldHVybiBvdXRcbn1cblxuRmlyc3RQZXJzb25DYW1lcmEucHJvdG90eXBlLmNvbnRyb2wgPSBmdW5jdGlvbihkdCwgbW92ZSwgbW91c2UsIHByZXZNb3VzZSkge1xuICB2YXIgc3BlZWQgPSAodGhpcy5wb3NpdGlvblNwZWVkIC8gMTAwMCkgKiBkdFxuICB2YXIgZGlyID0gWzAsMCwwXVxuICBpZiAobW92ZVswXSkgZGlyWzJdIC09IHNwZWVkICogKE1hcmNoaW5nLmtleXMuQWx0ID8gNCA6IDEgKVxuICBlbHNlIGlmIChtb3ZlWzFdKSBkaXJbMl0gKz0gc3BlZWQgKiAoTWFyY2hpbmcua2V5cy5BbHQgPyA0IDogMSApXG4gIGlmIChtb3ZlWzJdKSBkaXJbMF0gKz0gc3BlZWQgKiAoTWFyY2hpbmcua2V5cy5BbHQgPyA0IDogMSApXG4gIGVsc2UgaWYgKG1vdmVbM10pIGRpclswXSAtPSBzcGVlZCAqIChNYXJjaGluZy5rZXlzLkFsdCA/IDQgOiAxIClcbiAgaWYgKG1vdmVbNF0pIGRpclsxXSAtPSBzcGVlZCAqIChNYXJjaGluZy5rZXlzLkFsdCA/IDQgOiAxIClcbiAgZWxzZSBpZiAobW92ZVs1XSkgZGlyWzFdICs9IHNwZWVkICogKE1hcmNoaW5nLmtleXMuQWx0ID8gNCA6IDEgKVxuICB0aGlzLm1vdmUoZGlyKVxuICAvLyBqdXN0IHVzZSBhcnJvdyBrZXlzIGluc3RlYWQgb2YgbW91c2VcbiAgLy8gdGhpcy5wb2ludGVyKG1vdXNlLCBwcmV2TW91c2UpXG59XG5cbkZpcnN0UGVyc29uQ2FtZXJhLnByb3RvdHlwZS5tb3ZlID0gZnVuY3Rpb24oZGlyKSB7XG4gIGlmIChkaXJbMF0gIT09IDAgfHwgZGlyWzFdICE9PSAwIHx8IGRpclsyXSAhPT0gMCkge1xuICAgIHZhciBjYW0gPSBtYXQ0LmNyZWF0ZSgpXG4gICAgbWF0NC5yb3RhdGVZKGNhbSwgY2FtLCB0aGlzLnJvdGF0aW9uWzFdKVxuICAgIG1hdDQucm90YXRlWChjYW0sIGNhbSwgdGhpcy5yb3RhdGlvblswXSlcbiAgICB2ZWMzLnRyYW5zZm9ybU1hdDQoZGlyLCBkaXIsIGNhbSlcbiAgICB2ZWMzLmFkZCh0aGlzLnBvc2l0aW9uLCB0aGlzLnBvc2l0aW9uLCBkaXIpXG4gICAgdGhpcy5wYXJlbnQucG9zLmRpcnR5ID0gdHJ1ZVxuXG4gIH1cbn1cblxuLy9GaXJzdFBlcnNvbkNhbWVyYS5wcm90b3R5cGUucG9pbnRlciA9IGZ1bmN0aW9uKGRhLCBkYikge1xuLy8gIHZhciBkdCA9IFtkYVswXSAtIGRiWzBdLCBkYVsxXS0gZGJbMV1dXG4vLyAgdmFyIHJvdCA9IHRoaXMucm90YXRpb25cbi8vICByb3RbMV0gLT0gZHRbMF0gKiB0aGlzLnJvdGF0aW9uU3BlZWRcbi8vICBpZiAocm90WzFdIDwgMCkgcm90WzFdICs9IE1hdGguUEkgKiAyXG4vLyAgaWYgKHJvdFsxXSA+PSBNYXRoLlBJICogMikgcm90WzFdIC09IE1hdGguUEkgKiAyXG4vLyAgcm90WzBdIC09IGR0WzFdICogdGhpcy5yb3RhdGlvblNwZWVkXG4vLyAgaWYgKHJvdFswXSA8IC1NYXRoLlBJICogLjUpIHJvdFswXSA9IC1NYXRoLlBJKjAuNVxuLy8gIGlmIChyb3RbMF0gPiBNYXRoLlBJICogLjUpIHJvdFswXSA9IE1hdGguUEkqMC41XG4vL31cblxuY29uc3QgQ2FtZXJhID0ge1xuICBpbml0KCBnbCwgcHJvZ3JhbSwgaGFuZGxlciApIHtcblxuICAgIGNvbnN0IGNhbWVyYSA9IEZpcnN0UGVyc29uQ2FtZXJhKHtcbiAgICAgIGZvdjogMTkwLFxuICAgICAgbmVhcjouMDEsXG4gICAgICBmYXI6MTAsXG4gICAgICBkaXJlY3Rpb246WzAsMCwxXSxcbiAgICAgIHZpZXdwb3J0OlsxLDEsMSwtMV1cbiAgICB9KVxuICAgIGNhbWVyYS5yb3RhdGlvbiA9IFswLE1hdGguUEksTWF0aC5QSV0gXG4gICAgQ2FtZXJhLl9fY2FtZXJhID0gY2FtZXJhXG4gICAgY2FtZXJhLnBhcmVudCA9IHRoaXNcblxuICAgIGNvbnN0IGNhbWVyYV9wb3MgICAgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdjYW1lcmFfcG9zJyApXG4gICAgY29uc3QgY2FtZXJhX25vcm1hbCA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgJ2NhbWVyYV9ub3JtYWwnIClcbiAgICBjb25zdCBjYW1lcmFfcm90ICAgID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCAnY2FtZXJhX3JvdCcgKVxuICAgIGNvbnN0IHVjYW1lcmEgICAgICAgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24oIHByb2dyYW0sICdjYW1lcmEnIClcblxuICAgIHRoaXMucG9zID0geyBkaXJ0eTpmYWxzZSB9XG4gICAgdGhpcy5kaXIgPSB7IGRpcnR5OnRydWUgfVxuICAgIHRoaXMuX19yb3QgPSB7IGRpcnR5OnRydWUsIHZhbHVlOjAgfVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCAncm90YXRpb24nLCB7XG4gICAgICBjb25maWd1cmFibGU6dHJ1ZSxcbiAgICAgIGdldCgpIHsgcmV0dXJuIHRoaXMuX19yb3QudmFsdWUgfSxcbiAgICAgIHNldCh2KSB7IFxuICAgICAgICB0aGlzLl9fcm90LnZhbHVlID0gdiBcbiAgICAgICAgdGhpcy5fX3JvdC5kaXJ0eSA9IHRydWVcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgbGV0IHB4ID0gMCwgcHkgPTAsIHB6ID0gNSwgbnggPSAwLCBueSA9IDAsIG56ID0gMFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKCB0aGlzLnBvcywge1xuICAgICAgeDoge1xuICAgICAgICBnZXQoKSAgeyByZXR1cm4gcHggfSxcbiAgICAgICAgc2V0KHYpIHsgcHggPSBjYW1lcmEucG9zaXRpb25bMF0gPSB2O3RoaXMuZGlydHkgPSB0cnVlOyB9XG4gICAgICB9LFxuXG4gICAgICB5OiB7XG4gICAgICAgIGdldCgpICB7IHJldHVybiBweSB9LFxuICAgICAgICBzZXQodikgeyBweSA9IGNhbWVyYS5wb3NpdGlvblsxXSA9IHY7IHRoaXMuZGlydHkgPSB0cnVlOyB9XG4gICAgICB9LFxuXG4gICAgICB6OiB7XG4gICAgICAgIGdldCgpICB7IHJldHVybiBweiB9LFxuICAgICAgICBzZXQodikgeyBweiA9IGNhbWVyYS5wb3NpdGlvblsyXSA9IHY7IHRoaXMuZGlydHkgPSB0cnVlOyB9XG4gICAgICB9LFxuICAgIH0pXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggdGhpcy5kaXIsIHtcbiAgICAgIHg6IHtcbiAgICAgICAgZ2V0KCkgIHsgcmV0dXJuIG54IH0sXG4gICAgICAgIHNldCh2KSB7IG54ID0gY2FtZXJhLnJvdGF0aW9uWzBdID0gdjsgdGhpcy5kaXJ0eSA9IHRydWU7IH1cbiAgICAgIH0sXG5cbiAgICAgIHk6IHtcbiAgICAgICAgZ2V0KCkgIHsgcmV0dXJuIG55IH0sXG4gICAgICAgIHNldCh2KSB7IG55ID0gY2FtZXJhLnJvdGF0aW9uWzFdID0gdjsgdGhpcy5kaXJ0eSA9IHRydWU7IH1cbiAgICAgIH0sXG5cbiAgICAgIHo6IHtcbiAgICAgICAgZ2V0KCkgIHsgcmV0dXJuIG56IH0sXG4gICAgICAgIHNldCh2KSB7IG56ID0gY2FtZXJhLnJvdGF0aW9uWzJdID0gdjsgdGhpcy5kaXJ0eSA9IHRydWU7IH1cbiAgICAgIH0sXG4gICAgfSlcblxuICAgIGxldCBpbml0ID0gZmFsc2VcbiAgICBnbC51bmlmb3JtM2YoIGNhbWVyYV9ub3JtYWwsIHRoaXMuZGlyLngsIHRoaXMuZGlyLnksIHRoaXMuZGlyLnogKVxuICAgIGNhbWVyYS5wb3NpdGlvbiA9IFt0aGlzLnBvcy54LCB0aGlzLnBvcy55LCB0aGlzLnBvcy56IF0gXG4gICAgLy9jYW1lcmEudXBkYXRlKClcbiAgICBnbC51bmlmb3JtM2YoIGNhbWVyYV9wb3MsIHRoaXMucG9zLngsIHRoaXMucG9zLnksIHRoaXMucG9zLnogKVxuICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYoIHVjYW1lcmEsIGZhbHNlLCBjYW1lcmEudmlldygpIClcbiAgICBnbC51bmlmb3JtMWYoIGNhbWVyYV9yb3QsIHRoaXMucm90ICkgXG5cbiAgICBDYW1lcmEubW92ZSA9ICh4LHkseikgPT4ge1xuICAgICAgLy8gWFhYIGRvZXMgdGhpcyBuZWVkIHRvIHVwZGF0ZSBwcm9wZXJ0eSB2YWx1ZXM/XG4gICAgICBjYW1lcmEubW92ZShbeCx5LHpdKVxuICAgICAgQ2FtZXJhLnVwZGF0ZSgpXG4gICAgfVxuICAgIENhbWVyYS5tb3ZlVG8gPSAoeCx5LHopID0+IHtcbiAgICAgIENhbWVyYS5wb3MueCA9IHhcbiAgICAgIENhbWVyYS5wb3MueSA9IHlcbiAgICAgIENhbWVyYS5wb3MueiA9IHpcbiAgICB9XG4gICAgQ2FtZXJhLnVwZGF0ZSA9ICgpPT4ge1xuICAgICAgY29uc3QgcG9zID0gY2FtZXJhLnBvc2l0aW9uXG4gICAgICBnbC51bmlmb3JtM2YoIGNhbWVyYV9wb3MsIHBvc1swXSwgcG9zWzFdLCBwb3NbMl0gIClcbiAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYoIHVjYW1lcmEsIGZhbHNlLCBjYW1lcmEudmlldygpIClcbiAgICB9XG5cbiAgICAvLyBkZXRlcm1pbmUgYW4gb2Zmc2V0IGZyb20gdGhlIGN1cnJlbnQgY2FtZXJhIHBvc2l0aW9uIGJhc2VkXG4gICAgLy8gb24gdGhlIGN1cnJlbnQgY2FtZXJhIHJvdGF0aW9uIGUuZy4gdG8gYWx3YXlzIHBvc2l0aW9uIGEgbGlnaHRcbiAgICAvLyBiZWhpbmQgdGhlIGNhbWVyYS5cbiAgICBDYW1lcmEub2Zmc2V0ID0gKGFtdD1bMCwwLDNdKSA9PiB7XG4gICAgICBjb25zdCBjYW0gPSBtYXQ0LmNyZWF0ZSgpXG4gICAgICBtYXQ0LnJvdGF0ZVkoY2FtLCBjYW0sIGNhbWVyYS5yb3RhdGlvblsxXSlcbiAgICAgIG1hdDQucm90YXRlWChjYW0sIGNhbSwgY2FtZXJhLnJvdGF0aW9uWzBdKVxuICAgICAgdmVjMy50cmFuc2Zvcm1NYXQ0KGFtdCwgYW10LCBjYW0pXG4gICAgICByZXR1cm4gYW10XG4gICAgfVxuXG4gICAgbGV0IHBydnggPSAwLCBwcnZ5ID0gMCwgeCA9IDAsIHkgPSAwXG4gICAgQ2FtZXJhLl9fbW91c2Vtb3ZlZm5jID0gZSA9PiB7XG4gICAgICBwcnZ4ID0geFxuICAgICAgcHJ2eSA9IHlcbiAgICAgIHggPSBlLnBhZ2VYXG4gICAgICB5ID0gZS5wYWdlWVxuICAgIH1cblxuICAgIGxldCBwcmV2VGltZSA9IDBcbiAgICBsZXQgayAgPSBNYXJjaGluZy5rZXlzXG4gICAgQ2FtZXJhLl9fZnJhbWVmbmMgPSB0ID0+IHtcbiAgICAgIGlmKCBrLkFycm93TGVmdCApIGNhbWVyYS5yb3RhdGlvblsxXSArPSBjYW1lcmEucm90YXRpb25TcGVlZFxuICAgICAgaWYoIGsuQXJyb3dSaWdodCApIGNhbWVyYS5yb3RhdGlvblsxXSAtPSBjYW1lcmEucm90YXRpb25TcGVlZFxuICAgICAgaWYoIGsuQXJyb3dVcCAmJiAhay5TaGlmdCApIGNhbWVyYS5yb3RhdGlvblswXSAtPSBjYW1lcmEucm90YXRpb25TcGVlZFxuICAgICAgaWYoIGsuQXJyb3dEb3duICYmICFrLlNoaWZ0KSBjYW1lcmEucm90YXRpb25bMF0gKz0gY2FtZXJhLnJvdGF0aW9uU3BlZWRcbiAgICAgIFxuICAgICAgaWYoIE1hcmNoaW5nLmNhbWVyYUVuYWJsZWQgKSB7IFxuICAgICAgICBjYW1lcmEuY29udHJvbCggXG4gICAgICAgICAgdCoxMDAwIC0gcHJldlRpbWUsXG4gICAgICAgICAgW2sudyxrLnMsay5kLGsuYSxrLkFycm93VXAgJiYgay5TaGlmdCwgay5BcnJvd0Rvd24gJiYgay5TaGlmdF0sIFxuICAgICAgICAgIFt4LHldLCBbcHJ2eCxwcnZ5XSBcbiAgICAgICAgKVxuICAgICAgICBDYW1lcmEudXBkYXRlKClcbiAgICAgICAgcHJ2eCA9IHhcbiAgICAgICAgcHJ2eSA9IHlcbiAgICAgICAgcHJldlRpbWUgPSB0KjEwMDBcbiAgICAgIH1cbiAgICB9XG5cbiAgICBDYW1lcmEuX19tb3VzZW1vdmUgPSBudWxsXG4gICAgQ2FtZXJhLm9uID0gKCk9PiB7XG4gICAgICBpZiggQ2FtZXJhLl9fbW91c2Vtb3ZlID09PSBudWxsICkge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggJ21vdXNlbW92ZScsIENhbWVyYS5fX21vdXNlbW92ZWZuYyApXG4gICAgICAgIENhbWVyYS5fX21vdXNlbW92ZSA9IHRydWVcbiAgICAgIH1cbiAgICAgIGlmKCBNYXJjaGluZy5jYWxsYmFja3MuaW5kZXhPZiggQ2FtZXJhLl9fZnJhbWVmbmMgKSA9PT0gLTEgKSB7XG4gICAgICAgIE1hcmNoaW5nLmNhbGxiYWNrcy5wdXNoKCBDYW1lcmEuX19mcmFtZWZuYyApXG4gICAgICB9XG4gICAgfVxuXG4gICAgaGFuZGxlciggKCk9PiB7XG4gICAgICBpZiggdGhpcy5wb3MuZGlydHkgPT09IHRydWUgKSB7XG5cbiAgICAgICAgLy9jYW1lcmEucG9zaXRpb24gPSBbdGhpcy5wb3MueCwgdGhpcy5wb3MueSwgdGhpcy5wb3MueiBdXG4gXG4gICAgICAgIC8vY2FtZXJhLnBvc2l0aW9uID0gW3RoaXMucG9zLngsIHRoaXMucG9zLnksIHRoaXMucG9zLnogXVxuICAgICAgICAvL2NhbWVyYS51cGRhdGUoKVxuICAgICAgICBjb25zdCBwb3MgPSBjYW1lcmEucG9zaXRpb25cbiAgICAgICAgZ2wudW5pZm9ybTNmKCBjYW1lcmFfcG9zLCBwb3NbMF0sIHBvc1sxXSwgcG9zWzJdIClcbiAgICAgICAgZ2wudW5pZm9ybU1hdHJpeDRmdiggdWNhbWVyYSwgZmFsc2UsIGNhbWVyYS52aWV3KCkgKVxuICAgICAgICB0aGlzLnBvcy5kaXJ0eSA9IGZhbHNlXG5cblxuICAgICAgfVxuXG4gICAgICAvLyBYWFggdGhpcyBpcyBicm9rZW4gYW5kIG5lZWRzIHRvIGJlIGZpeGVkXG4gICAgICBpZiggdGhpcy5kaXIuZGlydHkgPT09IHRydWUgKSB7XG4gICAgICAgIGdsLnVuaWZvcm0zZiggY2FtZXJhX25vcm1hbCwgdGhpcy5kaXIueCwgdGhpcy5kaXIueSwgdGhpcy5kaXIueiApXG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYoIHVjYW1lcmEsIGZhbHNlLCBjYW1lcmEudmlldygpIClcbiAgICAgICAgdGhpcy5kaXIuZGlydHkgPSBmYWxzZVxuICAgICAgfVxuICAgICAgaWYoIHRoaXMuX19yb3QuZGlydHkgPT09IHRydWUgKSB7XG4gICAgICAgIGdsLnVuaWZvcm0xZiggY2FtZXJhX3JvdCwgdGhpcy5fX3JvdC52YWx1ZSApXG4gICAgICAgIHRoaXMuX19yb3QuZGlydHkgPSBmYWxzZVxuICAgICAgfVxuICAgICAgaWYoIHR5cGVvZiB0aGlzLm9ubW92ZSA9PT0gJ2Z1bmN0aW9uJyApIHtcbiAgICAgICAgdGhpcy5vbm1vdmUoIHRoaXMgKVxuICAgICAgfVxuICAgIH0pXG5cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENhbWVyYVxuIiwiY29uc3QgU2NlbmVOb2RlID0gcmVxdWlyZSggJy4vc2NlbmVOb2RlLmpzJyApXG5jb25zdCB7IHBhcmFtX3dyYXAsIE1hdGVyaWFsSUQgfSA9IHJlcXVpcmUoICcuL3V0aWxzLmpzJyApXG5jb25zdCB7IFZhciwgZmxvYXRfdmFyX2dlbiwgdmVjMl92YXJfZ2VuLCB2ZWMzX3Zhcl9nZW4sIHZlYzRfdmFyX2dlbiwgaW50X3Zhcl9nZW4sIFZhckFsbG9jIH0gPSByZXF1aXJlKCAnLi92YXIuanMnIClcbmNvbnN0IFRyYW5zZm9ybSA9IHJlcXVpcmUoICcuL3RyYW5zZm9ybS5qcycgKVxuXG5jb25zdCBvcHMgPSB7IFxuICAvLyB0aGlzIG5lZWRzIHRvIGNyZWF0ZSBhbiBvcE91dCwgbm90IHJldHVybiBhIHZlYzJcbiAgRGlzcGxhY2UoIF9fbmFtZSApIHtcbiAgICBsZXQgbmFtZSA9IF9fbmFtZSA9PT0gdW5kZWZpbmVkID8gJ3AnIDogX19uYW1lXG4gICAgY29uc3Qgc2RmID0gdGhpcy5zZGYuZW1pdCggbmFtZSApO1xuXG4gICAgY29uc3Qgc2RmU3RyID0gYGZsb2F0IGQxJHt0aGlzLmlkfSA9ICR7c2RmLm91dH0ueDtcXG5gXG5cbiAgICBsZXQgZGlzcGxhY2VTdHJpbmcgPSBgZmxvYXQgZDIke3RoaXMuaWR9ID0gc2luKCAke3RoaXMuYW1vdW50LmVtaXQoKX0ueCAqICR7bmFtZX0ueCApICogYCAgXG4gICAgZGlzcGxhY2VTdHJpbmcgKz0gYHNpbiggJHt0aGlzLmFtb3VudC5lbWl0KCl9LnkgKiAke25hbWV9LnkgKSAqIGBcbiAgICBkaXNwbGFjZVN0cmluZyArPSBgc2luKCAke3RoaXMuYW1vdW50LmVtaXQoKX0ueiAqICR7bmFtZX0ueiApO1xcbmBcbiAgICBkaXNwbGFjZVN0cmluZyArPSBgJHtzZGYub3V0fS54ID0gKGQxJHt0aGlzLmlkfSArIGQyJHt0aGlzLmlkfSoke3RoaXMuc2l6ZS5lbWl0KCl9KSouNTtcXG5gXG5cbiAgICBjb25zdCBvdXRwdXQgPSB7XG4gICAgICBvdXQ6IGAke3NkZi5vdXR9YCwgXG4gICAgICBwcmVmYWNlOiBzZGYucHJlZmFjZSArIHNkZlN0ciArIGRpc3BsYWNlU3RyaW5nIFxuICAgIH1cblxuICAgIHJldHVybiBvdXRwdXRcbiAgfSxcblxuICBCZW5kKCBfX25hbWUgKSB7XG4gICAgbGV0IG5hbWUgPSBfX25hbWUgPT09IHVuZGVmaW5lZCA/ICdwJyA6IF9fbmFtZVxuICAgIGNvbnN0IHNkZiA9IHRoaXMuc2RmLmVtaXQoICdxJyt0aGlzLmlkICk7XG5cbiAgICBsZXQgcHJlZmFjZT1gICAgICAgICBmbG9hdCBjJHt0aGlzLmlkfSA9IGNvcyggJHt0aGlzLmFtb3VudC5lbWl0KCl9LnggKiAke25hbWV9LnggKTtcbiAgICAgICAgZmxvYXQgcyR7dGhpcy5pZH0gPSBzaW4oICR7dGhpcy5hbW91bnQuZW1pdCgpfS54ICogJHtuYW1lfS54ICk7XG4gICAgICAgIG1hdDIgIG0ke3RoaXMuaWR9ID0gbWF0MiggYyR7dGhpcy5pZH0sLXMke3RoaXMuaWR9LHMke3RoaXMuaWR9LGMke3RoaXMuaWR9ICk7XG4gICAgICAgIHZlYzQgIHEke3RoaXMuaWR9ID0gdmVjNCggbSR7dGhpcy5pZH0gKiAke25hbWV9Lnh5LCAke25hbWV9LnosIDEuICk7XFxuYFxuXG4gICAgaWYoIHR5cGVvZiBzZGYucHJlZmFjZSA9PT0gJ3N0cmluZycgKSB7XG4gICAgICBwcmVmYWNlICs9IHNkZi5wcmVmYWNlXG4gICAgfVxuXG4gICAgcmV0dXJuIHsgcHJlZmFjZSwgb3V0OnNkZi5vdXQgfVxuICB9LFxuXG4gIFR3aXN0KCBfX25hbWUgKSB7XG4gICAgbGV0IG5hbWUgPSBfX25hbWUgPT09IHVuZGVmaW5lZCA/ICdwJyA6IF9fbmFtZVxuICAgIGNvbnN0IHNkZiA9IHRoaXMuc2RmLmVtaXQoICdxJyt0aGlzLmlkICk7XG5cbiAgICBsZXQgcHJlZmFjZT1gICAgICAgICBmbG9hdCBjJHt0aGlzLmlkfSA9IGNvcyggJHt0aGlzLmFtb3VudC5lbWl0KCl9LnggKiAke25hbWV9LnkgKTtcbiAgICAgICAgZmxvYXQgcyR7dGhpcy5pZH0gPSBzaW4oICR7dGhpcy5hbW91bnQuZW1pdCgpfS54ICogJHtuYW1lfS55ICk7XG4gICAgICAgIG1hdDIgIG0ke3RoaXMuaWR9ID0gbWF0MiggYyR7dGhpcy5pZH0sLXMke3RoaXMuaWR9LHMke3RoaXMuaWR9LGMke3RoaXMuaWR9ICk7XG4gICAgICAgIHZlYzQgIHEke3RoaXMuaWR9ID0gdmVjNCggbSR7dGhpcy5pZH0gKiAke25hbWV9Lnh6LCAke25hbWV9LnksIDEuICk7XFxuYFxuXG4gICAgaWYoIHR5cGVvZiBzZGYucHJlZmFjZSA9PT0gJ3N0cmluZycgKSB7XG4gICAgICBwcmVmYWNlICs9IHNkZi5wcmVmYWNlXG4gICAgfVxuXG4gICAgcmV0dXJuIHsgcHJlZmFjZSwgb3V0OnNkZi5vdXQgfVxuICB9LFxuICBfX0J1bXAoIF9fbmFtZSApIHtcbiAgICBsZXQgbmFtZSA9IF9fbmFtZSA9PT0gdW5kZWZpbmVkID8gJ3AnIDogX19uYW1lXG5cbiAgICBjb25zdCBidW1wU3RyaW5nID0gIGAgICAgICAgIHZlYzQgdHJhbnNmb3JtQnVtcCR7dGhpcy5pZH0gPSAke25hbWV9ICogJHt0aGlzLnRyYW5zZm9ybS5lbWl0KCl9O1xcbmBcbiAgICBjb25zdCB0ZXggPSB0aGlzLmFtb3VudC5lbWl0KCBuYW1lIClcblxuICAgIGNvbnN0IHBvaW50U3RyaW5nID0gYCh0cmFuc2Zvcm1CdW1wJHt0aGlzLmlkfSAqICR7dGhpcy5zZGYudHJhbnNmb3JtLmVtaXQoKX0pYFxuXG4gICAgY29uc3Qgc2RmID0gdGhpcy5zZGYuZW1pdCggcG9pbnRTdHJpbmcsIHRoaXMudHJhbnNmb3JtLCBgdGV4JHt0aGlzLmlkfWAgKSBcblxuICAgIE1hcmNoaW5nLnRleHR1cmVzLmFkZFRleHR1cmUoIHRoaXMuYW1vdW50LnZhbHVlIClcblxuICAgIGxldCBwcmVmYWNlPWAgIHZlYzMgdGV4JHt0aGlzLmlkfSA9IGdldFRleHR1cmUoICR7dGhpcy5hbW91bnQudmFsdWUuaWR9LCAke3BvaW50U3RyaW5nfS54eXogKSAqICR7dGhpcy5zaXplLmVtaXQoKX07XFxuXG4gICAgICAgIC8vdmVjNCBkaXNwbGFjZUJ1bXAke3RoaXMuaWR9ID0gdmVjNCgoJHtwb2ludFN0cmluZ30gLSB0ZXgke3RoaXMuaWR9KSwgMS4pO1xuICAgIGBcbiAgICAgICAgLy8ke3NkZi5vdXR9LnggPSAodGV4JHt0aGlzLmlkfS54ICsgdGV4JHt0aGlzLmlkfS55ICsgdGV4JHt0aGlzLmlkfS56ICkgLyAzLiAqIC41ICsgJHtzZGYub3V0fS54O1xcbmBcbiAgICAgICAgLy92ZWM0ICR7J3AnK3RoaXMuaWR9ID0gdmVjNCgke3BvaW50U3RyaW5nfSArIHRleCR7dGhpcy5pZH0sIDEuKTtcXG5gXG5cbiAgICAvL3NkZi5wcmVmYWNlICs9IGBcXG4gICAgICAgIFxuICAgIC8vICAgICR7c2RmLm91dH0ueCAtPSBtaW4odGV4JHt0aGlzLmlkfS54LCBtaW4odGV4JHt0aGlzLmlkfS55LCB0ZXgke3RoaXMuaWR9LnopKTtcXG5gIFxuXG4gICAgaWYoIHR5cGVvZiBzZGYucHJlZmFjZSA9PT0gJ3N0cmluZycgKSB7XG4gICAgICBwcmVmYWNlID0gcHJlZmFjZSArIHNkZi5wcmVmYWNlXG4gICAgfVxuXG4gICAgcHJlZmFjZSA9ICBidW1wU3RyaW5nICsgcHJlZmFjZVxuXG4gICAgcmV0dXJuIHsgcHJlZmFjZSwgb3V0OnNkZi5vdXQgfVxuICB9LFxuICAvLyBYWFggdG9kbzogc29tZXRoaW5nIGxpa2UgaHR0cHM6Ly93d3cuc2hhZGVydG95LmNvbS92aWV3L2xkU0d6UlxuICAvLyBodHRwczovL3d3dy5kcm9wYm94LmNvbS9zL2wxeWwxNjRqYjNyaG9tcS9tbV9zZmdyYWRfYnVtcC5wZGY/ZGw9MFxuICBCdW1wKCBfX25hbWUgKSB7XG4gICAgbGV0IG5hbWUgPSBfX25hbWUgPT09IHVuZGVmaW5lZCA/ICdwJyA6IF9fbmFtZVxuXG4gICAgY29uc3QgYnVtcFN0cmluZyA9ICBgICAgICAgICB2ZWM0IHRyYW5zZm9ybUJ1bXAke3RoaXMuaWR9ID0gJHtuYW1lfSAqICR7dGhpcy50cmFuc2Zvcm0uZW1pdCgpfTtcXG5gXG4gICAgY29uc3QgdGV4ID0gdGhpcy5hbW91bnQuZW1pdCggbmFtZSApXG5cbiAgICBjb25zdCBwb2ludFN0cmluZyA9IGAodHJhbnNmb3JtQnVtcCR7dGhpcy5pZH0gKiAke3RoaXMuc2RmLnRyYW5zZm9ybS5lbWl0KCl9KS54eXpgXG5cbiAgICBjb25zdCBzZGYgPSB0aGlzLnNkZi5lbWl0KCBgdHJhbnNmb3JtQnVtcCR7dGhpcy5pZH1gLCB0aGlzLnRyYW5zZm9ybSApIFxuXG4gICAgTWFyY2hpbmcudGV4dHVyZXMuYWRkVGV4dHVyZSggdGhpcy5hbW91bnQudmFsdWUgKVxuXG4gICAgbGV0IHByZWZhY2U9YCAgdmVjMyB0ZXgke3RoaXMuaWR9ID0gZ2V0VGV4dHVyZSggJHt0aGlzLmFtb3VudC52YWx1ZS5pZH0sICR7cG9pbnRTdHJpbmd9KSAqICR7dGhpcy5zaXplLmVtaXQoKX07XG4gICAgICAgICR7c2RmLm91dH0ueCA9ICh0ZXgke3RoaXMuaWR9LnggKyB0ZXgke3RoaXMuaWR9LnkgKyB0ZXgke3RoaXMuaWR9LnopLzMuICsgJHtzZGYub3V0fS54O1xcbmBcblxuICAgIGlmKCB0eXBlb2Ygc2RmLnByZWZhY2UgPT09ICdzdHJpbmcnICkge1xuICAgICAgcHJlZmFjZSA9IHNkZi5wcmVmYWNlICsgcHJlZmFjZVxuICAgIH1cblxuICAgIHByZWZhY2UgPSBidW1wU3RyaW5nICsgcHJlZmFjZVxuXG4gICAgcmV0dXJuIHsgcHJlZmFjZSwgb3V0OnNkZi5vdXQgfVxuICB9LFxufVxuXG5jb25zdCBEaXN0YW5jZU9wcyA9IHt9XG5cbmZvciggbGV0IG5hbWUgaW4gb3BzICkge1xuXG4gIC8vIGdldCBjb2RlZ2VuIGZ1bmN0aW9uXG4gIGxldCBfX29wID0gb3BzWyBuYW1lIF1cblxuICAvLyBjcmVhdGUgY29uc3RydWN0b3JcbiAgRGlzdGFuY2VPcHNbIG5hbWUgXSA9IGZ1bmN0aW9uKCBhLGIsYyApIHtcbiAgICBjb25zdCBvcCA9IE9iamVjdC5jcmVhdGUoIERpc3RhbmNlT3BzWyBuYW1lIF0ucHJvdG90eXBlIClcbiAgICBvcC5zZGYgPSBhXG4gICAgb3AuYW1vdW50ID0gYlxuICAgIG9wLmVtaXQgPSBfX29wXG4gICAgb3AubmFtZSA9IG5hbWVcbiAgICBvcC50cmFuc2Zvcm0gPSBUcmFuc2Zvcm0oKVxuXG4gICAgY29uc3QgZGVmYXVsdFZhbHVlcyA9IFsuNSwuNSwuNV1cblxuICAgIG9wLmlkID0gVmFyQWxsb2MuYWxsb2MoKVxuICAgIGNvbnN0IGlzQXJyYXkgPSB0cnVlIFxuICAgIFxuICAgIGlmKCB0eXBlb2YgYiA9PT0gJ251bWJlcicgKSB7XG4gICAgICBiID0gW2IsYixiXVxuICAgICAgYi50eXBlID0gJ3ZlYzMnXG4gICAgfVxuICAgIFxuICAgIGlmKCBuYW1lICE9PSAnQnVtcHonICkge1xuICAgICAgbGV0IF9fdmFyID0gIHBhcmFtX3dyYXAoIFxuICAgICAgICBiLCBcbiAgICAgICAgdmVjM192YXJfZ2VuKCAuLi5kZWZhdWx0VmFsdWVzICkgXG4gICAgICApXG5cbiAgICAgIC8vIGZvciBhc3NpZ25pbmcgZW50aXJlIG5ldyB2ZWN0b3JzIHRvIHByb3BlcnR5XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIG9wLCAnYW1vdW50Jywge1xuICAgICAgICBnZXQoKSB7IHJldHVybiBfX3ZhciB9LFxuICAgICAgICBzZXQodikge1xuICAgICAgICAgIGlmKCB0eXBlb2YgdiA9PT0gJ29iamVjdCcgKSB7XG4gICAgICAgICAgICBfX3Zhci5zZXQoIHYgKVxuICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgX192YXIudmFsdWUueCA9IHZcbiAgICAgICAgICAgIF9fdmFyLnZhbHVlLnkgPSB2XG4gICAgICAgICAgICBfX3Zhci52YWx1ZS56ID0gdlxuICAgICAgICAgICAgX192YXIudmFsdWUudyA9IHZcbiAgICAgICAgICAgIF9fdmFyLmRpcnR5ID0gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgb3AucGFyYW1zID0gW3sgbmFtZTonYW1vdW50JyB9XVxuICAgIH1lbHNle1xuICAgICAgb3AucGFyYW1zID0gW11cbiAgICAgIG9wLmVtaXRfZGVjbCA9IGZ1bmN0aW9uKCkge31cbiAgICAgIG9wLmVtaXQgPSBmdW5jdGlvbigpIHt9XG4gICAgICBvcC51cGRhdGVfZGF0YT0gZnVuY3Rpb24oKSB7fVxuICAgICAgb3AudXBsb2FkX2xvY2F0aW9uID0gZnVuY3Rpb24oKSB7fVxuICAgIH1cbiAgICBvcC5fX3NldE1hdGVyaWFsID0gZnVuY3Rpb24obWF0KSB7XG4gICAgICBpZiggdHlwZW9mIG1hdCA9PT0gJ3N0cmluZycgKSBtYXQgPSBNYXJjaGluZy5NYXRlcmlhbFsgbWF0IF1cbiAgICAgIHRoaXMuX19tYXRlcmlhbCA9IHRoaXMubWF0ID0gTWFyY2hpbmcubWF0ZXJpYWxzLmFkZE1hdGVyaWFsKCBtYXQgKVxuICAgICAgb3Auc2RmLm1hdGVyaWFsKCB0aGlzLl9fbWF0ZXJpYWwgKVxuICAgIH1cbiAgICBpZiggbmFtZSA9PT0gJ0Rpc3BsYWNlJyB8fCBuYW1lID09PSAnQnVtcCcgKSB7XG4gICAgICBsZXQgX192YXIyID0gIHBhcmFtX3dyYXAoIFxuICAgICAgICBjLCBcbiAgICAgICAgZmxvYXRfdmFyX2dlbiggLjAzICkgXG4gICAgICApXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIG9wLCAnc2l6ZScsIHtcbiAgICAgICAgZ2V0KCkgeyByZXR1cm4gX192YXIyIH0sXG4gICAgICAgIHNldCh2KSB7XG4gICAgICAgICAgX192YXIyLnNldCggdiApXG4gICAgICAgICAgX192YXIyLmRpcnR5ID0gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICBvcC5wYXJhbXMucHVzaCh7IG5hbWU6J3NpemUnIH0pXG4gICAgfVxuICAgIG9wLl9fZGVzYyA9IHsgcGFyYW1ldGVyczpvcC5wYXJhbXMgfVxuICAgIHJldHVybiBvcFxuICB9IFxuXG4gIERpc3RhbmNlT3BzWyBuYW1lIF0ucHJvdG90eXBlID0gU2NlbmVOb2RlKClcblxuICBEaXN0YW5jZU9wc1tuYW1lXS5wcm90b3R5cGUuZW1pdF9kZWNsID0gZnVuY3Rpb24gKCkge1xuICAgIGxldCBzdHIgPSAgdGhpcy5zZGYuZW1pdF9kZWNsKCkgKyAodGhpcy5uYW1lICE9PSAnQnVtcCcgPyB0aGlzLmFtb3VudC5lbWl0X2RlY2woKSA6ICcnKVxuICAgIHN0ciArPSB0aGlzLnRyYW5zZm9ybS5lbWl0X2RlY2woKVxuICAgIGlmKCB0aGlzLm5hbWUgPT09ICdEaXNwbGFjZScgfHwgdGhpcy5uYW1lID09PSAnQnVtcCcgKSBzdHIgKz0gdGhpcy5zaXplLmVtaXRfZGVjbCgpICBcblxuICAgIHJldHVybiBzdHJcbiAgfTtcblxuICBEaXN0YW5jZU9wc1tuYW1lXS5wcm90b3R5cGUudXBkYXRlX2xvY2F0aW9uID0gZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgICB0aGlzLnNkZi51cGRhdGVfbG9jYXRpb24oIGdsLCBwcm9ncmFtIClcbiAgICBpZiggdGhpcy5uYW1lICE9PSAnQnVtcCcgKSB0aGlzLmFtb3VudC51cGRhdGVfbG9jYXRpb24oIGdsLCBwcm9ncmFtIClcbiAgICBpZiggdGhpcy5uYW1lID09PSAnRGlzcGxhY2UnIHx8IHRoaXMubmFtZSA9PT0gJ0J1bXAnKSB0aGlzLnNpemUudXBkYXRlX2xvY2F0aW9uKCBnbCwgcHJvZ3JhbSApIFxuICAgIHRoaXMudHJhbnNmb3JtLnVwZGF0ZV9sb2NhdGlvbiggZ2wsIHByb2dyYW0gKVxuICB9XG5cbiAgRGlzdGFuY2VPcHNbbmFtZV0ucHJvdG90eXBlLnVwbG9hZF9kYXRhID0gZnVuY3Rpb24oZ2wpIHtcbiAgICB0aGlzLnNkZi51cGxvYWRfZGF0YSggZ2wgKVxuICAgIGlmKCB0aGlzLm5hbWUgIT09ICdCdW1wJyApIHRoaXMuYW1vdW50LnVwbG9hZF9kYXRhKCBnbCApXG4gICAgaWYoIHRoaXMubmFtZSA9PT0gJ0Rpc3BsYWNlJyB8fCB0aGlzLm5hbWUgPT09ICdCdW1wJykgdGhpcy5zaXplLnVwbG9hZF9kYXRhKCBnbCApXG4gICAgdGhpcy50cmFuc2Zvcm0udXBsb2FkX2RhdGEoIGdsIClcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERpc3RhbmNlT3BzXG5cbiIsImNvbnN0IFNjZW5lTm9kZSA9IHJlcXVpcmUoICcuL3NjZW5lTm9kZS5qcycgKVxuY29uc3QgeyBwYXJhbV93cmFwLCBNYXRlcmlhbElEIH0gPSByZXF1aXJlKCAnLi91dGlscy5qcycgKVxuY29uc3QgeyBWYXIsIGZsb2F0X3Zhcl9nZW4sIHZlYzJfdmFyX2dlbiwgdmVjM192YXJfZ2VuLCB2ZWM0X3Zhcl9nZW4sIGludF92YXJfZ2VuLCBWYXJBbGxvYyB9ID0gcmVxdWlyZSggJy4vdmFyLmpzJyApXG5jb25zdCBUcmFuc2Zvcm0gPSByZXF1aXJlKCAnLi90cmFuc2Zvcm0uanMnIClcbmNvbnN0IGdsc2xvcHMgPSByZXF1aXJlKCAnLi9kaXN0YW5jZU9wZXJhdGlvbnNHTFNMLmpzJyApXG5cbmNvbnN0IG9wc2xlbiA9IHsgXG4gIFVuaW9uOjIsXG4gIEludGVyc2VjdGlvbjoyLFxuICBEaWZmZXJlbmNlOjIsXG4gIFN0YWlyc1VuaW9uOjQsXG4gIFN0YWlyc0ludGVyc2VjdGlvbjo0LFxuICBTdGFpcnNEaWZmZXJlbmNlOjQsXG4gIFJvdW5kVW5pb246MyxcbiAgUm91bmREaWZmZXJlbmNlOjMsXG4gIFJvdW5kSW50ZXJzZWN0aW9uOjMsXG4gIENoYW1mZXJVbmlvbjozLFxuICBDaGFtZmVyRGlmZmVyZW5jZTozLFxuICBDaGFtZmVySW50ZXJzZWN0aW9uOjMsXG4gIFBpcGU6MyxcbiAgRW5ncmF2ZTozLFxuICBHcm9vdmU6NCxcbiAgVG9uZ3VlOjQsXG4gIFxuICAvLyB0aGVzZSB0d28gZG8gbm90IGN1cnJlbnRseSBoYXZlIHN1cHBvcnQgZm9yIHRyYW5zZm9ybXMgb3IgcmVwZWF0cy4uLlxuICBPbmlvbjoyLFxuICBTd2l0Y2g6MlxufVxuXG5jb25zdCBvcHMgPSB7IFxuICBVbmlvbiggLi4uYXJncyApIHsgcmV0dXJuIGBvcFUoICR7YXJncy5qb2luKCcsJyl9IClgIH0sXG4gIFNtb290aFVuaW9uKCAuLi5hcmdzICApIHsgcmV0dXJuIGBvcFNtb290aFVuaW9uKCAke2FyZ3Muam9pbignLCcpfSApYCB9LFxuICBJbnRlcnNlY3Rpb24oIC4uLmFyZ3MgKSB7IHJldHVybiBgb3BJKCAke2FyZ3Muam9pbignLCcpfSApYCB9LFxuICBTbW9vdGhJbnRlcnNlY3Rpb24oIC4uLmFyZ3MgKSB7IHJldHVybiBgb3BTbW9vdGhJbnRlcnNlY3Rpb24oICR7YXJncy5qb2luKCcsJyl9IClgIH0sICBcbiAgRGlmZmVyZW5jZSggLi4uYXJncyApIHsgcmV0dXJuIGBvcFMoICR7YXJncy5qb2luKCcsJyl9IClgIH0sICBcbiAgU21vb3RoRGlmZmVyZW5jZSggLi4uYXJncyApIHsgcmV0dXJuIGBvcFNtb290aFN1YnRyYWN0aW9uKCAke2FyZ3Muam9pbignLCcpfSApYCB9LCAgXG4gIFN0YWlyc1VuaW9uKCAgLi4uYXJncyApIHsgcmV0dXJuIGBmT3BVbmlvblN0YWlycyggJHthcmdzLmpvaW4oJywnKX0gKWAgIH0sXG4gIFN0YWlyc0ludGVyc2VjdGlvbiggLi4uYXJncyApIHsgcmV0dXJuIGBmT3BJbnRlcnNlY3Rpb25TdGFpcnMoICR7YXJncy5qb2luKCcsJyl9IClgIH0sXG4gIFN0YWlyc0RpZmZlcmVuY2UoIC4uLmFyZ3MgKSB7IHJldHVybiBgZk9wU3Vic3RyYWN0aW9uU3RhaXJzKCAke2FyZ3Muam9pbignLCcpfSApYCB9LFxuICBSb3VuZFVuaW9uKCAuLi5hcmdzICkgeyByZXR1cm4gYGZPcFVuaW9uUm91bmQoICR7YXJncy5qb2luKCcsJyl9IClgIH0sXG4gIFJvdW5kRGlmZmVyZW5jZSggLi4uYXJncyApIHsgcmV0dXJuIGBmT3BEaWZmZXJlbmNlUm91bmQoICR7YXJncy5qb2luKCcsJyl9IClgIH0sXG4gIFJvdW5kSW50ZXJzZWN0aW9uKCAuLi5hcmdzICkgeyByZXR1cm4gYGZPcEludGVyc2VjdGlvblJvdW5kKCAke2FyZ3Muam9pbignLCcpfSApYCB9LFxuICBDaGFtZmVyVW5pb24oIC4uLmFyZ3MgKSB7IHJldHVybiBgZk9wVW5pb25DaGFtZmVyKCAke2FyZ3Muam9pbignLCcpfSApYCB9LFxuICBDaGFtZmVyRGlmZmVyZW5jZSggLi4uYXJncyApIHsgcmV0dXJuIGBmT3BEaWZmZXJlbmNlQ2hhbWZlciggJHthcmdzLmpvaW4oJywnKX0gKWAgfSxcbiAgQ2hhbWZlckludGVyc2VjdGlvbiggLi4uYXJncyApIHsgcmV0dXJuIGBmT3BJbnRlcnNlY3Rpb25DaGFtZmVyKCAke2FyZ3Muam9pbignLCcpfSApYCB9LFxuICBQaXBlKCAuLi5hcmdzICkgeyByZXR1cm4gYGZPcFBpcGUoICR7YXJncy5qb2luKCcsJyl9IClgIH0sXG4gIEVuZ3JhdmUoIC4uLmFyZ3MgKSB7IHJldHVybiBgZk9wRW5ncmF2ZSggJHthcmdzLmpvaW4oJywnKX0gKWAgfSxcbiAgR3Jvb3ZlKCAuLi5hcmdzICkgeyByZXR1cm4gYGZPcEdyb292ZSggJHthcmdzLmpvaW4oJywnKX0gKWAgfSxcbiAgVG9uZ3VlKCAuLi5hcmdzICkgeyByZXR1cm4gYGZPcFRvbmd1ZSggJHthcmdzLmpvaW4oJywnKX0gKWAgfSxcbiAgXG4gIC8vIHRoZXNlIHR3byBkbyBub3QgY3VycmVudGx5IGhhdmUgc3VwcG9ydCBmb3IgdHJhbnNmb3JtcyBvciByZXBlYXRzLi4uXG4gIE9uaW9uKCBhLGIgKSB7IHJldHVybiBgb3BPbmlvbiggJHthfSwgJHtifSApYCB9LFxuICBTd2l0Y2goIGEsYixjLGQsZSxmICkgeyByZXR1cm4gYG9wU3dpdGNoKCAke2F9LCAke2J9LCAke2N9IClgIH1cbn1cblxuY29uc3QgZW1pdF9mbG9hdCA9IGZ1bmN0aW9uKCBhICkge1xuXHRpZiAoYSAlIDEgPT09IDApXG5cdFx0cmV0dXJuIGEudG9GaXhlZCggMSApXG5cdGVsc2Vcblx0XHRyZXR1cm4gYVxufVxuXG5jb25zdCBEaXN0YW5jZU9wcyA9IHtcbiAgX19nbHNsOltdLFxuICBfX2dldEdMU0woKSB7XG4gICAgcmV0dXJuIHRoaXMuX19nbHNsLmpvaW4oJ1xcbicpXG4gIH0sXG4gIF9fY2xlYXIoKSB7IHRoaXMuX19nbHNsLmxlbmd0aCA9IDAgfVxufVxuXG5cbmZvciggbGV0IG5hbWUgaW4gb3BzICkge1xuXG4gIC8vIGdldCBjb2RlZ2VuIGZ1bmN0aW9uXG4gIGxldCBvcCA9IG9wc1sgbmFtZSBdXG4gIGNvbnN0IG5hbWUyID0gbmFtZSArICcyJ1xuXG4gIC8vIGNyZWF0ZSBjb25zdHJ1Y3RvclxuICBEaXN0YW5jZU9wc1sgbmFtZSBdID0gZnVuY3Rpb24oIGEsYixjLGQgKSB7XG4gICAgY29uc3Qgb3AgPSBPYmplY3QuY3JlYXRlKCBEaXN0YW5jZU9wc1sgbmFtZSBdLnByb3RvdHlwZSApXG4gICAgb3AuYSA9IGFcbiAgICBvcC5iID0gYlxuICAgIG9wLnRyYW5zZm9ybSA9IFRyYW5zZm9ybSggZmFsc2UgKVxuICAgIG9wLmlkID0gVmFyQWxsb2MuYWxsb2MoKVxuICAgIG9wLnR5cGUgPSAnZGlzdGFuY2Vfb3AnXG4gICAgb3AubmFtZSA9IG5hbWVcblxuICAgIGxldCBfX2MgPSBwYXJhbV93cmFwKCBjLCBmbG9hdF92YXJfZ2VuKC4zKSApXG5cbiAgICBvcC5fX2xlbiA9IG9wc2xlblsgbmFtZSBdXG4gICAgaWYoIG9wLl9fbGVuID4gMiApIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb3AsICdjJywge1xuICAgICAgICBnZXQoKSB7IHJldHVybiBfX2MgfSxcbiAgICAgICAgc2V0KHYpIHtcbiAgICAgICAgICBfX2Muc2V0KCB2IClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIFxuICAgICAgaWYoIG9wLl9fbGVuID4gMyApIHtcbiAgICAgICAgbGV0IF9fZCA9IHBhcmFtX3dyYXAoIGQsIGZsb2F0X3Zhcl9nZW4oNCkgKVxuXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggb3AsICdkJywge1xuICAgICAgICAgIGdldCgpIHsgcmV0dXJuIF9fZCB9LFxuICAgICAgICAgIHNldCh2KSB7XG4gICAgICAgICAgICBfX2Quc2V0KCB2IClcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgb3AuX19zZXRUZXh0dXJlID0gZnVuY3Rpb24odGV4LHByb3BzKSB7XG4gICAgICBpZiggdHlwZW9mIHRleCA9PT0gJ3N0cmluZycgKSB7XG4gICAgICAgIHRoaXMudGV4dHVyZSA9IG9wLnRleHR1cmUuYmluZCggdGhpcyApXG4gICAgICAgIHRoaXMuX190ZXh0dXJlT2JqID0gdGhpcy50ZXggPSBNYXJjaGluZy5UZXh0dXJlKCB0ZXgscHJvcHMsdGhpcy50ZXh0dXJlIClcbiAgICAgICAgdGhpcy5fX3RleHR1cmVJRCA9IHRoaXMuX190ZXh0dXJlT2JqLmlkXG4gICAgICB9ZWxzZXtcbiAgICAgICAgdGhpcy5fX3RleHR1cmVPYmogPSB0aGlzLnRleCA9IE9iamVjdC5hc3NpZ24oIHRleCwgcHJvcHMgKVxuICAgICAgICB0aGlzLl9fdGV4dHVyZUlEID0gdGhpcy5fX3RleHR1cmVPYmouaWRcbiAgICAgIH1cbiAgICB9XG4gICAgb3AuX19zZXRNYXRlcmlhbCA9IGZ1bmN0aW9uKG1hdCkge1xuICAgICAgaWYoIHR5cGVvZiBtYXQgPT09ICdzdHJpbmcnICkgbWF0ID0gTWFyY2hpbmcuTWF0ZXJpYWxbIG1hdCBdXG4gICAgICB0aGlzLl9fbWF0ZXJpYWwgPSB0aGlzLm1hdCA9IE1hcmNoaW5nLm1hdGVyaWFscy5hZGRNYXRlcmlhbCggbWF0IClcbiAgICB9XG4gICAgb3AuX19zZXRCdW1wID0gZnVuY3Rpb24odGV4LHByb3BzKSB7XG4gICAgICAvL3RoaXMuYnVtcCA9IHAuYnVtcC5iaW5kKCB0aGlzIClcbiAgICAgIGNvbnN0IGIgPSB0aGlzLmJ1bXAgPSB0aGlzLl9fYnVtcE9iaiA9IE1hcmNoaW5nLkJ1bXAoIHRoaXMsIHRleCwgcHJvcHMgKVxuICAgICAgdGhpcy5idW1wLnRleHR1cmUgPSB0aGlzLmJ1bXAuYW1vdW50LnZhbHVlXG4gICAgICB0aGlzLl9fYnVtcElEID0gdGhpcy5fX2J1bXBPYmouaWRcbiAgICAgIHRoaXMucm90YXRlID0gdGhpcy5idW1wLnJvdGF0ZVxuICAgICAgdGhpcy50cmFuc2xhdGUgPSB0aGlzLmJ1bXAudHJhbnNsYXRlXG4gICAgICB0aGlzLnNjYWxlID0gdGhpcy5idW1wLnNjYWxlXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRoaXMuYnVtcCwgJ3N0cmVuZ3RoJywge1xuICAgICAgICBnZXQoKSB7IHJldHVybiBiLnNpemUgfSxcbiAgICAgICAgc2V0KHYpeyBiLnNpemUgPSB2IH1cbiAgICAgIH0pXG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24oIG9wLCB7XG4gICAgICByZW5kZXJpbmdCdW1wIDogZmFsc2UsXG4gICAgICBlbWl0dGluZ0RlY2wgIDogZmFsc2UsXG4gICAgICB1cGxvYWRpbmcgICAgIDogZmFsc2UsXG4gICAgICB1cGRhdGluZyAgICAgIDogZmFsc2VcbiAgICB9KVxuXG4gICAgbGV0IHJlcGVhdCA9IG51bGxcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIG9wLCAncmVwZWF0Jywge1xuICAgICAgZ2V0KCkgeyByZXR1cm4gcmVwZWF0IH0sXG4gICAgICBzZXQodil7IFxuICAgICAgICByZXBlYXQgPSB2XG4gICAgICAgIHRoaXMuYS5yZXBlYXQgPSB2XG4gICAgICAgIHRoaXMuYi5yZXBlYXQgPSB2XG4gICAgICB9XG4gICAgfSlcblxuICAgIG9wLm1hdElkID0gTWF0ZXJpYWxJRC5hbGxvYygpXG5cbiAgICBvcC5wYXJhbXMgPSBbe25hbWU6J2MnfSx7IG5hbWU6J2QnfV1cbiAgICBvcC5fX2Rlc2MgPSB7IHBhcmFtZXRlcnM6IG9wLnBhcmFtcyB9XG5cbiAgICByZXR1cm4gb3BcbiAgfSBcbiAgXG4gIERpc3RhbmNlT3BzWyBuYW1lMiBdID0gZnVuY3Rpb24oIC4uLmFyZ3MgKSB7XG4gICAgLy8gYWNjZXB0cyB1bmxpbWl0ZWQgYXJndW1lbnRzLCBidXQgdGhlIGxhc3Qgb25lIGNvdWxkIGJlIGEgYmxlbmRpbmcgY29lZmZpY2llbnRcbiAgICBsZXQgYmxlbmQgPSAuMjUsIGNvZWZmPTQsIHVcblxuICAgIGlmKCB0eXBlb2YgYXJnc1sgYXJncy5sZW5ndGggLSAxIF0gPT09ICdudW1iZXInICkge1xuICAgICAgYmxlbmQgPSBhcmdzLnBvcCgpXG5cbiAgICAgIC8vIGlmIHRoZXJlIGFyZSB0d28gbm9uLXNkZiBhcmd1bWVudHMgdG8gdGhlIGZ1bmN0aW9uLi4uXG4gICAgICBpZiggdHlwZW9mIGFyZ3NbIGFyZ3MubGVuZ3RoIC0gMSBdID09PSAnbnVtYmVyJyApIHtcbiAgICAgICAgY29lZmYgPSBibGVuZFxuICAgICAgICBibGVuZCA9IGFyZ3MucG9wKClcbiAgICAgIH1cblxuICAgICAgdSA9IGFyZ3MucmVkdWNlKCAoc3RhdGUsbmV4dCkgPT4gRGlzdGFuY2VPcHNbIG5hbWUgXSggc3RhdGUsIG5leHQsIGJsZW5kLCBjb2VmZiApIClcbiAgICB9ZWxzZXtcbiAgICAgIHUgPSBhcmdzLnJlZHVjZSggKHN0YXRlLG5leHQpID0+IERpc3RhbmNlT3BzWyBuYW1lIF0oIHN0YXRlLCBuZXh0ICkgKVxuICAgIH1cblxuICAgIHJldHVybiB1XG4gIH1cblxuICBEaXN0YW5jZU9wc1sgbmFtZSBdLnByb3RvdHlwZSA9IFNjZW5lTm9kZSgpXG5cbiAgRGlzdGFuY2VPcHNbIG5hbWUgXS5wcm90b3R5cGUudGV4dHVyZSA9IGZ1bmN0aW9uKCAuLi5hcmdzICkge1xuICAgIHRoaXMuX19zZXRUZXh0dXJlKCAuLi5hcmdzIClcbiAgICB0aGlzLmEudGV4dHVyZSggdGhpcy5fX3RleHR1cmVPYmogKVxuICAgIHRoaXMuYi50ZXh0dXJlKCB0aGlzLl9fdGV4dHVyZU9iaiApXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG4gIERpc3RhbmNlT3BzWyBuYW1lIF0ucHJvdG90eXBlLm1hdGVyaWFsID0gZnVuY3Rpb24oIC4uLmFyZ3MgKSB7XG4gICAgdGhpcy5fX3NldE1hdGVyaWFsKCAuLi5hcmdzIClcbiAgICB0aGlzLmEubWF0ZXJpYWwoIHRoaXMuX19tYXRlcmlhbCApXG4gICAgdGhpcy5iLm1hdGVyaWFsKCB0aGlzLl9fbWF0ZXJpYWwgKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGNvbnN0IHB1c2hTdHJpbmcgPSBmdW5jdGlvbiggbmFtZSApIHtcbiAgICBjb25zdCBnbHNsb2JqID0gZ2xzbG9wc1sgbmFtZSBdXG4gICAgXG4gICAgLy8gc29tZSBkZWZpbml0aW9ucyBhcmUgYSBzaW5nbGUgc3RyaW5nLCBhbmQgbm90IHNwbGl0IGludG9cbiAgICAvLyBzZXBhcmF0ZSBmbG9hdCBhbmQgb3BPdXQgZnVuY3Rpb25zXG4gICAgaWYoIHR5cGVvZiBnbHNsb2JqID09PSAnc3RyaW5nJyApIHtcbiAgICAgIGlmKCBEaXN0YW5jZU9wcy5fX2dsc2wuaW5kZXhPZiggZ2xzbG9iaiApID09PSAtMSApIHtcbiAgICAgICAgRGlzdGFuY2VPcHMuX19nbHNsLnB1c2goIGdsc2xvYmogKVxuICAgICAgfVxuICAgIH1lbHNle1xuICAgICAgLy8gc29tZSBkaXN0YW5jZSBvcGVyYXRpb25zIGFyZSBkZXBlbmRlbnQgb24gb3RoZXIgb25lcy4uLlxuICAgICAgLy8gaWYgdGhpcyBvbmUgaGFzIGRlcGVuZGVuY2llcyBhZGQgdGhlbS5cbiAgICAgIC8vIGRlcGVuZGVuY2llcyBtdXN0IGJlIGFkZGVkIGJlZm9yZSBhZGRpbmcgb3RoZXIgZnVuY3Rpb25zXG4gICAgICAvLyBzbyB0aGF0IHRoZXkncmUgYWJvdmUgdGhlbSBpbiB0aGUgZmluYWwgR0xTTCBjb2RlLlxuICAgICAgaWYoIGdsc2xvYmouZGVwZW5kZW5jaWVzICE9PSB1bmRlZmluZWQgKSB7XG4gICAgICAgIGZvciggbGV0IGRuYW1lIG9mIGdsc2xvYmouZGVwZW5kZW5jaWVzICkge1xuICAgICAgICAgIGNvbnN0IGQgPSBnbHNsb3BzWyBkbmFtZSBdXG4gICAgICAgICAgaWYoIERpc3RhbmNlT3BzLl9fZ2xzbC5pbmRleE9mKCBkLmZsb2F0ICkgPT09IC0xICkge1xuICAgICAgICAgICAgRGlzdGFuY2VPcHMuX19nbHNsLnB1c2goIGQuZmxvYXQgKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAgXG4gICAgICBpZiggRGlzdGFuY2VPcHMuX19nbHNsLmluZGV4T2YoIGdsc2xvYmouZmxvYXQgKSA9PT0gLTEgKSB7XG4gICAgICAgIERpc3RhbmNlT3BzLl9fZ2xzbC5wdXNoKCBnbHNsb2JqLmZsb2F0IClcbiAgICAgIH1cbiAgICAgIGlmKCBEaXN0YW5jZU9wcy5fX2dsc2wuaW5kZXhPZiggZ2xzbG9iai52ZWMyKSA9PT0gLTEgKSB7XG4gICAgICAgIERpc3RhbmNlT3BzLl9fZ2xzbC5wdXNoKCBnbHNsb2JqLnZlYzIgKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIERpc3RhbmNlT3BzWyBuYW1lIF0ucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAoIHBuYW1lPSdwJywgdHJhbnNmb3JtID0gbnVsbCApe1xuICAgIGlmKCB0aGlzLl9fYnVtcE9iaiAhPT0gdW5kZWZpbmVkICYmIHRoaXMucmVuZGVyaW5nQnVtcCA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMucmVuZGVyaW5nQnVtcCA9IHRydWVcbiAgICAgIHJldHVybiB0aGlzLl9fYnVtcE9iai5lbWl0KCBwbmFtZSwgdHJhbnNmb3JtIClcbiAgICB9XG4gICAgcHVzaFN0cmluZyggbmFtZSApXG5cbiAgICBpZiggdHJhbnNmb3JtICE9PSBudWxsICkgdGhpcy50cmFuc2Zvcm0uYXBwbHkoIHRyYW5zZm9ybSwgZmFsc2UgKVxuICAgIC8vdGhpcy50cmFuc2Zvcm0uaW50ZXJuYWwoKVxuXG4gICAgLy8gZmlyc3QgdHdvIGFyZ3MgYXJlIGZpeGVkLCByZXN0IGFyZSB2YXJpYWJsZVxuICAgIGxldCBlbWl0dGVycyA9IFtdXG4gICAgY29uc3QgYSA9IHRoaXMuYS5lbWl0KCBwbmFtZSwgdGhpcy50cmFuc2Zvcm0gKSwgXG4gICAgICAgICAgYiA9IHRoaXMuYi5lbWl0KCBwbmFtZSwgdGhpcy50cmFuc2Zvcm0gKSBcblxuICAgIGVtaXR0ZXJzWzBdID0gYS5vdXRcbiAgICBlbWl0dGVyc1sxXSA9IGIub3V0XG4gICAgaWYoIHRoaXMuX19sZW4gPiAyICkgZW1pdHRlcnMucHVzaCggdGhpcy5jLmVtaXQoKSApXG4gICAgaWYoIHRoaXMuX19sZW4gPiAzICkgZW1pdHRlcnMucHVzaCggdGhpcy5kLmVtaXQoKSApXG4gICAgXG4gICAgY29uc3QgYm9keSA9IGBcbiAgICAgICAgdmVjMiBkbyR7dGhpcy5pZH0gPSAke29wKCAuLi5lbWl0dGVycyApfTtcbiAgICAgICAgZG8ke3RoaXMuaWR9LnggKj0gJHt0aGlzLnRyYW5zZm9ybS5lbWl0KCl9X3NjYWxlO1xuICAgIGBcblxuICAgIGNvbnN0IG91dHB1dCA9IHtcbiAgICAgIG91dDogJ2RvJyt0aGlzLmlkLFxuICAgICAgcHJlZmFjZTogKGEucHJlZmFjZSB8fCAnJykgKyAoYi5wcmVmYWNlIHx8ICcnKSArIGJvZHlcbiAgICB9XG5cbiAgICB0aGlzLnJlbmRlcmluZ0J1bXAgPSBmYWxzZVxuICAgIHJldHVybiBvdXRwdXRcbiAgfVxuXG4gIERpc3RhbmNlT3BzW25hbWVdLnByb3RvdHlwZS5lbWl0X2RlY2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYoIHRoaXMuX19idW1wT2JqICE9PSB1bmRlZmluZWQgJiYgdGhpcy5lbWl0dGluZ0RlY2wgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmVtaXR0aW5nRGVjbCA9IHRydWVcbiAgICAgIHJldHVybiB0aGlzLl9fYnVtcE9iai5lbWl0X2RlY2woKSBcbiAgICB9XG4gICAgbGV0IHN0ciA9ICB0aGlzLnRyYW5zZm9ybS5lbWl0X2RlY2woKSArIHRoaXMuYS5lbWl0X2RlY2woKSArIHRoaXMuYi5lbWl0X2RlY2woKVxuICAgIGlmKCB0aGlzLmMgIT09IHVuZGVmaW5lZCApIHN0ciArPSB0aGlzLmMuZW1pdF9kZWNsKClcbiAgICBpZiggdGhpcy5kICE9PSB1bmRlZmluZWQgKSBzdHIgKz0gdGhpcy5kLmVtaXRfZGVjbCgpXG5cbiAgICBpZiggb3BzWyBuYW1lIF0uY29kZSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgLy9zdHIgKz0gb3BzWyBuYW1lIF0uY29kZVxuICAgICAgaWYoIE1hcmNoaW5nLnJlcXVpcmVkT3BzLmluZGV4T2YoIG9wc1sgbmFtZSBdLmNvZGUgKSA9PT0gLSAxICkge1xuICAgICAgICBNYXJjaGluZy5yZXF1aXJlZE9wcy5wdXNoKCBvcHNbIG5hbWUgXS5jb2RlIClcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmVtaXR0aW5nRGVjbCA9IGZhbHNlXG4gICAgcmV0dXJuIHN0clxuICB9O1xuXG4gIERpc3RhbmNlT3BzW25hbWVdLnByb3RvdHlwZS51cGRhdGVfbG9jYXRpb24gPSBmdW5jdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgIGlmKCB0aGlzLl9fYnVtcE9iaiAhPT0gdW5kZWZpbmVkICYmIHRoaXMudXBkYXRpbmcgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLnVwZGF0aW5nID0gdHJ1ZVxuICAgICAgcmV0dXJuIHRoaXMuX19idW1wT2JqLnVwZGF0ZV9sb2NhdGlvbiggZ2wsIHByb2dyYW0gKVxuICAgIH1cbiAgICB0aGlzLmEudXBkYXRlX2xvY2F0aW9uKCBnbCwgcHJvZ3JhbSApXG4gICAgdGhpcy50cmFuc2Zvcm0udXBkYXRlX2xvY2F0aW9uKCBnbCwgcHJvZ3JhbSApXG4gICAgdGhpcy5iLnVwZGF0ZV9sb2NhdGlvbiggZ2wsIHByb2dyYW0gKVxuICAgIGlmKCB0aGlzLmMgIT09IHVuZGVmaW5lZCApIHRoaXMuYy51cGRhdGVfbG9jYXRpb24oIGdsLCBwcm9ncmFtIClcbiAgICBpZiggdGhpcy5kICE9PSB1bmRlZmluZWQgKSB0aGlzLmQudXBkYXRlX2xvY2F0aW9uKCBnbCwgcHJvZ3JhbSApXG5cbiAgICB0aGlzLnVwZGF0aW5nID0gZmFsc2VcbiAgfVxuXG4gIERpc3RhbmNlT3BzW25hbWVdLnByb3RvdHlwZS51cGxvYWRfZGF0YSA9IGZ1bmN0aW9uKGdsKSB7XG4gICAgaWYoIHRoaXMuX19idW1wT2JqICE9PSB1bmRlZmluZWQgJiYgdGhpcy51cGxvYWRpbmcgID09PSBmYWxzZSApIHtcbiAgICAgIHRoaXMudXBsb2FkaW5nID0gdHJ1ZVxuICAgICAgcmV0dXJuIHRoaXMuX19idW1wT2JqLnVwbG9hZF9kYXRhKCBnbCApXG4gICAgfVxuICAgIHRoaXMudHJhbnNmb3JtLmludGVybmFsKClcbiAgICB0aGlzLnRyYW5zZm9ybS51cGxvYWRfZGF0YSggZ2wgKVxuICAgIHRoaXMuYS50cmFuc2Zvcm0uYXBwbHkoIHRoaXMudHJhbnNmb3JtIClcbiAgICB0aGlzLmIudHJhbnNmb3JtLmFwcGx5KCB0aGlzLnRyYW5zZm9ybSApXG4gICAgdGhpcy5hLnVwbG9hZF9kYXRhKCBnbCApXG4gICAgdGhpcy5iLnVwbG9hZF9kYXRhKCBnbCApXG4gICAgaWYoIHRoaXMuYyAhPT0gdW5kZWZpbmVkICkgdGhpcy5jLnVwbG9hZF9kYXRhKCBnbCApXG4gICAgaWYoIHRoaXMuZCAhPT0gdW5kZWZpbmVkICkgdGhpcy5kLnVwbG9hZF9kYXRhKCBnbCApXG4gICAgdGhpcy51cGxvYWRpbmcgPSBmYWxzZVxuICAgIFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRGlzdGFuY2VPcHNcbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBVbmlvbjp7XG4gICAgZmxvYXQ6YFxuICAgICAgZmxvYXQgb3BVKCBmbG9hdCBkMSwgZmxvYXQgZDIgKSB7XG4gICAgICAgIHJldHVybiBtaW4oZDEsZDIpO1xuICAgICAgfVxuICAgICAgYCxcbiAgICB2ZWMyOmBcbiAgICAgIHZlYzIgb3BVKCB2ZWMyIGQxLCB2ZWMyIGQyICkge1xuICAgICAgICB2ZWMyIG87XG5cbiAgICAgICAgaWYoIGQxLnggPCBkMi54ICkge1xuICAgICAgICAgIG8gPSBkMTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgbyA9IGQyOyBcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfVxuICAgICAgYFxuICB9LFxuICBJbnRlcnNlY3Rpb246e1xuICAgIGZsb2F0OmBcbiAgICAgIGZsb2F0IG9wSSggZmxvYXQgZDEsIGZsb2F0IGQyICkge1xuICAgICAgICByZXR1cm4gbWF4KGQxLGQyKTtcbiAgICAgIH1cbiAgICAgIGAsXG4gICAgdmVjMjpgXG4gICAgICB2ZWMyIG9wSSggdmVjMiBkMSwgdmVjMiBkMiAgKSB7XG4gICAgICAgIHZlYzIgbztcblxuICAgICAgICBpZiggZDEueCA+IGQyLnggKSB7XG4gICAgICAgICAgbyA9IGQxOyBcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgbyA9IGQyOyBcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfVxuICAgICAgYFxuICB9LFxuXG4gIERpZmZlcmVuY2U6e1xuICAgIGZsb2F0OmBcbiAgICAgIGZsb2F0IG9wUyggZmxvYXQgZDEsIGZsb2F0IGQyICkgeyByZXR1cm4gbWF4KGQxLC1kMik7IH1cbiAgICAgIGAsXG4gICAgdmVjMjpgXG4gICAgICB2ZWMyIG9wUyggdmVjMiBkMSwgdmVjMiBkMiAgKSB7XG4gICAgICAgIHZlYzIgbztcblxuICAgICAgICBpZiggZDEueCA+PSAtZDIueCApIHtcbiAgICAgICAgICBvID0gZDE7IFxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICBkMi54ICo9IC0xLjtcbiAgICAgICAgICBvID0gZDI7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbztcbiAgICAgIH1cbiAgICAgIGBcbiAgfSxcblxuICBTdGFpcnNVbmlvbjp7XG4gICAgZmxvYXQ6YFxuICAgICAgZmxvYXQgZk9wVW5pb25TdGFpcnMoZmxvYXQgYSwgZmxvYXQgYiwgZmxvYXQgciwgZmxvYXQgbikge1xuICAgICAgICBmbG9hdCBzID0gci9uO1xuICAgICAgICBmbG9hdCB1ID0gYi1yO1xuICAgICAgICByZXR1cm4gbWluKG1pbihhLGIpLCAwLjUgKiAodSArIGEgKyBhYnMgKChtb2QgKHUgLSBhICsgcywgMi4gKiBzKSkgLSBzKSkpO1xuICAgICAgfWAsXG4gICAgdmVjMjpgXG4gICAgICB2ZWMyIGZPcFVuaW9uU3RhaXJzKCB2ZWMyIGQxLCB2ZWMyIGQyLCBmbG9hdCByLCBmbG9hdCBuICApIHtcbiAgICAgICAgdmVjMiBvID0gdmVjMiggMC4sIGQxLnkgKTsgXG5cbiAgICAgICAgaWYoIGQxLnggPD0gZDIueCApIHtcbiAgICAgICAgICBvLnkgPSBkMS55OyBcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgby55ID0gZDIueTsgXG4gICAgICAgIH1cblxuICAgICAgICBvLnggPSBmT3BVbmlvblN0YWlycyggZDEueCwgZDIueCwgciwgbiApO1xuXG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfVxuICAgICAgYFxuICB9LFxuICBTdGFpcnNJbnRlcnNlY3Rpb246e1xuICAgIGRlcGVuZGVuY2llczogWydTdGFpcnNVbmlvbiddLFxuICAgIGZsb2F0OmBcbiAgICAgIC8vIFdlIGNhbiBqdXN0IGNhbGwgVW5pb24gc2luY2Ugc3RhaXJzIGFyZSBzeW1tZXRyaWMuXG4gICAgICBmbG9hdCBmT3BJbnRlcnNlY3Rpb25TdGFpcnMoZmxvYXQgYSwgZmxvYXQgYiwgZmxvYXQgciwgZmxvYXQgbikge1xuICAgICAgICByZXR1cm4gLWZPcFVuaW9uU3RhaXJzKC1hLCAtYiwgciwgbik7XG4gICAgICB9XG4gICAgICBgLFxuICAgIHZlYzI6YFxuICAgICAgdmVjMiBmT3BJbnRlcnNlY3Rpb25TdGFpcnMoIHZlYzIgZDEsIHZlYzIgZDIsIGZsb2F0IHIsIGZsb2F0IG4gICkge1xuICAgICAgICB2ZWMyIG8gPSB2ZWMyKCAwLiwgZDEueSApOyBcbiAgICAgICAgby54ID0gLWZPcFVuaW9uU3RhaXJzKCAtZDEueCwgLWQyLngsIHIsIG4gKTtcblxuICAgICAgICBpZiggLWQxLnggPD0gLWQyLnggKSB7XG4gICAgICAgICAgby55ID0gZDEueTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgby55ID0gZDIueTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfVxuICAgICAgYFxuICB9LFxuICBTdGFpcnNEaWZmZXJlbmNlOntcbiAgICBkZXBlbmRlbmNpZXM6IFsnU3RhaXJzVW5pb24nXSxcbiAgICBmbG9hdDpgXG4gICAgICBmbG9hdCBmT3BTdWJzdHJhY3Rpb25TdGFpcnMoZmxvYXQgYSwgZmxvYXQgYiwgZmxvYXQgciwgZmxvYXQgbikge1xuICAgICAgICByZXR1cm4gLWZPcFVuaW9uU3RhaXJzKC1hLCBiLCByLCBuKTtcbiAgICAgIH1gLFxuICAgIHZlYzI6YFxuICAgICAgdmVjMiBmT3BTdWJzdHJhY3Rpb25TdGFpcnMoIHZlYzIgZDEsIHZlYzIgZDIsIGZsb2F0IHIsIGZsb2F0IG4gICkge1xuICAgICAgICB2ZWMyIG8gPSB2ZWMyKCAwLiwgZDEueSApOyBcbiAgICAgICAgby54ID0gLWZPcFVuaW9uU3RhaXJzKCAtZDEueCwgZDIueCwgciwgbiApO1xuXG4gICAgICAgIGlmKCAtZDEueCA8PSBkMi54ICkge1xuICAgICAgICAgIG8ueSA9IGQxLnk7XG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIG8ueSA9IGQyLnk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbztcbiAgICAgIH1cbiAgICAgIGBcbiAgfSxcblxuICBSb3VuZFVuaW9uOntcbiAgICBmbG9hdDpgXG4gICAgICBmbG9hdCBmT3BVbmlvblJvdW5kKGZsb2F0IGEsIGZsb2F0IGIsIGZsb2F0IHIpIHtcbiAgICAgICAgdmVjMiB1ID0gbWF4KHZlYzIociAtIGEsciAtIGIpLCB2ZWMyKDApKTtcbiAgICAgICAgcmV0dXJuIG1heChyLCBtaW4gKGEsIGIpKSAtIGxlbmd0aCh1KTtcbiAgICAgIH1gLFxuXG4gICAgdmVjMjpgXG4gICAgICB2ZWMyIGZPcFVuaW9uUm91bmQoIHZlYzIgZDEsIHZlYzIgZDIsIGZsb2F0IHIgICkge1xuICAgICAgICB2ZWMyIG8gPSB2ZWMyKCAwLiwgZDEueSApOyBcbiAgICAgICAgby54ID0gZk9wVW5pb25Sb3VuZCggZDEueCwgZDIueCwgciApO1xuXG4gICAgICAgIGlmKCBkMS54IDw9IGQyLnggKSB7XG4gICAgICAgICAgby55ID0gZDEueTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgby55ID0gZDIueTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfVxuICAgICAgYFxuICB9LFxuICBSb3VuZEludGVyc2VjdGlvbjp7XG4gICAgZmxvYXQ6YFxuICAgICAgZmxvYXQgZk9wSW50ZXJzZWN0aW9uUm91bmQoZmxvYXQgYSwgZmxvYXQgYiwgZmxvYXQgcikge1xuICAgICAgICB2ZWMyIHUgPSBtYXgodmVjMihyICsgYSxyICsgYiksIHZlYzIoMCkpO1xuICAgICAgICByZXR1cm4gbWluKC1yLCBtYXggKGEsIGIpKSArIGxlbmd0aCh1KTtcbiAgICAgIH1gLFxuICAgIHZlYzI6YFxuICAgICAgdmVjMiBmT3BJbnRlcnNlY3Rpb25Sb3VuZCggdmVjMiBkMSwgdmVjMiBkMiwgZmxvYXQgciAgKSB7XG4gICAgICAgIHZlYzIgbyA9IHZlYzIoIDAuLCBkMS55ICk7IFxuICAgICAgICBvLnggPSBmT3BJbnRlcnNlY3Rpb25Sb3VuZCggZDEueCwgZDIueCwgciApO1xuXG4gICAgICAgIGlmKCBkMS54ID49IGQyLnggKSB7XG4gICAgICAgICAgby55ID0gZDEueTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgby55ID0gZDIueTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfVxuICAgICAgYFxuICB9LFxuXG4gIFJvdW5kRGlmZmVyZW5jZTp7XG4gICAgZGVwZW5kZW5jaWVzOiBbJ1JvdW5kSW50ZXJzZWN0aW9uJ10sXG4gICAgZmxvYXQ6YFxuICAgICAgZmxvYXQgZk9wRGlmZmVyZW5jZVJvdW5kIChmbG9hdCBhLCBmbG9hdCBiLCBmbG9hdCByKSB7XG4gICAgICAgIHJldHVybiBmT3BJbnRlcnNlY3Rpb25Sb3VuZChhLCAtYiwgcik7XG4gICAgICB9YCxcbiAgICB2ZWMyOmBcbiAgICAgIHZlYzIgZk9wRGlmZmVyZW5jZVJvdW5kKCB2ZWMyIGQxLCB2ZWMyIGQyLCBmbG9hdCByICApIHtcbiAgICAgICAgdmVjMiBvID0gdmVjMiggMC4sIGQxLnkgKTsgXG4gICAgICAgIG8ueCA9IGZPcERpZmZlcmVuY2VSb3VuZCggZDEueCwgZDIueCwgciApO1xuXG4gICAgICAgIGlmKCBkMS54ID49IC1kMi54ICkge1xuICAgICAgICAgIG8ueSA9IGQxLnk7IFxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICBvLnkgPSBkMi55O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG87XG4gICAgICB9XG4gICAgICBgXG4gIH0sXG4gIENoYW1mZXJVbmlvbjp7XG4gICAgZmxvYXQ6YFxuICAgICAgZmxvYXQgZk9wVW5pb25DaGFtZmVyKGZsb2F0IGEsIGZsb2F0IGIsIGZsb2F0IHIpIHtcbiAgICAgICAgcmV0dXJuIG1pbihtaW4oYSwgYiksIChhIC0gciArIGIpKnNxcnQoMC41KSk7XG4gICAgICB9YCxcbiAgICB2ZWMyOmBcbiAgICAgIHZlYzIgZk9wVW5pb25DaGFtZmVyKCB2ZWMyIGQxLCB2ZWMyIGQyLCBmbG9hdCByICApIHtcbiAgICAgICAgdmVjMiBvID0gdmVjMiggMC4sIGQxLnkgKTsgXG4gICAgICAgIG8ueCA9IGZPcFVuaW9uQ2hhbWZlciggZDEueCwgZDIueCwgciApO1xuXG4gICAgICAgIGlmKCBkMS54IDw9IGQyLnggKSB7XG4gICAgICAgICAgby55ID0gZDEueTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgby55ID0gZDIueTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfVxuICAgICAgYFxuICB9LFxuICBDaGFtZmVySW50ZXJzZWN0aW9uOntcbiAgICBmbG9hdDpgXG4gICAgICBmbG9hdCBmT3BJbnRlcnNlY3Rpb25DaGFtZmVyKGZsb2F0IGEsIGZsb2F0IGIsIGZsb2F0IHIpIHtcbiAgICAgICAgcmV0dXJuIG1heChtYXgoYSwgYiksIChhICsgciArIGIpKnNxcnQoMC41KSk7XG4gICAgICB9YCxcbiAgICB2ZWMyOmBcbiAgICAgIHZlYzIgZk9wSW50ZXJzZWN0aW9uQ2hhbWZlciggdmVjMiBkMSwgdmVjMiBkMiwgZmxvYXQgciAgICkge1xuICAgICAgICB2ZWMyIG8gPSB2ZWMyKCAwLiwgZDEueSApOyBcbiAgICAgICAgby54ID0gZk9wSW50ZXJzZWN0aW9uQ2hhbWZlciggZDEueCwgZDIueCwgciApO1xuXG4gICAgICAgIGlmKCBkMS54ID49IGQyLnggKSB7XG4gICAgICAgICAgby55ID0gZDEueTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgby55ID0gZDIueTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfVxuICAgICAgYFxuICB9LFxuXG4gIENoYW1mZXJEaWZmZXJlbmNlOntcbiAgICBkZXBlbmRlbmNpZXM6WydDaGFtZmVySW50ZXJzZWN0aW9uJ10sXG4gICAgZmxvYXQ6YFxuICAgICAgZmxvYXQgZk9wRGlmZmVyZW5jZUNoYW1mZXIgKGZsb2F0IGEsIGZsb2F0IGIsIGZsb2F0IHIpIHtcbiAgICAgICAgcmV0dXJuIGZPcEludGVyc2VjdGlvbkNoYW1mZXIoYSwgLWIsIHIpO1xuICAgICAgfWAsXG4gICAgdmVjMjpgXG4gICAgICB2ZWMyIGZPcERpZmZlcmVuY2VDaGFtZmVyKCB2ZWMyIGQxLCB2ZWMyIGQyLCBmbG9hdCByICApIHtcbiAgICAgICAgdmVjMiBvID0gdmVjMiggMC4sIGQxLnkgKTsgXG4gICAgICAgIG8ueCA9IGZPcERpZmZlcmVuY2VDaGFtZmVyKCBkMS54LCBkMi54LCByICk7XG5cbiAgICAgICAgaWYoIGQxLnggPj0gLWQyLnggKSB7XG4gICAgICAgICAgby55ID0gZDEueTtcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgby55ID0gZDIueTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfVxuICAgICAgYFxuICB9LFxuICBQaXBlOmBcbiAgICAgIGZsb2F0IGZPcFBpcGUoZmxvYXQgYSwgZmxvYXQgYiwgZmxvYXQgcikge1xuICAgICAgICByZXR1cm4gbGVuZ3RoKHZlYzIoYSwgYikpIC0gcjtcbiAgICAgIH1cbiAgICAgIHZlYzIgZk9wUGlwZSggdmVjMiBkMSwgdmVjMiBkMiwgZmxvYXQgciAgICkge1xuICAgICAgICB2ZWMyIG8gPSB2ZWMyKCAwLiwgZDEueSApOyBcbiAgICAgICAgby54ID0gZk9wUGlwZSggZDEueCwgZDIueCwgciApO1xuXG4gICAgICAgIHJldHVybiBvO1xuICAgICAgfVxuICAgICAgYCxcblxuICBFbmdyYXZlOmBcbiAgICAgIGZsb2F0IGZPcEVuZ3JhdmUoZmxvYXQgYSwgZmxvYXQgYiwgZmxvYXQgcikge1xuICAgICAgICByZXR1cm4gbWF4KGEsIChhICsgciAtIGFicyhiKSkqc3FydCgwLjUpKTtcbiAgICAgIH1cbiAgICAgIHZlYzIgZk9wRW5ncmF2ZSggdmVjMiBkMSwgdmVjMiBkMiwgZmxvYXQgciAgKSB7XG4gICAgICAgIHZlYzIgbyA9IHZlYzIoIDAuLCBkMS55ICk7IFxuICAgICAgICBvLnggPSBmT3BFbmdyYXZlKCBkMS54LCBkMi54LCByICk7XG5cbiAgICAgICAgcmV0dXJuIG87XG4gICAgICB9XG4gICAgICBgLFxuICBHcm9vdmU6YFxuICAgICAgZmxvYXQgZk9wR3Jvb3ZlKGZsb2F0IGEsIGZsb2F0IGIsIGZsb2F0IHJhLCBmbG9hdCByYikge1xuICAgICAgICByZXR1cm4gbWF4KGEsIG1pbihhICsgcmEsIHJiIC0gYWJzKGIpKSk7XG4gICAgICB9XG4gICAgICB2ZWMyIGZPcEdyb292ZSggdmVjMiBkMSwgdmVjMiBkMiwgZmxvYXQgciwgZmxvYXQgbiAgKSB7XG4gICAgICAgIHZlYzIgbyA9IHZlYzIoIDAuLCBkMS55ICk7IFxuICAgICAgICBvLnggPSBmT3BHcm9vdmUoIGQxLngsIGQyLngsIHIsIG4gKTtcblxuICAgICAgICByZXR1cm4gbztcbiAgICAgIH1cbiAgICAgIGAsXG5cbiAgVG9uZ3VlOmBcbiAgICAgIGZsb2F0IGZPcFRvbmd1ZShmbG9hdCBhLCBmbG9hdCBiLCBmbG9hdCByYSwgZmxvYXQgcmIpIHtcbiAgICAgICAgcmV0dXJuIG1pbihhLCBtYXgoYSAtIHJhLCBhYnMoYikgLSByYikpO1xuICAgICAgfVxuICAgICAgdmVjMiBmT3BUb25ndWUoIHZlYzIgZDEsIHZlYzIgZDIsIGZsb2F0IHIsIGZsb2F0IG4gICkge1xuICAgICAgICB2ZWMyIG8gPSB2ZWMyKCAwLiwgZDEueSApOyBcbiAgICAgICAgby54ID0gZk9wVG9uZ3VlKCBkMS54LCBkMi54LCByLCBuICk7XG5cbiAgICAgICAgcmV0dXJuIG87XG4gICAgICB9XG4gICAgICBgLFxuICBPbmlvbjpgXG4gICAgICBmbG9hdCBvcE9uaW9uKCBpbiBmbG9hdCBzZGYsIGluIGZsb2F0IHRoaWNrbmVzcyApe1xuICAgICAgICByZXR1cm4gYWJzKHNkZiktdGhpY2tuZXNzO1xuICAgICAgfVxuXG4gICAgICBmbG9hdCBvcEhhbHZlKCBpbiBmbG9hdCBzZGYsIHZlYzMgcCwgaW4gaW50IGRpciApe1xuICAgICAgICBmbG9hdCBfb3V0ID0gMC47XG4gICAgICAgIHN3aXRjaCggZGlyICkge1xuICAgICAgICAgIGNhc2UgMDogIFxuICAgICAgICAgICAgX291dCA9IG1heCggc2RmLCBwLnkgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIF9vdXQgPSBtYXgoIHNkZiwgLXAueSApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgX291dCA9IG1heCggc2RmLCBwLnggKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIF9vdXQgPSBtYXgoIHNkZiwgLXAueCApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX291dDtcbiAgICAgIH1cbiAgICAgIGAsXG5cbiAgU3dpdGNoOmBcbiAgICAgIHZlYzIgb3BTd2l0Y2goIHZlYzIgYSwgdmVjMiBiLCBmbG9hdCBjICkge1xuICAgICAgICBpZiggYyA8IC41ICkge1xuICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgfSBcbiAgICAgIH1cbiAgICAgIGBcbn1cbiIsImNvbnN0IHsgVmFyLCBmbG9hdF92YXJfZ2VuLCB2ZWMyX3Zhcl9nZW4sIHZlYzNfdmFyX2dlbiwgdmVjNF92YXJfZ2VuLCBpbnRfdmFyX2dlbiwgVmFyQWxsb2MgfSA9IHJlcXVpcmUoICcuL3Zhci5qcycgKVxuY29uc3QgU2NlbmVOb2RlID0gcmVxdWlyZSggJy4vc2NlbmVOb2RlLmpzJyApXG5jb25zdCB7IHBhcmFtX3dyYXAsIE1hdGVyaWFsSUQgfSA9IHJlcXVpcmUoICcuL3V0aWxzLmpzJyApXG5jb25zdCB7IFZlYzIsIFZlYzMsIFZlYzQgfSA9IHJlcXVpcmUoICcuL3ZlYy5qcycgKVxuY29uc3QgVHJhbnNmb3JtID0gcmVxdWlyZSggJy4vdHJhbnNmb3JtLmpzJyApXG5cbmNvbnN0IGRlc2NyaXB0aW9ucyA9IHtcbiAgRWxvbmdhdGlvbjoge1xuICAgIHBhcmFtZXRlcnM6WyB7IG5hbWU6J2Rpc3RhbmNlJywgdHlwZTondmVjMycsIGRlZmF1bHQ6VmVjMygwKSB9IF0sXG4gICAgZnVuYzpgXG4gICAgICB2ZWM0IG9wRWxvbmdhdGUoIGluIHZlYzMgcCwgaW4gdmVjMyBoICkge1xuICAgICAgICAvL3JldHVybiB2ZWM0KCBwLWNsYW1wKHAsLWgsaCksIDAuMCApOyAvLyBmYXN0ZXIsIGJ1dCBwcm9kdWNlcyB6ZXJvIGluIHRoZSBpbnRlcmlvciBlbG9uZ2F0ZWQgYm94XG4gICAgICAgIFxuICAgICAgICB2ZWMzIHEgPSBhYnMocCktaDtcbiAgICAgICAgcmV0dXJuIHZlYzQoIG1heChxLDAuMCksIG1pbihtYXgocS54LG1heChxLnkscS56KSksMC4wKSApO1xuICAgICAgfWAsXG4gICAgZW1pdCggbmFtZT0ncCcgKSB7XG4gICAgICBjb25zdCBwSWQgPSB0aGlzLmdldElEKClcbiAgICAgIGNvbnN0IHBOYW1lID0gJ3AnICsgcElkXG5cbiAgICAgIGxldCBwcmVmYWNlID1cbiAgICAgICAgYCAgICAgICAgdmVjNCAke3BOYW1lfV94eXp3ID0gb3BFbG9uZ2F0ZSggJHtuYW1lfSwgJHt0aGlzLmRpc3RhbmNlLmVtaXQoKX0gKTtcXG5cbiAgICAgICAgdmVjMyAke3BOYW1lfSA9ICR7cE5hbWV9X3h5encueHl6O1xcbmBcblxuXG4gICAgICBjb25zdCBzZGYgPSB0aGlzLnNkZi5lbWl0KCBwTmFtZSApXG5cbiAgICAgIGlmKCB0eXBlb2Ygc2RmLnByZWZhY2UgPT09ICdzdHJpbmcnICkgcHJlZmFjZSArPSBzZGYucHJlZmFjZSBcblxuICAgICAgcmV0dXJuIHsgb3V0OmB2ZWMyKCR7cE5hbWV9X3h5encudyArICR7c2RmLm91dH0ueCwgJHtzZGYub3V0fS55KWAsIHByZWZhY2UgfVxuICAgIH1cbiAgfSxcbiAgUG9sYXJSZXBldGl0aW9uOiB7XG4gICAgcGFyYW1ldGVyczpbIFxuICAgICAgeyBuYW1lOidjb3VudCcsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDo1IH0sXG4gICAgICB7IG5hbWU6J2Rpc3RhbmNlJywgdHlwZTondmVjMycsIGRlZmF1bHQ6VmVjMyguMjUpIH0sXG5cbiAgICBdLFxuICAgIGVtaXQoIG5hbWU9J3AnLCB0cmFuc2Zvcm09bnVsbCkge1xuICAgICAgY29uc3QgcElkID0gVmFyQWxsb2MuYWxsb2MoKVxuICAgICAgY29uc3QgcE5hbWUgPSAncCcgKyBwSWRcbiAgICAgIGNvbnN0IHBvaW50U3RyaW5nID0gIGAoICR7bmFtZX0gKiAke3RoaXMudHJhbnNmb3JtLmVtaXQoKX0gKS54eXpgXG5cbiAgICAgIGlmKCB0cmFuc2Zvcm0gIT09IG51bGwgKSB0aGlzLnRyYW5zZm9ybS5hcHBseSggdHJhbnNmb3JtLCBmYWxzZSApXG4gICAgICB0aGlzLnRyYW5zZm9ybS5pbnZlcnQoKVxuXG4gICAgICBsZXQgcHJlZmFjZSA9YFxuICAgICAgICAgIHZlYzQgJHtwTmFtZX0gPSB2ZWM0KCBwb2xhclJlcGVhdCggJHtwb2ludFN0cmluZ30sICR7dGhpcy5fX3RhcmdldC5jb3VudC5lbWl0KCkgfSApLCAxLiApOyBcbiAgICAgICAgICAke3BOYW1lfSAtPSB2ZWM0KCR7dGhpcy5fX3RhcmdldC5kaXN0YW5jZS5lbWl0KCl9LngsMC4sMC4sMC4pO1xcbmBcblxuICAgICAgY29uc3Qgc2RmID0gdGhpcy5zZGYuZW1pdCggcE5hbWUgKVxuXG4gICAgICBpZiggdHlwZW9mIHNkZi5wcmVmYWNlID09PSAnc3RyaW5nJyApIHByZWZhY2UgKz0gc2RmLnByZWZhY2VcblxuICAgICAgcmV0dXJuIHsgb3V0OnNkZi5vdXQsIHByZWZhY2UgfVxuICAgIH1cbiAgfSxcbiAgTWlycm9yOiB7XG4gICAgcGFyYW1ldGVyczogWyB7IG5hbWU6J2Rpc3RhbmNlJywgdHlwZTondmVjMycsIGRlZmF1bHQ6VmVjMygwKSB9IF0sXG4gICAgZXh0cmE6W3sgbmFtZTonZGltcycsIHR5cGU6J2xvY2FsJywgZGVmYXVsdDoneHl6JyB9XSxcblxuICAgIGVtaXQoIG5hbWU9J3AnLCB0cmFuc2Zvcm09bnVsbCwgbm90dXNlZD1udWxsLCBzY2FsZT1udWxsICkge1xuICAgICAgY29uc3QgcElkID0gVmFyQWxsb2MuYWxsb2MoKVxuICAgICAgY29uc3QgcE5hbWUgPSAncCcgKyBwSWRcblxuICAgICAgaWYoIHRyYW5zZm9ybSAhPT0gbnVsbCApIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0uYXBwbHkoIHRyYW5zZm9ybSwgZmFsc2UgKVxuICAgICAgfVxuICAgICAgdGhpcy50cmFuc2Zvcm0uaW52ZXJ0KClcbiAgICAgXG4gICAgICBjb25zdCBwb2ludFN0cmluZyA9ICBgKCAke25hbWV9ICogJHt0aGlzLnRyYW5zZm9ybS5lbWl0KCl9ICkueHl6YCxcbiAgICAgICAgICAgIHMgPSBzY2FsZSA9PT0gbnVsbCA/IHRoaXMudHJhbnNmb3JtLmVtaXRfc2NhbGUoKSA6IGAke3RoaXMudHJhbnNmb3JtLmVtaXRfc2NhbGUoKX0gKiAke3NjYWxlfWBcbiBcbiAgICAgIGxldCBwcmVmYWNlID1gXG4gICAgICAgIHZlYzQgJHtwTmFtZX0gPSB2ZWM0KCAoICR7cG9pbnRTdHJpbmd9ICkgLCAxLik7XFxuXG4gICAgICAgICR7cE5hbWV9LiR7dGhpcy5kaW1zfSA9IGFicyggJHtwTmFtZX0uJHt0aGlzLmRpbXN9ICk7XFxuYFxuXG4gICAgICBjb25zdCBzZGYgPSB0aGlzLnNkZi5lbWl0KCBwTmFtZSwgbnVsbCwgbnVsbCwgcyApXG5cbiAgICAgIGlmKCB0eXBlb2Ygc2RmLnByZWZhY2UgPT09ICdzdHJpbmcnICkgcHJlZmFjZSArPSBzZGYucHJlZmFjZSBcblxuICAgICAgcmV0dXJuIHsgb3V0OnNkZi5vdXQsIHByZWZhY2UgfVxuICAgIH1cbiAgfSxcbiAgLy9sZXQgcHJlZmFjZSA9IGAgICAgICAgICB2ZWMzICR7cE5hbWV9ID0gJHtuYW1lfSAvICR7dGhpcy5hbW91bnQuZW1pdCgpfTtcXG5gXG5cbiAgLy9sZXQgc2RmID0gdGhpcy5zZGYuZW1pdCggcE5hbWUgKVxuICAvL2xldCBvdXQgPSBzZGYub3V0IFxuXG4gIC8vc2RmLnByZWZhY2UgKz0gYCAgICAgICR7b3V0fS54ID0gJHtvdXR9LnggKiAke3RoaXMuYW1vdW50LmVtaXQoKX07XFxuYFxuXG4gIC8vaWYoIHR5cGVvZiBzZGYucHJlZmFjZSA9PT0gJ3N0cmluZycgKSBwcmVmYWNlICs9IHNkZi5wcmVmYWNlXG4gIFJlcGV0aXRpb246IHtcbiAgICBwYXJhbWV0ZXJzOiBbIHsgbmFtZTonZGlzdGFuY2UnLCB0eXBlOid2ZWMzJywgZGVmYXVsdDpWZWMzKDApIH0gXSxcbiAgICBlbWl0KCBuYW1lPSdwJywgdHJhbnNmb3JtPW51bGwgKSB7XG4gICAgICBjb25zdCBwSWQgPSBWYXJBbGxvYy5hbGxvYygpXG4gICAgICBjb25zdCBwTmFtZSA9ICdwJyArIHBJZFxuXG4gICAgICBpZiggdHJhbnNmb3JtICE9PSBudWxsICkgdGhpcy50cmFuc2Zvcm0uYXBwbHkoIHRyYW5zZm9ybSwgZmFsc2UgKVxuICAgICAgXG4gICAgICB0aGlzLnRyYW5zZm9ybS5pbnZlcnQoKVxuICAgICBcbiAgICAgIGNvbnN0IHBvaW50U3RyaW5nID0gIGAoICR7bmFtZX0gKiAke3RoaXMudHJhbnNmb3JtLmVtaXQoKX0gKS54eXpgO1xuXG4gICAgICBsZXQgcHJlZmFjZSA9YFxuICAgICAgICB2ZWM0ICR7cE5hbWV9ID0gdmVjNCggKG1vZCggJHtwb2ludFN0cmluZ30sICR7dGhpcy5fX3RhcmdldC5kaXN0YW5jZS5lbWl0KCl9ICkgLSAuNSAqICR7dGhpcy5fX3RhcmdldC5kaXN0YW5jZS5lbWl0KCl9KSAqICR7dGhpcy50cmFuc2Zvcm0uZW1pdF9zY2FsZSgpfSwgMS4pO1xcbmBcblxuICAgICAgY29uc3Qgc2RmID0gdGhpcy5zZGYuZW1pdCggcE5hbWUgKS8vLCB0aGlzLnRyYW5zZm9ybSApLy8sIDEsIHRoaXMuX190YXJnZXQuZGlzdGFuY2UgKVxuXG4gICAgICBpZiggdHlwZW9mIHNkZi5wcmVmYWNlID09PSAnc3RyaW5nJyApIHByZWZhY2UgKz0gc2RmLnByZWZhY2UgXG5cbiAgICAgIHJldHVybiB7IG91dDpzZGYub3V0LCBwcmVmYWNlIH1cbiAgICB9XG4gIH0sXG59XG4gIFxuY29uc3QgZ2V0RG9tYWluT3BzID0gZnVuY3Rpb24oIFNERiApIHtcbiAgY29uc3Qgb3BzID0ge31cblxuICBmb3IoIGxldCBrZXkgaW4gZGVzY3JpcHRpb25zICkge1xuICAgIGNvbnN0IG9wRGVzYyA9IGRlc2NyaXB0aW9uc1sga2V5IF1cbiAgICBcbiAgICBvcHNbIGtleSBdID0gZnVuY3Rpb24oIHNkZiwgLi4uYXJncyApIHtcbiAgICAgIGNvbnN0IG9wID0gT2JqZWN0LmNyZWF0ZSggb3BzWyBrZXkgXS5wcm90b3R5cGUgKVxuICAgICAgb3Auc2RmID0gc2RmXG4gICAgICBvcC5wYXJhbWV0ZXJzID0gW11cbiAgICAgIG9wLnRyYW5zZm9ybSA9IFRyYW5zZm9ybSgpXG4gICAgICBvcC5uYW1lID0ga2V5XG4gICAgICBjb25zdCB0YXJnZXQgPSBvcC5fX3RhcmdldCA9IG9wIC8vIHNkZi5fX3RhcmdldCAhPT0gdW5kZWZpbmVkID8gc2RmLl9fdGFyZ2V0IDogb3BcblxuICAgICAgbGV0IGNvdW50ID0gMFxuICAgICAgZm9yKCBsZXQgcHJvcCBvZiBvcERlc2MucGFyYW1ldGVycyApIHtcbiAgICAgICAgb3AucGFyYW1ldGVycy5wdXNoKCBwcm9wIClcblxuICAgICAgICBsZXQgYXJnID0gYXJnc1sgY291bnQgXVxuICAgICAgICBsZXQgX192YXJcblxuICAgICAgICBzd2l0Y2goIHByb3AudHlwZSApIHtcbiAgICAgICAgICBjYXNlICd2ZWMyJzpcbiAgICAgICAgICAgIGlmKCB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyApIGFyZyA9IFZlYzIoIGFyZyApXG4gICAgICAgICAgICBpZiggYXJnID09PSB1bmRlZmluZWQgKSBhcmcgPSBwcm9wLmRlZmF1bHQuY29weSgpXG5cbiAgICAgICAgICAgIF9fdmFyID0gcGFyYW1fd3JhcCggXG4gICAgICAgICAgICAgIGFyZywgXG4gICAgICAgICAgICAgIHZlYzJfdmFyX2dlbiggcHJvcC5kZWZhdWx0ICkgICAgXG4gICAgICAgICAgICApXG5cbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGFyZ2V0LCBwcm9wLm5hbWUsIHtcbiAgICAgICAgICAgICAgZ2V0KCkgeyByZXR1cm4gX192YXIgfSxcbiAgICAgICAgICAgICAgc2V0KHYpIHtcbiAgICAgICAgICAgICAgICBpZiggdHlwZW9mIHYgPT09ICdvYmplY3QnICkge1xuICAgICAgICAgICAgICAgICAgX192YXIuc2V0KCB2IClcbiAgICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICAgIF9fdmFyLnZhbHVlLnggPSB2XG4gICAgICAgICAgICAgICAgICBfX3Zhci52YWx1ZS55ID0gdlxuICAgICAgICAgICAgICAgICAgX192YXIuZGlydHkgPSB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSAgXG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3ZlYzMnOlxuICAgICAgICAgICAgaWYoIHR5cGVvZiBhcmcgPT09ICdudW1iZXInICkgYXJnID0gVmVjMyggYXJnIClcbiAgICAgICAgICAgIGlmKCBhcmcgPT09IHVuZGVmaW5lZCApIGFyZyA9IHByb3AuZGVmYXVsdC5jb3B5KClcblxuICAgICAgICAgICAgX192YXIgPSBwYXJhbV93cmFwKCBcbiAgICAgICAgICAgICAgYXJnLCBcbiAgICAgICAgICAgICAgdmVjM192YXJfZ2VuKCBwcm9wLmRlZmF1bHQgKVxuICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRhcmdldCwgcHJvcC5uYW1lLCB7XG4gICAgICAgICAgICAgIGdldCgpIHsgcmV0dXJuIF9fdmFyIH0sXG4gICAgICAgICAgICAgIHNldCh2KSB7XG4gICAgICAgICAgICAgICAgaWYoIHR5cGVvZiB2ID09PSAnb2JqZWN0JyApIHtcbiAgICAgICAgICAgICAgICAgIF9fdmFyLnNldCggdiApXG4gICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICBfX3Zhci52YWx1ZS54ID0gdlxuICAgICAgICAgICAgICAgICAgX192YXIudmFsdWUueSA9IHZcbiAgICAgICAgICAgICAgICAgIF9fdmFyLnZhbHVlLnogPSB2XG4gICAgICAgICAgICAgICAgICBfX3Zhci5kaXJ0eSA9IHRydWVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pICBcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndmVjNCc6XG4gICAgICAgICAgICBpZiggdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgKSBhcmcgPSBWZWM0KCBhcmcgKVxuICAgICAgICAgICAgICBfX3ZhciA9IHBhcmFtX3dyYXAoIFxuICAgICAgICAgICAgICBhcmcsIFxuICAgICAgICAgICAgICB2ZWM0X3Zhcl9nZW4oIHByb3AuZGVmYXVsdCApICBcbiAgICAgICAgICAgIClcblxuICAgICAgICAgICAgaWYoIGFyZyA9PT0gdW5kZWZpbmVkICkgYXJnID0gcHJvcC5kZWZhdWx0LmNvcHkoKVxuXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRhcmdldCwgcHJvcC5uYW1lLCB7XG4gICAgICAgICAgICAgIGdldCgpIHsgcmV0dXJuIF9fdmFyIH0sXG4gICAgICAgICAgICAgIHNldCh2KSB7XG4gICAgICAgICAgICAgICAgaWYoIHR5cGVvZiB2ID09PSAnb2JqZWN0JyApIHtcbiAgICAgICAgICAgICAgICAgIF9fdmFyLnNldCggdiApXG4gICAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICBfX3Zhci52YWx1ZS54ID0gdlxuICAgICAgICAgICAgICAgICAgX192YXIudmFsdWUueSA9IHZcbiAgICAgICAgICAgICAgICAgIF9fdmFyLnZhbHVlLnogPSB2XG4gICAgICAgICAgICAgICAgICBfX3Zhci52YWx1ZS53ID0gdlxuICAgICAgICAgICAgICAgICAgX192YXIuZGlydHkgPSB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSAgXG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6IC8vIGZsb2F0XG4gICAgICAgICAgICBfX3ZhciA9ICBwYXJhbV93cmFwKCBcbiAgICAgICAgICAgICAgYXJnLCBcbiAgICAgICAgICAgICAgZmxvYXRfdmFyX2dlbiggcHJvcC5kZWZhdWx0IClcbiAgICAgICAgICAgIClcblxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCB0YXJnZXQsIHByb3AubmFtZSwge1xuICAgICAgICAgICAgICBnZXQoKSB7IHJldHVybiBfX3ZhciB9LFxuICAgICAgICAgICAgICBzZXQodikge1xuICAgICAgICAgICAgICAgIF9fdmFyLnNldCggdiApIFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjb3VudCsrXG4gICAgICB9XG4gICAgICBcbiAgICAgIGlmKCBvcERlc2MuZXh0cmEgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgICAgZm9yKCBsZXQgZXh0cmEgb2Ygb3BEZXNjLmV4dHJhICkge1xuICAgICAgICAgIG9wWyBleHRyYS5uYW1lIF0gPSBhcmdzWyBjb3VudCAtIDEgXSB8fCBleHRyYS5kZWZhdWx0XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgb3AuX19zZXRUZXh0dXJlID0gZnVuY3Rpb24odGV4LHByb3BzKSB7XG4gICAgICAgIGlmKCB0eXBlb2YgdGV4ID09PSAnc3RyaW5nJyApIHtcbiAgICAgICAgICB0aGlzLnRleHR1cmUgPSBvcC50ZXh0dXJlLmJpbmQoIHRoaXMgKVxuICAgICAgICAgIHRoaXMuX190ZXh0dXJlT2JqID0gdGhpcy50ZXggPSBNYXJjaGluZy5UZXh0dXJlKCB0ZXgscHJvcHMsdGhpcy50ZXh0dXJlIClcbiAgICAgICAgICB0aGlzLl9fdGV4dHVyZUlEID0gdGhpcy5fX3RleHR1cmVPYmouaWRcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgdGhpcy5fX3RleHR1cmVPYmogPSB0aGlzLnRleCA9IE9iamVjdC5hc3NpZ24oIHRleCwgcHJvcHMgKVxuICAgICAgICAgIHRoaXMuX190ZXh0dXJlSUQgPSB0aGlzLl9fdGV4dHVyZU9iai5pZFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvcC5fX3NldE1hdGVyaWFsID0gZnVuY3Rpb24obWF0KSB7XG4gICAgICAgIGlmKCB0eXBlb2YgbWF0ID09PSAnc3RyaW5nJyApIG1hdCA9IE1hcmNoaW5nLk1hdGVyaWFsWyBtYXQgXVxuICAgICAgICB0aGlzLl9fbWF0ZXJpYWwgPSB0aGlzLm1hdCA9IE1hcmNoaW5nLm1hdGVyaWFscy5hZGRNYXRlcmlhbCggbWF0IClcbiAgICAgIH1cbiAgICAgIG9wLl9fZGVzYyA9IG9wRGVzY1xuXG4gICAgICBpZigga2V5ICE9PSAnTWlycm9yJyApIG9wLnNkZi5yZXBlYXQgPSBvcFxuICAgICAgcmV0dXJuIG9wXG4gICAgfVxuXG4gICAgb3BzWyBrZXkgXS5wcm90b3R5cGUgPSBTY2VuZU5vZGUoKVxuICAgIG9wc1sga2V5IF0ucHJvdG90eXBlLmVtaXQgPSBvcERlc2MuZW1pdFxuICAgIFxuICAgIG9wc1sga2V5IF0ucHJvdG90eXBlLnRleHR1cmUgPSBmdW5jdGlvbiggLi4uYXJncyApIHtcbiAgICAgIHRoaXMuX19zZXRUZXh0dXJlKCAuLi5hcmdzIClcbiAgICAgIHRoaXMuc2RmLnRleHR1cmUoIHRoaXMuX190ZXh0dXJlT2JqIClcblxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgb3BzWyBrZXkgXS5wcm90b3R5cGUubWF0ZXJpYWwgPSBmdW5jdGlvbiggLi4uYXJncyApIHtcbiAgICAgIHRoaXMuX19zZXRNYXRlcmlhbCggLi4uYXJncyApXG4gICAgICB0aGlzLnNkZi5tYXRlcmlhbCggdGhpcy5fX21hdGVyaWFsIClcblxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBvcHNbIGtleSBdLnByb3RvdHlwZS5lbWl0X2RlY2wgPSBmdW5jdGlvbiggc2hvdWxkRW1pdFNERj10cnVlICkge1xuICAgICAgbGV0IGRlY2wgPSAnJ1xuICAgICAgZGVjbCArPSB0aGlzLnRyYW5zZm9ybS5lbWl0X2RlY2woKVxuICAgICAgZm9yKCBsZXQgcGFyYW0gb2YgdGhpcy5wYXJhbWV0ZXJzICkge1xuICAgICAgICBkZWNsICs9IHRoaXMuX190YXJnZXRbIHBhcmFtLm5hbWUgXS5lbWl0X2RlY2woKSBcbiAgICAgIH1cbiAgICAgIGlmKCBzaG91bGRFbWl0U0RGICkgZGVjbCArPSB0aGlzLnNkZi5lbWl0X2RlY2woKVxuICAgICAgXG4gICAgICAvLyBmb3Igcm90YXRpb24gZXRjLi4uIGFueSBleHRyYSBnbHNsIGZ1bmN0aW9uIHRoYXQgbmVlZHMgdG9cbiAgICAgIC8vIGJlIGFkZGVkIHRvIHRoZSBzaGFkZXJcbiAgICAgIGlmKCBvcERlc2MuZ2xzbCAhPT0gdW5kZWZpbmVkICYmIFNERi5tZW1vWyBrZXkgXSA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICBkZWNsICs9IG9wRGVzYy5nbHNsXG4gICAgICAgIFNERi5tZW1vWyBrZXkgXSA9IHRydWVcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRlY2xcbiAgICB9XG4gICAgb3BzWyBrZXkgXS5wcm90b3R5cGUudXBkYXRlX2xvY2F0aW9uID0gZnVuY3Rpb24oIGdsLCBwcm9ncmFtLCBzaG91bGRVcGRhdGVTREY9dHJ1ZSApIHtcbiAgICAgIGZvciggbGV0IHBhcmFtIG9mIHRoaXMucGFyYW1ldGVycyApIHRoaXMuX190YXJnZXRbIHBhcmFtLm5hbWUgXS51cGRhdGVfbG9jYXRpb24oIGdsLCBwcm9ncmFtKVxuICAgICAgaWYoIHNob3VsZFVwZGF0ZVNERiApIHRoaXMuc2RmLnVwZGF0ZV9sb2NhdGlvbiggZ2wsIHByb2dyYW0gKVxuICAgICAgdGhpcy50cmFuc2Zvcm0udXBkYXRlX2xvY2F0aW9uKCBnbCwgcHJvZ3JhbSApXG4gICAgfVxuICAgIG9wc1sga2V5IF0ucHJvdG90eXBlLnVwbG9hZF9kYXRhID0gZnVuY3Rpb24oIGdsLCBzaG91bGRVcGxvYWRTREY9dHJ1ZSApIHtcbiAgICAgIGZvciggbGV0IHBhcmFtIG9mIHRoaXMucGFyYW1ldGVycyApIHRoaXMuX190YXJnZXRbIHBhcmFtLm5hbWUgXS51cGxvYWRfZGF0YSggZ2wgKVxuICAgICAgdGhpcy50cmFuc2Zvcm0udXBsb2FkX2RhdGEoIGdsIClcbiAgICAgIGlmKCBzaG91bGRVcGxvYWRTREYgKSB0aGlzLnNkZi51cGxvYWRfZGF0YSggZ2wgKVxuICAgIH1cbiAgfVxuICBcbiAgb3BzLlJlcGVhdCA9IG9wcy5SZXBldGl0aW9uXG4gIG9wcy5SZXBlYXRTY2FsZSA9IG9wcy5SZXBldGl0aW9uU2hyaW5rXG4gIG9wcy5Qb2xhclJlcGVhdCA9IG9wcy5Qb2xhclJlcGV0aXRpb25cblxuICByZXR1cm4gb3BzXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RG9tYWluT3BzXG4iLCIvLyBtYXRyaXguanMgLSB0YWtlbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9ldmFudy9saWdodGdsLmpzL1xuXG4vLyBSZXByZXNlbnRzIGEgNHg0IG1hdHJpeCBzdG9yZWQgaW4gcm93LW1ham9yIG9yZGVyIHRoYXQgdXNlcyBGbG9hdDMyQXJyYXlzXG4vLyB3aGVuIGF2YWlsYWJsZS4gTWF0cml4IG9wZXJhdGlvbnMgY2FuIGVpdGhlciBiZSBkb25lIHVzaW5nIGNvbnZlbmllbnRcbi8vIG1ldGhvZHMgdGhhdCByZXR1cm4gYSBuZXcgbWF0cml4IGZvciB0aGUgcmVzdWx0IG9yIG9wdGltaXplZCBtZXRob2RzXG4vLyB0aGF0IHN0b3JlIHRoZSByZXN1bHQgaW4gYW4gZXhpc3RpbmcgbWF0cml4IHRvIGF2b2lkIGdlbmVyYXRpbmcgZ2FyYmFnZS5cblxudmFyIGhhc0Zsb2F0MzJBcnJheSA9ICh0eXBlb2YgRmxvYXQzMkFycmF5ICE9ICd1bmRlZmluZWQnKTtcblxuLy8gIyMjIG5ldyBHTC5NYXRyaXgoW2VsZW1lbnRzXSlcbi8vXG4vLyBUaGlzIGNvbnN0cnVjdG9yIHRha2VzIDE2IGFyZ3VtZW50cyBpbiByb3ctbWFqb3Igb3JkZXIsIHdoaWNoIGNhbiBiZSBwYXNzZWRcbi8vIGluZGl2aWR1YWxseSwgYXMgYSBsaXN0LCBvciBldmVuIGFzIGZvdXIgbGlzdHMsIG9uZSBmb3IgZWFjaCByb3cuIElmIHRoZVxuLy8gYXJndW1lbnRzIGFyZSBvbWl0dGVkIHRoZW4gdGhlIGlkZW50aXR5IG1hdHJpeCBpcyBjb25zdHJ1Y3RlZCBpbnN0ZWFkLlxuZnVuY3Rpb24gTWF0cml4KCkge1xuICB2YXIgbSA9IEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGFyZ3VtZW50cyk7XG4gIGlmICghbS5sZW5ndGgpIHtcbiAgICBtID0gW1xuICAgICAgMSwgMCwgMCwgMCxcbiAgICAgIDAsIDEsIDAsIDAsXG4gICAgICAwLCAwLCAxLCAwLFxuICAgICAgMCwgMCwgMCwgMVxuICAgIF07XG4gIH1cbiAgdGhpcy5tID0gaGFzRmxvYXQzMkFycmF5ID8gbmV3IEZsb2F0MzJBcnJheShtKSA6IG07XG59XG5cbk1hdHJpeC5wcm90b3R5cGUgPSB7XG4gIC8vICMjIyAuaW52ZXJzZSgpXG4gIC8vXG4gIC8vIFJldHVybnMgdGhlIG1hdHJpeCB0aGF0IHdoZW4gbXVsdGlwbGllZCB3aXRoIHRoaXMgbWF0cml4IHJlc3VsdHMgaW4gdGhlXG4gIC8vIGlkZW50aXR5IG1hdHJpeC5cbiAgaW52ZXJzZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIE1hdHJpeC5pbnZlcnNlKHRoaXMsIG5ldyBNYXRyaXgoKSk7XG4gIH0sXG5cbiAgLy8gIyMjIC50cmFuc3Bvc2UoKVxuICAvL1xuICAvLyBSZXR1cm5zIHRoaXMgbWF0cml4LCBleGNoYW5naW5nIGNvbHVtbnMgZm9yIHJvd3MuXG4gIHRyYW5zcG9zZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIE1hdHJpeC50cmFuc3Bvc2UodGhpcywgbmV3IE1hdHJpeCgpKTtcbiAgfSxcblxuICAvLyAjIyMgLm11bHRpcGx5KG1hdHJpeClcbiAgLy9cbiAgLy8gUmV0dXJucyB0aGUgY29uY2F0ZW5hdGlvbiBvZiB0aGUgdHJhbnNmb3JtcyBmb3IgdGhpcyBtYXRyaXggYW5kIGBtYXRyaXhgLlxuICAvLyBUaGlzIGVtdWxhdGVzIHRoZSBPcGVuR0wgZnVuY3Rpb24gYGdsTXVsdE1hdHJpeCgpYC5cbiAgbXVsdGlwbHk6IGZ1bmN0aW9uKG1hdHJpeCkge1xuICAgIHJldHVybiBNYXRyaXgubXVsdGlwbHkodGhpcywgbWF0cml4LCBuZXcgTWF0cml4KCkpO1xuICB9LFxuXG4gIC8vICMjIyAudHJhbnNmb3JtUG9pbnQocG9pbnQpXG4gIC8vXG4gIC8vIFRyYW5zZm9ybXMgdGhlIHZlY3RvciBhcyBhIHBvaW50IHdpdGggYSB3IGNvb3JkaW5hdGUgb2YgMS4gVGhpc1xuICAvLyBtZWFucyB0cmFuc2xhdGlvbnMgd2lsbCBoYXZlIGFuIGVmZmVjdCwgZm9yIGV4YW1wbGUuXG4gIHRyYW5zZm9ybVBvaW50OiBmdW5jdGlvbih2KSB7XG4gICAgdmFyIG0gPSB0aGlzLm07XG4gICAgcmV0dXJuIG5ldyBWZWN0b3IoXG4gICAgICBtWzBdICogdi54ICsgbVsxXSAqIHYueSArIG1bMl0gKiB2LnogKyBtWzNdLFxuICAgICAgbVs0XSAqIHYueCArIG1bNV0gKiB2LnkgKyBtWzZdICogdi56ICsgbVs3XSxcbiAgICAgIG1bOF0gKiB2LnggKyBtWzldICogdi55ICsgbVsxMF0gKiB2LnogKyBtWzExXVxuICAgICkuZGl2aWRlKG1bMTJdICogdi54ICsgbVsxM10gKiB2LnkgKyBtWzE0XSAqIHYueiArIG1bMTVdKTtcbiAgfSxcblxuICAvLyAjIyMgLnRyYW5zZm9ybVBvaW50KHZlY3RvcilcbiAgLy9cbiAgLy8gVHJhbnNmb3JtcyB0aGUgdmVjdG9yIGFzIGEgdmVjdG9yIHdpdGggYSB3IGNvb3JkaW5hdGUgb2YgMC4gVGhpc1xuICAvLyBtZWFucyB0cmFuc2xhdGlvbnMgd2lsbCBoYXZlIG5vIGVmZmVjdCwgZm9yIGV4YW1wbGUuXG4gIHRyYW5zZm9ybVZlY3RvcjogZnVuY3Rpb24odikge1xuICAgIHZhciBtID0gdGhpcy5tO1xuICAgIHJldHVybiBuZXcgVmVjdG9yKFxuICAgICAgbVswXSAqIHYueCArIG1bMV0gKiB2LnkgKyBtWzJdICogdi56LFxuICAgICAgbVs0XSAqIHYueCArIG1bNV0gKiB2LnkgKyBtWzZdICogdi56LFxuICAgICAgbVs4XSAqIHYueCArIG1bOV0gKiB2LnkgKyBtWzEwXSAqIHYuelxuICAgICk7XG4gIH1cbn07XG5cbi8vICMjIyBHTC5NYXRyaXguaW52ZXJzZShtYXRyaXhbLCByZXN1bHRdKVxuLy9cbi8vIFJldHVybnMgdGhlIG1hdHJpeCB0aGF0IHdoZW4gbXVsdGlwbGllZCB3aXRoIGBtYXRyaXhgIHJlc3VsdHMgaW4gdGhlXG4vLyBpZGVudGl0eSBtYXRyaXguIFlvdSBjYW4gb3B0aW9uYWxseSBwYXNzIGFuIGV4aXN0aW5nIG1hdHJpeCBpbiBgcmVzdWx0YFxuLy8gdG8gYXZvaWQgYWxsb2NhdGluZyBhIG5ldyBtYXRyaXguIFRoaXMgaW1wbGVtZW50YXRpb24gaXMgZnJvbSB0aGUgTWVzYVxuLy8gT3BlbkdMIGZ1bmN0aW9uIGBfX2dsdUludmVydE1hdHJpeGQoKWAgZm91bmQgaW4gYHByb2plY3QuY2AuXG5NYXRyaXguaW52ZXJzZSA9IGZ1bmN0aW9uKG1hdHJpeCwgcmVzdWx0KSB7XG4gIHJlc3VsdCA9IHJlc3VsdCB8fCBuZXcgTWF0cml4KCk7XG4gIHZhciBtID0gbWF0cml4Lm0sIHIgPSByZXN1bHQubTtcblxuICByWzBdID0gbVs1XSptWzEwXSptWzE1XSAtIG1bNV0qbVsxNF0qbVsxMV0gLSBtWzZdKm1bOV0qbVsxNV0gKyBtWzZdKm1bMTNdKm1bMTFdICsgbVs3XSptWzldKm1bMTRdIC0gbVs3XSptWzEzXSptWzEwXTtcbiAgclsxXSA9IC1tWzFdKm1bMTBdKm1bMTVdICsgbVsxXSptWzE0XSptWzExXSArIG1bMl0qbVs5XSptWzE1XSAtIG1bMl0qbVsxM10qbVsxMV0gLSBtWzNdKm1bOV0qbVsxNF0gKyBtWzNdKm1bMTNdKm1bMTBdO1xuICByWzJdID0gbVsxXSptWzZdKm1bMTVdIC0gbVsxXSptWzE0XSptWzddIC0gbVsyXSptWzVdKm1bMTVdICsgbVsyXSptWzEzXSptWzddICsgbVszXSptWzVdKm1bMTRdIC0gbVszXSptWzEzXSptWzZdO1xuICByWzNdID0gLW1bMV0qbVs2XSptWzExXSArIG1bMV0qbVsxMF0qbVs3XSArIG1bMl0qbVs1XSptWzExXSAtIG1bMl0qbVs5XSptWzddIC0gbVszXSptWzVdKm1bMTBdICsgbVszXSptWzldKm1bNl07XG5cbiAgcls0XSA9IC1tWzRdKm1bMTBdKm1bMTVdICsgbVs0XSptWzE0XSptWzExXSArIG1bNl0qbVs4XSptWzE1XSAtIG1bNl0qbVsxMl0qbVsxMV0gLSBtWzddKm1bOF0qbVsxNF0gKyBtWzddKm1bMTJdKm1bMTBdO1xuICByWzVdID0gbVswXSptWzEwXSptWzE1XSAtIG1bMF0qbVsxNF0qbVsxMV0gLSBtWzJdKm1bOF0qbVsxNV0gKyBtWzJdKm1bMTJdKm1bMTFdICsgbVszXSptWzhdKm1bMTRdIC0gbVszXSptWzEyXSptWzEwXTtcbiAgcls2XSA9IC1tWzBdKm1bNl0qbVsxNV0gKyBtWzBdKm1bMTRdKm1bN10gKyBtWzJdKm1bNF0qbVsxNV0gLSBtWzJdKm1bMTJdKm1bN10gLSBtWzNdKm1bNF0qbVsxNF0gKyBtWzNdKm1bMTJdKm1bNl07XG4gIHJbN10gPSBtWzBdKm1bNl0qbVsxMV0gLSBtWzBdKm1bMTBdKm1bN10gLSBtWzJdKm1bNF0qbVsxMV0gKyBtWzJdKm1bOF0qbVs3XSArIG1bM10qbVs0XSptWzEwXSAtIG1bM10qbVs4XSptWzZdO1xuXG4gIHJbOF0gPSBtWzRdKm1bOV0qbVsxNV0gLSBtWzRdKm1bMTNdKm1bMTFdIC0gbVs1XSptWzhdKm1bMTVdICsgbVs1XSptWzEyXSptWzExXSArIG1bN10qbVs4XSptWzEzXSAtIG1bN10qbVsxMl0qbVs5XTtcbiAgcls5XSA9IC1tWzBdKm1bOV0qbVsxNV0gKyBtWzBdKm1bMTNdKm1bMTFdICsgbVsxXSptWzhdKm1bMTVdIC0gbVsxXSptWzEyXSptWzExXSAtIG1bM10qbVs4XSptWzEzXSArIG1bM10qbVsxMl0qbVs5XTtcbiAgclsxMF0gPSBtWzBdKm1bNV0qbVsxNV0gLSBtWzBdKm1bMTNdKm1bN10gLSBtWzFdKm1bNF0qbVsxNV0gKyBtWzFdKm1bMTJdKm1bN10gKyBtWzNdKm1bNF0qbVsxM10gLSBtWzNdKm1bMTJdKm1bNV07XG4gIHJbMTFdID0gLW1bMF0qbVs1XSptWzExXSArIG1bMF0qbVs5XSptWzddICsgbVsxXSptWzRdKm1bMTFdIC0gbVsxXSptWzhdKm1bN10gLSBtWzNdKm1bNF0qbVs5XSArIG1bM10qbVs4XSptWzVdO1xuXG4gIHJbMTJdID0gLW1bNF0qbVs5XSptWzE0XSArIG1bNF0qbVsxM10qbVsxMF0gKyBtWzVdKm1bOF0qbVsxNF0gLSBtWzVdKm1bMTJdKm1bMTBdIC0gbVs2XSptWzhdKm1bMTNdICsgbVs2XSptWzEyXSptWzldO1xuICByWzEzXSA9IG1bMF0qbVs5XSptWzE0XSAtIG1bMF0qbVsxM10qbVsxMF0gLSBtWzFdKm1bOF0qbVsxNF0gKyBtWzFdKm1bMTJdKm1bMTBdICsgbVsyXSptWzhdKm1bMTNdIC0gbVsyXSptWzEyXSptWzldO1xuICByWzE0XSA9IC1tWzBdKm1bNV0qbVsxNF0gKyBtWzBdKm1bMTNdKm1bNl0gKyBtWzFdKm1bNF0qbVsxNF0gLSBtWzFdKm1bMTJdKm1bNl0gLSBtWzJdKm1bNF0qbVsxM10gKyBtWzJdKm1bMTJdKm1bNV07XG4gIHJbMTVdID0gbVswXSptWzVdKm1bMTBdIC0gbVswXSptWzldKm1bNl0gLSBtWzFdKm1bNF0qbVsxMF0gKyBtWzFdKm1bOF0qbVs2XSArIG1bMl0qbVs0XSptWzldIC0gbVsyXSptWzhdKm1bNV07XG5cbiAgdmFyIGRldCA9IG1bMF0qclswXSArIG1bMV0qcls0XSArIG1bMl0qcls4XSArIG1bM10qclsxMl07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykgcltpXSAvPSBkZXQ7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyAjIyMgR0wuTWF0cml4LnRyYW5zcG9zZShtYXRyaXhbLCByZXN1bHRdKVxuLy9cbi8vIFJldHVybnMgYG1hdHJpeGAsIGV4Y2hhbmdpbmcgY29sdW1ucyBmb3Igcm93cy4gWW91IGNhbiBvcHRpb25hbGx5IHBhc3MgYW5cbi8vIGV4aXN0aW5nIG1hdHJpeCBpbiBgcmVzdWx0YCB0byBhdm9pZCBhbGxvY2F0aW5nIGEgbmV3IG1hdHJpeC5cbk1hdHJpeC50cmFuc3Bvc2UgPSBmdW5jdGlvbihtYXRyaXgsIHJlc3VsdCkge1xuICByZXN1bHQgPSByZXN1bHQgfHwgbmV3IE1hdHJpeCgpO1xuICB2YXIgbSA9IG1hdHJpeC5tLCByID0gcmVzdWx0Lm07XG4gIHJbMF0gPSBtWzBdOyByWzFdID0gbVs0XTsgclsyXSA9IG1bOF07IHJbM10gPSBtWzEyXTtcbiAgcls0XSA9IG1bMV07IHJbNV0gPSBtWzVdOyByWzZdID0gbVs5XTsgcls3XSA9IG1bMTNdO1xuICByWzhdID0gbVsyXTsgcls5XSA9IG1bNl07IHJbMTBdID0gbVsxMF07IHJbMTFdID0gbVsxNF07XG4gIHJbMTJdID0gbVszXTsgclsxM10gPSBtWzddOyByWzE0XSA9IG1bMTFdOyByWzE1XSA9IG1bMTVdO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gIyMjIEdMLk1hdHJpeC5tdWx0aXBseShsZWZ0LCByaWdodFssIHJlc3VsdF0pXG4vL1xuLy8gUmV0dXJucyB0aGUgY29uY2F0ZW5hdGlvbiBvZiB0aGUgdHJhbnNmb3JtcyBmb3IgYGxlZnRgIGFuZCBgcmlnaHRgLiBZb3UgY2FuXG4vLyBvcHRpb25hbGx5IHBhc3MgYW4gZXhpc3RpbmcgbWF0cml4IGluIGByZXN1bHRgIHRvIGF2b2lkIGFsbG9jYXRpbmcgYSBuZXdcbi8vIG1hdHJpeC4gVGhpcyBlbXVsYXRlcyB0aGUgT3BlbkdMIGZ1bmN0aW9uIGBnbE11bHRNYXRyaXgoKWAuXG5NYXRyaXgubXVsdGlwbHkgPSBmdW5jdGlvbihsZWZ0LCByaWdodCwgcmVzdWx0KSB7XG4gIHJlc3VsdCA9IHJlc3VsdCB8fCBuZXcgTWF0cml4KCk7XG4gIHZhciBhID0gbGVmdC5tLCBiID0gcmlnaHQubSwgciA9IHJlc3VsdC5tO1xuXG4gIHJbMF0gPSBhWzBdICogYlswXSArIGFbMV0gKiBiWzRdICsgYVsyXSAqIGJbOF0gKyBhWzNdICogYlsxMl07XG4gIHJbMV0gPSBhWzBdICogYlsxXSArIGFbMV0gKiBiWzVdICsgYVsyXSAqIGJbOV0gKyBhWzNdICogYlsxM107XG4gIHJbMl0gPSBhWzBdICogYlsyXSArIGFbMV0gKiBiWzZdICsgYVsyXSAqIGJbMTBdICsgYVszXSAqIGJbMTRdO1xuICByWzNdID0gYVswXSAqIGJbM10gKyBhWzFdICogYls3XSArIGFbMl0gKiBiWzExXSArIGFbM10gKiBiWzE1XTtcblxuICByWzRdID0gYVs0XSAqIGJbMF0gKyBhWzVdICogYls0XSArIGFbNl0gKiBiWzhdICsgYVs3XSAqIGJbMTJdO1xuICByWzVdID0gYVs0XSAqIGJbMV0gKyBhWzVdICogYls1XSArIGFbNl0gKiBiWzldICsgYVs3XSAqIGJbMTNdO1xuICByWzZdID0gYVs0XSAqIGJbMl0gKyBhWzVdICogYls2XSArIGFbNl0gKiBiWzEwXSArIGFbN10gKiBiWzE0XTtcbiAgcls3XSA9IGFbNF0gKiBiWzNdICsgYVs1XSAqIGJbN10gKyBhWzZdICogYlsxMV0gKyBhWzddICogYlsxNV07XG5cbiAgcls4XSA9IGFbOF0gKiBiWzBdICsgYVs5XSAqIGJbNF0gKyBhWzEwXSAqIGJbOF0gKyBhWzExXSAqIGJbMTJdO1xuICByWzldID0gYVs4XSAqIGJbMV0gKyBhWzldICogYls1XSArIGFbMTBdICogYls5XSArIGFbMTFdICogYlsxM107XG4gIHJbMTBdID0gYVs4XSAqIGJbMl0gKyBhWzldICogYls2XSArIGFbMTBdICogYlsxMF0gKyBhWzExXSAqIGJbMTRdO1xuICByWzExXSA9IGFbOF0gKiBiWzNdICsgYVs5XSAqIGJbN10gKyBhWzEwXSAqIGJbMTFdICsgYVsxMV0gKiBiWzE1XTtcblxuICByWzEyXSA9IGFbMTJdICogYlswXSArIGFbMTNdICogYls0XSArIGFbMTRdICogYls4XSArIGFbMTVdICogYlsxMl07XG4gIHJbMTNdID0gYVsxMl0gKiBiWzFdICsgYVsxM10gKiBiWzVdICsgYVsxNF0gKiBiWzldICsgYVsxNV0gKiBiWzEzXTtcbiAgclsxNF0gPSBhWzEyXSAqIGJbMl0gKyBhWzEzXSAqIGJbNl0gKyBhWzE0XSAqIGJbMTBdICsgYVsxNV0gKiBiWzE0XTtcbiAgclsxNV0gPSBhWzEyXSAqIGJbM10gKyBhWzEzXSAqIGJbN10gKyBhWzE0XSAqIGJbMTFdICsgYVsxNV0gKiBiWzE1XTtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gIyMjIEdMLk1hdHJpeC5pZGVudGl0eShbcmVzdWx0XSlcbi8vXG4vLyBSZXR1cm5zIGFuIGlkZW50aXR5IG1hdHJpeC4gWW91IGNhbiBvcHRpb25hbGx5IHBhc3MgYW4gZXhpc3RpbmcgbWF0cml4IGluXG4vLyBgcmVzdWx0YCB0byBhdm9pZCBhbGxvY2F0aW5nIGEgbmV3IG1hdHJpeC4gVGhpcyBlbXVsYXRlcyB0aGUgT3BlbkdMIGZ1bmN0aW9uXG4vLyBgZ2xMb2FkSWRlbnRpdHkoKWAuXG5NYXRyaXguaWRlbnRpdHkgPSBmdW5jdGlvbihyZXN1bHQpIHtcbiAgcmVzdWx0ID0gcmVzdWx0IHx8IG5ldyBNYXRyaXgoKTtcbiAgdmFyIG0gPSByZXN1bHQubTtcbiAgbVswXSA9IG1bNV0gPSBtWzEwXSA9IG1bMTVdID0gMTtcbiAgbVsxXSA9IG1bMl0gPSBtWzNdID0gbVs0XSA9IG1bNl0gPSBtWzddID0gbVs4XSA9IG1bOV0gPSBtWzExXSA9IG1bMTJdID0gbVsxM10gPSBtWzE0XSA9IDA7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyAjIyMgR0wuTWF0cml4LnBlcnNwZWN0aXZlKGZvdiwgYXNwZWN0LCBuZWFyLCBmYXJbLCByZXN1bHRdKVxuLy9cbi8vIFJldHVybnMgYSBwZXJzcGVjdGl2ZSB0cmFuc2Zvcm0gbWF0cml4LCB3aGljaCBtYWtlcyBmYXIgYXdheSBvYmplY3RzIGFwcGVhclxuLy8gc21hbGxlciB0aGFuIG5lYXJieSBvYmplY3RzLiBUaGUgYGFzcGVjdGAgYXJndW1lbnQgc2hvdWxkIGJlIHRoZSB3aWR0aFxuLy8gZGl2aWRlZCBieSB0aGUgaGVpZ2h0IG9mIHlvdXIgdmlld3BvcnQgYW5kIGBmb3ZgIGlzIHRoZSB0b3AtdG8tYm90dG9tIGFuZ2xlXG4vLyBvZiB0aGUgZmllbGQgb2YgdmlldyBpbiBkZWdyZWVzLiBZb3UgY2FuIG9wdGlvbmFsbHkgcGFzcyBhbiBleGlzdGluZyBtYXRyaXhcbi8vIGluIGByZXN1bHRgIHRvIGF2b2lkIGFsbG9jYXRpbmcgYSBuZXcgbWF0cml4LiBUaGlzIGVtdWxhdGVzIHRoZSBPcGVuR0xcbi8vIGZ1bmN0aW9uIGBnbHVQZXJzcGVjdGl2ZSgpYC5cbk1hdHJpeC5wZXJzcGVjdGl2ZSA9IGZ1bmN0aW9uKGZvdiwgYXNwZWN0LCBuZWFyLCBmYXIsIHJlc3VsdCkge1xuICB2YXIgeSA9IE1hdGgudGFuKGZvdiAqIE1hdGguUEkgLyAzNjApICogbmVhcjtcbiAgdmFyIHggPSB5ICogYXNwZWN0O1xuICByZXR1cm4gTWF0cml4LmZydXN0dW0oLXgsIHgsIC15LCB5LCBuZWFyLCBmYXIsIHJlc3VsdCk7XG59O1xuXG4vLyAjIyMgR0wuTWF0cml4LmZydXN0dW0obGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXJbLCByZXN1bHRdKVxuLy9cbi8vIFNldHMgdXAgYSB2aWV3aW5nIGZydXN0dW0sIHdoaWNoIGlzIHNoYXBlZCBsaWtlIGEgdHJ1bmNhdGVkIHB5cmFtaWQgd2l0aCB0aGVcbi8vIGNhbWVyYSB3aGVyZSB0aGUgcG9pbnQgb2YgdGhlIHB5cmFtaWQgd291bGQgYmUuIFlvdSBjYW4gb3B0aW9uYWxseSBwYXNzIGFuXG4vLyBleGlzdGluZyBtYXRyaXggaW4gYHJlc3VsdGAgdG8gYXZvaWQgYWxsb2NhdGluZyBhIG5ldyBtYXRyaXguIFRoaXMgZW11bGF0ZXNcbi8vIHRoZSBPcGVuR0wgZnVuY3Rpb24gYGdsRnJ1c3R1bSgpYC5cbk1hdHJpeC5mcnVzdHVtID0gZnVuY3Rpb24obCwgciwgYiwgdCwgbiwgZiwgcmVzdWx0KSB7XG4gIHJlc3VsdCA9IHJlc3VsdCB8fCBuZXcgTWF0cml4KCk7XG4gIHZhciBtID0gcmVzdWx0Lm07XG5cbiAgbVswXSA9IDIgKiBuIC8gKHIgLSBsKTtcbiAgbVsxXSA9IDA7XG4gIG1bMl0gPSAociArIGwpIC8gKHIgLSBsKTtcbiAgbVszXSA9IDA7XG5cbiAgbVs0XSA9IDA7XG4gIG1bNV0gPSAyICogbiAvICh0IC0gYik7XG4gIG1bNl0gPSAodCArIGIpIC8gKHQgLSBiKTtcbiAgbVs3XSA9IDA7XG5cbiAgbVs4XSA9IDA7XG4gIG1bOV0gPSAwO1xuICBtWzEwXSA9IC0oZiArIG4pIC8gKGYgLSBuKTtcbiAgbVsxMV0gPSAtMiAqIGYgKiBuIC8gKGYgLSBuKTtcblxuICBtWzEyXSA9IDA7XG4gIG1bMTNdID0gMDtcbiAgbVsxNF0gPSAtMTtcbiAgbVsxNV0gPSAwO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vLyAjIyMgR0wuTWF0cml4Lm9ydGhvKGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyWywgcmVzdWx0XSlcbi8vXG4vLyBSZXR1cm5zIGFuIG9ydGhvZ3JhcGhpYyBwcm9qZWN0aW9uLCBpbiB3aGljaCBvYmplY3RzIGFyZSB0aGUgc2FtZSBzaXplIG5vXG4vLyBtYXR0ZXIgaG93IGZhciBhd2F5IG9yIG5lYXJieSB0aGV5IGFyZS4gWW91IGNhbiBvcHRpb25hbGx5IHBhc3MgYW4gZXhpc3Rpbmdcbi8vIG1hdHJpeCBpbiBgcmVzdWx0YCB0byBhdm9pZCBhbGxvY2F0aW5nIGEgbmV3IG1hdHJpeC4gVGhpcyBlbXVsYXRlcyB0aGUgT3BlbkdMXG4vLyBmdW5jdGlvbiBgZ2xPcnRobygpYC5cbk1hdHJpeC5vcnRobyA9IGZ1bmN0aW9uKGwsIHIsIGIsIHQsIG4sIGYsIHJlc3VsdCkge1xuICByZXN1bHQgPSByZXN1bHQgfHwgbmV3IE1hdHJpeCgpO1xuICB2YXIgbSA9IHJlc3VsdC5tO1xuXG4gIG1bMF0gPSAyIC8gKHIgLSBsKTtcbiAgbVsxXSA9IDA7XG4gIG1bMl0gPSAwO1xuICBtWzNdID0gLShyICsgbCkgLyAociAtIGwpO1xuXG4gIG1bNF0gPSAwO1xuICBtWzVdID0gMiAvICh0IC0gYik7XG4gIG1bNl0gPSAwO1xuICBtWzddID0gLSh0ICsgYikgLyAodCAtIGIpO1xuXG4gIG1bOF0gPSAwO1xuICBtWzldID0gMDtcbiAgbVsxMF0gPSAtMiAvIChmIC0gbik7XG4gIG1bMTFdID0gLShmICsgbikgLyAoZiAtIG4pO1xuXG4gIG1bMTJdID0gMDtcbiAgbVsxM10gPSAwO1xuICBtWzE0XSA9IDA7XG4gIG1bMTVdID0gMTtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gIyMjIEdMLk1hdHJpeC5zY2FsZSh4LCB5LCB6WywgcmVzdWx0XSlcbi8vXG4vLyBUaGlzIGVtdWxhdGVzIHRoZSBPcGVuR0wgZnVuY3Rpb24gYGdsU2NhbGUoKWAuIFlvdSBjYW4gb3B0aW9uYWxseSBwYXNzIGFuXG4vLyBleGlzdGluZyBtYXRyaXggaW4gYHJlc3VsdGAgdG8gYXZvaWQgYWxsb2NhdGluZyBhIG5ldyBtYXRyaXguXG5NYXRyaXguc2NhbGUgPSBmdW5jdGlvbih4LCB5LCB6LCByZXN1bHQpIHtcbiAgcmVzdWx0ID0gcmVzdWx0IHx8IG5ldyBNYXRyaXgoKTtcbiAgdmFyIG0gPSByZXN1bHQubTtcblxuICBtWzBdID0geDtcbiAgbVsxXSA9IDA7XG4gIG1bMl0gPSAwO1xuICBtWzNdID0gMDtcblxuICBtWzRdID0gMDtcbiAgbVs1XSA9IHk7XG4gIG1bNl0gPSAwO1xuICBtWzddID0gMDtcblxuICBtWzhdID0gMDtcbiAgbVs5XSA9IDA7XG4gIG1bMTBdID0gejtcbiAgbVsxMV0gPSAwO1xuXG4gIG1bMTJdID0gMDtcbiAgbVsxM10gPSAwO1xuICBtWzE0XSA9IDA7XG4gIG1bMTVdID0gMTtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gIyMjIEdMLk1hdHJpeC50cmFuc2xhdGUoeCwgeSwgelssIHJlc3VsdF0pXG4vL1xuLy8gVGhpcyBlbXVsYXRlcyB0aGUgT3BlbkdMIGZ1bmN0aW9uIGBnbFRyYW5zbGF0ZSgpYC4gWW91IGNhbiBvcHRpb25hbGx5IHBhc3Ncbi8vIGFuIGV4aXN0aW5nIG1hdHJpeCBpbiBgcmVzdWx0YCB0byBhdm9pZCBhbGxvY2F0aW5nIGEgbmV3IG1hdHJpeC5cbk1hdHJpeC50cmFuc2xhdGUgPSBmdW5jdGlvbih4LCB5LCB6LCByZXN1bHQpIHtcbiAgcmVzdWx0ID0gcmVzdWx0IHx8IG5ldyBNYXRyaXgoKTtcbiAgdmFyIG0gPSByZXN1bHQubTtcblxuICBtWzBdID0gMTtcbiAgbVsxXSA9IDA7XG4gIG1bMl0gPSAwO1xuICBtWzNdID0geDtcblxuICBtWzRdID0gMDtcbiAgbVs1XSA9IDE7XG4gIG1bNl0gPSAwO1xuICBtWzddID0geTtcblxuICBtWzhdID0gMDtcbiAgbVs5XSA9IDA7XG4gIG1bMTBdID0gMTtcbiAgbVsxMV0gPSB6O1xuXG4gIG1bMTJdID0gMDtcbiAgbVsxM10gPSAwO1xuICBtWzE0XSA9IDA7XG4gIG1bMTVdID0gMTtcblxuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gIyMjIEdMLk1hdHJpeC5yb3RhdGUoYSwgeCwgeSwgelssIHJlc3VsdF0pXG4vL1xuLy8gUmV0dXJucyBhIG1hdHJpeCB0aGF0IHJvdGF0ZXMgYnkgYGFgIGRlZ3JlZXMgYXJvdW5kIHRoZSB2ZWN0b3IgYHgsIHksIHpgLlxuLy8gWW91IGNhbiBvcHRpb25hbGx5IHBhc3MgYW4gZXhpc3RpbmcgbWF0cml4IGluIGByZXN1bHRgIHRvIGF2b2lkIGFsbG9jYXRpbmdcbi8vIGEgbmV3IG1hdHJpeC4gVGhpcyBlbXVsYXRlcyB0aGUgT3BlbkdMIGZ1bmN0aW9uIGBnbFJvdGF0ZSgpYC5cbk1hdHJpeC5yb3RhdGUgPSBmdW5jdGlvbihhLCB4LCB5LCB6LCByZXN1bHQpIHtcbiAgaWYgKCFhIHx8ICgheCAmJiAheSAmJiAheikpIHtcbiAgICByZXR1cm4gTWF0cml4LmlkZW50aXR5KHJlc3VsdCk7XG4gIH1cblxuICByZXN1bHQgPSByZXN1bHQgfHwgbmV3IE1hdHJpeCgpO1xuICB2YXIgbSA9IHJlc3VsdC5tO1xuXG4gIHZhciBkID0gTWF0aC5zcXJ0KHgqeCArIHkqeSArIHoqeik7XG4gIGEgKj0gTWF0aC5QSSAvIDE4MDsgeCAvPSBkOyB5IC89IGQ7IHogLz0gZDtcbiAgdmFyIGMgPSBNYXRoLmNvcyhhKSwgcyA9IE1hdGguc2luKGEpLCB0ID0gMSAtIGM7XG5cbiAgbVswXSA9IHggKiB4ICogdCArIGM7XG4gIG1bMV0gPSB4ICogeSAqIHQgLSB6ICogcztcbiAgbVsyXSA9IHggKiB6ICogdCArIHkgKiBzO1xuICBtWzNdID0gMDtcblxuICBtWzRdID0geSAqIHggKiB0ICsgeiAqIHM7XG4gIG1bNV0gPSB5ICogeSAqIHQgKyBjO1xuICBtWzZdID0geSAqIHogKiB0IC0geCAqIHM7XG4gIG1bN10gPSAwO1xuXG4gIG1bOF0gPSB6ICogeCAqIHQgLSB5ICogcztcbiAgbVs5XSA9IHogKiB5ICogdCArIHggKiBzO1xuICBtWzEwXSA9IHogKiB6ICogdCArIGM7XG4gIG1bMTFdID0gMDtcblxuICBtWzEyXSA9IDA7XG4gIG1bMTNdID0gMDtcbiAgbVsxNF0gPSAwO1xuICBtWzE1XSA9IDE7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vICMjIyBHTC5NYXRyaXgubG9va0F0KGV4LCBleSwgZXosIGN4LCBjeSwgY3osIHV4LCB1eSwgdXpbLCByZXN1bHRdKVxuLy9cbi8vIFJldHVybnMgYSBtYXRyaXggdGhhdCBwdXRzIHRoZSBjYW1lcmEgYXQgdGhlIGV5ZSBwb2ludCBgZXgsIGV5LCBlemAgbG9va2luZ1xuLy8gdG93YXJkIHRoZSBjZW50ZXIgcG9pbnQgYGN4LCBjeSwgY3pgIHdpdGggYW4gdXAgZGlyZWN0aW9uIG9mIGB1eCwgdXksIHV6YC5cbi8vIFlvdSBjYW4gb3B0aW9uYWxseSBwYXNzIGFuIGV4aXN0aW5nIG1hdHJpeCBpbiBgcmVzdWx0YCB0byBhdm9pZCBhbGxvY2F0aW5nXG4vLyBhIG5ldyBtYXRyaXguIFRoaXMgZW11bGF0ZXMgdGhlIE9wZW5HTCBmdW5jdGlvbiBgZ2x1TG9va0F0KClgLlxuTWF0cml4Lmxvb2tBdCA9IGZ1bmN0aW9uKGV4LCBleSwgZXosIGN4LCBjeSwgY3osIHV4LCB1eSwgdXosIHJlc3VsdCkge1xuICByZXN1bHQgPSByZXN1bHQgfHwgbmV3IE1hdHJpeCgpO1xuICB2YXIgbSA9IHJlc3VsdC5tO1xuXG4gIHZhciBlID0gbmV3IFZlY3RvcihleCwgZXksIGV6KTtcbiAgdmFyIGMgPSBuZXcgVmVjdG9yKGN4LCBjeSwgY3opO1xuICB2YXIgdSA9IG5ldyBWZWN0b3IodXgsIHV5LCB1eik7XG4gIHZhciBmID0gZS5zdWJ0cmFjdChjKS51bml0KCk7XG4gIHZhciBzID0gdS5jcm9zcyhmKS51bml0KCk7XG4gIHZhciB0ID0gZi5jcm9zcyhzKS51bml0KCk7XG5cbiAgbVswXSA9IHMueDtcbiAgbVsxXSA9IHMueTtcbiAgbVsyXSA9IHMuejtcbiAgbVszXSA9IC1zLmRvdChlKTtcblxuICBtWzRdID0gdC54O1xuICBtWzVdID0gdC55O1xuICBtWzZdID0gdC56O1xuICBtWzddID0gLXQuZG90KGUpO1xuXG4gIG1bOF0gPSBmLng7XG4gIG1bOV0gPSBmLnk7XG4gIG1bMTBdID0gZi56O1xuICBtWzExXSA9IC1mLmRvdChlKTtcblxuICBtWzEyXSA9IDA7XG4gIG1bMTNdID0gMDtcbiAgbVsxNF0gPSAwO1xuICBtWzE1XSA9IDE7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTWF0cml4XG4iLCJjb25zdCBlbWl0X2Zsb2F0ID0gZnVuY3Rpb24oIGEgKSB7XG5cdGlmIChhICUgMSA9PT0gMClcblx0XHRyZXR1cm4gYS50b0ZpeGVkKCAxIClcblx0ZWxzZVxuXHRcdHJldHVybiBhXG59XG5cbmNvbnN0IEZsb2F0UHJvdG90eXBlID0ge1xuICB0eXBlOiAnZmxvYXQnLFxuXHRlbWl0KCkgeyByZXR1cm4gZW1pdF9mbG9hdCggdGhpcy54ICkgfSxcblx0ZW1pdF9kZWNsKCkgeyByZXR1cm4gXCJcIiB9XG59XG5cblxuY29uc3QgRmxvYXQgPSBmdW5jdGlvbiggeD0wICkge1xuICBjb25zdCBmID0gT2JqZWN0LmNyZWF0ZSggRmxvYXRQcm90b3R5cGUgKVxuICBmLnggPSB4XG4gIHJldHVybiBmXG59XG5cbm1vZHVsZS5leHBvcnRzID0gRmxvYXRcbiIsImNvbnN0IFNjZW5lTm9kZSA9IHJlcXVpcmUoICcuL3NjZW5lTm9kZS5qcycgKSxcbiAgICAgIHsgcGFyYW1fd3JhcCwgTWF0ZXJpYWxJRCB9ID0gcmVxdWlyZSggJy4vdXRpbHMuanMnICksXG4gICAgICB7IFZhciwgZmxvYXRfdmFyX2dlbiwgdmVjMl92YXJfZ2VuLCB2ZWMzX3Zhcl9nZW4sIHZlYzRfdmFyX2dlbiwgaW50X3Zhcl9nZW4sIFZhckFsbG9jIH0gPSByZXF1aXJlKCAnLi92YXIuanMnIClcblxuY29uc3QgeyBWZWMyLCBWZWMzLCBWZWM0IH0gPSByZXF1aXJlKCAnLi92ZWMuanMnIClcblxuY29uc3QgRm9nZ2VyID0gZnVuY3Rpb24oIFNjZW5lLCBTREYgKSB7XG5cbiAgY29uc3QgRm9nID0gZnVuY3Rpb24oIGFtb3VudD0wLjA1NSwgY29sb3IgKSB7XG4gICAgY29uc3QgZm9nID0gT2JqZWN0LmNyZWF0ZSggRm9nLnByb3RvdHlwZSApXG4gICAgY29uc3QgX19hbW91bnQgPSBwYXJhbV93cmFwKCBhbW91bnQsIGZsb2F0X3Zhcl9nZW4oIGFtb3VudCApICkgIFxuICAgIFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggZm9nLCAnYW1vdW50Jywge1xuICAgICAgZ2V0KCkgeyByZXR1cm4gX19hbW91bnQgfSxcbiAgICAgIHNldCggdiApIHtcbiAgICAgICAgX19hbW91bnQuc2V0KCB2IClcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgY29uc3QgX19jb2xvciA9IHBhcmFtX3dyYXAoIFZlYzMoY29sb3IpLCB2ZWMzX3Zhcl9nZW4oIDAsMCwwICkgKSAgXG4gICAgXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBmb2csICdjb2xvcicsIHtcbiAgICAgIGdldCgpIHsgcmV0dXJuIF9fY29sb3IgfSxcbiAgICAgIHNldCggdiApIHtcbiAgICAgICAgX19jb2xvci52YXIuc2V0KCB2IClcbiAgICAgIH1cbiAgICB9KVxuICAgIFxuICAgIC8vIHRoaXMgcmVmZXJzIHRvIHRoZSBjdXJyZW50IHNjZW5lIHZpYSBpbXBsaWNpdCBiaW5kaW5nIGluIHNjZW5lLmpzXG4gICAgdGhpcy5wb3N0cHJvY2Vzc2luZy5wdXNoKCBmb2cgKVxuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIEZvZy5wcm90b3R5cGUgPSBTY2VuZU5vZGUoKVxuIFxuICBPYmplY3QuYXNzaWduKCBGb2cucHJvdG90eXBlLCB7XG4gICAgZW1pdCgpIHtcbiAgICAgIHJldHVybiBgICBjb2xvciA9IGFwcGx5Rm9nKCBjb2xvciwgdC54LCAke3RoaXMuYW1vdW50LmVtaXQoKX0gKTtgXG4gICAgfSxcbiAgIFxuICAgIGVtaXRfZGVjbCgpIHtcbiAgICAgIGxldCBzdHIgPSB0aGlzLmFtb3VudC5lbWl0X2RlY2woKSArIHRoaXMuY29sb3IuZW1pdF9kZWNsKClcbiAgICAgIGNvbnN0IHByZWZhY2UgPSBgICB2ZWMzIGFwcGx5Rm9nKCBpbiB2ZWMzIHJnYiwgaW4gZmxvYXQgZGlzdGFuY2UsIGluIGZsb2F0IGFtb3VudCApIHtcbiAgICBmbG9hdCBmb2dBbW91bnQgPSAxLiAtIGV4cCggLWRpc3RhbmNlICogYW1vdW50ICk7XG4gICAgdmVjMyAgZm9nQ29sb3IgID0gJHt0aGlzLmNvbG9yLmVtaXQoKX07XG4gICAgcmV0dXJuIG1peCggcmdiLCBmb2dDb2xvciwgZm9nQW1vdW50ICk7XG4gIH1cbiAgYFxuICAgICAgaWYoIFNERi5tZW1vLmZvZyA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICBzdHIgPSBzdHIgKyBwcmVmYWNlXG4gICAgICAgIFNERi5tZW1vLmZvZyA9IHRydWVcbiAgICAgIH1lbHNle1xuICAgICAgICBzdHIgPSAnJ1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RyXG4gICAgfSxcblxuICAgIHVwZGF0ZV9sb2NhdGlvbiggZ2wsIHByb2dyYW0gKSB7XG4gICAgICB0aGlzLmFtb3VudC51cGRhdGVfbG9jYXRpb24oIGdsLCBwcm9ncmFtIClcbiAgICAgIHRoaXMuY29sb3IudXBkYXRlX2xvY2F0aW9uKCBnbCwgcHJvZ3JhbSApXG4gICAgfSxcblxuICAgIHVwbG9hZF9kYXRhKCBnbCApIHtcbiAgICAgIHRoaXMuYW1vdW50LnVwbG9hZF9kYXRhKCBnbCApXG4gICAgICB0aGlzLmNvbG9yLnVwbG9hZF9kYXRhKCBnbCApXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiBGb2dcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBGb2dnZXJcbiIsIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBNYXJjaGluZyA9IHJlcXVpcmUoICcuL21haW4uanMnIClcblxuTWFyY2hpbmcuX19leHBvcnQgPSBNYXJjaGluZy5leHBvcnRcbk1hcmNoaW5nLmV4cG9ydCA9IG9iaiA9PiB7XG4gIG9iai5tYXJjaCA9IE1hcmNoaW5nLmNyZWF0ZVNjZW5lLmJpbmQoIE1hcmNoaW5nIClcbiAgTWFyY2hpbmcuX19leHBvcnQoIG9iaiApXG59XG5cbndpbmRvdy5NYXJjaGluZyA9IE1hcmNoaW5nXG5cbm1vZHVsZS5leHBvcnRzID0gTWFyY2hpbmdcbiIsImNvbnN0IGVtaXRfaW50ID0gZnVuY3Rpb24oIGEgKSB7XG5cdGlmKCBhICUgMSAhPT0gMCApXG5cdFx0cmV0dXJuIE1hdGgucm91bmQoIGEgKVxuXHRlbHNlXG5cdFx0cmV0dXJuIGFcbn1cblxuY29uc3QgSW50UHJvdG90eXBlID0ge1xuICB0eXBlOiAnaW50Jyxcblx0ZW1pdCgpIHsgcmV0dXJuIGVtaXRfaW50KCB0aGlzLnggKSB9LFxuXHRlbWl0X2RlY2woKSB7IHJldHVybiBcIlwiIH1cbn1cblxuXG5jb25zdCBJbnQgPSBmdW5jdGlvbiggeD0wICkge1xuICBjb25zdCBmID0gT2JqZWN0LmNyZWF0ZSggSW50UHJvdG90eXBlIClcbiAgZi54ID0geFxuICByZXR1cm4gZlxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEludFxuIiwiY29uc3QgU2NlbmVOb2RlID0gcmVxdWlyZSggJy4vc2NlbmVOb2RlLmpzJyApLFxuICAgICAgeyBwYXJhbV93cmFwLCBNYXRlcmlhbElEIH0gPSByZXF1aXJlKCAnLi91dGlscy5qcycgKSxcbiAgICAgIHsgVmFyLCBmbG9hdF92YXJfZ2VuLCB2ZWMyX3Zhcl9nZW4sIHZlYzNfdmFyX2dlbiwgdmVjNF92YXJfZ2VuIH0gPSByZXF1aXJlKCAnLi92YXIuanMnICksXG4gICAgICB7IFZlYzIsIFZlYzMsIFZlYzQgfSA9IHJlcXVpcmUoICcuL3ZlYy5qcycgKVxuXG5jb25zdCBnbHNsID0gcmVxdWlyZSggJ2dsc2xpZnknIClcblxuY29uc3QgTGlnaHRzID0gZnVuY3Rpb24oIFNERiApIHtcblxuICBjb25zdCBMaWdodCA9IHtcbiAgICBsaWdodHM6W10sXG4gICAgbWF0ZXJpYWxzOltdLFxuXG4gICAgZGVmYXVsdExpZ2h0czpgXG4gICAgICBMaWdodCBsaWdodHNbMl0gPSBMaWdodFsyXShcbiAgICAgICAgTGlnaHQoIHZlYzMoIDIuLDIuLDMuICksICB2ZWMzKDAuMjUsMC4yNSwuMjUpLCAxLiApLFxuICAgICAgICBMaWdodCggdmVjMyggLTIuLDIuLDMuICksIHZlYzMoLjI1LDAuMjUsMC4yNSksIDEuIClcbiAgICAgICk7XG4gICAgYCxcblxuICAgIGRlZmF1bHRNYXRlcmlhbHM6YFxuICAgICAgTWF0ZXJpYWwgbWF0ZXJpYWxzWzJdID0gTWF0ZXJpYWxbMl0oXG4gICAgICAgIE1hdGVyaWFsKCAwLCB2ZWMzKCAxLiApLCB2ZWMzKDAuLDAuLDAuKSwgdmVjMygxLiksIDguLCBGcmVzbmVsKCAwLiwgMS4sIDIuKSwgMCApLFxuICAgICAgICBNYXRlcmlhbCggMCwgdmVjMyggMS4gKSwgdmVjMygxLiwwLiwwLiksIHZlYzMoMS4pLCA4LiwgRnJlc25lbCggMC4sIDEuLCAyLiksIDAgKVxuICAgICAgKTtcbiAgICBgLFxuXG4gICAgbGlnaHQoIF9fcG9zPVZlYzMoMiwyLDMpLCBfX2NvbG9yPVZlYzMoMCwwLDEpLCBhdHRlbnVhdGlvbj0xICkge1xuICAgICAgY29uc3QgbGlnaHQgPSB7IFxuICAgICAgICBfX2F0dGVudWF0aW9uOiBwYXJhbV93cmFwKCBhdHRlbnVhdGlvbiwgZmxvYXRfdmFyX2dlbiggMSApICksXG4gICAgICB9XG5cbiAgICAgIHBvcyA9IHR5cGVvZiBfX3BvcyA9PT0gJ251bWJlcicgPyBWZWMzKCBfX3BvcyApIDogX19wb3NcblxuICAgICAgY29uc3QgX192YXJwb3MgPSBwYXJhbV93cmFwKCBcbiAgICAgICAgcG9zLCBcbiAgICAgICAgdmVjM192YXJfZ2VuKCBbMiwyLDNdIClcbiAgICAgIClcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBsaWdodCwgJ3BvcycsIHtcbiAgICAgICAgZ2V0KCkgeyByZXR1cm4gX192YXJwb3MgfSxcbiAgICAgICAgc2V0KHYpIHtcbiAgICAgICAgICBpZiggdHlwZW9mIHYgPT09ICdvYmplY3QnICkge1xuICAgICAgICAgICAgX192YXJwb3Muc2V0KCB2IClcbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIF9fdmFycG9zLnZhbHVlLnggPSB2XG4gICAgICAgICAgICBfX3ZhcnBvcy52YWx1ZS55ID0gdlxuICAgICAgICAgICAgX192YXJwb3MudmFsdWUueiA9IHZcbiAgICAgICAgICAgIF9fdmFycG9zLmRpcnR5ID0gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSkgIFxuXG4gICAgICBjb2xvciA9IHR5cGVvZiBfX2NvbG9yID09PSAnbnVtYmVyJyA/IFZlYzMoIF9fY29sb3IgKSA6IF9fY29sb3JcblxuICAgICAgY29uc3QgX192YXJjb2wgPSBwYXJhbV93cmFwKCBcbiAgICAgICAgY29sb3IsIFxuICAgICAgICB2ZWMzX3Zhcl9nZW4oIFswLDAsMV0gKVxuICAgICAgKVxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIGxpZ2h0LCAnY29sb3InLCB7XG4gICAgICAgIGdldCgpIHsgcmV0dXJuIF9fdmFyY29sIH0sXG4gICAgICAgIHNldCh2KSB7XG4gICAgICAgICAgaWYoIHR5cGVvZiB2ID09PSAnb2JqZWN0JyApIHtcbiAgICAgICAgICAgIF9fdmFyY29sLnNldCggdiApXG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBfX3ZhcmNvbC52YWx1ZS54ID0gdlxuICAgICAgICAgICAgX192YXJjb2wudmFsdWUueSA9IHZcbiAgICAgICAgICAgIF9fdmFyY29sLnZhbHVlLnogPSB2XG4gICAgICAgICAgICBfX3ZhcmNvbC5kaXJ0eSA9IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pICBcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBsaWdodCwgJ2F0dGVudWF0aW9uJywge1xuICAgICAgICBnZXQoKSB7IHJldHVybiBsaWdodC5fX2F0dGVudWF0aW9uLnZhbHVlIH0sXG4gICAgICAgIHNldCh2KXtcbiAgICAgICAgICBsaWdodC5fX2F0dGVudWF0aW9uLnZhbHVlID0gdlxuICAgICAgICAgIGxpZ2h0Ll9fYXR0ZW51YXRpb24uZGlydHkgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICAgIHJldHVybiBsaWdodFxuICAgIH0sXG5cbiAgICBlbWl0X2xpZ2h0cygpIHtcbiAgICAgIGlmKCB0aGlzLmxpZ2h0cy5sZW5ndGggPT09IDAgKSByZXR1cm4gdGhpcy5kZWZhdWx0TGlnaHRzXG5cbiAgICAgIGxldCBzdHIgPSBgTGlnaHQgbGlnaHRzWyR7dGhpcy5saWdodHMubGVuZ3RofV0gPSBMaWdodFske3RoaXMubGlnaHRzLmxlbmd0aH1dKGBcblxuICAgICAgZm9yKCBsZXQgbGlnaHQgb2YgdGhpcy5saWdodHMgKSB7XG4gICAgICAgIHN0ciArPSBgXFxuICAgICAgICBMaWdodCggJHtsaWdodC5wb3MuZW1pdCgpfSwgJHtsaWdodC5jb2xvci5lbWl0KCl9LCAke2xpZ2h0Ll9fYXR0ZW51YXRpb24uZW1pdCgpfSksYCBcbiAgICAgIH1cbiAgICAgIFxuICAgICAgc3RyID0gc3RyLnNsaWNlKDAsLTEpIC8vIHJlbW92ZSB0cmFpbGluZyBjb21tYVxuXG4gICAgICBzdHIgKz0gJ1xcbiAgICAgICk7J1xuXG4gICAgICByZXR1cm4gc3RyXG4gICAgfSxcblxuICAgIG1vZGU6J2dsb2JhbCcsXG5cbiAgICBnZW4oIHNoYWRvd3M9OCwgZ2VvbWV0cmllcyApIHtcbiAgICAgIC8vY29uc3Qgc3RyID0gdGhpcy5tb2Rlc1sgdGhpcy5tb2RlIF0oIHRoaXMubGlnaHRzLmxlbmd0aCB8fCAyLCB0aGlzLmVtaXRfbGlnaHRzKCksIFNERi5tYXRlcmlhbHMuZW1pdF9tYXRlcmlhbHMoKSwgc2hhZG93cyApXG4gICBcbiAgICAgIGNvbnN0IG1vZGVDb25zdGFudHMgPSBTREYubWF0ZXJpYWxzLm1vZGVDb25zdGFudHNcbiAgICAgIHRoaXMubW9kZXNFbXBsb3llZC5sZW5ndGggPSAwXG5cbiAgICAgIGxldCBsaWdodGluZ0Z1bmN0aW9ucyA9IFtdXG5cbiAgICAgIC8vIGxvb3AgdGhyb3VnaCBhbGwgbWF0ZXJpYWxzIHVzZWQgYW5kIGFkZCBjb3JyZXNwb25kaW5nIGxpZ2h0aW5nIGZ1bmN0aW9ucyBhcyBuZWVkZWRcbiAgICAgIGZvciggbGV0IG1hdCBvZiBTREYubWF0ZXJpYWxzLm1hdGVyaWFscyApIHtcbiAgICAgICAgaWYoIHRoaXMubW9kZXNFbXBsb3llZC5pbmRleE9mKCBtYXQubW9kZSApID09PSAtMSApIHtcbiAgICAgICAgICBsaWdodGluZ0Z1bmN0aW9ucy5wdXNoKCB0aGlzLm1vZGVzWyBtYXQubW9kZSBdKCkgKSAgXG5cbiAgICAgICAgICB0aGlzLm1vZGVzRW1wbG95ZWQucHVzaCggbWF0Lm1vZGUgKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIGFsbCBtb2RlcyB0byBzZWUgaWYgdGhleSdyZSBsaWdodGluZyBmdW5jdGlvbiBoYXMgYmVlbiBhZGRlZCB0byB0aGUgc2hhZGVyLFxuICAgICAgLy8gaWYgbm90LCBhZGQgdGhlaXIgZnVuY3Rpb24gc3R1YlxuICAgICAgZm9yKCBsZXQgbW9kZSBvZiBtb2RlQ29uc3RhbnRzICkge1xuICAgICAgICAvLyBrZXkgaXMgaXRlcmF0ZWQgYXMgc3RyaW5nLCBtdXN0IHVzZSBwYXJzZUludFxuICAgICAgICBpZiggdGhpcy5tb2Rlc0VtcGxveWVkLmluZGV4T2YoIG1vZGUgKSA9PT0gLTEgKSB7XG4gICAgICAgICAgbGlnaHRpbmdGdW5jdGlvbnMucHVzaCggdGhpcy5kZWZhdWx0RnVuY3Rpb25EZWNsYXJhdGlvbnNbIG1vZGVDb25zdGFudHMuaW5kZXhPZiggbW9kZSApIF0gKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRleHR1cmVzID0gTWFyY2hpbmcudGV4dHVyZXMuX19lbWl0RnVuY3Rpb24oKVxuICAgICAgY29uc3QgbGlnaHRpbmcgPSB0aGlzLnNoZWxsKCBcbiAgICAgICAgdGhpcy5saWdodHMubGVuZ3RoIHx8IDIsIFxuICAgICAgICB0aGlzLmVtaXRfbGlnaHRzKCksIFxuICAgICAgICBTREYubWF0ZXJpYWxzLmVtaXRfbWF0ZXJpYWxzKCksIFxuICAgICAgICBzaGFkb3dzLFxuICAgICAgICBnZW9tZXRyaWVzLCBcbiAgICAgICAgdGV4dHVyZXMuZ2xzbGRlZnMsXG4gICAgICAgIHRleHR1cmVzLm1haW5mdW5jXG4gICAgICApXG5cbiAgICAgIGxldCBsaWdodGluZ0Z1bmNTdHIgPSBsaWdodGluZ0Z1bmN0aW9ucy5qb2luKCdcXG4nKVxuICAgICAgbGlnaHRpbmdGdW5jU3RyID0gbGlnaHRpbmdGdW5jU3RyLnJlcGxhY2UoIC8oTUFYXFxfTElHSFRTKS9nLCB0aGlzLmxpZ2h0cy5sZW5ndGggfHwgMiApXG4gICAgICByZXR1cm4gbGlnaHRpbmdbMF0gKyBsaWdodGluZ0Z1bmNTdHIgKyBsaWdodGluZ1sxXVxuICAgIH0sXG5cbiAgICBlbWl0X2RlY2woKSB7XG4gICAgICBsZXQgc3RyID0gJydcbiAgICAgIGZvciggbGV0IGxpZ2h0IG9mIHRoaXMubGlnaHRzICkge1xuICAgICAgICBzdHIgKz0gbGlnaHQucG9zLmVtaXRfZGVjbCgpXG4gICAgICAgIHN0ciArPSBsaWdodC5jb2xvci5lbWl0X2RlY2woKVxuICAgICAgICBzdHIgKz0gbGlnaHQuX19hdHRlbnVhdGlvbi5lbWl0X2RlY2woKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3RyXG4gICAgfSxcblxuICAgIHVwZGF0ZV9sb2NhdGlvbiggZ2wsIHByb2dyYW0gKSB7XG4gICAgICBmb3IoIGxldCBsaWdodCBvZiB0aGlzLmxpZ2h0cyApIHtcbiAgICAgICAgaWYoIGxpZ2h0LnBvcy5kaXJ0eSA9PT0gdHJ1ZSApICBsaWdodC5wb3MudXBkYXRlX2xvY2F0aW9uKCBnbCwgcHJvZ3JhbSApXG4gICAgICAgIGlmKCBsaWdodC5jb2xvci5kaXJ0eSA9PT0gdHJ1ZSApICBsaWdodC5jb2xvci51cGRhdGVfbG9jYXRpb24oIGdsLCBwcm9ncmFtIClcbiAgICAgICAgaWYoIGxpZ2h0Ll9fYXR0ZW51YXRpb24uZGlydHkgPT09IHRydWUgKSBsaWdodC5fX2F0dGVudWF0aW9uLnVwZGF0ZV9sb2NhdGlvbiggZ2wsIHByb2dyYW0gKVxuICAgICAgfVxuXG4gICAgfSxcblxuICAgIHVwbG9hZF9kYXRhKCBnbCwgcHJvZ3JhbT0nJyApIHtcbiAgICAgIGZvciggbGV0IGxpZ2h0IG9mIHRoaXMubGlnaHRzICkge1xuICAgICAgICBpZiggbGlnaHQucG9zLmRpcnR5ID09PSB0cnVlICkgICBsaWdodC5wb3MudXBsb2FkX2RhdGEoIGdsLCBwcm9ncmFtIClcbiAgICAgICAgaWYoIGxpZ2h0LmNvbG9yLmRpcnR5ID09PSB0cnVlICkgIGxpZ2h0LmNvbG9yLnVwbG9hZF9kYXRhKCBnbCwgcHJvZ3JhbSApXG4gICAgICAgIGlmKCBsaWdodC5fX2F0dGVudWF0aW9uLmRpcnR5ID09PSB0cnVlICkgIGxpZ2h0Ll9fYXR0ZW51YXRpb24udXBsb2FkX2RhdGEoIGdsLCBwcm9ncmFtIClcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgbW9kZXNFbXBsb3llZDpbXSxcblxuICAgIC8vIHRoZXNlIHN0dWJzIGFyZSBwbGFjZWQgaW4gdGhlIHNoYWRlciBieSBkZWZhdWx0IGFzIHBsYWNlaG9sZGVycyBzbyB0aGF0IHRoZXkgY2FuIGJlIHJlZmVyZW5jZWQgaW4gXG4gICAgLy8gYSBzd2l0Y2ggc3RhdGVtZW50IHNlbGVjdGluZyBsaWdodGluZy4gVGhleSBhcmUgb3ZlcnJpZGRlbiBieSBhY3R1YWwgbGlnaHRpbmcgZnVuY3Rpb25zIGlmIGFueVxuICAgIC8vIG1hdGVyaWFsIGluIHRoZSBzY2VuZSB1c2VzIGEgY29ycmVzcG9uZGluZyBmdW5jdGlvbi5cbiAgICBkZWZhdWx0RnVuY3Rpb25EZWNsYXJhdGlvbnM6IFtcbiAgICAgICcgICAgdmVjMyBnbG9iYWwoIHZlYzMgc3VyZmFjZVBvc2l0aW9uLCB2ZWMzIG5vcm1hbCwgdmVjMyByYXlPcmlnaW4sIHZlYzMgcmF5RGlyZWN0aW9uLCBNYXRlcmlhbCBtYXQsIExpZ2h0IGxpZ2h0c1tNQVhfTElHSFRTXSwgdmVjMyB0ZXh0dXJlQ29sb3IgKSB7IHJldHVybiB2ZWMzKDAuKTsgfScsXG4gICAgICAnICAgIHZlYzMgbm9ybWFsKCB2ZWMzIHN1cmZhY2VQb3NpdGlvbiwgdmVjMyBub3JtYWwsIHZlYzMgcmF5T3JpZ2luLCB2ZWMzIHJheURpcmVjdGlvbiwgTWF0ZXJpYWwgbWF0LCBMaWdodCBsaWdodHNbTUFYX0xJR0hUU10gKSB7IHJldHVybiB2ZWMzKDAuKTsgfScsXG4gICAgICAnICAgIHZlYzMgZGlyZWN0aW9uYWwoIHZlYzMgc3VyZmFjZVBvc2l0aW9uLCB2ZWMzIG5vcm1hbCwgdmVjMyByYXlPcmlnaW4sIHZlYzMgcmF5RGlyZWN0aW9uLCBNYXRlcmlhbCBtYXQsIExpZ2h0IGxpZ2h0c1tNQVhfTElHSFRTXSwgdmVjMyB0ZXh0dXJlQ29sb3IgKSB7IHJldHVybiB2ZWMzKDAuKTsgfScsXG4gICAgICAnICAgIHZlYzMgb3Jlbm4oIHZlYzMgc3VyZmFjZVBvc2l0aW9uLCB2ZWMzIG5vcm1hbCwgdmVjMyByYXlPcmlnaW4sIHZlYzMgcmF5RGlyZWN0aW9uLCBNYXRlcmlhbCBtYXQsIExpZ2h0IGxpZ2h0c1tNQVhfTElHSFRTXSApIHsgcmV0dXJuIHZlYzMoMC4pOyB9JyxcbiAgICBdLFxuXG4gICAgc2hlbGwoIG51bWxpZ2h0cywgbGlnaHRzLCBtYXRlcmlhbHMsIHNoYWRvdz0wLCBzZGZzLCB0ZXh0dXJlUHJlZmFjZSwgdGV4dHVyZUJvZHkgKSB7XG4gICAgICBjb25zdCBfX3NoYWRvdyA9IHNoYWRvdyA+IDBcbiAgICAgICAgPyBgZGlmZnVzZUNvZWZmaWNpZW50ICo9IHNvZnRzaGFkb3coIHN1cmZhY2VQb3NpdGlvbiwgbm9ybWFsaXplKCBsaWdodC5wb3NpdGlvbiApLCAwLjAyLCAyLjUsICR7c2hhZG93LnRvRml4ZWQoMSl9ICk7YCBcbiAgICAgICAgOiAnJ1xuXG5cbiAgICAgIGxldCBwcmVmYWNlID0gZ2xzbChbXCIjZGVmaW5lIEdMU0xJRlkgMVxcbiAgaW50IE1BWF9MSUdIVFMgPSBcIixcIjtcXG4gICAgZmxvYXQgYW8oIGluIHZlYzMgcG9zLCBpbiB2ZWMzIG5vciApe1xcbiAgICAgIGZsb2F0IG9jYyA9IDAuMDtcXG4gICAgICBmbG9hdCBzY2EgPSAxLjA7XFxuICAgICAgZm9yKCBpbnQgaT0wOyBpPDU7IGkrKyApXFxuICAgICAge1xcbiAgICAgICAgICBmbG9hdCBociA9IDAuMDEgKyAwLjEyICogZmxvYXQoIGkgKSAvIDQuMDtcXG4gICAgICAgICAgdmVjMyBhb3BvcyA9ICBub3IgKiBociArIHBvcztcXG4gICAgICAgICAgZmxvYXQgZGQgPSBzY2VuZSAoIGFvcG9zICkueDtcXG4gICAgICAgICAgb2NjICs9IC0oZGQtaHIpKnNjYTtcXG4gICAgICAgICAgc2NhICo9IDAuOTU7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBjbGFtcCggMS4wIC0gMy4wKm9jYywgMC4wLCAxLjAgKTsgICAgXFxuICAgIH1cXG5cXG4gICAgXFxuICAgIFwiLFwiXFxuICAgIFwiLFwiXFxuICAgIFwiLFwiXCJdLG51bWxpZ2h0cyx0ZXh0dXJlUHJlZmFjZSx0ZXh0dXJlQm9keSlcbiAgICAgIGxldCBmdW5jID0gYFxuXG4gICAgdmVjMyBsaWdodGluZyggdmVjMyBzdXJmYWNlUG9zaXRpb24sIHZlYzMgbm9ybWFsLCB2ZWMzIHJheU9yaWdpbiwgdmVjMyByYXlEaXJlY3Rpb24sIGZsb2F0IHNkZklELCBib29sIHVzZVRleHR1cmVUcmFuc2Zvcm0gKSB7XG4gICAgICAke3NkZnN9XG4gICAgICBTREYgc2RmID0gc2Rmc1sgaW50KCBzZGZJRCApIF07XG5cbiAgICAgICR7bWF0ZXJpYWxzfVxuICAgICAgTWF0ZXJpYWwgbWF0ID0gbWF0ZXJpYWxzWyBzZGYubWF0ZXJpYWxJRCBdO1xuXG4gICAgICBpbnQgTUFYX0xJR0hUUyA9ICR7bnVtbGlnaHRzfTsgICAgIFxuXG4gICAgICAke2xpZ2h0c31cbiBcbiAgICAgIHZlYzMgdGV4ID0gZ2V0VGV4dHVyZSggaW50KHNkZi50ZXh0dXJlSUQpLCBzdXJmYWNlUG9zaXRpb24sIG5vcm1hbCwgc2RmLCB1c2VUZXh0dXJlVHJhbnNmb3JtICk7XG5cbiAgICAgIHZlYzMgY2xyO1xuICAgICAgc3dpdGNoKCBtYXQubW9kZSApIHtcbiAgICAgICAgY2FzZSAwOiBjbHIgPSBnbG9iYWwoIHN1cmZhY2VQb3NpdGlvbiwgbm9ybWFsLCByYXlPcmlnaW4sIHJheURpcmVjdGlvbiwgbWF0LCBsaWdodHMsIHRleCApOyBicmVhaztcbiAgICAgICAgY2FzZSAxOiBjbHIgPSBub3JtYWw7IGJyZWFrO1xuICAgICAgICBjYXNlIDI6IGNsciA9IGRpcmVjdGlvbmFsKCBzdXJmYWNlUG9zaXRpb24sIG5vcm1hbCwgcmF5T3JpZ2luLCByYXlEaXJlY3Rpb24sIG1hdCwgbGlnaHRzLCB0ZXggKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogY2xyID0gb3Jlbm4oIHN1cmZhY2VQb3NpdGlvbiwgbm9ybWFsLCByYXlPcmlnaW4sIHJheURpcmVjdGlvbiwgbWF0LCBsaWdodHMgKTsgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgY2xyID0gbm9ybWFsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2xyOyBcbiAgICB9XG5gXG4gICAgICByZXR1cm4gWyBwcmVmYWNlLCBmdW5jIF1cbiAgICB9LCBcblxuICAgIG1vZGVzOntcbiAgICAgIGdsb2JhbCgpIHtcbiAgICAgICAgY29uc3Qgc2hhZG93ID0gU0RGLl9fc2NlbmUuX19zaGFkb3dcblxuICAgICAgICBjb25zdCBzdHIgPSBnbHNsKFtcIiNkZWZpbmUgR0xTTElGWSAxXFxuXFxuXFxuICAgICAgICB2ZWMzIGdsb2JhbCggdmVjMyBwb3MsIHZlYzMgbm9yLCB2ZWMzIHJvLCB2ZWMzIHJkLCBNYXRlcmlhbCBtYXQsIExpZ2h0IGxpZ2h0c1tNQVhfTElHSFRTXSwgdmVjMyB0ZXh0dXJlQ29sb3IgKSB7XFxuICAgICAgICAgIExpZ2h0IGxpZ2h0ID0gbGlnaHRzWyAwIF07XFxuICAgICAgICAgIHZlYzMgIHJlZiA9IHJlZmxlY3QoIHJkLCBub3IgKTsgLy8gcmVmbGVjdGlvbiBhbmdsZVxcbiAgICAgICAgICBmbG9hdCBvY2MgPSBhbyggcG9zLCBub3IgKTtcXG4gICAgICAgICAgdmVjMyAgbGlnID0gbm9ybWFsaXplKCBsaWdodC5wb3NpdGlvbiApOyAvLyBsaWdodCBwb3NpdGlvblxcbiAgICAgICAgICBmbG9hdCBhbWIgPSBjbGFtcCggMC41ICsgMC41ICogbm9yLnksIDAuMCwgMS4wICk7XFxuICAgICAgICAgIGZsb2F0IGRpZiA9IGNsYW1wKCBkb3QoIG5vciwgbGlnICksIDAuMCwgMS4wICk7XFxuXFxuICAgICAgICAgIC8vIHNpbXVsYXRlZCBiYWNrbGlnaHRcXG4gICAgICAgICAgZmxvYXQgYmFjID0gY2xhbXAoIGRvdCggbm9yLCBub3JtYWxpemUoIHZlYzMoIC1saWcueCwgMC4wICwgLWxpZy56ICkpKSwgMC4wLCAxLjAgKSAqIGNsYW1wKCAxLjAtcG9zLnksIDAuMCAsMS4wICk7XFxuXFxuICAgICAgICAgIC8vIHNpbXVsYXRlZCBza3lkb21lIGxpZ2h0XFxuICAgICAgICAgIGZsb2F0IGRvbSA9IHNtb290aHN0ZXAoIC0wLjEsIDAuMSwgcmVmLnkgKTtcXG4gICAgICAgICAgZmxvYXQgZnJlID0gcG93KCBjbGFtcCggMS4wICsgZG90KCBub3IscmQgKSwwLjAsMS4wICksIDMuMCk7XFxuICAgICAgICAgIGZsb2F0IHNwZSA9IHBvdyggY2xhbXAoIGRvdCggcmVmLCBsaWcgKSwgMC4wLCAxLjAgKSwgOC4wICk7XFxuXFxuICAgICAgICAgIGRpZiAqPSBzb2Z0c2hhZG93KCBwb3MsIGxpZywgMC4wMiwgMi41LCBcIixcIiApO1xcbiAgICAgICAgICBkb20gKj0gc29mdHNoYWRvdyggcG9zLCByZWYsIDAuMDIsIDIuNSwgXCIsXCIgKTtcXG5cXG4gICAgICAgICAgdmVjMyBicmRmID0gdGV4dHVyZUNvbG9yOy8vdmVjMyggMC4wICk7XFxuICAgICAgICAgIGJyZGYgKz0gMS4yMCAqIGRpZiAqIHZlYzMoIDEuMDAsMC45MCwwLjYwICkgKiBtYXQuZGlmZnVzZSAqIGxpZ2h0LmNvbG9yO1xcbiAgICAgICAgICBicmRmICs9IDIuMjAgKiBzcGUgKiB2ZWMzKCAxLjAwLDAuOTAsMC42MCApICogZGlmICogbWF0LnNwZWN1bGFyICogbGlnaHQuY29sb3I7XFxuICAgICAgICAgIGJyZGYgKz0gMC4zMCAqIGFtYiAqIHZlYzMoIDAuNTAsMC43MCwxLjAwICkgKiBvY2MgKiBtYXQuYW1iaWVudCAqIGxpZ2h0LmNvbG9yO1xcbiAgICAgICAgICBicmRmICs9IDAuNDAgKiBkb20gKiB2ZWMzKCAwLjUwLDAuNzAsMS4wMCApO1xcbiAgICAgICAgICBicmRmICs9IDAuNzAgKiBiYWMgKiB2ZWMzKCAwLjI1ICk7XFxuICAgICAgICAgIGJyZGYgKz0gMC40MCAqIChmcmUgKiBsaWdodC5jb2xvcik7XFxuXFxuICAgICAgICAgIHJldHVybiBicmRmO1xcbiAgICAgICAgfVxcbiAgICAgICAgXCIsXCJcIl0sc2hhZG93LnRvRml4ZWQoMSksc2hhZG93LnRvRml4ZWQoMSkpXG5cbiAgICAgICAgcmV0dXJuIHN0clxuICAgICAgfSxcblxuICAgICAgcGhvbmcoIG51bWxpZ2h0cywgbGlnaHRzLCBtYXRlcmlhbHMgKSB7XG4gICAgICAgIGNvbnN0IHNoYWRvdyA9IFNERi5fX3NjZW5lLl9fc2hhZG93XG5cbiAgICAgICAgY29uc3QgX19zaGFkb3cgPSBzaGFkb3cgPiAwXG4gICAgICAgICAgPyBgZGlmZnVzZUNvZWZmaWNpZW50ICo9IHNvZnRzaGFkb3coIHN1cmZhY2VQb3NpdGlvbiwgbm9ybWFsaXplKCBsaWdodC5wb3NpdGlvbiApLCAwLjAyLCAyLjUsICR7c2hhZG93LnRvRml4ZWQoMSl9ICk7YCBcbiAgICAgICAgICA6ICcnXG5cbiAgICAgICAgY29uc3Qgc3RyID0gZ2xzbChbXCIjZGVmaW5lIEdMU0xJRlkgMVxcbiAgXFxuICAgICAgICBcXG4gICAgICAgIHZlYzMgZGlyZWN0aW9uYWwoIHZlYzMgc3VyZmFjZVBvc2l0aW9uLCB2ZWMzIG5vcm1hbCwgdmVjMyByYXlPcmlnaW4sIHZlYzMgcmF5RGlyZWN0aW9uLCBNYXRlcmlhbCBtYXQsIExpZ2h0IGxpZ2h0c1tNQVhfTElHSFRTXSwgdmVjMyB0ZXh0dXJlQ29sb3IgKSB7XFxuICAgICAgICAgIHZlYzMgIG91dHB1dENvbG9yICAgPSB0ZXh0dXJlQ29sb3I7Ly92ZWMzKCAwLiApO1xcbiAgIFxcbiAgICAgICAgICAvLyBhcHBsaWVzIHRvIGFsbCBsaWdodHNcXG4gICAgICAgICAgZmxvYXQgb2NjbHVzaW9uID0gYW8oIHN1cmZhY2VQb3NpdGlvbiwgbm9ybWFsICk7XFxuXFxuICAgICAgICAgIGZvciggaW50IGkgPSAwOyBpIDwgMjAwMDA7IGkrKyApIHtcXG4gICAgICAgICAgICBpZiggaSA+PSBNQVhfTElHSFRTICkgYnJlYWs7XFxuXFxuICAgICAgICAgICAgTGlnaHQgbGlnaHQgPSBsaWdodHNbIGkgXTtcXG5cXG4gICAgICAgICAgICB2ZWMzIHN1cmZhY2VUb0xpZ2h0RGlyZWN0aW9uID0gbm9ybWFsaXplKCBsaWdodC5wb3NpdGlvbiAtIHN1cmZhY2VQb3NpdGlvbiApO1xcbiAgICAgICAgICAgIFxcbiAgICAgICAgICAgIC8vIGdldCBzaW1pbGFyaXR5IGJldHdlZW4gbm9ybWFsIGFuZCBkaXJlY3Rpb24gdG8gbGlnaHRcXG4gICAgICAgICAgICBmbG9hdCBkaWZmdXNlQ29lZmZpY2llbnQgPSBkb3QoIG5vcm1hbCwgc3VyZmFjZVRvTGlnaHREaXJlY3Rpb24gKTsgXFxuXFxuICAgICAgICAgICAgLy8gZ2V0IHJlZmxlY3Rpb24gYW5nbGUgZm9yIGxpZ2h0IHN0cmlraW5nIHN1cmZhY2VcXG4gICAgICAgICAgICB2ZWMzIGFuZ2xlT2ZSZWZsZWN0aW9uID0gcmVmbGVjdCggLXN1cmZhY2VUb0xpZ2h0RGlyZWN0aW9uLCBub3JtYWwgKTtcXG5cXG4gICAgICAgICAgICAvLyBzZWUgaWYgcmVmbGVjdGVkIGxpZ2h0IHRyYXZlbHMgdG8gY2FtZXJhIGFuZCBnZW5lcmF0ZSBjb2VmZmljaWVudCBhY2NvcmRpbmdseVxcbiAgICAgICAgICAgIGZsb2F0IHNwZWN1bGFyQW5nbGUgPSBjbGFtcCggZG90KCBhbmdsZU9mUmVmbGVjdGlvbiwgLXJheURpcmVjdGlvbiApLCAwLiwgMS4gKTtcXG4gICAgICAgICAgICBmbG9hdCBzcGVjdWxhckNvZWZmaWNpZW50ID0gcG93KCBzcGVjdWxhckFuZ2xlLCBtYXQuc2hpbmluZXNzICk7XFxuXFxuICAgICAgICAgICAgLy8gbGlnaHRzIHNob3VsZCBoYXZlIGFuIGF0dGVudWF0aW9uIGZhY3RvclxcbiAgICAgICAgICAgIGZsb2F0IGF0dGVudWF0aW9uID0gMS4gLyAoIGxpZ2h0LmF0dGVudWF0aW9uICogcG93KCBsZW5ndGgoIGxpZ2h0LnBvc2l0aW9uIC0gc3VyZmFjZVBvc2l0aW9uICksIDIuICkgKTsgXFxuXFxuICAgICAgICAgICAgLy8gYmlhcywgc2NhbGUsIHBvd2VyXFxuICAgICAgICAgICAgZmxvYXQgZnJlc25lbCA9IG1hdC5mcmVzbmVsLnggKyBtYXQuZnJlc25lbC55ICogcG93KCAxLjAgKyBkb3QoIHJheURpcmVjdGlvbiwgbm9ybWFsICksIG1hdC5mcmVzbmVsLnogKTsgXFxuXFxuICAgICAgICAgICAgXCIsXCJcXG5cXG4gICAgICAgICAgICB2ZWMzIGNvbG9yID0gdmVjMyggMC4gKTtcXG4gICAgICAgICAgICBjb2xvciArPSAxLjIgKiBkaWZmdXNlQ29lZmZpY2llbnQgKiBtYXQuZGlmZnVzZSAqIGxpZ2h0LmNvbG9yO1xcbiAgICAgICAgICAgIGNvbG9yICs9IDIuMiAqIHNwZWN1bGFyQ29lZmZpY2llbnQgKiBtYXQuc3BlY3VsYXIgKiBsaWdodC5jb2xvcjtcXG4gICAgICAgICAgICBjb2xvciArPSAwLjMgKiAobWF0LmFtYmllbnQgKiBsaWdodC5jb2xvcikgKiBvY2NsdXNpb247XFxuICAgICAgICAgICAgY29sb3IgKz0gKGZyZXNuZWwgKiBsaWdodC5jb2xvcik7XFxuXFxuICAgICAgICAgICAgLy8gdGV4dHVyZVxcbiAgICAgICAgICAgIC8vY29sb3IgKj0gdGV4dHVyZUNvbG9yLnh5ejtcXG5cXG4gICAgICAgICAgICAvLyBnYW1tYSBjb3JyZWN0aW9uIG11c3Qgb2NjdXIgYmVmb3JlIGxpZ2h0IGF0dGVudWF0aW9uXFxuICAgICAgICAgICAgLy8gd2hpY2ggbWVhbnMgaXQgbXVzdCBiZSBhcHBsaWVkIG9uIGEgcGVyLWxpZ2h0IGJhc2lzIHVuZm9ydHVuYXRlbHlcXG4gICAgICAgICAgICB2ZWMzIGdhbW1hQ29ycmVjdGVkQ29sb3IgPSBwb3coIGNvbG9yLCB2ZWMzKCAxLi8yLjIgKSApO1xcbiAgICAgICAgICAgIHZlYzMgYXR0ZW51YXRlZENvbG9yID0gMi4gKiBnYW1tYUNvcnJlY3RlZENvbG9yICogYXR0ZW51YXRpb247IFxcblxcbiAgICAgICAgICAgIG91dHB1dENvbG9yICs9IGF0dGVudWF0ZWRDb2xvcjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICByZXR1cm4gb3V0cHV0Q29sb3I7XFxuICAgICAgICB9XFxuICAgICAgICBcIixcIlwiXSxfX3NoYWRvdylcblxuICAgICAgICByZXR1cm4gc3RyXG4gICAgICB9LCBcbiAgICAgIHBob25nVCggbnVtbGlnaHRzLCBsaWdodHMsIG1hdGVyaWFscyApIHtcbiAgICAgICAgY29uc3Qgc2hhZG93ID0gU0RGLl9fc2NlbmUuX19zaGFkb3dcblxuICAgICAgICBjb25zdCBfX3NoYWRvdyA9IHNoYWRvdyA+IDBcbiAgICAgICAgICA/IGBkaWZmdXNlQ29lZmZpY2llbnQgKj0gc29mdHNoYWRvdyggc3VyZmFjZVBvc2l0aW9uLCBub3JtYWxpemUoIGxpZ2h0LnBvc2l0aW9uICksIDAuMDIsIDIuNSwgJHtzaGFkb3cudG9GaXhlZCgxKX0gKTtgIFxuICAgICAgICAgIDogJydcblxuICAgICAgICBjb25zdCBzdHIgPSBnbHNsKFtcIiNkZWZpbmUgR0xTTElGWSAxXFxuICBcXG5cXG4gICAgICAgIHZlYzMgZGlyZWN0aW9uYWwoIHZlYzMgc3VyZmFjZVBvc2l0aW9uLCB2ZWMzIG5vcm1hbCwgdmVjMyByYXlPcmlnaW4sIHZlYzMgcmF5RGlyZWN0aW9uLCBNYXRlcmlhbCBtYXQsIExpZ2h0IGxpZ2h0c1tNQVhfTElHSFRTXSApIHtcXG4gICAgICAgICAgdmVjMyAgb3V0cHV0Q29sb3IgICA9IHZlYzMoIDAuICk7XFxuICAgXFxuICAgICAgICAgIC8vIGFwcGxpZXMgdG8gYWxsIGxpZ2h0c1xcbiAgICAgICAgICBmbG9hdCBvY2NsdXNpb24gPSBhbyggc3VyZmFjZVBvc2l0aW9uLCBub3JtYWwgKTtcXG5cXG4gICAgICAgICAgdmVjNCB0ZXh0dXJlQ29sb3I7XFxuICAgICAgICAgIGlmKCBtYXQudGV4dHVyZUlEID4gLTEgKSB7XFxuICAgICAgICAgICAgLy90ZXh0dXJlQ29sb3IgPSB0ZXhjdWJlKCB0ZXh0dXJlc1sgbWF0LnRleHR1cmVJRCBdLCBzdXJmYWNlUG9zaXRpb24sIG5vcm1hbCwgMS4gKTsvL3RleHR1cmUoIHRleHR1cmVzWyBtYXQudGV4dHVyZUlEIF0sIHN1cmZhY2VQb3NpdGlvbi54eSAtIG5vcm1hbC54eSApOyBcXG4gICAgICAgICAgICB2ZWMyIHV2ID0gZ2V0VVZDdWJpYyggc3VyZmFjZVBvc2l0aW9uLCB2ZWMzKDAuKSApOy8vc3VyZmFjZVBvc2l0aW9uLnh6KnZlYzIoMC4wMywwLjA3KTtcXG4gICAgICAgICAgICB0ZXh0dXJlQ29sb3IgPSB0ZXh0dXJlKCB0ZXh0dXJlc1sgbWF0LnRleHR1cmVJRCBdLCB1diApO1xcbiAgICAgICAgICB9ZWxzZXtcXG4gICAgICAgICAgICB0ZXh0dXJlQ29sb3IgPSB2ZWM0KDAuKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBvdXRwdXRDb2xvciA9IDA7Ly90ZXh0dXJlQ29sb3IueHl6O1xcblxcbiAgICAgICAgICBmb3IoIGludCBpID0gMDsgaSA8IDIwMDAwOyBpKysgKSB7XFxuICAgICAgICAgICAgaWYoIGkgPj0gTUFYX0xJR0hUUyApIGJyZWFrO1xcblxcbiAgICAgICAgICAgIExpZ2h0IGxpZ2h0ID0gbGlnaHRzWyBpIF07XFxuXFxuICAgICAgICAgICAgdmVjMyBzdXJmYWNlVG9MaWdodERpcmVjdGlvbiA9IG5vcm1hbGl6ZSggbGlnaHQucG9zaXRpb24gLSBzdXJmYWNlUG9zaXRpb24gKTtcXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICAvLyBnZXQgc2ltaWxhcml0eSBiZXR3ZWVuIG5vcm1hbCBhbmQgZGlyZWN0aW9uIHRvIGxpZ2h0XFxuICAgICAgICAgICAgZmxvYXQgZGlmZnVzZUNvZWZmaWNpZW50ID0gZG90KCBub3JtYWwsIHN1cmZhY2VUb0xpZ2h0RGlyZWN0aW9uICk7IFxcblxcbiAgICAgICAgICAgIC8vIGdldCByZWZsZWN0aW9uIGFuZ2xlIGZvciBsaWdodCBzdHJpa2luZyBzdXJmYWNlXFxuICAgICAgICAgICAgdmVjMyBhbmdsZU9mUmVmbGVjdGlvbiA9IHJlZmxlY3QoIC1zdXJmYWNlVG9MaWdodERpcmVjdGlvbiwgbm9ybWFsICk7XFxuXFxuICAgICAgICAgICAgLy8gc2VlIGlmIHJlZmxlY3RlZCBsaWdodCB0cmF2ZWxzIHRvIGNhbWVyYSBhbmQgZ2VuZXJhdGUgY29lZmZpY2llbnQgYWNjb3JkaW5nbHlcXG4gICAgICAgICAgICBmbG9hdCBzcGVjdWxhckFuZ2xlID0gY2xhbXAoIGRvdCggYW5nbGVPZlJlZmxlY3Rpb24sIC1yYXlEaXJlY3Rpb24gKSwgMC4sIDEuICk7XFxuICAgICAgICAgICAgZmxvYXQgc3BlY3VsYXJDb2VmZmljaWVudCA9IHBvdyggc3BlY3VsYXJBbmdsZSwgbWF0LnNoaW5pbmVzcyApO1xcblxcbiAgICAgICAgICAgIC8vIGxpZ2h0cyBzaG91bGQgaGF2ZSBhbiBhdHRlbnVhdGlvbiBmYWN0b3JcXG4gICAgICAgICAgICBmbG9hdCBhdHRlbnVhdGlvbiA9IDEuIC8gKCBsaWdodC5hdHRlbnVhdGlvbiAqIHBvdyggbGVuZ3RoKCBsaWdodC5wb3NpdGlvbiAtIHN1cmZhY2VQb3NpdGlvbiApLCAyLiApICk7IFxcblxcbiAgICAgICAgICAgIC8vIGJpYXMsIHNjYWxlLCBwb3dlclxcbiAgICAgICAgICAgIGZsb2F0IGZyZXNuZWwgPSBtYXQuZnJlc25lbC54ICsgbWF0LmZyZXNuZWwueSAqIHBvdyggMS4wICsgZG90KCByYXlEaXJlY3Rpb24sIG5vcm1hbCApLCBtYXQuZnJlc25lbC56ICk7IFxcblxcbiAgICAgICAgICAgIFwiLFwiXFxuXFxuICAgICAgICAgICAgdmVjMyBjb2xvciA9IHZlYzMoIDAuICk7XFxuICAgICAgICAgICAgY29sb3IgKz0gMS4yICogZGlmZnVzZUNvZWZmaWNpZW50ICogdGV4dHVyZUNvbG9yLnh5eiAqIGxpZ2h0LmNvbG9yO1xcbiAgICAgICAgICAgIGNvbG9yICs9IDIuMiAqIHNwZWN1bGFyQ29lZmZpY2llbnQgKiB0ZXh0dXJlQ29sb3IueHl6ICogbGlnaHQuY29sb3I7XFxuICAgICAgICAgICAgY29sb3IgKz0gMC4zICogKG1hdC5hbWJpZW50ICogbGlnaHQuY29sb3IpICogb2NjbHVzaW9uO1xcbiAgICAgICAgICAgIGNvbG9yICs9IChmcmVzbmVsICogbGlnaHQuY29sb3IpO1xcblxcbiAgICAgICAgICAgIC8vIHRleHR1cmVcXG4gICAgICAgICAgICAvL2NvbG9yICo9IHRleHR1cmVDb2xvci54eXo7XFxuXFxuICAgICAgICAgICAgLy8gZ2FtbWEgY29ycmVjdGlvbiBtdXN0IG9jY3VyIGJlZm9yZSBsaWdodCBhdHRlbnVhdGlvblxcbiAgICAgICAgICAgIC8vIHdoaWNoIG1lYW5zIGl0IG11c3QgYmUgYXBwbGllZCBvbiBhIHBlci1saWdodCBiYXNpcyB1bmZvcnR1bmF0ZWx5XFxuICAgICAgICAgICAgdmVjMyBnYW1tYUNvcnJlY3RlZENvbG9yID0gcG93KCBjb2xvciwgdmVjMyggMS4vMi4yICkgKTtcXG4gICAgICAgICAgICB2ZWMzIGF0dGVudWF0ZWRDb2xvciA9IDIuICogZ2FtbWFDb3JyZWN0ZWRDb2xvciAqIGF0dGVudWF0aW9uOyBcXG5cXG4gICAgICAgICAgICBvdXRwdXRDb2xvciArPSBhdHRlbnVhdGVkQ29sb3I7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgcmV0dXJuIG91dHB1dENvbG9yO1xcbiAgICAgICAgfVxcbiAgICAgICAgXCIsXCJcIl0sX19zaGFkb3cpXG5cbiAgICAgICAgcmV0dXJuIHN0clxuICAgICAgfSwgXG5cblxuICAgICAgb3Jlbm4oIG51bWxpZ2h0cywgbGlnaHRzLCBtYXRlcmlhbHMgKSB7XG4gICAgICAgIGNvbnN0IHNoYWRvdyA9IFNERi5fX3NjZW5lLl9fc2hhZG93XG4gICAgICAgIGNvbnN0IF9fc2hhZG93ID0gc2hhZG93ID4gMFxuICAgICAgICAgID8gYGRpZmZ1c2VDb2VmZmljaWVudCAqPSBzb2Z0c2hhZG93KCBzdXJmYWNlUG9zaXRpb24sIG5vcm1hbGl6ZSggbGlnaHQucG9zaXRpb24gKSwgMC4wMiwgMi41LCAke3NoYWRvdy50b0ZpeGVkKDEpfSApO2AgXG4gICAgICAgICAgOiAnJ1xuXG4gICAgICAgIGNvbnN0IHN0ciA9IGdsc2woW1wiI2RlZmluZSBHTFNMSUZZIDFcXG4gIFxcbiAgICAgICAgZmxvYXQgb3Jlbk5heWFyRGlmZnVzZShcXG4gIHZlYzMgbGlnaHREaXJlY3Rpb24sXFxuICB2ZWMzIHZpZXdEaXJlY3Rpb24sXFxuICB2ZWMzIHN1cmZhY2VOb3JtYWwsXFxuICBmbG9hdCByb3VnaG5lc3MsXFxuICBmbG9hdCBhbGJlZG8pIHtcXG4gIFxcbiAgZmxvYXQgTGRvdFYgPSBkb3QobGlnaHREaXJlY3Rpb24sIHZpZXdEaXJlY3Rpb24pO1xcbiAgZmxvYXQgTmRvdEwgPSBkb3QobGlnaHREaXJlY3Rpb24sIHN1cmZhY2VOb3JtYWwpO1xcbiAgZmxvYXQgTmRvdFYgPSBkb3Qoc3VyZmFjZU5vcm1hbCwgdmlld0RpcmVjdGlvbik7XFxuXFxuICBmbG9hdCBzID0gTGRvdFYgLSBOZG90TCAqIE5kb3RWO1xcbiAgZmxvYXQgdCA9IG1peCgxLjAsIG1heChOZG90TCwgTmRvdFYpLCBzdGVwKDAuMCwgcykpO1xcblxcbiAgZmxvYXQgc2lnbWEyID0gcm91Z2huZXNzICogcm91Z2huZXNzO1xcbiAgZmxvYXQgQSA9IDEuMCArIHNpZ21hMiAqIChhbGJlZG8gLyAoc2lnbWEyICsgMC4xMykgKyAwLjUgLyAoc2lnbWEyICsgMC4zMykpO1xcbiAgZmxvYXQgQiA9IDAuNDUgKiBzaWdtYTIgLyAoc2lnbWEyICsgMC4wOSk7XFxuXFxuICByZXR1cm4gYWxiZWRvICogbWF4KDAuMCwgTmRvdEwpICogKEEgKyBCICogcyAvIHQpIC8gMy4xNDE1OTI2NTtcXG59XFxuXFxuICAgICAgICBmbG9hdCBnYXVzc2lhblNwZWN1bGFyKFxcbiAgdmVjMyBsaWdodERpcmVjdGlvbixcXG4gIHZlYzMgdmlld0RpcmVjdGlvbixcXG4gIHZlYzMgc3VyZmFjZU5vcm1hbCxcXG4gIGZsb2F0IHNoaW5pbmVzcykge1xcbiAgdmVjMyBIID0gbm9ybWFsaXplKGxpZ2h0RGlyZWN0aW9uICsgdmlld0RpcmVjdGlvbik7XFxuICBmbG9hdCB0aGV0YSA9IGFjb3MoZG90KEgsIHN1cmZhY2VOb3JtYWwpKTtcXG4gIGZsb2F0IHcgPSB0aGV0YSAvIHNoaW5pbmVzcztcXG4gIHJldHVybiBleHAoLXcqdyk7XFxufVxcblxcbiAgICAgICAgdmVjMyBvcmVubiggdmVjMyBzdXJmYWNlUG9zaXRpb24sIHZlYzMgbm9ybWFsLCB2ZWMzIHJheU9yaWdpbiwgdmVjMyByYXlEaXJlY3Rpb24sIE1hdGVyaWFsIG1hdCwgTGlnaHQgbGlnaHRzW01BWF9MSUdIVFNdICkge1xcbiAgICAgICAgICB2ZWMzICBvdXRwdXRDb2xvciAgID0gdmVjMyggMC4gKTtcXG4gICBcXG4gICAgICAgICAgLy8gYXBwbGllcyB0byBhbGwgbGlnaHRzXFxuICAgICAgICAgIGZsb2F0IG9jY2x1c2lvbiA9IGFvKCBzdXJmYWNlUG9zaXRpb24sIG5vcm1hbCApO1xcblxcbiAgICAgICAgICBmb3IoIGludCBpID0gMDsgaSA8IDIwMDAwOyBpKysgKSB7XFxuICAgICAgICAgICAgaWYoIGkgPj0gTUFYX0xJR0hUUyApIGJyZWFrO1xcblxcbiAgICAgICAgICAgIExpZ2h0IGxpZ2h0ID0gbGlnaHRzWyBpIF07XFxuXFxuICAgICAgICAgICAgdmVjMyBzdXJmYWNlVG9MaWdodERpcmVjdGlvbiA9IG5vcm1hbGl6ZSggbGlnaHQucG9zaXRpb24gLSBzdXJmYWNlUG9zaXRpb24gKTtcXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICAvLyBnZXQgc2ltaWxhcml0eSBiZXR3ZWVuIG5vcm1hbCBhbmQgZGlyZWN0aW9uIHRvIGxpZ2h0XFxuICAgICAgICAgICAgZmxvYXQgZGlmZnVzZUNvZWZmaWNpZW50ID0gb3Jlbk5heWFyRGlmZnVzZSggc3VyZmFjZVRvTGlnaHREaXJlY3Rpb24sIC1yYXlEaXJlY3Rpb24sIG5vcm1hbCwgMC4xNSwgNC4wKTtcXG5cXG4gICAgICAgICAgICAvLyBnZXQgcmVmbGVjdGlvbiBhbmdsZSBmb3IgbGlnaHQgc3RyaWtpbmcgc3VyZmFjZVxcbiAgICAgICAgICAgIHZlYzMgYW5nbGVPZlJlZmxlY3Rpb24gPSByZWZsZWN0KCAtc3VyZmFjZVRvTGlnaHREaXJlY3Rpb24sIG5vcm1hbCApO1xcblxcbiAgICAgICAgICAgIC8vIHNlZSBpZiByZWZsZWN0ZWQgbGlnaHQgdHJhdmVscyB0byBjYW1lcmEgYW5kIGdlbmVyYXRlIGNvZWZmaWNpZW50IGFjY29yZGluZ2x5XFxuICAgICAgICAgICAgZmxvYXQgc3BlY3VsYXJBbmdsZSA9IGNsYW1wKCBkb3QoIGFuZ2xlT2ZSZWZsZWN0aW9uLCAtcmF5RGlyZWN0aW9uICksIDAuLCAxLiApO1xcbiAgICAgICAgICAgIGZsb2F0IHNwZWN1bGFyQ29lZmZpY2llbnQgPSBnYXVzc2lhblNwZWN1bGFyKCBzdXJmYWNlVG9MaWdodERpcmVjdGlvbiwgLXJheURpcmVjdGlvbiwgbm9ybWFsLCAuNSApOyBcXG5cXG4gICAgICAgICAgICAvLyBsaWdodHMgc2hvdWxkIGhhdmUgYW4gYXR0ZW51YXRpb24gZmFjdG9yXFxuICAgICAgICAgICAgZmxvYXQgYXR0ZW51YXRpb24gPSAxLiAvICggbGlnaHQuYXR0ZW51YXRpb24gKiBwb3coIGxlbmd0aCggbGlnaHQucG9zaXRpb24gLSBzdXJmYWNlUG9zaXRpb24gKSwgMi4gKSApOyBcXG5cXG4gICAgICAgICAgICBmbG9hdCBmcmVzbmVsID0gbWF0LmZyZXNuZWwueCArIG1hdC5mcmVzbmVsLnkgKiBwb3coIDEuMCArIGRvdCggcmF5RGlyZWN0aW9uLCBub3JtYWwgKSwgbWF0LmZyZXNuZWwueiApOyBcXG5cXG4gICAgICAgICAgICBcIixcIlxcblxcbiAgICAgICAgICAgIHZlYzMgY29sb3IgPSB2ZWMzKCAwLiApO1xcbiAgICAgICAgICAgIGNvbG9yICs9IDEuMiAqIGRpZmZ1c2VDb2VmZmljaWVudCAqIG1hdC5kaWZmdXNlICogbGlnaHQuY29sb3I7XFxuICAgICAgICAgICAgY29sb3IgKz0gMi4yICogc3BlY3VsYXJDb2VmZmljaWVudCAqIG1hdC5zcGVjdWxhciAqIGxpZ2h0LmNvbG9yO1xcbiAgICAgICAgICAgIGNvbG9yICs9IDAuMyAqIChtYXQuYW1iaWVudCAqIGxpZ2h0LmNvbG9yKSAqIG9jY2x1c2lvbjtcXG4gICAgICAgICAgICBjb2xvciArPSAoZnJlc25lbCAqIGxpZ2h0LmNvbG9yKTtcXG5cXG4gICAgICAgICAgICAvLyBnYW1tYSBjb3JyZWN0aW9uIG11c3Qgb2NjdXIgYmVmb3JlIGxpZ2h0IGF0dGVudWF0aW9uXFxuICAgICAgICAgICAgLy8gd2hpY2ggbWVhbnMgaXQgbXVzdCBiZSBhcHBsaWVkIG9uIGEgcGVyLWxpZ2h0IGJhc2lzIHVuZm9ydHVuYXRlbHlcXG4gICAgICAgICAgICB2ZWMzIGdhbW1hQ29ycmVjdGVkQ29sb3IgPSBwb3coIGNvbG9yLCB2ZWMzKCAxLi8yLjIgKSApO1xcbiAgICAgICAgICAgIHZlYzMgYXR0ZW51YXRlZENvbG9yID0gMi4gKiBnYW1tYUNvcnJlY3RlZENvbG9yICogYXR0ZW51YXRpb247IFxcblxcbiAgICAgICAgICAgIG91dHB1dENvbG9yICs9IGF0dGVudWF0ZWRDb2xvcjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICByZXR1cm4gb3V0cHV0Q29sb3I7XFxuICAgICAgICB9XCIsXCJcIl0sX19zaGFkb3cpXG5cbiAgICAgICAgcmV0dXJuIHN0clxuICAgICAgfSwgXG5cbiAgICAgIG5vcm1hbCgpIHsgcmV0dXJuICcnIH0sXG4gICAgICBub2lzZSgpIHsgcmV0dXJuICcnIH1cbiAgICB9LFxuICB9XG5cbiAgcmV0dXJuIExpZ2h0XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTGlnaHRzXG5cbi8vIG9sZCBsaWdodGluZ1xuLypcbiovXG4iLCJjb25zdCBTREYgPSB7XHJcbiAgY2FtZXJhOiAgICAgICAgICAgcmVxdWlyZSggJy4vY2FtZXJhLmpzJyApLFxyXG4gIF9fcHJpbWl0aXZlczogICAgIHJlcXVpcmUoICcuL3ByaW1pdGl2ZXMuanMnICksXHJcbiAgdmVjdG9yczogICAgICAgICAgcmVxdWlyZSggJy4vdmVjLmpzJyApLFxyXG4gIGRpc3RhbmNlT3BzOiAgICAgIHJlcXVpcmUoICcuL2Rpc3RhbmNlT3BlcmF0aW9ucy5qcycgKSxcclxuICBhbHRlcmF0aW9uczogICAgICByZXF1aXJlKCAnLi9hbHRlcmF0aW9ucy5qcycgKSxcclxuICBkaXN0YW5jZURlZm9ybXM6ICByZXF1aXJlKCAnLi9kaXN0YW5jZURlZm9ybWF0aW9ucy5qcycgKSxcclxuICBfX2RvbWFpbk9wczogICAgICByZXF1aXJlKCAnLi9kb21haW5PcGVyYXRpb25zLmpzJyApLFxyXG4gIF9fbm9pc2U6ICAgICAgICAgIHJlcXVpcmUoICcuL25vaXNlLmpzJyApLFxyXG4gIF9fc2NlbmU6ICAgICAgICAgIHJlcXVpcmUoICcuL3NjZW5lLmpzJyApLFxyXG4gIF9fbGlnaHRpbmc6ICAgICAgIHJlcXVpcmUoICcuL2xpZ2h0aW5nLmpzJyApLFxyXG4gIF9fbWF0ZXJpYWxzOiAgICAgIHJlcXVpcmUoICcuL21hdGVyaWFsLmpzJyApLFxyXG4gIF9fdGV4dHVyZXM6ICAgICAgIHJlcXVpcmUoICcuL3RleHR1cmUuanMnICksXHJcbiAgVmFyOiAgICAgICAgICAgICAgcmVxdWlyZSggJy4vdmFyLmpzJyApLlZhcixcclxuICAvL0NvbG9yOiAgICAgICAgICAgIHJlcXVpcmUoICcuL2NvbG9yLmpzJyApLFxyXG4gIEZGVDogICAgICAgICAgICAgIHJlcXVpcmUoICcuL2F1ZGlvLmpzJyApLFxyXG4gIGZ4OiAgICAgICAgICAgICAgIHJlcXVpcmUoICcuL21lcmdlcGFzcy5qcycgKSxcclxuXHJcbiAgLy8gYSBmdW5jdGlvbiB0aGF0IGdlbmVyYXRlcyB0aGUgZnJhZ21lbnQgc2hhZGVyXHJcbiAgcmVuZGVyRnJhZ21lbnRTaGFkZXI6IHJlcXVpcmUoICcuL3JlbmRlckZyYWdtZW50U2hhZGVyLmpzJyApLFxyXG5cclxuICAvLyBhZGRpdGlvbmFsIGNhbGxiYWNrcyB0aGF0IGFyZSBydW4gb25jZSBwZXIgZnJhbWVcclxuICBjYWxsYmFja3M6IFtdLFxyXG4gIGdlb21ldHJpZXM6IFtdLFxyXG5cclxuICAvLyB0aGUgbWFpbiBkcmF3aW5nIGNhbGxiYWNrXHJcbiAgcmVuZGVyOiBudWxsLFxyXG5cclxuICAvLyB0aGUgc2NlbmUgaXMgYSBjaGFpbiBvZiBVbmlvbnMgY29tYmluaW5nIGFsbCBlbGVtZW50cyB0b2dldGhlclxyXG4gIHNjZW5lOiAgbnVsbCxcclxuXHJcbiAgLy8gYSBzcGVlZCBvZiAxIGNvcnJlc3BvbmRzIHRvIDYwIGZwcy5cclxuICBkZWxheTogMCxcclxuICBfX2lzUGF1c2VkOmZhbHNlLFxyXG5cclxuICBkZWZhdWx0VmVydGV4U291cmNlOmAgICAgI3ZlcnNpb24gMzAwIGVzXHJcbiAgICBpbiB2ZWMyIGFfcG9zO1xyXG5cclxuXHRcdHZvaWQgbWFpbigpIHtcclxuXHRcdFx0Z2xfUG9zaXRpb24gPSB2ZWM0KCBhX3BvcywgMC4sIDEuICk7XHJcbiAgICB9YFxyXG4gICxcclxuXHJcbiAgZXhwb3J0KCBvYmogKSB7XHJcbiAgICBPYmplY3QuYXNzaWduKCBcclxuICAgICAgb2JqLCBcclxuICAgICAgdGhpcy5wcmltaXRpdmVzLFxyXG4gICAgICB0aGlzLnZlY3RvcnMsXHJcbiAgICAgIHRoaXMuZGlzdGFuY2VPcHMsXHJcbiAgICAgIHRoaXMuZG9tYWluT3BzLFxyXG4gICAgICB0aGlzLmRpc3RhbmNlRGVmb3JtcyxcclxuICAgICAgdGhpcy5hbHRlcmF0aW9uc1xyXG4gICAgKVxyXG5cclxuICAgIHRoaXMuZnguZXhwb3J0KCBvYmogKVxyXG5cclxuICAgIG9iai5MaWdodCA9IHRoaXMuTGlnaHRcclxuICAgIG9iai5NYXRlcmlhbCA9IHRoaXMuTWF0ZXJpYWxcclxuICAgIG9iai5UZXh0dXJlICA9IHRoaXMuVGV4dHVyZVxyXG4gICAgb2JqLmNhbWVyYSA9IHRoaXMuY2FtZXJhXHJcbiAgICBvYmouY2FsbGJhY2tzID0gdGhpcy5jYWxsYmFja3MgLy8gWFhYIHJlbW92ZSBvbmNlIEFQSSBzdG9wcyB1c2luZyBjYWxsYmFja3NcclxuICAgIG9iai5GRlQgPSB0aGlzLkZGVFxyXG4gIH0sXHJcblxyXG4gIGluaXQoIGNhbnZhcywgc2hvdWxkSW5pdCA9IGZhbHNlICkge1xyXG4gICAgdGhpcy5wcmltaXRpdmVzID0gdGhpcy5fX3ByaW1pdGl2ZXMoIHRoaXMgKVxyXG4gICAgdGhpcy5TY2VuZSAgICAgID0gdGhpcy5fX3NjZW5lKCB0aGlzIClcclxuICAgIHRoaXMuZG9tYWluT3BzICA9IHRoaXMuX19kb21haW5PcHMoIHRoaXMgKVxyXG4gICAgdGhpcy5ub2lzZSAgICAgPSB0aGlzLl9fbm9pc2UoIHRoaXMgKVxyXG4gICAgdGhpcy5leHBvcnQoIHRoaXMgKVxyXG5cclxuICAgIHRoaXMuY2FudmFzID0gY2FudmFzLy9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKVxyXG4gICAgdGhpcy5jYW52YXNNUCA9IGNhbnZhc1xyXG5cclxuICAgIHRoaXMubGlnaHRpbmcgICA9IHRoaXMuX19saWdodGluZyggdGhpcyApXHJcbiAgICB0aGlzLkxpZ2h0ID0gdGhpcy5saWdodGluZy5saWdodFxyXG4gICAgdGhpcy5tYXRlcmlhbHMgID0gdGhpcy5fX21hdGVyaWFscyggdGhpcyApXHJcbiAgICB0aGlzLk1hdGVyaWFsID0gdGhpcy5tYXRlcmlhbHMubWF0ZXJpYWxcclxuICAgIHRoaXMudGV4dHVyZXMgPSB0aGlzLl9fdGV4dHVyZXMoIHRoaXMgKVxyXG4gICAgdGhpcy5UZXh0dXJlID0gdGhpcy50ZXh0dXJlcy50ZXh0dXJlXHJcblxyXG4gICAgdGhpcy5jYW52YXMud2lkdGggPSB0aGlzLmNhbnZhc01QLndpZHRoID0gd2luZG93LmlubmVyV2lkdGggXHJcbiAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSB0aGlzLmNhbnZhc01QLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodFxyXG4gICAgdGhpcy5nbCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoICd3ZWJnbDInLCB7IGFudGlhbGlhczp0cnVlLCBhbHBoYTp0cnVlIH0pXHJcblxyXG4gICAgLy90aGlzLmdsTVAgPSB0aGlzLmNhbnZhc01QLmdldENvbnRleHQoICd3ZWJnbDInLCB7IGFudGlhbGlhczp0cnVlLCBhbHBoYTp0cnVlIH0pXHJcbiAgfSxcclxuICAvLyBnZW5lcmF0ZSBzaGFkZXJzLCBpbml0aWFsaXplIGNhbWVyYSwgc3RhcnQgcmVuZGVyaW5nIGxvb3AgXHJcbiAgY3JlYXRlU2NlbmUoIC4uLmFyZ3MgKSB7XHJcbiAgICBjb25zdCBzY2VuZSA9IHRoaXMuU2NlbmUoIGFyZ3MsIHRoaXMuY2FudmFzIClcclxuXHJcbiAgICB0aGlzLnJlcXVpcmVkR2VvbWV0cmllcyA9IFtdXHJcbiAgICB0aGlzLnJlcXVpcmVkT3BzID0gW11cclxuICAgIHRoaXMubWVtbyA9IHt9XHJcblxyXG4gICAgcmV0dXJuIHNjZW5lXHJcbiAgfSxcclxuXHJcbiAgc3RhcnQoIGZzLCB3aWR0aCwgaGVpZ2h0LCBzaG91bGRBbmltYXRlICkge1xyXG4gICAgaWYoIHRoaXMucmVuZGVyICE9PSBudWxsICkgdGhpcy5yZW5kZXIucnVubmluZyA9IGZhbHNlXHJcblxyXG4gICAgdGhpcy5mcyA9IGZzXHJcbiAgICB0aGlzLmNhbGxiYWNrcy5sZW5ndGggPSAwXHJcblxyXG4gICAgdGhpcy5yZW5kZXIgPSB0aGlzLmluaXRXZWJHTCggdGhpcy5kZWZhdWx0VmVydGV4U291cmNlLCBmcywgd2lkdGgsIGhlaWdodCwgc2hvdWxkQW5pbWF0ZSApXHJcbiAgICB0aGlzLnJlbmRlci5ydW5uaW5nID0gdHJ1ZVxyXG5cclxuICAgIHRoaXMuY2FtZXJhLmluaXQoIHRoaXMuZ2wsIHRoaXMucHJvZ3JhbSwgY2IgPT4geyBcclxuICAgICAgdGhpcy5jYWxsYmFja3MucHVzaCggY2IgKVxyXG4gICAgfSlcclxuXHJcbiAgICBzZXRUaW1lb3V0KCAoKT0+IHRoaXMucmVuZGVyKCAwLjAgKSwgMCApXHJcbiAgfSxcclxuXHJcbiAgZ2VuZXJhdGVTREYoIF9fc2NlbmUgKSB7XHJcbiAgICBsZXQgc2NlbmUgPSB7IHByZWZhY2U6JycgfVxyXG5cclxuICAgIC8qIGlmIHRoZXJlIGlzIG1vcmUgdGhhbiBvbmUgb2JqZWN0IGluIG91ciBzY2VuZSwgY2hhaW4gcGFpcnMgb2Ygb2JqZWN0c1xyXG4gICAgICAgaW4gVW5pb25zLiBTbywgZ2l2ZW4gb2JqZWN0cyBhLGIsYywgYW5kIGQgY3JlYXRlOlxyXG5cclxuICAgICAgIFVuaW9uKCBhLCBVbmlvbiggYiwgVW5pb24oIGMsZCApICkgKVxyXG5cclxuICAgICAgIC4uLiBvciBzb21ldGhpbmcgbGlrZSB0aGF0LiBJZiB0aGVyZSBpcyBvbmx5IGEgc2luZ2xlIG9iamVjdCxcclxuICAgICAgIHVzZSB0aGF0IG9iamVjdCBhcyB0aGUgZW50aXJlIHNjZW5lLlxyXG4gICAgICovXHJcblxyXG4gICAgbGV0IG9ianMgPSBfX3NjZW5lLm9ianNcclxuICAgIGlmKCBvYmpzLmxlbmd0aCA+IDEgKSB7XHJcbiAgICAgIC8vIHJlZHVjZSBvYmplY3RzIHRvIG5lc3RlZCBVbmlvbnNcclxuICAgICAgc2NlbmUub3V0cHV0ID0gb2Jqcy5yZWR1Y2UoICggY3VycmVudCwgbmV4dCApID0+IHRoaXMuVW5pb24oIGN1cnJlbnQsIG5leHQgKSApXHJcbiAgICB9ZWxzZXtcclxuICAgICAgc2NlbmUub3V0cHV0ID0gb2Jqc1swXVxyXG4gICAgfVxyXG5cclxuICAgIC8vIGNyZWF0ZSBhbiBmYW5jeSBlbWl0KCkgZnVuY3Rpb24gdGhhdCB3cmFwcyB0aGUgc2NlbmVcclxuICAgIC8vIHdpdGggYW4gaWQgIy5cclxuXHJcbiAgICBzY2VuZS5vdXRwdXQuX19lbWl0ID0gc2NlbmUub3V0cHV0LmVtaXQuYmluZCggc2NlbmUub3V0cHV0IClcclxuICAgIHNjZW5lLm91dHB1dC5lbWl0ID0gZnVuY3Rpb24oIC4uLmFyZ3MgKSB7XHJcbiAgICAgIGNvbnN0IGVtaXR0ZWQgPSBzY2VuZS5vdXRwdXQuX19lbWl0KC4uLmFyZ3MpXHJcbiAgICAgIGNvbnN0IG91dHB1dCA9IHtcclxuICAgICAgICBvdXQ6ICAgICBlbWl0dGVkLm91dCxcclxuICAgICAgICBwcmVmYWNlOiBlbWl0dGVkLnByZWZhY2UgfHwgJycgXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBvdXRwdXQgXHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5zY2VuZSA9IHNjZW5lLm91dHB1dFxyXG5cclxuICAgIGxldCB2YXJpYWJsZXNEZWNsYXJhdGlvbiA9IHNjZW5lLm91dHB1dC5lbWl0X2RlY2woKVxyXG4gICAgY29uc3Qgc2NlbmVSZW5kZXJpbmcgPSBzY2VuZS5vdXRwdXQuZW1pdCgpXHJcblxyXG4gICAgLy8gZm9nIGV0Yy4gbWF5YmUgbXNhYT9cclxuICAgIGxldCBwcCA9ICcnXHJcbiAgICBmb3IoIGxldCBwcm9jZXNzb3Igb2YgX19zY2VuZS5wb3N0cHJvY2Vzc2luZyApIHtcclxuICAgICAgcHAgKz0gcHJvY2Vzc29yLmVtaXQoKVxyXG4gICAgICB2YXJpYWJsZXNEZWNsYXJhdGlvbiArPSBwcm9jZXNzb3IuZW1pdF9kZWNsKClcclxuICAgIH1cclxuICAgIFxyXG4gICAgdGhpcy5wb3N0cHJvY2Vzc2luZyA9IF9fc2NlbmUucG9zdHByb2Nlc3NpbmdcclxuXHJcbiAgICByZXR1cm4gWyB2YXJpYWJsZXNEZWNsYXJhdGlvbiwgc2NlbmVSZW5kZXJpbmcsIHBwIF1cclxuICB9LFxyXG5cclxuXHRjb21waWxlKCB0eXBlLCBzb3VyY2UgKSB7XHJcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2xcclxuXHJcblx0XHRjb25zdCBzaGFkZXIgPSB0aGlzLnNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlciggdHlwZSApO1xyXG5cdFx0Z2wuc2hhZGVyU291cmNlKCBzaGFkZXIsIHNvdXJjZSApXHJcblx0XHRnbC5jb21waWxlU2hhZGVyKCBzaGFkZXIgKVxyXG5cclxuXHRcdGlmKCBnbC5nZXRTaGFkZXJQYXJhbWV0ZXIoIHNoYWRlciwgZ2wuQ09NUElMRV9TVEFUVVMpICE9PSB0cnVlICkge1xyXG5cdFx0XHRsZXQgbG9nID0gZ2wuZ2V0U2hhZGVySW5mb0xvZyggc2hhZGVyIClcclxuXHRcdFx0Z2wuZGVsZXRlU2hhZGVyKCBzaGFkZXIgKVxyXG5cclxuXHRcdFx0Y29uc29sZS5sb2coIHNvdXJjZSApXHJcblx0XHRcdGNvbnNvbGUubG9nKCBsb2cgKVxyXG5cclxuXHRcdFx0cmV0dXJuIG51bGxcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gc2hhZGVyXHJcblx0fSxcclxuXHJcbiAgY3JlYXRlUHJvZ3JhbSggdnNfc291cmNlLCBmc19zb3VyY2UgKSB7XHJcbiAgICBjb25zdCBnbCA9IHRoaXMuZ2xcclxuXHRcdGNvbnN0IHZzID0gdGhpcy5jb21waWxlKCBnbC5WRVJURVhfU0hBREVSLCB2c19zb3VyY2UgKVxyXG5cdFx0Y29uc3QgZnMgPSB0aGlzLmNvbXBpbGUoIGdsLkZSQUdNRU5UX1NIQURFUiwgZnNfc291cmNlIClcclxuXHJcblx0XHRpZiggbnVsbCA9PT0gdnMgfHwgbnVsbCA9PT0gZnMgKSByZXR1cm4gbnVsbFxyXG5cclxuXHRcdGNvbnN0IHByb2dyYW0gPSBnbC5jcmVhdGVQcm9ncmFtKClcclxuXHRcdGdsLmF0dGFjaFNoYWRlciggcHJvZ3JhbSwgdnMgKVxyXG5cdFx0Z2wuYXR0YWNoU2hhZGVyKCBwcm9ncmFtLCBmcyApXHJcblx0XHRnbC5saW5rUHJvZ3JhbSggcHJvZ3JhbSApXHJcblxyXG5cdFx0aWYoIGdsLmdldFByb2dyYW1QYXJhbWV0ZXIoIHByb2dyYW0sIGdsLkxJTktfU1RBVFVTICkgIT09IHRydWUgKXtcclxuXHRcdFx0Y29uc3QgbG9nID0gZ2wuZ2V0UHJvZ3JhbUluZm9Mb2coIHByb2dyYW0gKVxyXG5cdFx0XHRnbC5kZWxldGVTaGFkZXIodnMpXHJcblx0XHRcdGdsLmRlbGV0ZVNoYWRlcihmcylcclxuXHRcdFx0Z2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKVxyXG5cclxuXHRcdFx0Y29uc29sZS5lcnJvciggbG9nIClcclxuXHRcdFx0cmV0dXJuIG51bGxcclxuXHRcdH1cclxuXHJcbiAgICBjb25zdCBkcmF3UHJvZ3JhbSA9IGdsLmNyZWF0ZVByb2dyYW0oKVxyXG4gICAgY29uc3QgZnJhZ1NvdXJjZSA9IGAgI3ZlcnNpb24gMzAwIGVzXHJcbiAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XHJcblxyXG4gIHVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xyXG4gIHVuaWZvcm0gdmVjMiByZXNvbHV0aW9uO1xyXG5cclxuICBvdXQgdmVjNCBjb2w7XHJcbiAgdm9pZCBtYWluKCkge1xyXG4gICAgLy8gY29weSBjb2xvciBpbmZvIGZyb20gdGV4dHVyZVxyXG4gICAgY29sID0gdmVjNCggdGV4dHVyZSggdVNhbXBsZXIsIGdsX0ZyYWdDb29yZC54eSAvIHJlc29sdXRpb24gKS5yZ2IsIDEuICk7XHJcbiAgfWBcclxuXHJcbiAgICBjb25zdCBmc19kcmF3ID0gdGhpcy5jb21waWxlKCBnbC5GUkFHTUVOVF9TSEFERVIsIGZyYWdTb3VyY2UgKVxyXG4gICAgY29uc3QgdnNfZHJhdyA9IHRoaXMuY29tcGlsZSggZ2wuVkVSVEVYX1NIQURFUiwgdnNfc291cmNlIClcclxuXHJcbiAgICBnbC5hdHRhY2hTaGFkZXIoIGRyYXdQcm9ncmFtLCB2c19kcmF3IClcclxuXHRcdGdsLmF0dGFjaFNoYWRlciggZHJhd1Byb2dyYW0sIGZzX2RyYXcgKVxyXG5cdFx0Z2wubGlua1Byb2dyYW0oIGRyYXdQcm9ncmFtIClcclxuXHJcbiAgICByZXR1cm4gWyBwcm9ncmFtLCBkcmF3UHJvZ3JhbSBdXHJcbiAgfSxcclxuXHJcbiAgY2xlYXIoKSB7XHJcbiAgICBpZiggdGhpcy5jYWxsYmFja3MgIT09IHVuZGVmaW5lZCApIHRoaXMuY2FsbGJhY2tzLmxlbmd0aCA9IDBcclxuICAgIGlmKCB0aGlzLnJlbmRlciAhPT0gbnVsbCApIHRoaXMucmVuZGVyLnJ1bm5pbmcgPSBmYWxzZVxyXG5cclxuICAgIC8vIHJlbW92ZSBwb3N0LXByb2Nlc3NpbmcgZnhcclxuICAgIHRoaXMuZnguY2xlYXIoKVxyXG5cclxuICAgIHRoaXMuZ2VvbWV0cmllcy5sZW5ndGggPSAwXHJcblxyXG4gICAgY29uc3QgZ2wgPSB0aGlzLmdsXHJcbiAgICBnbC5jbGVhciggZ2wuQ09MT1JfQlVGRkVSX0JJVCB8IGdsLkRFUFRIX0JVRkZFUl9CSVQgfCBnbC5TVEVOQ0lMX0JVRkZFUl9CSVQgKVxyXG4gIH0sXHJcblxyXG4gIHBhdXNlKCkge1xyXG4gICAgdGhpcy5fX2lzUGF1c2VkID0gIXRoaXMuX19pc1BhdXNlZFxyXG4gIH0sXHJcblxyXG4gIGluaXRCdWZmZXJzKCB3aWR0aCwgaGVpZ2h0LCBjb2xvclRleHR1cmUsIGRlcHRoVGV4dHVyZSApIHtcclxuICAgIGNvbnN0IGdsID0gdGhpcy5nbFxyXG4gICAgZ2wuY2xlYXJDb2xvciggMC4wLCAwLjAsIDAuMCwgMC4wIClcclxuICAgIGdsLmNsZWFyKGdsLkNPTE9SX0JVRkZFUl9CSVQpXHJcblxyXG4gICAgY29uc3QgZnJhbWVidWZmZXIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpXHJcbiAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZyYW1lYnVmZmVyKTtcclxuICAgIGNvbnN0IHZibyA9IGdsLmNyZWF0ZUJ1ZmZlcigpXHJcblxyXG4gICAgY29uc3QgdmVydGljZXMgPSBuZXcgRmxvYXQzMkFycmF5KFtcclxuICAgICAgLTEsIC0xLFxyXG4gICAgICAxLCAgLTEsXHJcbiAgICAgIC0xLCAxLFxyXG4gICAgICAtMSwgMSxcclxuICAgICAgMSwgLTEsXHJcbiAgICAgIDEsIDFcclxuICAgIF0pXHJcblxyXG4gICAgLy8gaW5pdGlhbGl6ZSBtZW1vcnkgZm9yIGJ1ZmZlciBhbmQgcG9wdWxhdGUgaXQuIEdpdmVcclxuICAgIC8vIG9wZW4gZ2wgaGludCBjb250ZW50cyB3aWxsIG5vdCBjaGFuZ2UgZHluYW1pY2FsbHkuXHJcbiAgICBnbC5iaW5kQnVmZmVyKCBnbC5BUlJBWV9CVUZGRVIsIHZibyApXHJcbiAgICBnbC5idWZmZXJEYXRhKCBnbC5BUlJBWV9CVUZGRVIsIHZlcnRpY2VzLCBnbC5TVEFUSUNfRFJBVyApXHJcblxyXG4gICAgZ2wuZHJhd0J1ZmZlcnMoW1xyXG4gICAgICBnbC5DT0xPUl9BVFRBQ0hNRU5UMCxcclxuICAgICAgZ2wuQ09MT1JfQVRUQUNITUVOVDEgXHJcbiAgICBdKVxyXG5cclxuICAgIHJldHVybiB7IHZibywgdmVydGljZXMsIGZyYW1lYnVmZmVyIH1cclxuICB9LFxyXG5cclxuICBpbml0VW5pZm9ybXMoIGdsLCBwcm9ncmFtICkge1xyXG4gICAgY29uc3QgYVBvcyA9IHRoaXMuZ2wuZ2V0QXR0cmliTG9jYXRpb24oIHRoaXMucHJvZ3JhbSwgXCJhX3Bvc1wiIClcclxuXHJcbiAgICBjb25zdCB1VGltZT0gdGhpcy5nbC5nZXRVbmlmb3JtTG9jYXRpb24oIHRoaXMucHJvZ3JhbSwgXCJ0aW1lXCIgKVxyXG4gICAgY29uc3QgdVJlc29sdXRpb24gPSB0aGlzLmdsLmdldFVuaWZvcm1Mb2NhdGlvbiggdGhpcy5wcm9ncmFtLCBcInJlc29sdXRpb25cIiApXHJcblxyXG4gICAgcmV0dXJuIHsgYVBvcywgdVRpbWUsIHVSZXNvbHV0aW9uIH0gXHJcbiAgfSxcclxuXHJcbiAgaW5pdFRleHR1cmVzKCBnbCwgd2lkdGgsIGhlaWdodCApIHtcclxuICAgIGdsLmdldEV4dGVuc2lvbiggJ0VYVF9jb2xvcl9idWZmZXJfZmxvYXQnIClcclxuXHJcbiAgICBjb25zdCBjb2xvclRleHR1cmUgPSBnbC5jcmVhdGVUZXh0dXJlKClcclxuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGNvbG9yVGV4dHVyZSlcclxuICAgIFxyXG4gICAgLy8gbXVzdCB1c2UgbGluZWFyIGludGVycG9sYXRpb24gZm9yIG1lcmdlLXBhc3MgaW50ZWdyYXRpb24gXHJcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLkxJTkVBUiApXHJcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLkxJTkVBUiApXHJcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfUywgZ2wuQ0xBTVBfVE9fRURHRSApXHJcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKCBnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSApXHJcbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIHdpZHRoLCBoZWlnaHQsIDAsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIG51bGwpXHJcbiAgICBnbC5teUNvbG9yVGV4dHVyZSA9IGNvbG9yVGV4dHVyZVxyXG5cclxuICAgIC8vIHN0b3JlIGRlcHRoIGluIGZsb2F0aW5nIHBvaW50IHRleHR1cmVcclxuICAgIGNvbnN0IGRlcHRoVGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcclxuICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIGRlcHRoVGV4dHVyZSlcclxuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBnbC5ORUFSRVNUKVxyXG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01JTl9GSUxURVIsIGdsLk5FQVJFU1QpXHJcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKVxyXG4gICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSlcclxuICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgZ2wuUkdCQTMyRiwgd2lkdGgsIGhlaWdodCwgMCwgZ2wuUkdCQSwgZ2wuRkxPQVQsIG51bGwpXHJcblxyXG4gICAgcmV0dXJuIHsgY29sb3JUZXh0dXJlLCBkZXB0aFRleHR1cmUgfVxyXG4gIH0sXHJcblxyXG4gIHVwZGF0ZUxvY2F0aW9ucygpIHtcclxuICAgIHRoaXMucG9zdHByb2Nlc3NpbmcuZm9yRWFjaCggcHAgPT4gcHAudXBkYXRlX2xvY2F0aW9uKCB0aGlzLmdsLCB0aGlzLnByb2dyYW0gKSApXHJcbiAgICB0aGlzLnNjZW5lLnVwZGF0ZV9sb2NhdGlvbiggdGhpcy5nbCwgdGhpcy5wcm9ncmFtIClcclxuICAgIHRoaXMudGV4dHVyZXMudXBkYXRlX2xvY2F0aW9uKCB0aGlzLmdsLCB0aGlzLnByb2dyYW0gKVxyXG4gICAgdGhpcy5tYXRlcmlhbHMudXBkYXRlX2xvY2F0aW9uKCB0aGlzLmdsLCB0aGlzLnByb2dyYW0gKVxyXG4gICAgdGhpcy5saWdodGluZy51cGRhdGVfbG9jYXRpb24oIHRoaXMuZ2wsIHRoaXMucHJvZ3JhbSApXHJcbiAgfSxcclxuXHJcbiAgaW5pdFNoYWRlclByb2dyYW0oIHZzLCBmcywgZ2wgKSB7XHJcbiAgICBjb25zdCBwcm9ncmFtcyA9IHRoaXMuY3JlYXRlUHJvZ3JhbSggdnMsIGZzIClcclxuICAgIHRoaXMucHJvZ3JhbSA9IHByb2dyYW1zWzBdXHJcblxyXG4gICAgcmV0dXJuIHByb2dyYW1zXHJcbiAgfSxcclxuXHJcbiAgdXBsb2FkRGF0YSggZ2wgKSB7XHJcbiAgICB0aGlzLm1hdGVyaWFscy51cGxvYWRfZGF0YSggZ2wgKVxyXG4gICAgdGhpcy50ZXh0dXJlcy51cGxvYWRfZGF0YSggZ2wgKVxyXG4gICAgdGhpcy5zY2VuZS51cGxvYWRfZGF0YSggZ2wgKVxyXG4gICAgdGhpcy5saWdodGluZy51cGxvYWRfZGF0YSggZ2wgKVxyXG4gICAgdGhpcy5wb3N0cHJvY2Vzc2luZy5mb3JFYWNoKCBwcCA9PiBwcC51cGxvYWRfZGF0YSggZ2wgKSApXHJcbiAgfSxcclxuXHJcbiAgdXBsb2FkVmVydGljZXMoIGdsLCBhUG9zLCB2ZXJ0aWNlcyApIHtcclxuICAgIGdsLmJ1ZmZlckRhdGEoIGdsLkFSUkFZX0JVRkZFUiwgdmVydGljZXMsIGdsLlNUQVRJQ19EUkFXIClcclxuXHJcbiAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSggYVBvcyApXHJcbiAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKCBhUG9zLCAyLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApXHJcbiAgfSxcclxuXHJcbiAgaW5pdFdlYkdMKCB2cywgZnMsIHdpZHRoLCBoZWlnaHQsc2hvdWxkQW5pbWF0ZT1mYWxzZSApIHtcclxuICAgIGNvbnN0IGdsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IHRoaXMuZ2wsXHJcbiAgICAgICAgICBwcm9ncmFtcyAgICAgICAgICAgICAgICAgICAgICAgICAgPSB0aGlzLmluaXRTaGFkZXJQcm9ncmFtKCB2cywgZnMsIGdsICksXHJcbiAgICAgICAgICB7IGNvbG9yVGV4dHVyZSwgZGVwdGhUZXh0dXJlIH0gICAgPSB0aGlzLmluaXRUZXh0dXJlcyggZ2wsIHdpZHRoLCBoZWlnaHQgKSxcclxuICAgICAgICAgIHsgYVBvcywgdVRpbWUsIHVSZXNvbHV0aW9uIH0gICAgICA9IHRoaXMuaW5pdFVuaWZvcm1zKCBnbCwgcHJvZ3JhbXNbMF0gKSxcclxuICAgICAgICAgIHsgdmJvLCB2ZXJ0aWNlcywgZnJhbWVidWZmZXIgfSAgICA9IHRoaXMuaW5pdEJ1ZmZlcnMoIHdpZHRoLCBoZWlnaHQsIGNvbG9yVGV4dHVyZSwgZGVwdGhUZXh0dXJlIClcclxuIFxyXG4gICAgbGV0IHRvdGFsX3RpbWUgPSAwLjAsXHJcbiAgICAgICAgZnJhbWVDb3VudCA9IDBcclxuXHJcbiAgICAvLyBvbmx5IGluaXQgcG9zdC1wcm9jZXNzaW5nIGlmIGVmZmVjdHMgaGF2ZSBiZWVuIHJlZ2lzdGVyZWRcclxuICAgIGlmKCB0aGlzLmZ4LmNoYWluLmxlbmd0aCA+IDAgKSB0aGlzLmZ4LmluaXQoIGNvbG9yVGV4dHVyZSwgZGVwdGhUZXh0dXJlLCBnbCApXHJcblxyXG4gICAgZ2wudXNlUHJvZ3JhbSggdGhpcy5wcm9ncmFtIClcclxuICAgIHRoaXMudXBkYXRlTG9jYXRpb25zKCBnbCwgdGhpcy5wcm9ncmFtIClcclxuICAgIHRoaXMudXBsb2FkVmVydGljZXMoIGdsLCBhUG9zLCB2ZXJ0aWNlcyApXHJcblxyXG4gICAgZ2wudmlld3BvcnQoIDAsMCx3aWR0aCxoZWlnaHQgKVxyXG4gICAgZ2wudW5pZm9ybTJmKCB1UmVzb2x1dGlvbiwgd2lkdGgsIGhlaWdodCApXHJcbiBcclxuICAgIGNvbnN0IHJlbmRlciA9IGZ1bmN0aW9uKCB0aW1lc3RhbXAgKXtcclxuICAgICAgaWYoIHJlbmRlci5ydW5uaW5nID09PSB0cnVlICYmIHNob3VsZEFuaW1hdGUgPT09IHRydWUgKSB7XHJcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSggcmVuZGVyIClcclxuICAgICAgfWVsc2UgaWYoIHJlbmRlci5ydW5uaW5nID09PSBmYWxzZSApIHtcclxuICAgICAgICBnbC5jbGVhciggZ2wuQ09MT1JfQlVGRkVSX0JJVCB8IGdsLkRFUFRIX0JVRkZFUl9CSVQgfCBnbC5TVEVOQ0lMX0JVRkZFUl9CSVQgKVxyXG4gICAgICAgIHJldHVyblxyXG4gICAgICB9XHJcblxyXG4gICAgICBnbC51c2VQcm9ncmFtKCB0aGlzLnByb2dyYW0gKVxyXG4gICAgICBnbC5iaW5kRnJhbWVidWZmZXIoIGdsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlciApXHJcbiAgICBcclxuICAgICAgaWYoIHRoaXMuZngubWVyZ2VyICE9PSBudWxsICkge1xyXG4gICAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgdGhpcy5meC5tZXJnZXIudGV4LmJhY2sudGV4LCAwIClcclxuICAgICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDEsIGdsLlRFWFRVUkVfMkQsIHRoaXMuZngubWVyZ2VyLnRleC5idWZUZXh0dXJlc1swXS50ZXgsIDApXHJcbiAgICAgIH1lbHNle1xyXG4gICAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMCwgZ2wuVEVYVFVSRV8yRCwgY29sb3JUZXh0dXJlLCAwKVxyXG4gICAgICAgIGdsLmZyYW1lYnVmZmVyVGV4dHVyZTJEKGdsLkZSQU1FQlVGRkVSLCBnbC5DT0xPUl9BVFRBQ0hNRU5UMSwgZ2wuVEVYVFVSRV8yRCwgZGVwdGhUZXh0dXJlLCAwKVxyXG4gICAgICB9XHJcblxyXG4gICAgICBnbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSggYVBvcyApXHJcblxyXG4gICAgICBpZiggdGhpcy5fX2lzUGF1c2VkID09PSBmYWxzZSApIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRUaW1lID0gdGltZXN0YW1wXHJcblxyXG4gICAgICAgIGlmKCB0aGlzLmRlbGF5ICE9PSAwICYmIHRoaXMuZGVsYXkgPj0gZnJhbWVDb3VudCApIHtcclxuICAgICAgICAgIGZyYW1lQ291bnQrK1xyXG4gICAgICAgICAgcmV0dXJuXHJcbiAgICAgICAgfWVsc2UgaWYoIHRoaXMuZGVsYXkgIT09IDAgKSB7XHJcbiAgICAgICAgICBmcmFtZUNvdW50ID0gMFxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdG90YWxfdGltZSA9IHRpbWVzdGFtcCAvIDEwMDAuMFxyXG4gICAgICAgIGdsLnVuaWZvcm0xZiggdVRpbWUsIHRvdGFsX3RpbWUgKVxyXG5cclxuICAgICAgICB0aGlzLmNhbGxiYWNrcy5mb3JFYWNoKCBjYiA9PiBjYiggdG90YWxfdGltZSwgdGhpcy5jdXJyZW50VGltZSApIClcclxuXHJcbiAgICAgICAgaWYoIHR5cGVvZiB3aW5kb3cub25mcmFtZSA9PT0gJ2Z1bmN0aW9uJyApIHdpbmRvdy5vbmZyYW1lKCB0b3RhbF90aW1lIClcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gdHJhbnNmZXIgYWxsIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHVuaWZvcm1zIGluIG1hcmNoaW5nLmpzXHJcbiAgICAgIHRoaXMudXBsb2FkRGF0YSggZ2wgKVxyXG5cclxuICAgICAgLy8gZHJhdyB0byBjb2xvciBhbmQgZGVwdGggdGV4dHVyZXNlXHJcbiAgICAgIGdsLmJpbmRCdWZmZXIoIGdsLkFSUkFZX0JVRkZFUiwgdmJvIClcclxuXHJcbiAgICAgIC8vIGlmIHBvc3QtcHJvY2Vzc2luZyBpcyBub3QgYmVpbmcgdXNlZCxcclxuICAgICAgLy8gZHJhdyBkaXJlY3RseSB0byBzY3JlZW5cclxuICAgICAgaWYoIHRoaXMuZngubWVyZ2VyID09PSBudWxsICkge1xyXG4gICAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlciggZ2wuRlJBTUVCVUZGRVIsIG51bGwgKVxyXG4gICAgICB9XHJcblxyXG4gICAgICBnbC5kcmF3QXJyYXlzKCBnbC5UUklBTkdMRVMsIDAsIDYgKVxyXG5cclxuICAgICAgLyoqKioqKioqKiBVTkNPTU1FTlQgVEhJUyBMSU5FIFRPIENIRUNLIE1BUkNISU5HLkpTIENPTE9SIE9VUFRVVCAqKioqKioqKioqKioqKiovXHJcbiAgICAgIC8vdGhpcy5ydW5Db3B5U2hhZGVyKCBnbCwgd2lkdGgsIGhlaWdodCwgYVBvcywgcHJvZ3JhbXMsIGNvbG9yVGV4dHVyZSwgdmJvIClcclxuICAgICAgXHJcbiAgICAgIC8qKioqKioqKiogVU5DT01NRU5UIFRISVMgTElORSBUTyBDSEVDSyBNQVJDSElORy5KUyBERVBUSCBPVVBUVVQgKioqKioqKioqKioqKioqL1xyXG4gICAgICAvLyB0aGlzLnJ1bkNvcHlTaGFkZXIoIGdsLCB3aWR0aCwgaGVpZ2h0LCBhUG9zLCBwcm9ncmFtcywgZGVwdGhUZXh0dXJlLCB2Ym8gKVxyXG4gXHJcbiAgICAgIC8vIGNvbmRpdGlvbmFsIG1lcmdlcGFzcyByZW5kZXJcclxuICAgICAgaWYoIHRoaXMuZngubWVyZ2VyICE9PSBudWxsICkgdGhpcy5meC5tZXJnZXIuZHJhdyggdG90YWxfdGltZSApXHJcblxyXG4gICAgfS5iaW5kKCBTREYgKVxyXG5cclxuICAgIHJlbmRlci5ydW5uaW5nID0gdHJ1ZVxyXG5cclxuICAgIHJldHVybiByZW5kZXIgICAgXHJcbiAgfSxcclxuXHJcbiAgcnVuQ29weVNoYWRlciggZ2wsIHdpZHRoLCBoZWlnaHQsIGxvY19hX3BvcywgcHJvZ3JhbXMsIGNvbG9yVGV4dHVyZSwgdmJvICkge1xyXG4gICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBudWxsIClcclxuXHJcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBjb2xvclRleHR1cmUpXHJcbiAgICBnbC52aWV3cG9ydCgwLCAwLCB3aWR0aCwgaGVpZ2h0IClcclxuXHJcbiAgICBnbC5iaW5kQnVmZmVyKCBnbC5BUlJBWV9CVUZGRVIsIHZibyApXHJcbiAgICBnbC51c2VQcm9ncmFtKCBwcm9ncmFtc1sxXSApXHJcblxyXG4gICAgY29uc3QgdV9yZXNvbHV0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW1zWzFdLCBcInJlc29sdXRpb25cIiApXHJcbiAgICBnbC51bmlmb3JtMmYoIHVfcmVzb2x1dGlvbiwgd2lkdGgsIGhlaWdodCApXHJcblxyXG4gICAgZ2wuZHJhd0FycmF5cyggZ2wuVFJJQU5HTEVTLCAwLCA2IClcclxuICB9XHJcbn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gU0RGXHJcbiIsImNvbnN0IFNjZW5lTm9kZSA9IHJlcXVpcmUoICcuL3NjZW5lTm9kZS5qcycgKSxcbiAgICAgIHsgcGFyYW1fd3JhcCwgTWF0ZXJpYWxJRCB9ID0gcmVxdWlyZSggJy4vdXRpbHMuanMnICksXG4gICAgICB7IFZhciwgZmxvYXRfdmFyX2dlbiwgdmVjMl92YXJfZ2VuLCB2ZWMzX3Zhcl9nZW4sIHZlYzRfdmFyX2dlbiB9ID0gcmVxdWlyZSggJy4vdmFyLmpzJyApLFxuICAgICAgeyBWZWMyLCBWZWMzLCBWZWM0IH0gPSByZXF1aXJlKCAnLi92ZWMuanMnIClcblxuXG5jb25zdCBnbHNsID0gcmVxdWlyZSggJ2dsc2xpZnknIClcblxuY29uc3QgX19NYXRlcmlhbHMgPSBmdW5jdGlvbiggU0RGICkge1xuXG4gIGNvbnN0IE1hdGVyaWFscyA9IHtcbiAgICBtYXRlcmlhbHM6W10sXG4gICAgX19tYXRlcmlhbHM6W10sXG4gICAgbW9kZUNvbnN0YW50cyA6IFtcbiAgICAgICdnbG9iYWwnLFxuICAgICAgJ25vcm1hbCcsXG4gICAgICAncGhvbmcnLFxuICAgICAgJ29yZW5uJyxcbiAgICAgICdub2lzZSdcbiAgICBdLFxuXG4gICAgZGVmYXVsdDogJ2dsb2JhbCcsXG5cbiAgICAvL2RlZmF1bHRNYXRlcmlhbHM6YFxuICAgIC8vICBNYXRlcmlhbCBtYXRlcmlhbHNbMl0gPSBNYXRlcmlhbFsyXShcbiAgICAvLyAgICBNYXRlcmlhbCggMCwgdmVjMyggMS4gKSwgdmVjMygwLiwwLiwwLiksIHZlYzMoMS4pLCA4LiwgRnJlc25lbCggMC4sIDEuLCAyLikgKSxcbiAgICAvLyAgICBNYXRlcmlhbCggMCwgdmVjMyggMS4gKSwgdmVjMygxLiwwLiwwLiksIHZlYzMoMS4pLCA4LiwgRnJlc25lbCggMC4sIDEuLCAyLikgKVxuICAgIC8vICApO1xuICAgIC8vYCxcblxuICAgIGFkZE1hdGVyaWFsKCBtYXQgKSB7XG4gICAgICBpZiggbWF0ID09PSB1bmRlZmluZWQgKSBtYXQgPSBNYXRlcmlhbHMubWF0ZXJpYWwuZGVmYXVsdFxuXG4gICAgICBpZiggTWF0ZXJpYWxzLm1hdGVyaWFscy5pbmRleE9mKCBtYXQgKSA9PT0gLTEgKSB7XG4gICAgICAgIG1hdC5pZCA9IE1hdGVyaWFsSUQuYWxsb2MoKVxuXG4gICAgICAgIC8vIHdlIGhhdmUgdG8gZGlydHkgdGhlIG1hdGVyaWFsIHNvIHRoYXQgaXRzIGRhdGFcbiAgICAgICAgLy8gd2lsbCBiZSB1cGxvYWRlZCB0byBuZXcgc2hhZGVycywgb3RoZXJ3aXNlIHRoZVxuICAgICAgICAvLyBtYXRlcmlhbCB3aWxsIG9ubHkgd29yayB0aGUgZmlyc3QgdGltZSBpdCdzIHVzZWQsIHdoZW5cbiAgICAgICAgLy8gaXQncyBkaXJ0eSBvbiBpbml0aWFsaXphdGlvbi5cbiAgICAgICAgTWF0ZXJpYWxzLmRpcnR5KCBtYXQgKVxuXG4gICAgICAgIE1hdGVyaWFscy5tYXRlcmlhbHMucHVzaCggbWF0IClcbiAgICAgIH0gXG5cbiAgICAgIHJldHVybiBtYXRcbiAgICB9LFxuXG4gICAgbWF0ZXJpYWwoIG1vZGU9J2dsb2JhbCcsIF9fYW1iaWVudCwgX19kaWZmdXNlLCBfX3NwZWN1bGFyLCBfX3NoaW5pbmVzcywgX19mcmVzbmVsLCBfX3RleHR1cmU9bnVsbCApe1xuICAgICAgbGV0IG1vZGVJZHggPSBNYXRlcmlhbHMubW9kZUNvbnN0YW50cy5pbmRleE9mKCBtb2RlIClcbiAgICAgIGlmKCBtb2RlSWR4ID09PSAtMSApIHtcbiAgICAgICAgY29uc29sZS53YXJuKCBgVGhlcmUgaXMgbm8gbWF0ZXJpYWwgdHlwZSBuYW1lZCAke21vZGV9LiBVc2luZyB0aGUgZGVmYXVsdCBtYXRlcmlhbCwgJHtNYXRlcmlhbHMuZGVmYXVsdH0sIGluc3RlYWQuYCApXG4gICAgICAgIG1vZGUgPSBNYXRlcmlhbHMuZGVmYXVsdFxuICAgICAgICBtb2RlSWR4ID0gTWF0ZXJpYWxzLm1vZGVDb25zdGFudHMuaW5kZXhPZiggbW9kZSApXG4gICAgICB9XG5cbiAgICAgIGlmKCB0eXBlb2YgX19hbWJpZW50ID09PSAnbnVtYmVyJyApIF9fYW1iaWVudCA9IFZlYzMoIF9fYW1iaWVudCApXG4gICAgICBjb25zdCBhbWJpZW50ID0gcGFyYW1fd3JhcCggX19hbWJpZW50LCB2ZWMzX3Zhcl9nZW4oLjEsLjEsLjEpIClcbiAgICAgIGlmKCB0eXBlb2YgX19kaWZmdXNlPT09ICdudW1iZXInICkgX19kaWZmdXNlPSBWZWMzKCBfX2RpZmZ1c2UgKVxuICAgICAgY29uc3QgZGlmZnVzZSA9IHBhcmFtX3dyYXAoIF9fZGlmZnVzZSwgdmVjM192YXJfZ2VuKDAsMCwxKSApXG4gICAgICBpZiggdHlwZW9mIF9fc3BlY3VsYXIgPT09ICdudW1iZXInICkgX19zcGVjdWxhciA9IFZlYzMoIF9fc3BlY3VsYXIgKVxuICAgICAgY29uc3Qgc3BlY3VsYXIgPSBwYXJhbV93cmFwKCBfX3NwZWN1bGFyLCB2ZWMzX3Zhcl9nZW4oMSwxLDEpIClcbiAgICAgIGNvbnN0IHNoaW5pbmVzcyA9IHBhcmFtX3dyYXAoIF9fc2hpbmluZXNzLCBmbG9hdF92YXJfZ2VuKDgpIClcbiAgICAgIGlmKCB0eXBlb2YgX19mcmVzbmVsID09PSAnbnVtYmVyJyApIF9fZnJlc25lbCA9IFZlYzMoIF9fZnJlc25lbCApXG4gICAgICBjb25zdCBmcmVzbmVsID0gcGFyYW1fd3JhcCggX19mcmVzbmVsLCB2ZWMzX3Zhcl9nZW4oMCwxLDIpIClcblxuICAgICAgY29uc3QgbWF0ID0geyBzaGluaW5lc3MsIG1vZGUsIHRleHR1cmU6X190ZXh0dXJlLCB0eXBlOidtYXRlcmlhbCcgfVxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIG1hdCwgJ2FtYmllbnQnLCB7XG4gICAgICAgIGdldCgpIHsgcmV0dXJuIGFtYmllbnQgfSxcbiAgICAgICAgc2V0KHYpIHtcbiAgICAgICAgICBpZiggdHlwZW9mIHYgPT09ICdvYmplY3QnICkge1xuICAgICAgICAgICAgYW1iaWVudC5zZXQoIHYgKVxuICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgYW1iaWVudC52YWx1ZS54ID0gdlxuICAgICAgICAgICAgYW1iaWVudC52YWx1ZS55ID0gdlxuICAgICAgICAgICAgYW1iaWVudC52YWx1ZS56ID0gdlxuICAgICAgICAgICAgYW1iaWVudC5kaXJ0eSA9IHRydWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pICBcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggbWF0LCAnZGlmZnVzZScsIHtcbiAgICAgICAgZ2V0KCkgeyByZXR1cm4gZGlmZnVzZSB9LFxuICAgICAgICBzZXQodikge1xuICAgICAgICAgIGlmKCB0eXBlb2YgdiA9PT0gJ29iamVjdCcgKSB7XG4gICAgICAgICAgICBkaWZmdXNlLnNldCggdiApXG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBkaWZmdXNlLnZhbHVlLnggPSB2XG4gICAgICAgICAgICBkaWZmdXNlLnZhbHVlLnkgPSB2XG4gICAgICAgICAgICBkaWZmdXNlLnZhbHVlLnogPSB2XG4gICAgICAgICAgICBkaWZmdXNlLmRpcnR5ID0gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSkgIFxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBtYXQsICdzcGVjdWxhcicsIHtcbiAgICAgICAgZ2V0KCkgeyByZXR1cm4gc3BlY3VsYXIgfSxcbiAgICAgICAgc2V0KHYpIHtcbiAgICAgICAgICBpZiggdHlwZW9mIHYgPT09ICdvYmplY3QnICkge1xuICAgICAgICAgICAgc3BlY3VsYXIuc2V0KCB2IClcbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIHNwZWN1bGFyLnZhbHVlLnggPSB2XG4gICAgICAgICAgICBzcGVjdWxhci52YWx1ZS55ID0gdlxuICAgICAgICAgICAgc3BlY3VsYXIudmFsdWUueiA9IHZcbiAgICAgICAgICAgIHNwZWN1bGFyLmRpcnR5ID0gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSkgIFxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBtYXQsICdmcmVzbmVsJywge1xuICAgICAgICBnZXQoKSB7IHJldHVybiBmcmVzbmVsIH0sXG4gICAgICAgIHNldCh2KSB7XG4gICAgICAgICAgaWYoIHR5cGVvZiB2ID09PSAnb2JqZWN0JyApIHtcbiAgICAgICAgICAgIGZyZXNuZWwuc2V0KCB2IClcbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIGZyZXNuZWwudmFsdWUueCA9IHZcbiAgICAgICAgICAgIGZyZXNuZWwudmFsdWUueSA9IHZcbiAgICAgICAgICAgIGZyZXNuZWwudmFsdWUueiA9IHZcbiAgICAgICAgICAgIGZyZXNuZWwuZGlydHkgPSB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KSAgXG4gICAgICAvL09iamVjdC5kZWZpbmVQcm9wZXJ0eSggbWF0LCAnc2hpbmluZXNzJywge1xuICAgICAgLy8gIGdldCgpIHsgcmV0dXJuIG1hdC5zaGluaW5lc3MudmFsdWUgfSxcbiAgICAgIC8vICBzZXQodil7XG4gICAgICAvLyAgICBtYXQuc2hpbmluZXNzLnZhbHVlID0gdlxuICAgICAgLy8gICAgbWF0LnNoaW5pbmVzcy5kaXJ0eSA9IHRydWVcbiAgICAgIC8vICB9XG4gICAgICAvL30pICAgICAvL1xuICAgICAgXG4gICAgICByZXR1cm4gbWF0IFxuICAgIH0sXG5cbiAgICBkaXJ0eSggbWF0ICkge1xuICAgICAgbWF0LmFtYmllbnQuZGlydHkgPSB0cnVlXG4gICAgICBtYXQuZGlmZnVzZS5kaXJ0eSA9IHRydWVcbiAgICAgIG1hdC5zcGVjdWxhci5kaXJ0eSA9IHRydWVcbiAgICAgIG1hdC5zaGluaW5lc3MuZGlydHkgPSB0cnVlXG4gICAgICBtYXQuZnJlc25lbC5kaXJ0eSA9IHRydWVcbiAgICAgIGlmKCBtYXQudGV4dHVyZSAhPT0gbnVsbCApIG1hdC50ZXh0dXJlLmRpcnR5ID0gdHJ1ZVxuICAgIH0sXG4gICBcbiAgICBlbWl0X21hdGVyaWFscygpIHtcbiAgICAgIGlmKCB0aGlzLm1hdGVyaWFscy5sZW5ndGggPT09IDAgKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCAncmV0dXJuaW5nIHVuZGVmaW5lZD8nLCB0aGlzLmRlZmF1bHRNYXRlcmlhbHMgKVxuICAgICAgICByZXR1cm4gdGhpcy5kZWZhdWx0TWF0ZXJpYWxzLy90aGlzLmFkZE1hdGVyaWFsKCkgXG4gICAgICB9XG5cbiAgICAgIGxldCBzdHIgPSBgTWF0ZXJpYWwgbWF0ZXJpYWxzWyR7dGhpcy5tYXRlcmlhbHMubGVuZ3RofV0gPSBNYXRlcmlhbFske3RoaXMubWF0ZXJpYWxzLmxlbmd0aH1dKGBcblxuICAgICAgdGhpcy5tYXRlcmlhbHMuc29ydCggKGEsYikgPT4gYS5pZCA+IGIuaWQgPyAxIDogLTEgKSBcblxuICAgICAgZm9yKCBsZXQgbWF0IG9mIHRoaXMubWF0ZXJpYWxzICkge1xuICAgICAgICBjb25zdCBmcmVzbmVsID0gYEZyZXNuZWwoICR7ZihtYXQuZnJlc25lbC54KX0sICR7ZihtYXQuZnJlc25lbC55KX0sICR7ZihtYXQuZnJlc25lbC56KX0gKWBcblxuICAgICAgICBjb25zdCB0ZXhpZCA9IDAvL1NERi50ZXh0dXJlcy50ZXh0dXJlcy5pbmRleE9mKCBtYXQudGV4dHVyZSApXG4gICAgICAgIHN0ciArPSBtYXQudGV4dHVyZSA9PT0gbnVsbCBcbiAgICAgICAgICA/IGBcXG4gICAgICAgIE1hdGVyaWFsKCAke3RoaXMubW9kZUNvbnN0YW50cy5pbmRleE9mKCBtYXQubW9kZSApfSwgJHttYXQuYW1iaWVudC5lbWl0KCl9LCAke21hdC5kaWZmdXNlLmVtaXQoKX0sICR7bWF0LnNwZWN1bGFyLmVtaXQoKX0sICR7bWF0LnNoaW5pbmVzcy5lbWl0KCl9LCAke21hdC5mcmVzbmVsLmVtaXQoKX0sICR7IHRleGlkIH0gKSxgIFxuICAgICAgICAgIDogYFxcbiAgICAgICAgTWF0ZXJpYWwoICR7dGhpcy5tb2RlQ29uc3RhbnRzLmluZGV4T2YoIG1hdC5tb2RlICl9LCAke21hdC5hbWJpZW50LmVtaXQoKX0sICR7bWF0LmRpZmZ1c2UuZW1pdCgpfSwgJHttYXQuc3BlY3VsYXIuZW1pdCgpfSwgJHttYXQuc2hpbmluZXNzLmVtaXQoKX0sICR7bWF0LmZyZXNuZWwuZW1pdCgpfSwgJHsgdGV4aWQgfSApLGAgXG4gICAgICB9XG4gICAgICBcbiAgICAgIHN0ciA9IHN0ci5zbGljZSgwLC0xKSAvLyByZW1vdmUgdHJhaWxpbmcgY29tbWFcblxuICAgICAgc3RyICs9ICdcXG4gICAgICApOydcblxuICAgICAgdGhpcy5fX21hdGVyaWFscyA9IHRoaXMubWF0ZXJpYWxzLnNsaWNlKCAwIClcbiAgICAgIHRoaXMubWF0ZXJpYWxzLmxlbmd0aCA9IDBcblxuICAgICAgcmV0dXJuIHN0clxuICAgIH0sXG5cbiAgICBlbWl0X2RlY2woKSB7XG4gICAgICBsZXQgc3RyID0gJydcbiAgICAgIGZvciggbGV0IG1hdCBvZiB0aGlzLl9fbWF0ZXJpYWxzICkge1xuICAgICAgICBzdHIgKz0gbWF0LmFtYmllbnQuZW1pdF9kZWNsKClcbiAgICAgICAgc3RyICs9IG1hdC5kaWZmdXNlLmVtaXRfZGVjbCgpXG4gICAgICAgIHN0ciArPSBtYXQuc3BlY3VsYXIuZW1pdF9kZWNsKClcbiAgICAgICAgc3RyICs9IG1hdC5zaGluaW5lc3MuZW1pdF9kZWNsKClcbiAgICAgICAgc3RyICs9IG1hdC5mcmVzbmVsLmVtaXRfZGVjbCgpXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHJcbiAgICB9LFxuXG4gICAgdXBkYXRlX2xvY2F0aW9uKCBnbCwgcHJvZ3JhbSApIHtcbiAgICAgIGZvciggbGV0IG1hdCBvZiB0aGlzLl9fbWF0ZXJpYWxzICkge1xuICAgICAgICBpZiggbWF0LmFtYmllbnQuZGlydHkgPT09IHRydWUgKSAgIG1hdC5hbWJpZW50LnVwZGF0ZV9sb2NhdGlvbiggZ2wsIHByb2dyYW0gKVxuICAgICAgICBpZiggbWF0LmRpZmZ1c2UuZGlydHkgPT09IHRydWUgKSAgIG1hdC5kaWZmdXNlLnVwZGF0ZV9sb2NhdGlvbiggZ2wsIHByb2dyYW0gKVxuICAgICAgICBpZiggbWF0LnNwZWN1bGFyLmRpcnR5ID09PSB0cnVlICkgIG1hdC5zcGVjdWxhci51cGRhdGVfbG9jYXRpb24oIGdsLCBwcm9ncmFtIClcbiAgICAgICAgaWYoIG1hdC5zaGluaW5lc3MuZGlydHkgPT09IHRydWUgKSBtYXQuc2hpbmluZXNzLnVwZGF0ZV9sb2NhdGlvbiggZ2wsIHByb2dyYW0gKVxuICAgICAgICBpZiggbWF0LmZyZXNuZWwuZGlydHkgPT09IHRydWUgKSAgIG1hdC5mcmVzbmVsLnVwZGF0ZV9sb2NhdGlvbiggZ2wsIHByb2dyYW0gKVxuICAgICAgfVxuICAgIH0sXG5cbiAgICB1cGxvYWRfZGF0YSggZ2wsIHByb2dyYW09JycgKSB7XG4gICAgICBmb3IoIGxldCBtYXQgb2YgdGhpcy5fX21hdGVyaWFscyApIHtcbiAgICAgICAgaWYoIG1hdC5hbWJpZW50LmRpcnR5ID09PSB0cnVlICkgICBtYXQuYW1iaWVudC51cGxvYWRfZGF0YSggZ2wsIHByb2dyYW0gKVxuICAgICAgICBpZiggbWF0LmRpZmZ1c2UuZGlydHkgPT09IHRydWUgKSAgIG1hdC5kaWZmdXNlLnVwbG9hZF9kYXRhKCBnbCwgcHJvZ3JhbSApXG4gICAgICAgIGlmKCBtYXQuc3BlY3VsYXIuZGlydHkgPT09IHRydWUgKSAgbWF0LnNwZWN1bGFyLnVwbG9hZF9kYXRhKCBnbCwgcHJvZ3JhbSApXG4gICAgICAgIGlmKCBtYXQuc2hpbmluZXNzLmRpcnR5ID09PSB0cnVlICkgbWF0LnNoaW5pbmVzcy51cGxvYWRfZGF0YSggZ2wsIHByb2dyYW0gKVxuICAgICAgICBpZiggbWF0LmZyZXNuZWwuZGlydHkgPT09IHRydWUgKSAgIG1hdC5mcmVzbmVsLnVwbG9hZF9kYXRhKCBnbCwgcHJvZ3JhbSApXG4gICAgICB9XG4gICAgfVxuXG4gIH1cblxuICBjb25zdCBmID0gdmFsdWUgPT4gdmFsdWUgJSAxID09PSAwID8gdmFsdWUudG9GaXhlZCgxKSA6IHZhbHVlIFxuXG4gIE9iamVjdC5hc3NpZ24oIE1hdGVyaWFscy5tYXRlcmlhbCwge1xuICAgIGRlZmF1bHQgOiBNYXRlcmlhbHMubWF0ZXJpYWwoICdnbG9iYWwnLCBWZWMzKCAuMTUgKSwgVmVjMygwKSwgVmVjMygxKSwgOCwgVmVjMyggMCwgMSwgLjUgKSApLCAgXG4gICAgcmVkICAgICA6IE1hdGVyaWFscy5tYXRlcmlhbCggJ2dsb2JhbCcsIFZlYzMoLjI1LDAsMCksIFZlYzMoMSwwLDApLCBWZWMzKDApLCAyLCBWZWMzKDApICksXG4gICAgZ3JlZW4gICA6IE1hdGVyaWFscy5tYXRlcmlhbCggJ2dsb2JhbCcsIFZlYzMoMCwuMjUsMCksIFZlYzMoMCwxLDApLCBWZWMzKDApLCAyLCBWZWMzKDApICksXG4gICAgYmx1ZSAgICA6IE1hdGVyaWFscy5tYXRlcmlhbCggJ2dsb2JhbCcsIFZlYzMoMCwwLC4yNSksIFZlYzMoMCwwLDEpLCBWZWMzKDApLCAyLCBWZWMzKDApICksXG4gICAgY3lhbiAgICA6IE1hdGVyaWFscy5tYXRlcmlhbCggJ2dsb2JhbCcsIFZlYzMoMCwuMjUsLjI1KSwgVmVjMygwLDEsMSksIFZlYzMoMCksIDIsIFZlYzMoMCkgKSxcbiAgICBtYWdlbnRhIDogTWF0ZXJpYWxzLm1hdGVyaWFsKCAnZ2xvYmFsJywgVmVjMyguMjUsMCwuMjUpLCBWZWMzKDEsMCwxKSwgVmVjMygwKSwgMiwgVmVjMygwKSApLFxuICAgIHllbGxvdyAgOiBNYXRlcmlhbHMubWF0ZXJpYWwoICdnbG9iYWwnLCBWZWMzKC4yNSwuMjUsLjApLCBWZWMzKDEsMSwwKSwgVmVjMygwKSwgMiwgVmVjMygwKSApLFxuICAgIGJsYWNrICAgOiBNYXRlcmlhbHMubWF0ZXJpYWwoICdnbG9iYWwnLCBWZWMzKDAsIDAsIDApLCBWZWMzKDAsMCwwKSwgVmVjMygwKSwgMiwgVmVjMygwKSApLFxuICAgIHdoaXRlICAgOiBNYXRlcmlhbHMubWF0ZXJpYWwoICdnbG9iYWwnLCBWZWMzKC4yNSksIFZlYzMoMSksIFZlYzMoMSksIDIsIFZlYzMoMCkgKSxcbiAgICBncmV5ICAgIDogTWF0ZXJpYWxzLm1hdGVyaWFsKCAnZ2xvYmFsJywgVmVjMyguMjUpLCBWZWMzKC4zMyksIFZlYzMoMSksIDIsIFZlYzMoMCkgKSxcblxuICAgICd3aGl0ZSBnbG93JyA6IE1hdGVyaWFscy5tYXRlcmlhbCggJ3Bob25nJywgIFZlYzMoLjAxNSksIFZlYzMoMSksIFZlYzMoMSksIDE2LCBWZWMzKDAsMjAwLDUpICksXG4gICAgZ2x1ZSAgICA6IE1hdGVyaWFscy5tYXRlcmlhbCggJ3Bob25nJywgIFZlYzMoLjAxNSksIFZlYzMoMSksIFZlYzMoMSksIDE2LCBWZWMzKDAsMTUsLS4xKSApLFxuICAgIGludmVyc2UgOiBNYXRlcmlhbHMubWF0ZXJpYWwoICdwaG9uZycsIDEsIC41LCAxLCAxNiwgVmVjMygxLC41LC0yKSApLFxuXG4gICAgbm9ybWFsICA6IE1hdGVyaWFscy5tYXRlcmlhbCggJ25vcm1hbCcgKSxcbiAgICBub2lzZSAgIDogTWF0ZXJpYWxzLm1hdGVyaWFsKCAnbm9pc2UnLCAgVmVjMyggLjE1ICksIFZlYzMoMSwwLDApLCBWZWMzKDEpLCA4LCBWZWMzKCAwLCAxLCAuNSApKVxuICB9KVxuXG4gIHJldHVybiBNYXRlcmlhbHNcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfX01hdGVyaWFsc1xuIiwiY29uc3QgTVAgICA9IHJlcXVpcmUoICdAYmFuZGFsb28vbWVyZ2UtcGFzcycgKVxuXG5jb25zdCBGWCA9IHtcbiAgbWVyZ2VyOm51bGwsXG4gIGNoYWluOiBbXSxcbiAgTVAsXG4gIGNsZWFyKCkge1xuICAgIGlmKCB0aGlzLm1lcmdlciAhPT0gbnVsbCApIHtcbiAgICAgICB0aGlzLm1lcmdlci5kZWxldGUoKVxuICAgICAgIHRoaXMubWVyZ2VyID0gbnVsbFxuICAgIH1cblxuICAgIHRoaXMuY2hhaW4ubGVuZ3RoID0gMFxuICB9LFxuXG4gIGluaXQoIGNvbG9yVGV4dHVyZSwgZGVwdGhUZXh0dXJlLCBnbCApIHtcbiAgICB0aGlzLm1lcmdlciA9IG5ldyBNUC5NZXJnZXIoIFxuICAgICAgdGhpcy5jaGFpbixcbiAgICAgIGNvbG9yVGV4dHVyZSwgXG4gICAgICBnbCwgXG4gICAgICB7IGNoYW5uZWxzOiBbIGRlcHRoVGV4dHVyZSwgbnVsbCBdIH1cbiAgICApXG4gIH0sIFxuXG4gIHJ1biggdGltZSApIHtcbiAgICBtZXJnZXIuZHJhdyggdGltZSApXG4gIH0sXG5cbiAgcG9zdCggLi4uZnggKSB7XG4gICAgLy9GWC5jaGFpbiA9IGZ4Lm1hcCggdiA9PiB2Ll9fd3JhcHBlZF9fIClcbiAgICBGWC5jaGFpbi5sZW5ndGggPSAwXG5cbiAgICBmeC5mb3JFYWNoKCB2ID0+IHtcbiAgICAgIGlmKCBBcnJheS5pc0FycmF5KCB2Ll9fd3JhcHBlZF9fICkgKSB7XG4gICAgICAgIHYuX193cmFwcGVkX18uZm9yRWFjaCggdyA9PiBGWC5jaGFpbi5wdXNoKCB3ICkgKVxuICAgICAgfWVsc2V7XG4gICAgICAgIEZYLmNoYWluLnB1c2goIHYuX193cmFwcGVkX18gKVxuICAgICAgfVxuICAgIH0pXG4gIH0sXG5cbiAgZXhwb3J0KCBvYmogKSB7XG4gICAgb2JqLkFudGlhbGlhcyAgPSBGWC5BbnRpYWxpYXNcbiAgICBvYmouQmx1ciAgICAgICA9IEZYLkJsdXJcbiAgICBvYmouQmxvb20gICAgICA9IEZYLkJsb29tXG4gICAgb2JqLkJyaWdodG5lc3MgPSBGWC5CcmlnaHRuZXNzXG4gICAgb2JqLkNvbnRyYXN0ICAgPSBGWC5Db250cmFzdFxuICAgIG9iai5FZGdlICAgICAgID0gRlguRWRnZVxuICAgIG9iai5Gb2N1cyAgICAgID0gRlguRm9jdXNcbiAgICBvYmouR2xvdyAgICAgICA9IEZYLkdsb3dcbiAgICBvYmouR29kcmF5cyAgICA9IEZYLkdvZHJheXNcbiAgICBvYmouSHVlICAgICAgICA9IEZYLkh1ZVxuICAgIG9iai5JbnZlcnQgICAgID0gRlguSW52ZXJ0XG4gICAgb2JqLk1vdGlvbkJsdXIgPSBGWC5Nb3Rpb25CbHVyXG4gIH0sXG5cbiAgd3JhcFByb3BlcnR5KCBvYmosIG5hbWUsIF9fdmFsdWUsIHRyYW5zZm9ybT1udWxsICkge1xuICAgIF9fdmFsdWUgPSB0cmFuc2Zvcm0gPT09IG51bGwgPyBfX3ZhbHVlIDogdHJhbnNmb3JtKCBfX3ZhbHVlIClcbiAgICBjb25zdCBwcmltaXRpdmUgPSBNUC5mbG9hdCggTVAubXV0KCBfX3ZhbHVlICkgKVxuICAgIFxuICAgIGxldCB2YWx1ZSA9IF9fdmFsdWUgXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBvYmosIG5hbWUsIHtcbiAgICAgIGdldCgpIHsgcmV0dXJuIHZhbHVlIH0sXG4gICAgICBzZXQodikge1xuICAgICAgICB2YWx1ZSA9IHRyYW5zZm9ybSA9PT0gbnVsbCA/IHYgOiB0cmFuc2Zvcm0oIHYgKVxuICAgICAgICBwcmltaXRpdmUuc2V0VmFsKCB2YWx1ZSApXG4gICAgICB9XG4gICAgfSlcblxuICAgIHJldHVybiBwcmltaXRpdmVcbiAgfSxcblxuICBCbG9vbSggX190aHJlc2hvbGQ9MCwgX19ib29zdD0uMDEgKSB7XG4gICAgY29uc3QgZnggPSB7fSxcbiAgICAgICAgICB0aHJlc2hvbGQgID0gRlgud3JhcFByb3BlcnR5KCBmeCwgJ3RocmVzaG9sZCcsICBfX3RocmVzaG9sZCApLFxuICAgICAgICAgIGJvb3N0ICAgICAgPSBGWC53cmFwUHJvcGVydHkoIGZ4LCAnYW1vdW50JywgX19ib29zdCApIFxuXG4gICAgZnguX193cmFwcGVkX18gPSBNUC5ibG9vbSggdGhyZXNob2xkLCBib29zdCApIFxuXG4gICAgcmV0dXJuIGZ4XG4gIH0sXG5cbiAgQmx1ciggYW1vdW50PTMsIHJlcHM9MiwgdGFwcz01ICkge1xuICAgIGNvbnN0IGZ4ID0ge31cblxuICAgIGNvbnN0IF9fYW1vdW50ID0gRlgud3JhcFByb3BlcnR5KCBmeCwgJ2Ftb3VudCcsIGFtb3VudCApXG4gICAgZnguX193cmFwcGVkX18gPSBNUC5ibHVyMmQoIF9fYW1vdW50LCBfX2Ftb3VudCwgcmVwcywgdGFwcyApXG5cbiAgICByZXR1cm4gZnggXG4gIH0sXG5cbiAgQnJpZ2h0bmVzcyggX19hbW91bnQ9LjI1ICkge1xuICAgIGNvbnN0IGZ4ID0ge30sXG4gICAgICAgICAgYW1vdW50ID0gRlgud3JhcFByb3BlcnR5KCBmeCwgJ2Ftb3VudCcsIF9fYW1vdW50IClcblxuICAgIGZ4Ll9fd3JhcHBlZF9fID0gTVAuYnJpZ2h0bmVzcyggYW1vdW50IClcblxuICAgIHJldHVybiBmeFxuICB9LFxuXG4gIENvbnRyYXN0KCBfX2Ftb3VudD0uNSApIHtcbiAgICBjb25zdCBmeCA9IHt9LFxuICAgICAgICAgIGFtb3VudCA9IEZYLndyYXBQcm9wZXJ0eSggZngsICdhbW91bnQnLCBfX2Ftb3VudCApXG5cbiAgICBmeC5fX3dyYXBwZWRfXyA9IE1QLmNvbnRyYXN0KCBhbW91bnQgKVxuXG4gICAgcmV0dXJuIGZ4XG4gIH0sXG5cbiAgRWRnZSgpIHtcbiAgICBjb25zdCBmeCA9IHt9XG4gICAgZnguX193cmFwcGVkX18gPSBNUC5zb2JlbCgpXG5cbiAgICByZXR1cm4gZnggXG4gIH0sXG5cbiAgRm9jdXMoIF9fZGVwdGg9MCwgX19yYWRpdXM9LjAxICkge1xuICAgIGNvbnN0IGZ4ID0ge30sXG4gICAgICAgICAgZGVwdGggID0gRlgud3JhcFByb3BlcnR5KCBmeCwgJ2RlcHRoJywgIF9fZGVwdGgsIHYgPT4gMSAtIHYgKSxcbiAgICAgICAgICByYWRpdXMgPSBGWC53cmFwUHJvcGVydHkoIGZ4LCAncmFkaXVzJywgX19yYWRpdXMgKSBcblxuICAgIGZ4Ll9fd3JhcHBlZF9fID0gTVAuZG9mKCBkZXB0aCwgcmFkaXVzICkgXG5cbiAgICByZXR1cm4gZnhcbiAgfSxcblxuICBHbG93KCBfX2NvbnRyYXN0PTEuMiwgX19icmlnaHRuZXNzID0gLjE1LCBfX2JsdXI9MSwgX19hZGp1c3Q9LS41LCBsb29wcz01ICkge1xuICAgIGNvbnN0IGZ4ID0ge30sXG4gICAgICAgICAgY29udHJhc3QgICA9IEZYLndyYXBQcm9wZXJ0eSggZngsICdjb250cmFzdCcsIF9fY29udHJhc3QgKSxcbiAgICAgICAgICBicmlnaHRuZXNzID0gRlgud3JhcFByb3BlcnR5KCBmeCwgJ2JyaWdodG5lc3MnLCBfX2JyaWdodG5lc3MgKSxcbiAgICAgICAgICBibHVyICAgICAgID0gRlgud3JhcFByb3BlcnR5KCBmeCwgJ2JsdXInLCBfX2JsdXIgKSxcbiAgICAgICAgICBhZGp1c3QgICAgID0gRlgud3JhcFByb3BlcnR5KCBmeCwgJ2FkanVzdCcsIF9fYWRqdXN0IClcblxuICAgIGZ4Ll9fd3JhcHBlZF9fID0gWyAgXG4gICAgICBNUC5sb29wKFtcbiAgICAgICAgTVAuZ2F1c3MoTVAudmVjMihibHVyLCAwKSksXG4gICAgICAgIE1QLmdhdXNzKE1QLnZlYzIoMCwgYmx1cikpLFxuICAgICAgICBNUC5icmlnaHRuZXNzKCBicmlnaHRuZXNzICksXG4gICAgICAgIE1QLmNvbnRyYXN0KCBjb250cmFzdCksXG4gICAgICBdLCBsb29wcyApLFxuICAgICAgTVAuYnJpZ2h0bmVzcyggYWRqdXN0ICksXG4gICAgICBNUC5zZXRjb2xvciggTVAub3AoIE1QLmZjb2xvcigpLCBcIitcIiwgTVAuaW5wdXQoKSApIClcbiAgICBdXG5cbiAgICByZXR1cm4gZnhcbiAgfSxcblxuXG4gIEdvZHJheXMoIF9fZGVjYXk9MSwgX193ZWlnaHQ9LjAxLCBfX2RlbnNpdHk9MSwgX190aHJlc2hvbGQ9LjksIF9fbmV3Q29sb3I9Wy41LC4xNSwwLDFdICkge1xuICAgIGNvbnN0IGZ4ID0ge30sXG4gICAgICAgICAgZGVjYXkgICA9IEZYLndyYXBQcm9wZXJ0eSggZngsICdkZWNheScsICAgX19kZWNheSAgICksXG4gICAgICAgICAgd2VpZ2h0ICA9IEZYLndyYXBQcm9wZXJ0eSggZngsICd3ZWlnaHQnLCAgX193ZWlnaHQgICksXG4gICAgICAgICAgZGVuc2l0eSA9IEZYLndyYXBQcm9wZXJ0eSggZngsICdkZW5zaXR5JywgX19kZW5zaXR5ICksXG4gICAgICAgICAgdGhyZXNob2xkID0gRlgud3JhcFByb3BlcnR5KCBmeCwgJ3RocmVzaG9sZCcsIF9fdGhyZXNob2xkLCB2ID0+IDEgLSB2IClcblxuICAgIGNvbnN0IG5ld0NvbG9yID0gTVAubXV0KCBNUC5wdmVjNCggLi4uX19uZXdDb2xvciApIClcbiAgICBcbiAgICBsZXQgdmFsdWUgPSBfX25ld0NvbG9yIFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggZngsICdjb2xvcicsIHtcbiAgICAgIGdldCgpIHsgcmV0dXJuIHZhbHVlIH0sXG4gICAgICBzZXQodikge1xuICAgICAgICB2YWx1ZSA9IEFycmF5LmlzQXJyYXkodikgPyB2IDogW3Ysdix2LHZdXG4gICAgICAgIGZ4Ll9fd3JhcHBlZF9fLnNldE5ld0NvbG9yKCBNUC5wdmVjNCggLi4udmFsdWUgKSApXG4gICAgICB9XG4gICAgfSlcblxuXG4gICAgZnguX193cmFwcGVkX18gPSBNUC5nb2RyYXlzKHsgXG4gICAgICBkZWNheSwgd2VpZ2h0LCBkZW5zaXR5LFxuXG4gICAgICBjb252ZXJ0RGVwdGg6IHsgICAgICAgICAgICAgICAgIFxuICAgICAgICB0aHJlc2hvbGQsICAgICAgICAgICAgICAgICBcbiAgICAgICAgbmV3Q29sb3JcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgcmV0dXJuIGZ4XG4gIH0sXG5cbiAgSHVlKCBfX3NoaWZ0PS41LCBfX3RocmVzaG9sZCA9IC45OSApICB7XG4gICAgY29uc3QgZnggPSB7fSxcbiAgICAgICAgICBmcmFnID0gTVAuZmNvbG9yKCksIFxuICAgICAgICAgIGRlcHRoID0gTVAuY2hhbm5lbCgwKSxcbiAgICAgICAgICB0aHJlc2hvbGQgPSBGWC53cmFwUHJvcGVydHkoIGZ4LCAndGhyZXNob2xkJywgX190aHJlc2hvbGQsIHYgPT4gMSAtIHYgKSxcbiAgICAgICAgICBzaGlmdD0gRlgud3JhcFByb3BlcnR5KCBmeCwgJ3NoaWZ0JywgX19zaGlmdCApXG5cbiAgICBsZXQgY29udHJvbFxuICAgIGZ4Ll9fd3JhcHBlZF9fID0gTVAuaHN2MnJnYiggXG4gICAgICBNUC5jaGFuZ2Vjb21wKFxuICAgICAgICBNUC5yZ2IyaHN2KCBNUC5mY29sb3IoKSApLFxuICAgICAgICBNUC5jZmxvYXQoIE1QLnRhZyBgbGVuZ3RoKCR7ZGVwdGh9LnJnYikgPj0gJHt0aHJlc2hvbGR9ID8gJHtzaGlmdH0gOiAwLmAgICksXG4gICAgICAgIFwiclwiLCBcbiAgICAgICAgXCIrXCJcbiAgICAgIClcbiAgICApXG5cbiAgICByZXR1cm4gZnhcbiAgfSxcblxuICBJbnZlcnQoIF9fdGhyZXNob2xkID0gLjk5ICkgIHtcbiAgICBjb25zdCBmeCA9IHt9LFxuICAgICAgICAgIGZyYWcgPSBNUC5mY29sb3IoKSwgXG4gICAgICAgICAgZGVwdGggPSBNUC5jaGFubmVsKDApLFxuICAgICAgICAgIHRocmVzaG9sZCA9IEZYLndyYXBQcm9wZXJ0eSggZngsICd0aHJlc2hvbGQnLCBfX3RocmVzaG9sZCwgdiA9PiAxIC0gdiApXG5cbiAgICBmeC5fX3dyYXBwZWRfXyA9IE1QLnNldGNvbG9yKCBcbiAgICAgIE1QLmN2ZWM0KCBNUC50YWcgYGxlbmd0aCgke2RlcHRofS5yZ2IpID49ICR7dGhyZXNob2xkfSA/ICgxLiAtIHZlYzQoJHtmcmFnfS5yZ2IsIDAuKSkgOiAke2ZyYWd9YCAgKVxuICAgICkgXG5cbiAgICByZXR1cm4gZnhcbiAgfSxcblxuICBNb3Rpb25CbHVyKCBfX2Ftb3VudCA9IC43KSB7XG4gICAgY29uc3QgZnggPSB7fSxcbiAgICAgICAgICBhbW91bnQgPSBGWC53cmFwUHJvcGVydHkoIGZ4LCAnYW1vdW50JywgX19hbW91bnQsIHYgPT4gMS12IClcblxuICAgIGZ4Ll9fd3JhcHBlZF9fID0gTVAubW90aW9uYmx1ciggMSwgYW1vdW50ICkgXG5cbiAgICByZXR1cm4gZnhcbiAgfSxcblxuICBBbnRpYWxpYXMoIG11bHQ9MSApIHtcbiAgICByZXR1cm4geyBfX3dyYXBwZWQ6IE1QLmxvb3AoWyBNUC5meGFhKCkgXSwgbXVsdCApIH1cbiAgfSxcblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEZYXG4iLCJjb25zdCBnbHNsID0gcmVxdWlyZSggJ2dsc2xpZnknIClcbmNvbnN0IFNjZW5lTm9kZSA9IHJlcXVpcmUoICcuL3NjZW5lTm9kZS5qcycgKVxuY29uc3QgeyBwYXJhbV93cmFwLCBNYXRlcmlhbElEIH0gPSByZXF1aXJlKCAnLi91dGlscy5qcycgKVxuY29uc3QgeyBWYXIsIGZsb2F0X3Zhcl9nZW4sIHZlYzJfdmFyX2dlbiwgdmVjM192YXJfZ2VuLCB2ZWM0X3Zhcl9nZW4gfSA9IHJlcXVpcmUoICcuL3Zhci5qcycgKVxuXG5jb25zdCBnZXROb2lzZSA9IGZ1bmN0aW9uKCBTREYgKSB7XG5Ob2lzZSA9IGZ1bmN0aW9uKCBzdHJlbmd0aD0uMjUsIGJpYXM9MSwgdGltZU1vZD0xICkge1xuICBjb25zdCBvcCA9IE9iamVjdC5jcmVhdGUoIE5vaXNlLnByb3RvdHlwZSApXG4gIG9wLnR5cGUgPSAnc3RyaW5nJ1xuICBvcC5pc0dlbiA9IHRydWVcblxuICBjb25zdCBkZWZhdWx0VmFsdWVzID0gWy41LC41LC41XVxuXG4gIG9wLm1hdElkID0gTWF0ZXJpYWxJRC5hbGxvYygpXG5cbiAgY29uc3QgX19zdHJlbmd0aCA9IHBhcmFtX3dyYXAoIHN0cmVuZ3RoLCBmbG9hdF92YXJfZ2VuKCBzdHJlbmd0aCApIClcbiAgY29uc3QgX190aW1lTW9kICA9IHBhcmFtX3dyYXAoIHRpbWVNb2QsIGZsb2F0X3Zhcl9nZW4oIHRpbWVNb2QgKSApXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBvcCwgJ3N0cmVuZ3RoJywge1xuICAgIGdldCgpIHsgcmV0dXJuIF9fc3RyZW5ndGggfSxcbiAgICBzZXQodikge1xuICAgICBfX3N0cmVuZ3RoLnZhci5zZXQoIHYgKVxuICAgIH1cbiAgfSlcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBvcCwgJ3RpbWVNb2QnLCB7XG4gICAgZ2V0KCkgeyByZXR1cm4gX190aW1lTW9kIH0sXG4gICAgc2V0KHYpIHtcbiAgICAgX190aW1lTW9kLnZhci5zZXQoIHYgKVxuICAgIH1cbiAgfSlcbiAgY29uc3QgX19iaWFzICA9IHBhcmFtX3dyYXAoIGJpYXMsIGZsb2F0X3Zhcl9nZW4oIGJpYXMgKSApXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBvcCwgJ2JpYXMnLCB7XG4gICAgZ2V0KCkgeyByZXR1cm4gX19iaWFzfSxcbiAgICBzZXQodikge1xuICAgICBfX2JpYXMudmFyLnNldCggdiApXG4gICAgfVxuICB9KVxuICByZXR1cm4gb3Bcbn0gXG5cbk5vaXNlLnByb3RvdHlwZSA9IFNjZW5lTm9kZSgpXG5cbk5vaXNlLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKCBfX25hbWUgKSB7XG4gIGxldCBuYW1lID0gX19uYW1lID09PSB1bmRlZmluZWQgPyAncCcgOiBfX25hbWVcblxuICBjb25zdCBvdXQgPSBgKCR7dGhpcy5iaWFzLmVtaXQoKX0gKyBzbm9pc2UoIHZlYzQoIHAueHl6LCB0aW1lICogJHt0aGlzLnRpbWVNb2QuZW1pdCgpfSApKSAqICR7dGhpcy5zdHJlbmd0aC5lbWl0KCl9KWAgIFxuXG4gIGNvbnN0IG91dHB1dCA9IHtcbiAgICBvdXQsXG4gICAgcHJlZmFjZTonJ1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dFxufVxuTm9pc2UucHJvdG90eXBlLmdsc2wgPSBnbHNsKFtcIiNkZWZpbmUgR0xTTElGWSAxXFxuICAgIC8vXFxuLy8gRGVzY3JpcHRpb24gOiBBcnJheSBhbmQgdGV4dHVyZWxlc3MgR0xTTCAyRC8zRC80RCBzaW1wbGV4XFxuLy8gICAgICAgICAgICAgICBub2lzZSBmdW5jdGlvbnMuXFxuLy8gICAgICBBdXRob3IgOiBJYW4gTWNFd2FuLCBBc2hpbWEgQXJ0cy5cXG4vLyAgTWFpbnRhaW5lciA6IGlqbVxcbi8vICAgICBMYXN0bW9kIDogMjAxMTA4MjIgKGlqbSlcXG4vLyAgICAgTGljZW5zZSA6IENvcHlyaWdodCAoQykgMjAxMSBBc2hpbWEgQXJ0cy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cXG4vLyAgICAgICAgICAgICAgIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZS5cXG4vLyAgICAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9hc2hpbWEvd2ViZ2wtbm9pc2VcXG4vL1xcblxcbnZlYzQgbW9kMjg5KHZlYzQgeCkge1xcbiAgcmV0dXJuIHggLSBmbG9vcih4ICogKDEuMCAvIDI4OS4wKSkgKiAyODkuMDsgfVxcblxcbmZsb2F0IG1vZDI4OShmbG9hdCB4KSB7XFxuICByZXR1cm4geCAtIGZsb29yKHggKiAoMS4wIC8gMjg5LjApKSAqIDI4OS4wOyB9XFxuXFxudmVjNCBwZXJtdXRlKHZlYzQgeCkge1xcbiAgICAgcmV0dXJuIG1vZDI4OSgoKHgqMzQuMCkrMS4wKSp4KTtcXG59XFxuXFxuZmxvYXQgcGVybXV0ZShmbG9hdCB4KSB7XFxuICAgICByZXR1cm4gbW9kMjg5KCgoeCozNC4wKSsxLjApKngpO1xcbn1cXG5cXG52ZWM0IHRheWxvckludlNxcnQodmVjNCByKVxcbntcXG4gIHJldHVybiAxLjc5Mjg0MjkxNDAwMTU5IC0gMC44NTM3MzQ3MjA5NTMxNCAqIHI7XFxufVxcblxcbmZsb2F0IHRheWxvckludlNxcnQoZmxvYXQgcilcXG57XFxuICByZXR1cm4gMS43OTI4NDI5MTQwMDE1OSAtIDAuODUzNzM0NzIwOTUzMTQgKiByO1xcbn1cXG5cXG52ZWM0IGdyYWQ0KGZsb2F0IGosIHZlYzQgaXApXFxuICB7XFxuICBjb25zdCB2ZWM0IG9uZXMgPSB2ZWM0KDEuMCwgMS4wLCAxLjAsIC0xLjApO1xcbiAgdmVjNCBwLHM7XFxuXFxuICBwLnh5eiA9IGZsb29yKCBmcmFjdCAodmVjMyhqKSAqIGlwLnh5eikgKiA3LjApICogaXAueiAtIDEuMDtcXG4gIHAudyA9IDEuNSAtIGRvdChhYnMocC54eXopLCBvbmVzLnh5eik7XFxuICBzID0gdmVjNChsZXNzVGhhbihwLCB2ZWM0KDAuMCkpKTtcXG4gIHAueHl6ID0gcC54eXogKyAocy54eXoqMi4wIC0gMS4wKSAqIHMud3d3O1xcblxcbiAgcmV0dXJuIHA7XFxuICB9XFxuXFxuLy8gKHNxcnQoNSkgLSAxKS80ID0gRjQsIHVzZWQgb25jZSBiZWxvd1xcbiNkZWZpbmUgRjQgMC4zMDkwMTY5OTQzNzQ5NDc0NTFcXG5cXG5mbG9hdCBzbm9pc2UodmVjNCB2KVxcbiAge1xcbiAgY29uc3QgdmVjNCAgQyA9IHZlYzQoIDAuMTM4MTk2NjAxMTI1MDExLCAgLy8gKDUgLSBzcXJ0KDUpKS8yMCAgRzRcXG4gICAgICAgICAgICAgICAgICAgICAgICAwLjI3NjM5MzIwMjI1MDAyMSwgIC8vIDIgKiBHNFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAuNDE0NTg5ODAzMzc1MDMyLCAgLy8gMyAqIEc0XFxuICAgICAgICAgICAgICAgICAgICAgICAtMC40NDcyMTM1OTU0OTk5NTgpOyAvLyAtMSArIDQgKiBHNFxcblxcbi8vIEZpcnN0IGNvcm5lclxcbiAgdmVjNCBpICA9IGZsb29yKHYgKyBkb3QodiwgdmVjNChGNCkpICk7XFxuICB2ZWM0IHgwID0gdiAtICAgaSArIGRvdChpLCBDLnh4eHgpO1xcblxcbi8vIE90aGVyIGNvcm5lcnNcXG5cXG4vLyBSYW5rIHNvcnRpbmcgb3JpZ2luYWxseSBjb250cmlidXRlZCBieSBCaWxsIExpY2VhLUthbmUsIEFNRCAoZm9ybWVybHkgQVRJKVxcbiAgdmVjNCBpMDtcXG4gIHZlYzMgaXNYID0gc3RlcCggeDAueXp3LCB4MC54eHggKTtcXG4gIHZlYzMgaXNZWiA9IHN0ZXAoIHgwLnp3dywgeDAueXl6ICk7XFxuLy8gIGkwLnggPSBkb3QoIGlzWCwgdmVjMyggMS4wICkgKTtcXG4gIGkwLnggPSBpc1gueCArIGlzWC55ICsgaXNYLno7XFxuICBpMC55encgPSAxLjAgLSBpc1g7XFxuLy8gIGkwLnkgKz0gZG90KCBpc1laLnh5LCB2ZWMyKCAxLjAgKSApO1xcbiAgaTAueSArPSBpc1laLnggKyBpc1laLnk7XFxuICBpMC56dyArPSAxLjAgLSBpc1laLnh5O1xcbiAgaTAueiArPSBpc1laLno7XFxuICBpMC53ICs9IDEuMCAtIGlzWVouejtcXG5cXG4gIC8vIGkwIG5vdyBjb250YWlucyB0aGUgdW5pcXVlIHZhbHVlcyAwLDEsMiwzIGluIGVhY2ggY2hhbm5lbFxcbiAgdmVjNCBpMyA9IGNsYW1wKCBpMCwgMC4wLCAxLjAgKTtcXG4gIHZlYzQgaTIgPSBjbGFtcCggaTAtMS4wLCAwLjAsIDEuMCApO1xcbiAgdmVjNCBpMSA9IGNsYW1wKCBpMC0yLjAsIDAuMCwgMS4wICk7XFxuXFxuICAvLyAgeDAgPSB4MCAtIDAuMCArIDAuMCAqIEMueHh4eFxcbiAgLy8gIHgxID0geDAgLSBpMSAgKyAxLjAgKiBDLnh4eHhcXG4gIC8vICB4MiA9IHgwIC0gaTIgICsgMi4wICogQy54eHh4XFxuICAvLyAgeDMgPSB4MCAtIGkzICArIDMuMCAqIEMueHh4eFxcbiAgLy8gIHg0ID0geDAgLSAxLjAgKyA0LjAgKiBDLnh4eHhcXG4gIHZlYzQgeDEgPSB4MCAtIGkxICsgQy54eHh4O1xcbiAgdmVjNCB4MiA9IHgwIC0gaTIgKyBDLnl5eXk7XFxuICB2ZWM0IHgzID0geDAgLSBpMyArIEMuenp6ejtcXG4gIHZlYzQgeDQgPSB4MCArIEMud3d3dztcXG5cXG4vLyBQZXJtdXRhdGlvbnNcXG4gIGkgPSBtb2QyODkoaSk7XFxuICBmbG9hdCBqMCA9IHBlcm11dGUoIHBlcm11dGUoIHBlcm11dGUoIHBlcm11dGUoaS53KSArIGkueikgKyBpLnkpICsgaS54KTtcXG4gIHZlYzQgajEgPSBwZXJtdXRlKCBwZXJtdXRlKCBwZXJtdXRlKCBwZXJtdXRlIChcXG4gICAgICAgICAgICAgaS53ICsgdmVjNChpMS53LCBpMi53LCBpMy53LCAxLjAgKSlcXG4gICAgICAgICAgICsgaS56ICsgdmVjNChpMS56LCBpMi56LCBpMy56LCAxLjAgKSlcXG4gICAgICAgICAgICsgaS55ICsgdmVjNChpMS55LCBpMi55LCBpMy55LCAxLjAgKSlcXG4gICAgICAgICAgICsgaS54ICsgdmVjNChpMS54LCBpMi54LCBpMy54LCAxLjAgKSk7XFxuXFxuLy8gR3JhZGllbnRzOiA3eDd4NiBwb2ludHMgb3ZlciBhIGN1YmUsIG1hcHBlZCBvbnRvIGEgNC1jcm9zcyBwb2x5dG9wZVxcbi8vIDcqNyo2ID0gMjk0LCB3aGljaCBpcyBjbG9zZSB0byB0aGUgcmluZyBzaXplIDE3KjE3ID0gMjg5LlxcbiAgdmVjNCBpcCA9IHZlYzQoMS4wLzI5NC4wLCAxLjAvNDkuMCwgMS4wLzcuMCwgMC4wKSA7XFxuXFxuICB2ZWM0IHAwID0gZ3JhZDQoajAsICAgaXApO1xcbiAgdmVjNCBwMSA9IGdyYWQ0KGoxLngsIGlwKTtcXG4gIHZlYzQgcDIgPSBncmFkNChqMS55LCBpcCk7XFxuICB2ZWM0IHAzID0gZ3JhZDQoajEueiwgaXApO1xcbiAgdmVjNCBwNCA9IGdyYWQ0KGoxLncsIGlwKTtcXG5cXG4vLyBOb3JtYWxpc2UgZ3JhZGllbnRzXFxuICB2ZWM0IG5vcm0gPSB0YXlsb3JJbnZTcXJ0KHZlYzQoZG90KHAwLHAwKSwgZG90KHAxLHAxKSwgZG90KHAyLCBwMiksIGRvdChwMyxwMykpKTtcXG4gIHAwICo9IG5vcm0ueDtcXG4gIHAxICo9IG5vcm0ueTtcXG4gIHAyICo9IG5vcm0uejtcXG4gIHAzICo9IG5vcm0udztcXG4gIHA0ICo9IHRheWxvckludlNxcnQoZG90KHA0LHA0KSk7XFxuXFxuLy8gTWl4IGNvbnRyaWJ1dGlvbnMgZnJvbSB0aGUgZml2ZSBjb3JuZXJzXFxuICB2ZWMzIG0wID0gbWF4KDAuNiAtIHZlYzMoZG90KHgwLHgwKSwgZG90KHgxLHgxKSwgZG90KHgyLHgyKSksIDAuMCk7XFxuICB2ZWMyIG0xID0gbWF4KDAuNiAtIHZlYzIoZG90KHgzLHgzKSwgZG90KHg0LHg0KSAgICAgICAgICAgICksIDAuMCk7XFxuICBtMCA9IG0wICogbTA7XFxuICBtMSA9IG0xICogbTE7XFxuICByZXR1cm4gNDkuMCAqICggZG90KG0wKm0wLCB2ZWMzKCBkb3QoIHAwLCB4MCApLCBkb3QoIHAxLCB4MSApLCBkb3QoIHAyLCB4MiApKSlcXG4gICAgICAgICAgICAgICArIGRvdChtMSptMSwgdmVjMiggZG90KCBwMywgeDMgKSwgZG90KCBwNCwgeDQgKSApICkgKSA7XFxuXFxuICB9XFxuXFxuXCJdKVxuXG5Ob2lzZS5wcm90b3R5cGUuZW1pdF9kZWNsID0gZnVuY3Rpb24gKCkge1xuICBsZXQgc3RyID0gdGhpcy5zdHJlbmd0aC5lbWl0X2RlY2woKSArIHRoaXMudGltZU1vZC5lbWl0X2RlY2woKSArIHRoaXMuYmlhcy5lbWl0X2RlY2woKVxuXG4gIGlmKCBTREYubWVtby5ub2lzZSA9PT0gdW5kZWZpbmVkICkge1xuICAgIHN0ciA9IE5vaXNlLnByb3RvdHlwZS5nbHNsICsgc3RyXG4gICAgU0RGLm1lbW8ubm9pc2UgPSB0cnVlXG4gIH1cblxuICByZXR1cm4gc3RyXG59O1xuXG5Ob2lzZS5wcm90b3R5cGUudXBkYXRlX2xvY2F0aW9uID0gZnVuY3Rpb24oZ2wsIHByb2dyYW0pIHtcbiAgdGhpcy5zdHJlbmd0aC51cGRhdGVfbG9jYXRpb24oIGdsLCBwcm9ncmFtIClcbiAgdGhpcy50aW1lTW9kLnVwZGF0ZV9sb2NhdGlvbiggZ2wsIHByb2dyYW0gKVxuICB0aGlzLmJpYXMudXBkYXRlX2xvY2F0aW9uKCBnbCwgcHJvZ3JhbSApXG59XG5cbk5vaXNlLnByb3RvdHlwZS51cGxvYWRfZGF0YSA9IGZ1bmN0aW9uKGdsKSB7XG4gIHRoaXMuc3RyZW5ndGgudXBsb2FkX2RhdGEoIGdsIClcbiAgdGhpcy50aW1lTW9kLnVwbG9hZF9kYXRhKCBnbCApXG4gIHRoaXMuYmlhcy51cGxvYWRfZGF0YSggZ2wgKVxufVxuXG5yZXR1cm4gTm9pc2VcblxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldE5vaXNlIFxuIiwiY29uc3QgZ2xzbCA9IHJlcXVpcmUoICdnbHNsaWZ5JyApXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBCb3g6IHtcbiAgICBwYXJhbWV0ZXJzOltcbiAgICAgIHsgbmFtZTonc2l6ZScsIHR5cGU6J3ZlYzMnLCBkZWZhdWx0OlsxLDEsMV0sIG1pbjouMDAxLCBtYXg6NSB9LFxuICAgIF0sXG5cbiAgICBwcmltaXRpdmVTdHJpbmcoIHBOYW1lICkgeyBcblx0ICAgIHJldHVybiBgc2RCb3goICR7cE5hbWV9LCAke3RoaXMuc2l6ZS5lbWl0KCl9IClgO1xuICAgIH0sXG5cbiAgICBnbHNsaWZ5Omdsc2woW1wiI2RlZmluZSBHTFNMSUZZIDFcXG4gICAgZmxvYXQgc2RCb3goIHZlYzMgcCwgdmVjMyBiIClcXG57XFxuICB2ZWMzIGQgPSBhYnMocCkgLSBiO1xcbiAgcmV0dXJuIG1pbihtYXgoZC54LG1heChkLnksZC56KSksMC4wKSArXFxuICAgICAgICAgbGVuZ3RoKG1heChkLDAuMCkpO1xcbn1cXG5cXG5cIl0pXG4gIH0sIFxuXG4gIC8vIFhYWCB3ZSBzaG91bGQgbm9ybWFsaXplIGRpbWVuc2lvbnMgaW4gdGhlIHNoYWRlci4uLiBcbiAgQ29uZToge1xuICAgIHBhcmFtZXRlcnM6W1xuICAgICAgeyBuYW1lOidkaW1lbnNpb25zJywgdHlwZTondmVjMycsIGRlZmF1bHQ6Wy44LC42LC4zXSwgbWluOi4wMDEsIG1heDo1IH0sXG4gICAgXSxcblxuICAgIHByaW1pdGl2ZVN0cmluZyggcE5hbWUgKSB7IFxuICAgICAgcmV0dXJuIGBzZENvbmUoICR7cE5hbWV9LCAke3RoaXMuZGltZW5zaW9ucy5lbWl0KCl9IClgXG4gICAgfSxcbiAgICBnbHNsaWZ5Omdsc2woW1wiI2RlZmluZSBHTFNMSUZZIDFcXG4gICAgZmxvYXQgc2RDb25lKCBpbiB2ZWMzIHAsIGluIHZlYzMgYyApXFxue1xcbiAgICB2ZWMyIHEgPSB2ZWMyKCBsZW5ndGgocC54eiksIHAueSApO1xcbiAgICBmbG9hdCBkMSA9IC1wLnktYy56O1xcbiAgICBmbG9hdCBkMiA9IG1heCggZG90KHEsYy54eSksIHAueSk7XFxuICAgIHJldHVybiBsZW5ndGgobWF4KHZlYzIoZDEsZDIpLDAuMCkpICsgbWluKG1heChkMSxkMiksIDAuKTtcXG59XFxuXFxuXCJdKVxuICB9LCBcblxuXHRDeWxpbmRlcjoge1xuICAgIHBhcmFtZXRlcnM6W1xuICAgICAgeyBuYW1lOidkaW1lbnNpb25zJywgdHlwZTondmVjMicsIGRlZmF1bHQ6Wy44LC42XSwgbWluOi4wMDEsIG1heDo1IH0sXG4gICAgXSxcblxuICAgIHByaW1pdGl2ZVN0cmluZyggcE5hbWUgKSB7IFxuICAgICAgcmV0dXJuIGBzZENhcHBlZEN5bGluZGVyKCAke3BOYW1lfSwgJHt0aGlzLmRpbWVuc2lvbnMuZW1pdCgpfSApYFxuICAgIH0sXG5cbiAgICBnbHNsaWZ5OmAgICAgZmxvYXQgc2RDYXBwZWRDeWxpbmRlciggdmVjMyBwLCB2ZWMyIGggKSB7XG4gICAgdmVjMiBkID0gYWJzKHZlYzIobGVuZ3RoKHAueHopLHAueSkpIC0gaDtcbiAgICByZXR1cm4gbWluKG1heChkLngsZC55KSwwLjApICsgbGVuZ3RoKG1heChkLDAuMCkpO1xuICB9YFxuICB9LCBcblxuICBDYXBzdWxlOiB7XHRcbiAgICBwYXJhbWV0ZXJzOltcbiAgICAgIHsgbmFtZTonc3RhcnQnLCB0eXBlOid2ZWMzJywgZGVmYXVsdDpbMCwwLDBdLCBtaW46MCwgbWF4Oi41IH0sXG4gICAgICB7IG5hbWU6J2VuZCcsIHR5cGU6J3ZlYzMnLCBkZWZhdWx0OlsuOCwxLDBdLCBtaW46LjUsIG1heDoxIH0sXG4gICAgICB7IG5hbWU6J3JhZGl1cycsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDouNSwgbWluOi4wMDEsIG1heDo1IH0sXG4gICAgXSxcblxuICAgIHByaW1pdGl2ZVN0cmluZyggcE5hbWUgKSB7IFxuICAgICAgcmV0dXJuIGBzZENhcHN1bGUoICR7cE5hbWV9LCAke3RoaXMuc3RhcnQuZW1pdCgpfSwgJHt0aGlzLmVuZC5lbWl0KCl9LCAke3RoaXMucmFkaXVzLmVtaXQoKX0gKWBcbiAgICB9LFxuICAgIGdsc2xpZnk6Z2xzbChbXCIjZGVmaW5lIEdMU0xJRlkgMVxcbiAgICAgIGZsb2F0IHNkQ2Fwc3VsZSggdmVjMyBwLCB2ZWMzIGEsIHZlYzMgYiwgZmxvYXQgciApXFxue1xcbiAgICB2ZWMzIHBhID0gcCAtIGEsIGJhID0gYiAtIGE7XFxuICAgIGZsb2F0IGggPSBjbGFtcCggZG90KHBhLGJhKS9kb3QoYmEsYmEpLCAwLjAsIDEuMCApO1xcbiAgICByZXR1cm4gbGVuZ3RoKCBwYSAtIGJhKmggKSAtIHI7XFxufVxcblxcblwiXSlcblxuICB9LFxuXG4gIC8vIFhYWCBObyBjeWxpbmRlciBkZXNjcmlwdGlvblxuICAvL2AgI3ByYWdtYSBnbHNsaWZ5OiBzZEN5bGluZGVyXHQ9IHJlcXVpcmUoJ2dsc2wtc2RmLXByaW1pdGl2ZXMvc2RDeWxpbmRlcicpYFxuIFx0SGV4UHJpc206IHtcbiAgICBwYXJhbWV0ZXJzOltcbiAgICAgIHsgbmFtZTonZGltZW5zaW9ucycsIHR5cGU6J3ZlYzInLCBkZWZhdWx0OlsuOCwuNl0sIG1pbjouMDAxLCBtYXg6NSB9LFxuICAgIF0sXG5cbiAgICBwcmltaXRpdmVTdHJpbmcoIHBOYW1lICkgeyBcbiAgICAgIHJldHVybiBgc2RIZXhQcmlzbSggJHtwTmFtZX0sICR7dGhpcy5kaW1lbnNpb25zLmVtaXQoKX0gKWBcbiAgICB9LFxuICAgIGdsc2xpZnk6Z2xzbChbXCIjZGVmaW5lIEdMU0xJRlkgMVxcbiAgICAgIGZsb2F0IHNkSGV4UHJpc20oIHZlYzMgcCwgdmVjMiBoIClcXG57XFxuICAgIHZlYzMgcSA9IGFicyhwKTtcXG4gICAgcmV0dXJuIG1heChxLnotaC55LG1heCgocS54KjAuODY2MDI1K3EueSowLjUpLHEueSktaC54KTtcXG59XFxuXFxuXCJdKVxuICB9LFxuXG4gIEp1bGlhOiB7XG4gICAgcGFyYW1ldGVyczpbXG4gICAgICB7IG5hbWU6J2ZvbGQnLCB0eXBlOidmbG9hdCcsIGRlZmF1bHQ6MCwgbWluOjAsIG1heDoxMCB9LFxuICAgIF0sXG5cbiAgICBwcmltaXRpdmVTdHJpbmcoIHBOYW1lICkgeyBcbiAgICAgIHJldHVybiBganVsaWEoICR7cE5hbWV9LCAke3RoaXMuZm9sZC5lbWl0KCl9IClgXG4gICAgfSxcblxuICAgIC8vIGh0dHBzOi8vd3d3LnNoYWRlcnRveS5jb20vdmlldy9Nc2ZHUnJcbiAgICBnbHNsaWZ5Omdsc2woW1wiI2RlZmluZSBHTFNMSUZZIDFcXG4gIHZlYzQgcXNxciggaW4gdmVjNCBhICkge1xcbiAgICByZXR1cm4gdmVjNCggYS54KmEueCAtIGEueSphLnkgLSBhLnoqYS56IC0gYS53KmEudyxcXG4gICAgICAgICAgICAgICAgIDIuMCphLngqYS55LFxcbiAgICAgICAgICAgICAgICAgMi4wKmEueCphLnosXFxuICAgICAgICAgICAgICAgICAyLjAqYS54KmEudyApO1xcbiAgfVxcblxcbiAgZmxvYXQganVsaWEoIGluIHZlYzMgcCwgZmxvYXQgYXRpbWUgKXtcXG4gICAgdmVjNCBjID0gMC40NSpjb3MoIHZlYzQoMC41LDMuOSwxLjQsMS4xKSArIGF0aW1lICogdmVjNCgxLjIsMS43LDEuMywyLjUpICkgLSB2ZWM0KDAuMywwLjAsMC4wLDAuMCk7XFxuICAgIHZlYzQgeiA9IHZlYzQocCwwLik7XFxuICAgIGZsb2F0IG1kMiA9IDEuMDtcXG4gICAgZmxvYXQgbXoyID0gZG90KHoseik7XFxuXFxuICAgIGZvciggaW50IGk9MDsgaTwxMTsgaSsrICl7XFxuICAgICAgbWQyICo9IDQuMCptejI7ICAgXFxuICAgICAgLy8gZHogLT4gMsK3esK3ZHosIG1lYW5pbmcgfGR6fCAtPiAywrd8enzCt3xkenwgKGNhbiB0YWtlIHRoZSA0IG91dCBvZiB0aGUgbG9vcCBhbmQgZG8gYW4gZXhwMigpIGFmdGVyd2FyZHMpXFxuICAgICAgeiA9IHFzcXIoeikgKyBjOyAgLy8geiAgLT4gel4yICsgY1xcblxcbiAgICAgIG16MiA9IGRvdCh6LHopO1xcbiAgICAgIGlmKG16Mj40LjApIGJyZWFrO1xcbiAgICB9XFxuICAgIFxcbiAgICByZXR1cm4gMC4yNSpzcXJ0KG16Mi9tZDIpKmxvZyhtejIpOyAgLy8gZCA9IDAuNcK3fHp8wrdsb2d8enwgLyB8ZHp8XFxuICB9XCIsXCJcIl0pLFxuICB9LFxuICBLSUZTOiB7XG4gICAgcGFyYW1ldGVyczpbXG4gICAgICB7IG5hbWU6J2NvdW50JywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjggfSxcbiAgICAgIHsgbmFtZTonZm9sZCcsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDowIH0sXG4gICAgICB7IG5hbWU6J3JhZGl1cycsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDouMDEgfSxcbiAgICAgIHsgbmFtZTondGhyZXNob2xkJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0Oi4wMDQgfSxcbiAgICAgIHsgbmFtZTonc2NhbGUnLCB0eXBlOidmbG9hdCcsIGRlZmF1bHQ6MiB9LFxuICAgIF0sXG5cbiAgICBwcmltaXRpdmVTdHJpbmcoIHBOYW1lICkgeyBcbiAgICAgIHJldHVybiBga2lmcyggJHtwTmFtZX0sICR7dGhpcy5jb3VudC5lbWl0KCl9LCAke3RoaXMuZm9sZC5lbWl0KCl9LCAke3RoaXMucmFkaXVzLmVtaXQoKX0sICR7dGhpcy50aHJlc2hvbGQuZW1pdCgpfSwgJHt0aGlzLnNjYWxlLmVtaXQoKX0gKWBcbiAgICB9LFxuXG4gICAgLy8gYWRhcHRlZCBmcm9tIGh0dHA6Ly9yb3kucmVkL2ZvbGRpbmctdGhlLWtvY2gtc25vd2ZsYWtlLS5odG1sXG4gICAgZ2xzbGlmeTpnbHNsKFtcIiNkZWZpbmUgR0xTTElGWSAxXFxuICAgICAgZmxvYXQgYm94KCB2ZWMzIHAsIHZlYzMgYiApe1xcbiAgICAgIHZlYzMgZCA9IGFicyhwKSAtIGI7XFxuICAgICAgcmV0dXJuIG1pbihtYXgoZC54LG1heChkLnksZC56KSksMC4wKSArXFxuICAgICAgICAgICAgIGxlbmd0aChtYXgoZCwwLjApKTtcXG4gICAgfVxcbiAgICB2ZWMyIGZvbGQodmVjMiBwLCBmbG9hdCBhbmcpeyAgICBcXG4gICAgICAgIHZlYzIgbj12ZWMyKGNvcygtYW5nKSxzaW4oLWFuZykpO1xcbiAgICAgICAgcC09Mi4qbWluKDAuLGRvdChwLG4pKSpuO1xcbiAgICAgICAgcmV0dXJuIHA7XFxuICAgIH1cXG4gICAgI2RlZmluZSBLUEkgMy4xNDE1OVxcbiAgICB2ZWMzIHRyaV9mb2xkKHZlYzMgcHQsIGZsb2F0IGZvbGRhbXQpIHtcXG4gICAgICAgIHB0Lnh5ID0gZm9sZChwdC54eSxLUEkvMy4gKyBmb2xkYW10ICk7XFxuICAgICAgICBwdC54eSA9IGZvbGQocHQueHksLUtQSS8zLiArIGZvbGRhbXQgKTtcXG4gICAgICAgIHB0Lnl6ID0gZm9sZChwdC55eixLUEkvNi4rLjcgKyBmb2xkYW10ICk7XFxuICAgICAgICBwdC55eiA9IGZvbGQocHQueXosLUtQSS82LiArIGZvbGRhbXQgKTtcXG4gICAgICAgIHJldHVybiBwdDtcXG4gICAgfVxcbiAgICB2ZWMzIHRyaV9jdXJ2ZSh2ZWMzIHB0LCBmbG9hdCBpdGVyLCBmbG9hdCBmb2xkLCBmbG9hdCBzY2FsZSApIHtcXG4gICAgICAgIGludCBjb3VudCA9IGludChpdGVyKTtcXG4gICAgICAgIGZvcihpbnQgaT0wO2k8Y291bnQ7aSsrKXtcXG4gICAgICAgICAgICBwdCo9c2NhbGU7XFxuICAgICAgICAgICAgcHQueC09Mi42O1xcbiAgICAgICAgICAgIHB0PXRyaV9mb2xkKHB0LGZvbGQpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHB0O1xcbiAgICB9XFxuICAgIGZsb2F0IGtpZnMoaW4gdmVjMyBwLCBmbG9hdCBhLCBmbG9hdCBmb2xkLCBmbG9hdCByYWRpdXMsIGZsb2F0IHRocmVzaCwgZmxvYXQgc2NhbGUgKXtcXG4gICAgICAgIHAueCs9MS41O1xcbiAgICAgICAgcD10cmlfY3VydmUocCxhLGZvbGQsc2NhbGUpO1xcbiAgICAgICAgLy8gdW5jb21tZW50IGJlbG93IGxpbmUgdG8gdXNlIHNwaGVyZXMgaW5zdGVhZCBvZiBib3hlc1xcbiAgICAgICAgcmV0dXJuIChsZW5ndGgoIHAqdGhyZXNoICkgLSByYWRpdXMgKTtcXG4gICAgICAgIC8vcmV0dXJuIGJveCggcCp0aHJlc2gsIHZlYzMocmFkaXVzKSApO1xcbiAgICB9XFxuXCIsXCJcIl0pLFxuICB9LFxuXG4gIE1hbmRhbGF5OiB7XG4gICAgcGFyYW1ldGVyczpbXG4gICAgICB7IG5hbWU6J3NpemUnLCB0eXBlOidmbG9hdCcsIGRlZmF1bHQ6NSwgbWluOjEsIG1heDoxMCB9LFxuICAgICAgeyBuYW1lOidtaW5yYWQnLCB0eXBlOidmbG9hdCcsIGRlZmF1bHQ6MS8zLCBtaW46MCwgbWF4OjEgfSwgICAgXG4gICAgICB7IG5hbWU6J2l0ZXJhdGlvbnMnLCB0eXBlOidmbG9hdCcsIGRlZmF1bHQ6NSwgbWluOjEsIG1heDoxMCwgc3RlcDoxIH0sICAgIFxuICAgIF0sXG4gICAgZ2xzbGlmeTpgICAgICAgICAgICAgICAgICBcbiAgZmxvYXQgc3IgPSA0LjA7XG4gIHZlYzMgZm8gPXZlYzMgKDAuNywuOTUyOCwuOSk7XG4gIHZlYzMgZ2ggPSB2ZWMzICguOCwuNywwLjU2MzgpO1xuICB2ZWMzIGd3ID0gdmVjMyAoLjMsIDAuNSAsLjIpO1xuICB2ZWM0IFggPSB2ZWM0KCAuMSwwLjUsMC4xLC4zKTtcbiAgdmVjNCBZID0gdmVjNCguMSwgMC44LCAuMSwgLjEpO1xuICB2ZWM0IFogPSB2ZWM0KC4yLDAuMiwuMiwuNDU5MDIpO1xuICB2ZWM0IFIgPSB2ZWM0KDAuMTksLjEsLjEsLjIpO1xuICB2ZWM0IG9yYml0VHJhcCA9IHZlYzQoNDAwMDAuMCk7XG4gIGZsb2F0IERCRm9sZCggdmVjMyBwLCBmbG9hdCBmbywgZmxvYXQgZywgZmxvYXQgdyApe1xuICAgICAgaWYocC56PnAueSkgcC55ej1wLnp5O1xuICAgICAgZmxvYXQgdng9cC54LTIuKmZvO1xuICAgICAgZmxvYXQgdnk9cC55LTQuKmZvO1xuICAgICAgZmxvYXQgdj1tYXgoYWJzKHZ4K2ZvKS1mbyx2eSk7XG4gICAgICBmbG9hdCB2MT1tYXgodngtZyxwLnktdyk7XG4gICAgICB2PW1pbih2LHYxKTtcbiAgICAgIHYxPW1heCh2MSwtYWJzKHAueCkpO1xuICAgICAgcmV0dXJuIG1pbih2LHAueCk7XG4gIH1cbiAgIFxuICB2ZWMzIERCRm9sZFBhcmFsbGVsKHZlYzMgcCwgdmVjMyBmbywgdmVjMyBnLCB2ZWMzIHcpe1xuICAgIHZlYzMgcDE9cDtcbiAgICBwLng9REJGb2xkKHAxLGZvLngsZy54LHcueCk7XG4gICAgcC55PURCRm9sZChwMS55engsZm8ueSxnLnksdy55KTtcbiAgICBwLno9REJGb2xkKHAxLnp4eSxmby56LGcueix3LnopO1xuICAgIHJldHVybiBwO1xuICB9XG5cbiAgdmVjMyBEQkZvbGRTZXJpYWwodmVjMyBwLCB2ZWMzIGZvLCB2ZWMzIGcsdmVjMyB3KXtcbiAgICBwLng9REJGb2xkKHAsZm8ueCxnLngsdy54KTtcbiAgICBwLnk9REJGb2xkKHAueXp4LGZvLnksZy55LHcueSk7XG4gICAgcC56PURCRm9sZChwLnp4eSxmby56LGcueix3LnopO1xuICAgIHJldHVybiBwO1xuICB9XG4gIGZsb2F0IHNpbmVTcG9uZ2UodmVjMyBwLCBmbG9hdCBzY2FsZSwgZmxvYXQgbWlucmFkLCBmbG9hdCBpdGVyYXRpb25zICkge1xuICAgIHZlYzQgSkM9dmVjNChwLDEuKTtcbiAgICBmbG9hdCByMj1kb3QocCxwKTtcbiAgICBmbG9hdCBkZCA9IDEuO1xuICAgIGZvcihpbnQgaSA9IDA7IGk8aW50KGl0ZXJhdGlvbnMpOyBpKyspe1xuICAgICAgcCA9IHAgLSBjbGFtcChwLnh5eiwgLTEuMCwgMS4wKSAqIDIuMDsgIC8vIG1hbmRlbGJveCdzIGJveCBmb2xkXG4gICBcbiAgICAgIHZlYzMgc2lnbnM9c2lnbihwKTsvL1NhdmUgXHR0aGUgb3JpZ2luYWwgc2lnbnNcbiAgICAgIHA9YWJzKHApO1xuICAgICAgcD1EQkZvbGRQYXJhbGxlbChwLGZvLGdoLGd3KTtcbiAgICAgIFxuICAgICAgcCo9c2lnbnM7Ly9yZXNvcmUgc2lnbnM6IHRoaXMgd2F5IHRoZSBtYW5kZWxicm90IHNldCB3b24ndCBleHRlbmQgaW4gbmVnYXRpdmUgZGlyZWN0aW9uc1xuICAgICAgXG5cbiAgICAgIHIyPWRvdChwLHApO1xuICAgICAgZmxvYXQgIHQgPSBjbGFtcCgxLi9yMiwgMS4sIDEuL21pbnJhZCk7XG4gICAgICBwKj10OyBkZCo9dDtcbiAgICAgICBcblxuICAgICAgcD1wKnNjYWxlK0pDLnh5ejsgZGQ9ZGQqc2NhbGUrSkMudztcbiAgICAgIHA9dmVjMygxLjAsMS4wLC45MikqcDtcbiAgIFxuICAgICAgcjI9ZG90KHAscCk7XG4gICAgICBvcmJpdFRyYXAgPSBtaW4ob3JiaXRUcmFwLCBhYnModmVjNChwLngscC55LHAueixyMikpKTtcdFxuICAgIH1cbiAgICBkZD1hYnMoZGQpO1xuICAgICAgI2lmIDBcbiAgICAgICAgcmV0dXJuIChzcXJ0KHIyKS1zcikvZGQ7Ly9ib3VuZGluZyB2b2x1bWUgaXMgYSBzcGhlcmVcbiAgICAgICNlbHNlXG4gICAgICAgIHA9YWJzKHApOyByZXR1cm4gKG1heChwLngsbWF4KHAueSxwLnopKS1zcikvZGQ7Ly9ib3VuZGluZyB2b2x1bWUgaXMgYSBjdWJlXG4gICAgICAjZW5kaWZcbiAgICB9XG4gICAgYCxcbiAgIFxuICAgIHByaW1pdGl2ZVN0cmluZyggcE5hbWUgKSB7IFxuICAgICAgcmV0dXJuIGBzaW5lU3BvbmdlKCAke3BOYW1lfSwgJHt0aGlzLnNpemUuZW1pdCgpfSwgJHt0aGlzLm1pbnJhZC5lbWl0KCl9LCAke3RoaXMuaXRlcmF0aW9ucy5lbWl0KCl9IClgXG4gICAgfVxuICB9LCAgXG4gIE1hbmRlbGJ1bGI6IHtcbiAgICBwYXJhbWV0ZXJzOltcbiAgICAgIHsgbmFtZTonZm9sZCcsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDo4LCBtaW46MSwgbWF4OjE1IH0sXG4gICAgICB7IG5hbWU6J2l0ZXJhdGlvbnMnLCB0eXBlOidmbG9hdCcsIGRlZmF1bHQ6NCwgbWluOjEsIG1heDo2LCBzdGVwOjEgfSwgICAgXG4gICAgXSxcblxuICAgIHByaW1pdGl2ZVN0cmluZyggcE5hbWUgKSB7IFxuICAgICAgcmV0dXJuIGBtYW5kZWxidWxiKCAke3BOYW1lfSwgJHt0aGlzLmZvbGQuZW1pdCgpfSwgJHt0aGlzLml0ZXJhdGlvbnMuZW1pdCgpfSApYFxuICAgIH0sXG5cbiAgICAvLyBhZGFwdGVkIGZyb206IGh0dHBzOi8vd3d3LnNoYWRlcnRveS5jb20vdmlldy9sdGZTV25cbiAgICBnbHNsaWZ5Omdsc2woW1wiI2RlZmluZSBHTFNMSUZZIDFcXG4gICAgICBmbG9hdCBtYW5kZWxidWxiKCBpbiB2ZWMzIHAsIGluIGZsb2F0IGFhLCBmbG9hdCBpdGVyYXRpb25zICl7XFxuICAgICAgICB2ZWMzIHcgPSBwO1xcbiAgICAgICAgZmxvYXQgbSA9IGRvdCh3LHcpO1xcblxcbiAgICAgICAgdmVjNCB0cmFwID0gdmVjNChhYnModyksbSk7XFxuICAgICAgICBmbG9hdCBkeiA9IDEuMDtcXG4gICAgICAgICAgICAgICAgXFxuICAgICAgICBmb3IoIGludCBpPTA7IGk8aW50KGl0ZXJhdGlvbnMpOyBpKysgKSB7XFxuICAgICAgICAgIGR6ID0gYWEqcG93KHNxcnQobSksYWEgLSAxLikqZHogKyAxLjA7XFxuXFxuICAgICAgICAgIGZsb2F0IHIgPSBsZW5ndGgodyk7XFxuICAgICAgICAgIGZsb2F0IGIgPSBhYSphY29zKCB3LnkgL3IpO1xcbiAgICAgICAgICBmbG9hdCBhID0gYWEqYXRhbiggdy54LCB3LnogKTtcXG4gICAgICAgICAgdyA9IHAgKyBwb3cocixhYSkgKiB2ZWMzKCBzaW4oYikqc2luKGEpLCBjb3MoYiksIHNpbihiKSpjb3MoYSkgKTtcXG5cXG4gICAgICAgICAgdHJhcCA9IG1pbiggdHJhcCwgdmVjNChhYnModyksbSkgKTtcXG5cXG4gICAgICAgICAgbSA9IGRvdCh3LHcpO1xcbiAgICAgICAgICBpZiggbSA+IDI1Ni4wICkge1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gMC4yNSpsb2cobSkqc3FydChtKS9kejtcXG4gICAgICB9XFxuICAgIFwiLFwiXCJdKSxcbiAgfSxcblxuICAvLyBhZGFwdGVkIGZyb20gaHR0cHM6Ly93d3cuc2hhZGVydG95LmNvbS92aWV3L2xsR1hEUlxuICBNYW5kZWxib3g6IHtcbiAgICBwYXJhbWV0ZXJzOltcbiAgICAgIHsgbmFtZTonZm9sZCcsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDouMSB9LFxuICAgICAgeyBuYW1lOidzY2FsZScsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDozLiwgbWluOjEsIG1heDoxMCB9LFxuICAgICAgeyBuYW1lOidpdGVyYXRpb25zJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjUsIG1pbjoxLCBtYXg6MTAsIHN0ZXA6MSB9LFxuICAgIF0sXG5cbiAgICBnbHNsaWZ5OmBmbG9hdCBtYW5kZWxib3goIGZsb2F0IE1SMiwgZmxvYXQgU0NBTEUsIGZsb2F0IElURVIsIHZlYzMgcG9zaXRpb24gKXtcbiAgICAgIHZlYzQgc2NhbGV2ZWMgPSB2ZWM0KFNDQUxFLCBTQ0FMRSwgU0NBTEUsIGFicyhTQ0FMRSkpIC8gTVIyO1xuICAgICAgZmxvYXQgQzEgPSBhYnMoU0NBTEUtMS4wKSwgQzIgPSBwb3coYWJzKFNDQUxFKSwgMS4tSVRFUik7IC8vIDEwIGlzIElURVJTXG4gICAgICB2ZWM0IHAgPSB2ZWM0KHBvc2l0aW9uLnh5eiwgMS4wKSwgcDAgPSB2ZWM0KHBvc2l0aW9uLnh5eiwgMS4wKTsgIC8vIHAudyBpcyBrbmlnaHR5J3MgREVmYWN0b3JcbiAgICAgIGZvciAoaW50IGk9MDsgaTxpbnQoSVRFUik7IGkrKykge1xuICAgICAgICBwLnh5eiA9IGNsYW1wKHAueHl6LCAtMS4wLCAxLjApICogMi4wIC0gcC54eXo7ICAvLyBib3ggZm9sZDogbWluMywgbWF4M2dnLCBtYWQzXG4gICAgICAgIGZsb2F0IHIyID0gZG90KHAueHl6LCBwLnh5eik7ICAvLyBkcDNcbiAgICAgICAgcC54eXp3ICo9IGNsYW1wKG1heChNUjIvcjIsIE1SMiksIDAuMCwgMS4wKTsgIC8vIHNwaGVyZSBmb2xkOiBkaXYxLCBtYXgxLnNhdCwgbXVsNFxuICAgICAgICBwLnh5encgPSBwKnNjYWxldmVjICsgcDA7ICAvLyBtYWQ0XG4gICAgICB9XG4gICAgICByZXR1cm4gKGxlbmd0aChwLnh5eikgLSBDMSkgLyBwLncgLSBDMjtcbiAgfWAsXG5cbiAgICBwcmltaXRpdmVTdHJpbmcoIHBOYW1lICkge1xuICAgICAgcmV0dXJuIGBtYW5kZWxib3goICR7dGhpcy5mb2xkLmVtaXQoKX0sICR7dGhpcy5zY2FsZS5lbWl0KCl9LCAke3RoaXMuaXRlcmF0aW9ucy5lbWl0KCl9LCAke3BOYW1lfSApYFxuICAgIH1cbiAgfSxcblxuXHRPY3RhaGVkcm9uOiB7XG4gICAgcGFyYW1ldGVyczpbXG4gICAgICB7IG5hbWU6J3JhZGl1cycsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDoxLCBtaW46MCwgbWF4OjQgfSxcbiAgICBdLFxuXG4gICAgcHJpbWl0aXZlU3RyaW5nKCBwTmFtZSApIHsgXG4gICAgICByZXR1cm4gYHNkT2N0YWhlZHJvbiggJHtwTmFtZX0sICR7dGhpcy5yYWRpdXMuZW1pdCgpfSApYFxuICAgIH0sXG5cbiAgICBnbHNsaWZ5OmAgICAgZmxvYXQgc2RPY3RhaGVkcm9uKHZlYzMgcCwgZmxvYXQgaCkge1xuICAgIHAueSA9IHAueSArIGg7IC8vIGNlbnRlciB2ZXJ0aWNhbGx5Li4uIGlzIGl0IGNlbnRlcmVkIG9uIHRoZSB6LWF4aXM/XG4gICAgdmVjMiBkID0gLjUqKGFicyhwLnh6KStwLnkpIC0gbWluKGgscC55KTtcbiAgICByZXR1cm4gbGVuZ3RoKG1heChkLDAuKSkgKyBtaW4obWF4KGQueCxkLnkpLCAwLik7XG4gIH1gXG4gIH0sIFxuXG4gXHRQbGFuZToge1xuICAgIHBhcmFtZXRlcnM6W1xuICAgICAgeyBuYW1lOidub3JtYWwnLCB0eXBlOid2ZWMzJywgZGVmYXVsdDpbMCwxLDBdLCBtaW46MCwgbWF4OjEgfSxcbiAgICAgIHsgbmFtZTonZGlzdGFuY2UnLCB0eXBlOidmbG9hdCcsIGRlZmF1bHQ6MSwgbWluOjAsIG1heDo1IH0sXG4gICAgXSxcblxuICAgIHByaW1pdGl2ZVN0cmluZyggcE5hbWUgKSB7IFxuICAgICAgcmV0dXJuIGBzZFBsYW5lKCAke3BOYW1lfSwgdmVjNCggJHt0aGlzLm5vcm1hbC5lbWl0KCl9LCAke3RoaXMuZGlzdGFuY2UuZW1pdCgpfSApKWBcbiAgICB9LFxuICAgIFxuICAgIGdsc2xpZnk6Z2xzbChbXCIjZGVmaW5lIEdMU0xJRlkgMVxcbmZsb2F0IHNkUGxhbmUoIHZlYzMgcCwgdmVjNCBuIClcXG57XFxuICAvLyBuIG11c3QgYmUgbm9ybWFsaXplZFxcbiAgcmV0dXJuIGRvdChwLG4ueHl6KSArIG4udztcXG59XFxuXFxuXCJdKVxuICAgIFxuICB9LCAgXG4gXHRRdWFkOiB7XG4gICAgcGFyYW1ldGVyczpbXG4gICAgICB7IG5hbWU6J3YxJywgdHlwZTondmVjMycsIGRlZmF1bHQ6Wy0uNSwtLjUsMF0gfSxcbiAgICAgIHsgbmFtZTondjInLCB0eXBlOid2ZWMzJywgZGVmYXVsdDpbLjUsLS41LDBdIH0sXG4gICAgICB7IG5hbWU6J3YzJywgdHlwZTondmVjMycsIGRlZmF1bHQ6Wy41LC41LDBdIH0sXG4gICAgICB7IG5hbWU6J3Y0JywgdHlwZTondmVjMycsIGRlZmF1bHQ6Wy0uNSwuNSwwXSB9LFxuICAgIF0sXG5cbiAgICBwcmltaXRpdmVTdHJpbmcoIHBOYW1lICkgeyBcbiAgICAgIHJldHVybiBgdWRRdWFkKCAke3BOYW1lfSwgJHt0aGlzLnYxLmVtaXQoKX0sICR7dGhpcy52Mi5lbWl0KCl9LCAke3RoaXMudjMuZW1pdCgpfSwgJHt0aGlzLnY0LmVtaXQoKX0gKWBcbiAgICB9LFxuICAgIGdsc2xpZnk6Z2xzbChbXCIjZGVmaW5lIEdMU0xJRlkgMVxcbiAgICBmbG9hdCBkb3QyKCBpbiB2ZWMzIHYgKSB7IHJldHVybiBkb3Qodix2KTsgfVxcbmZsb2F0IHVkUXVhZCggdmVjMyBwLCB2ZWMzIGEsIHZlYzMgYiwgdmVjMyBjLCB2ZWMzIGQgKVxcbntcXG4gICAgdmVjMyBiYSA9IGIgLSBhOyB2ZWMzIHBhID0gcCAtIGE7XFxuICAgIHZlYzMgY2IgPSBjIC0gYjsgdmVjMyBwYiA9IHAgLSBiO1xcbiAgICB2ZWMzIGRjID0gZCAtIGM7IHZlYzMgcGMgPSBwIC0gYztcXG4gICAgdmVjMyBhZCA9IGEgLSBkOyB2ZWMzIHBkID0gcCAtIGQ7XFxuICAgIHZlYzMgbm9yID0gY3Jvc3MoIGJhLCBhZCApO1xcblxcbiAgICByZXR1cm4gc3FydChcXG4gICAgKHNpZ24oZG90KGNyb3NzKGJhLG5vcikscGEpKSArXFxuICAgICBzaWduKGRvdChjcm9zcyhjYixub3IpLHBiKSkgK1xcbiAgICAgc2lnbihkb3QoY3Jvc3MoZGMsbm9yKSxwYykpICtcXG4gICAgIHNpZ24oZG90KGNyb3NzKGFkLG5vcikscGQpKTwzLjApXFxuICAgICA/XFxuICAgICBtaW4oIG1pbiggbWluKFxcbiAgICAgZG90MihiYSpjbGFtcChkb3QoYmEscGEpL2RvdDIoYmEpLDAuMCwxLjApLXBhKSxcXG4gICAgIGRvdDIoY2IqY2xhbXAoZG90KGNiLHBiKS9kb3QyKGNiKSwwLjAsMS4wKS1wYikgKSxcXG4gICAgIGRvdDIoZGMqY2xhbXAoZG90KGRjLHBjKS9kb3QyKGRjKSwwLjAsMS4wKS1wYykgKSxcXG4gICAgIGRvdDIoYWQqY2xhbXAoZG90KGFkLHBkKS9kb3QyKGFkKSwwLjAsMS4wKS1wZCkgKVxcbiAgICAgOlxcbiAgICAgZG90KG5vcixwYSkqZG90KG5vcixwYSkvZG90Mihub3IpICk7XFxufVxcblxcblwiXSlcbiAgfSwgXG5cbiAgUm91bmRCb3g6IHtcbiAgICBwYXJhbWV0ZXJzOltcbiAgICAgIHsgbmFtZTonc2l6ZScsIHR5cGU6J3ZlYzMnLCBkZWZhdWx0OlsxLDEsMV0sIG1pbjowLCBtYXg6MyB9LFxuICAgICAgeyBuYW1lOidyYWRpdXMnLCB0eXBlOidmbG9hdCcsIGRlZmF1bHQ6MSwgbWluOjAsIG1heDozIH0sXG4gICAgXSxcblxuICAgIHByaW1pdGl2ZVN0cmluZyggcE5hbWUgKSB7IFxuICAgICAgcmV0dXJuIGB1ZFJvdW5kQm94KCAke3BOYW1lfSwgJHt0aGlzLnNpemUuZW1pdCgpfSwgICR7dGhpcy5yYWRpdXMuZW1pdCgpfSApYFxuICAgIH0sIFxuICAgIGdsc2xpZnk6Z2xzbChbXCIjZGVmaW5lIEdMU0xJRlkgMVxcbiAgICBmbG9hdCB1ZFJvdW5kQm94KCB2ZWMzIHAsIHZlYzMgYiwgZmxvYXQgciApXFxue1xcbiAgcmV0dXJuIGxlbmd0aChtYXgoYWJzKHApLWIsMC4wKSktcjtcXG59XFxuXFxuXCJdKVxuICB9LCBcbiAgU3BoZXJlOntcbiAgICBwYXJhbWV0ZXJzOltcbiAgICAgIHsgbmFtZToncmFkaXVzJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjEsIG1pbjowLCBtYXg6MyB9LFxuICAgIF0sXG5cbiAgICBwcmltaXRpdmVTdHJpbmcoIHBOYW1lICkgeyBcbiAgICAgIHJldHVybiBgKGxlbmd0aCgke3BOYW1lfSkgLSAke3RoaXMucmFkaXVzLmVtaXQoKX0pYFxuICAgIH0sXG4gICAgZ2xzbGlmeTpnbHNsKFtcIiNkZWZpbmUgR0xTTElGWSAxXFxuICAgIGZsb2F0IHNkU3BoZXJlKCB2ZWMzIHAsIGZsb2F0IHMgKVxcbntcXG4gIHJldHVybiBsZW5ndGgoIHAgKSAtIHM7XFxufVxcblxcblwiXSlcbiAgfSxcbiAgLy8gcGhpLCBtLCBuMSwgbjIsIG4zLCBhLCBiXG4gIFN1cGVyRm9ybXVsYTp7XG4gICAgcGFyYW1ldGVyczpbXG4gICAgICB7IG5hbWU6J21fMScsIHR5cGU6J2Zsb2F0JywgIGRlZmF1bHQ6MSwgbWluOi1NYXRoLlBJKjQsIG1heDpNYXRoLlBJKjQgfSxcbiAgICAgIHsgbmFtZTonbjFfMScsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDoxLCBtaW46LU1hdGguUEkqNCwgbWF4Ok1hdGguUEkqNCB9LFxuICAgICAgeyBuYW1lOiduMl8xJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjEsIG1pbjotTWF0aC5QSSo0LCBtYXg6TWF0aC5QSSo0IH0sXG4gICAgICB7IG5hbWU6J24zXzEnLCB0eXBlOidmbG9hdCcsIGRlZmF1bHQ6MSwgbWluOi1NYXRoLlBJKjQsIG1heDpNYXRoLlBJKjQgfSxcbiAgICAgIHsgbmFtZTonYV8xJywgdHlwZTonZmxvYXQnLCAgZGVmYXVsdDoxLCBtaW46LU1hdGguUEkqNCwgbWF4Ok1hdGguUEkqNCB9LFxuICAgICAgeyBuYW1lOidiXzEnLCB0eXBlOidmbG9hdCcsICBkZWZhdWx0OjEsIG1pbjotTWF0aC5QSSo0LCBtYXg6TWF0aC5QSSo0IH0sXG4gICAgICB7IG5hbWU6J21fMicsIHR5cGU6J2Zsb2F0JywgIGRlZmF1bHQ6MSwgbWluOi1NYXRoLlBJKjQsIG1heDpNYXRoLlBJKjQgfSxcbiAgICAgIHsgbmFtZTonbjFfMicsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDoxLCBtaW46LU1hdGguUEkqNCwgbWF4Ok1hdGguUEkqNCB9LFxuICAgICAgeyBuYW1lOiduMl8yJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjEsIG1pbjotTWF0aC5QSSo0LCBtYXg6TWF0aC5QSSo0IH0sXG4gICAgICB7IG5hbWU6J24zXzInLCB0eXBlOidmbG9hdCcsIGRlZmF1bHQ6MSwgbWluOi1NYXRoLlBJKjQsIG1heDpNYXRoLlBJKjQgfSxcbiAgICAgIHsgbmFtZTonYV8yJywgdHlwZTonZmxvYXQnLCAgZGVmYXVsdDoxLCBtaW46LU1hdGguUEkqNCwgbWF4Ok1hdGguUEkqNCB9LFxuICAgICAgeyBuYW1lOidiXzInLCB0eXBlOidmbG9hdCcsICBkZWZhdWx0OjEsIG1pbjotTWF0aC5QSSo0LCBtYXg6TWF0aC5QSSo0IH0sXG4gICAgXSxcblxuICAgIHByaW1pdGl2ZVN0cmluZyggcE5hbWUgKSB7IFxuICAgICAgcmV0dXJuIGBzdXBlcmZvcm11bGEoICR7cE5hbWV9LCAke3RoaXMubV8xLmVtaXQoKX0sICR7dGhpcy5uMV8xLmVtaXQoKX0sJHt0aGlzLm4yXzEuZW1pdCgpfSwke3RoaXMubjNfMS5lbWl0KCl9LCR7dGhpcy5hXzEuZW1pdCgpfSwke3RoaXMuYl8xLmVtaXQoKX0sICR7dGhpcy5tXzIuZW1pdCgpfSwgJHt0aGlzLm4xXzIuZW1pdCgpfSwke3RoaXMubjJfMi5lbWl0KCl9LCR7dGhpcy5uM18yLmVtaXQoKX0sJHt0aGlzLmFfMi5lbWl0KCl9LCR7dGhpcy5iXzIuZW1pdCgpfSApYFxuICAgIH0sXG4gICAgZ2xzbGlmeTpnbHNsKFtcIiNkZWZpbmUgR0xTTElGWSAxXFxuICAgIGZsb2F0IFN1cGVyRm9ybXVsYSggZmxvYXQgcGhpLCBmbG9hdCBtLCBmbG9hdCBuMSwgZmxvYXQgbjIsIGZsb2F0IG4zLCBmbG9hdCBhLCBmbG9hdCBiICl7XFxuXFx0XFxuXFx0ZmxvYXQgdDEgPSBhYnMoKDEuMCAvIGEpICogY29zKG0gKiBwaGkgLyA0LjApKTtcXG5cXHR0MSA9IHBvdyh0MSwgbjIpO1xcblxcblxcdGZsb2F0IHQyID0gYWJzKChhIC8gYikgKiBzaW4obSAqIHBoaSAvIDQuMCkpO1xcblxcdHQyID0gcG93KHQyLCBuMyk7XFxuXFxuXFx0ZmxvYXQgdDMgPSB0MSArIHQyO1xcblxcblxcdGZsb2F0IHIgPSBwb3codDMsIC0xLjAgLyBuMSk7XFxuXFxuXFx0cmV0dXJuIHI7XFxufVxcblxcbiBmbG9hdCBzdXBlcmZvcm11bGEoIHZlYzMgcCwgZmxvYXQgbV8xLCBmbG9hdCBuMV8xLCBmbG9hdCBuMl8xLCBmbG9hdCBuM18xLCBmbG9hdCBhXzEsIGZsb2F0IGJfMSwgZmxvYXQgbV8yLCBmbG9hdCBuMV8yLCBmbG9hdCBuMl8yLCBmbG9hdCBuM18yLCBmbG9hdCBhXzIsIGZsb2F0IGJfMiApIHtcXG4gICAgZmxvYXQgZCA9IGxlbmd0aCggcCApO1xcbiAgICBmbG9hdCB0aGV0YSA9IGF0YW4ocC55LCBwLngpO1xcbiAgICBmbG9hdCBwaGkgPSBkID09IDAuID8gMC4gOiBhc2luKHAueiAvIGQpO1xcbiAgICBmbG9hdCByMSA9IFN1cGVyRm9ybXVsYSggdGhldGEsIG1fMSwgbjFfMSwgbjJfMSwgbjNfMSwgYV8xLCBiXzEgKTtcXG4gICAgZmxvYXQgcjIgPSBTdXBlckZvcm11bGEoIHBoaSwgbV8yLCBuMV8yLCBuMl8yLCBuM18yLCBhXzIsIGJfMiApO1xcbiAgICB2ZWMzIHEgPSByMiAqIHZlYzMocjEgKiBjb3ModGhldGEpICogY29zKHBoaSksIHIxICogc2luKHRoZXRhKSAqIGNvcyhwaGkpLCBzaW4ocGhpKSk7XFxuICAgIGQgPSBkIC0gbGVuZ3RoKHEpO1xcblxcbiAgICByZXR1cm4gZDtcXG4gIH0gICAgXFxuXCIsXCJcIl0pIH0sXG4gXG4gIFRvcnVzOntcbiAgICBwYXJhbWV0ZXJzOltcbiAgICAgIHsgbmFtZToncmFkaWknLCAgdHlwZTondmVjMicsIGRlZmF1bHQ6Wy41LC4xXSwgbWluOjAsIG1heDozIH0sXG4gICAgXSxcblxuICAgIHByaW1pdGl2ZVN0cmluZyggcG5hbWUgKSB7IFxuICAgICAgcmV0dXJuIGBzZFRvcnVzKCAke3BuYW1lfSwgJHt0aGlzLnJhZGlpLmVtaXQoKX0gKWBcbiAgICB9LFxuICAgIGdsc2xpZnk6Z2xzbChbXCIjZGVmaW5lIEdMU0xJRlkgMVxcbiAgICBmbG9hdCBzZFRvcnVzKCB2ZWMzIHAsIHZlYzIgdCApXFxue1xcbiAgdmVjMiBxID0gdmVjMihsZW5ndGgocC54eiktdC54LHAueSk7XFxuICByZXR1cm4gbGVuZ3RoKHEpLXQueTtcXG59XFxuXFxuXCJdKVxuXG4gIH0sICBcbiAgVG9ydXM4ODp7XG4gICAgcGFyYW1ldGVyczpbXG4gICAgICB7IG5hbWU6J3JhZGlpJywgIHR5cGU6J3ZlYzInLCBkZWZhdWx0OlsuNSwuMV0sIG1pbjowLCBtYXg6MyB9LFxuICAgIF0sXG5cbiAgICBwcmltaXRpdmVTdHJpbmcoIHBuYW1lICkgeyBcbiAgICAgIHJldHVybiBgc2RUb3J1czg4KCAke3BuYW1lfSwgJHt0aGlzLnJhZGlpLmVtaXQoKX0gKWBcbiAgICB9LFxuICAgIGdsc2xpZnk6YGZsb2F0IHNkVG9ydXM4OCggdmVjMyBwLCB2ZWMyIHQgKSB7XG4gICAgICAgIHZlYzIgcSA9IHZlYzIoIGxlbmd0aDgoIHAueHogKSAtIHQueCwgcC55ICk7XG4gICAgICAgIHJldHVybiBsZW5ndGg4KCBxICkgLSB0Lnk7XG4gICAgICB9XFxuYCxcbiAgfSxcbiAgVG9ydXM4Mjp7XG4gICAgcGFyYW1ldGVyczpbXG4gICAgICB7IG5hbWU6J3JhZGlpJywgIHR5cGU6J3ZlYzInLCBkZWZhdWx0OlsuNSwuMV0sIG1pbjowLCBtYXg6MyB9LFxuICAgIF0sXG5cbiAgICBwcmltaXRpdmVTdHJpbmcoIHBuYW1lICkgeyBcbiAgICAgIHJldHVybiBgc2RUb3J1czgyKCAke3BuYW1lfSwgJHt0aGlzLnJhZGlpLmVtaXQoKX0gKWBcbiAgICB9LFxuICAgIGdsc2xpZnk6YGZsb2F0IHNkVG9ydXM4MiggdmVjMyBwLCB2ZWMyIHQgKSB7XG4gICAgICAgIHZlYzIgcSA9IHZlYzIoIGxlbmd0aCggcC54eiApIC0gdC54LCBwLnkgKTtcbiAgICAgICAgcmV0dXJuIGxlbmd0aDgoIHEgKSAtIHQueTtcbiAgICAgIH1cXG5gXG4gIH0sXG4gXHRUcmlhbmdsZToge1xuICAgIHBhcmFtZXRlcnM6W1xuICAgICAgeyBuYW1lOid2MScsIHR5cGU6J3ZlYzMnLCBkZWZhdWx0OlswLC0uNSwwXSB9LFxuICAgICAgeyBuYW1lOid2MicsIHR5cGU6J3ZlYzMnLCBkZWZhdWx0OlstLjUsLjAsMF0gfSxcbiAgICAgIHsgbmFtZTondjMnLCB0eXBlOid2ZWMzJywgZGVmYXVsdDpbLjUsLjAsMF0gfSxcbiAgICBdLFxuXG4gICAgcHJpbWl0aXZlc3RyaW5nKCBwbmFtZSApIHsgXG4gICAgICByZXR1cm4gYHVkdHJpYW5nbGUoICR7cG5hbWV9LCAke3RoaXMudjEuZW1pdCgpfSwgJHt0aGlzLnYyLmVtaXQoKX0sICR7dGhpcy52My5lbWl0KCl9IClgXG4gICAgfSxcbiAgICBnbHNsaWZ5Omdsc2woW1wiI2RlZmluZSBHTFNMSUZZIDFcXG4gICAgZmxvYXQgZG90MiggaW4gdmVjMyB2ICkgeyByZXR1cm4gZG90KHYsdik7IH1cXG5mbG9hdCB1ZFRyaWFuZ2xlKCB2ZWMzIHAsIHZlYzMgYSwgdmVjMyBiLCB2ZWMzIGMgKVxcbntcXG4gICAgdmVjMyBiYSA9IGIgLSBhOyB2ZWMzIHBhID0gcCAtIGE7XFxuICAgIHZlYzMgY2IgPSBjIC0gYjsgdmVjMyBwYiA9IHAgLSBiO1xcbiAgICB2ZWMzIGFjID0gYSAtIGM7IHZlYzMgcGMgPSBwIC0gYztcXG4gICAgdmVjMyBub3IgPSBjcm9zcyggYmEsIGFjICk7XFxuXFxuICAgIHJldHVybiBzcXJ0KFxcbiAgICAoc2lnbihkb3QoY3Jvc3MoYmEsbm9yKSxwYSkpICtcXG4gICAgIHNpZ24oZG90KGNyb3NzKGNiLG5vcikscGIpKSArXFxuICAgICBzaWduKGRvdChjcm9zcyhhYyxub3IpLHBjKSk8Mi4wKVxcbiAgICAgP1xcbiAgICAgbWluKCBtaW4oXFxuICAgICBkb3QyKGJhKmNsYW1wKGRvdChiYSxwYSkvZG90MihiYSksMC4wLDEuMCktcGEpLFxcbiAgICAgZG90MihjYipjbGFtcChkb3QoY2IscGIpL2RvdDIoY2IpLDAuMCwxLjApLXBiKSApLFxcbiAgICAgZG90MihhYypjbGFtcChkb3QoYWMscGMpL2RvdDIoYWMpLDAuMCwxLjApLXBjKSApXFxuICAgICA6XFxuICAgICBkb3Qobm9yLHBhKSpkb3Qobm9yLHBhKS9kb3QyKG5vcikgKTtcXG59XFxuXFxuXCJdKVxuICB9LCBcblxuICBUcmlQcmlzbToge1xuICAgIHBhcmFtZXRlcnM6W1xuICAgICAgeyBuYW1lOidkaW1lbnNpb25zJywgdHlwZTondmVjMicsIGRlZmF1bHQ6Wy41LC41XSwgbWluOjAsIG1heDozIH0sXG4gICAgXSxcblxuICAgIHByaW1pdGl2ZVN0cmluZyggcE5hbWUgKSB7IFxuICAgICAgcmV0dXJuIGBzZFRyaVByaXNtKCAke3BOYW1lfSwgJHt0aGlzLmRpbWVuc2lvbnMuZW1pdCgpfSlgXG4gICAgfSxcbiAgICBnbHNsaWZ5Omdsc2woW1wiI2RlZmluZSBHTFNMSUZZIDFcXG4gICAgICBmbG9hdCBzZFRyaVByaXNtKCB2ZWMzIHAsIHZlYzIgaCApXFxue1xcbiAgICB2ZWMzIHEgPSBhYnMocCk7XFxuICAgIHJldHVybiBtYXgocS56LWgueSxtYXgocS54KjAuODY2MDI1K3AueSowLjUsLXAueSktaC54KjAuNSk7XFxufVxcblxcblwiXSlcblxuICB9LFxuXG59XG4iLCJjb25zdCB7IFZhciwgZmxvYXRfdmFyX2dlbiwgdmVjMl92YXJfZ2VuLCB2ZWMzX3Zhcl9nZW4sIHZlYzRfdmFyX2dlbiwgaW50X3Zhcl9nZW4sIFZhckFsbG9jIH0gID0gcmVxdWlyZSggJy4vdmFyLmpzJyApXG5jb25zdCBTY2VuZU5vZGUgPSByZXF1aXJlKCAnLi9zY2VuZU5vZGUuanMnIClcbmNvbnN0IHsgcGFyYW1fd3JhcCwgTWF0ZXJpYWxJRCB9ID0gcmVxdWlyZSggJy4vdXRpbHMuanMnIClcbmNvbnN0IHsgVmVjMiwgVmVjMywgVmVjNCB9ID0gcmVxdWlyZSggJy4vdmVjLmpzJyApXG5jb25zdCBUcmFuc2Zvcm0gPSByZXF1aXJlKCAnLi90cmFuc2Zvcm0uanMnIClcblxuY29uc3QgY3JlYXRlUHJpbWl0aXZlcyA9IGZ1bmN0aW9uKCBTREYgKSB7XG5cbiAgY29uc3QgZ2VucyA9IHsgXG4gICAgaW50OiAgIGludF92YXJfZ2VuLFxuICAgIGZsb2F0OiBmbG9hdF92YXJfZ2VuLFxuICAgIHZlYzI6IHZlYzJfdmFyX2dlbixcbiAgICB2ZWMzOiB2ZWMzX3Zhcl9nZW4sXG4gICAgdmVjNDogdmVjNF92YXJfZ2VuLFxuICB9XG5cbiAgY29uc3QgdmFycyA9IHsgXG4gICAgdmVjMjogVmVjMixcbiAgICB2ZWMzOiBWZWMzLFxuICAgIHZlYzQ6IFZlYzRcbiAgfVxuXG4gIC8vIGxvYWQgZGVzY3JpcHRpb25zIG9mIGFsbCBwcmltdGl2ZXNcbiAgY29uc3QgZGVzY3JpcHRpb25zID0gcmVxdWlyZSggJy4vcHJpbWl0aXZlRGVzY3JpcHRpb25zLmpzJyApXG5cbiAgY29uc3QgUHJpbWl0aXZlcyA9IHsgXG4gICAgZGVzY3JpcHRpb25zLFxuXG4gICAgdGV4dHVyZU1lbW86IFtdLFxuXG4gICAgZW1pdF9nZW9tZXRyaWVzKCkge1xuICAgICAgY29uc3QgaGVhZCA9IEFycmF5LmlzQXJyYXkoIFNERi5fX3NjZW5lLl9fcHJlcmVuZGVyICkgPyBTREYuX19zY2VuZS5fX3ByZXJlbmRlclswXSA6IFNERi5fX3NjZW5lLl9fcHJlcmVuZGVyXG4gICAgICBjb25zdCBnZW9zID0gUHJpbWl0aXZlcy5jcmF3bE5vZGUoIGhlYWQsIFtdIClcblxuICAgICAgZ2Vvcy5mb3JFYWNoKCAoZ2VvLGkpID0+IHtcbiAgICAgICAgZ2VvLl9fc2RmSUQgPSBpIFxuICAgICAgICBpZiggZ2VvLl9fdGV4dHVyZU9iaiAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgIFNERi50ZXh0dXJlcy5hZGRUZXh0dXJlKCBnZW8uX190ZXh0dXJlT2JqIClcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgY29uc3QgbGVuZ3RoID0gZ2Vvcy5sZW5ndGhcbiAgICAgIGNvbnN0IG1hdGVyaWFscyA9IFNERi5tYXRlcmlhbHMubWF0ZXJpYWxzXG5cbiAgICAgIGxldCBkZWNsID0gYFNERiBzZGZzWyR7bGVuZ3RofV0gPSBTREZbJHtsZW5ndGh9XShcXG5gXG4gICAgICBnZW9zLmZvckVhY2goIChnZW8sIGkpID0+IHtcbiAgICAgICAgY29uc3QgdGV4dHVyZUlEID0gZ2VvLl9fdGV4dHVyZU9iaiA9PT0gdW5kZWZpbmVkID8gNTAwMDAgOiBnZW8uX190ZXh0dXJlT2JqLmlkXG4gICAgICAgIGNvbnN0IGhhc1JlcGVhdCA9IGdlby5yZXBlYXQgIT09IG51bGwgJiYgZ2VvLnJlcGVhdCAhPT0gdW5kZWZpbmVkXG4gICAgICAgIGRlY2wgKz0gYCAgICAgICAgU0RGKCAke21hdGVyaWFscy5pbmRleE9mKCBnZW8uX19tYXRlcmlhbCApfSwgJHtnZW8udHJhbnNmb3JtLnZhck5hbWV9LCAke3RleHR1cmVJRH0sICR7aGFzUmVwZWF0ID8gZ2VvLnJlcGVhdC5kaXN0YW5jZS5lbWl0KCkgOiAndmVjMygwLiknfSwgJHtoYXNSZXBlYXQgPyBnZW8ucmVwZWF0LnRyYW5zZm9ybS5lbWl0KCkgOiBgbWF0NCgxLilgfSApYFxuICAgICAgICBpZiggaSA8IGdlb3MubGVuZ3RoIC0gMSApIGRlY2wgKz0gJywnXG4gICAgICAgIGRlY2wgKz0gJ1xcbidcbiAgICAgIH0pXG5cbiAgICAgIGRlY2wgKz0gYCAgICAgICk7XFxuYFxuXG4gICAgICB0aGlzLmdlb21ldHJpZXMgPSBnZW9zXG5cbiAgICAgIHJldHVybiBkZWNsXG4gICAgfSxcblxuICAgIGNyYXdsTm9kZSggbm9kZSwgYXJyICkge1xuICAgICAgaWYoIG5vZGUudHlwZSA9PT0gJ2dlb21ldHJ5JyApIHtcbiAgICAgICAgYXJyLnB1c2goIG5vZGUgKVxuICAgICAgfWVsc2V7XG4gICAgICAgIGlmKCBub2RlLmEgIT09IHVuZGVmaW5lZCApIFByaW1pdGl2ZXMuY3Jhd2xOb2RlKCBub2RlLmEsIGFyciApXG4gICAgICAgIGlmKCBub2RlLmIgIT09IHVuZGVmaW5lZCApIFByaW1pdGl2ZXMuY3Jhd2xOb2RlKCBub2RlLmIsIGFyciApXG4gICAgICAgIGlmKCBub2RlLnNkZiAhPT0gdW5kZWZpbmVkICkgUHJpbWl0aXZlcy5jcmF3bE5vZGUoIG5vZGUuc2RmLCBhcnIgKVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJyXG4gICAgfVxuICB9XG5cbiAgY29uc3QgY3JlYXRlUHJpbWl0aXZlID0gZnVuY3Rpb24oIG5hbWUsIGRlc2MgKSB7XG5cbiAgICBjb25zdCBwYXJhbXMgPSBkZXNjLnBhcmFtZXRlcnNcbiAgICAvLyBjcmVhdGUgY29uc3RydWN0b3JcbiAgICBQcmltaXRpdmVzWyBuYW1lIF0gPSBmdW5jdGlvbiggLi4uYXJncyApIHtcbiAgICAgIGNvbnN0IHAgPSBPYmplY3QuY3JlYXRlKCBQcmltaXRpdmVzWyBuYW1lIF0ucHJvdG90eXBlIClcbiAgICAgIHAucGFyYW1zID0gcGFyYW1zXG4gICAgICBwLnRyYW5zZm9ybSA9IFRyYW5zZm9ybSgpXG4gICAgICBwLnRyYW5zZm9ybS5zaG91bGRJbnZlcnQgPSB0cnVlXG4gICAgICBwLnR5cGUgPSAnZ2VvbWV0cnknXG4gICAgICBwLm5hbWUgPSBuYW1lXG4gICAgICBwLnJlcGVhdCA9IG51bGwvL1ZhciggdmFycy52ZWMzKCAwICksIG51bGwsICd2ZWMzJyApXG5cbiAgICAgIHAuX19tYXRlcmlhbCA9IG51bGxcbiAgICAgIHAuX190ZXh0dXJlSUQgID0gNTAwMDAwXG4gICAgICBcbiAgICAgIGxldCBjb3VudCA9IDBcblxuICAgICAgLy8gd3JhcCBlYWNoIHBhcmFtIGluIGEgVmFyIG9iamVjdCBmb3IgY29kZWdlblxuICAgICAgZm9yKCBsZXQgcGFyYW0gb2YgcGFyYW1zICkge1xuICAgICAgICBpZiggcGFyYW0ubmFtZSA9PT0gJ2NvbG9yJyApIHtcbiAgICAgICAgICBwLmNvbG9yID0gYXJnc1sgY291bnQgXSA9PT0gdW5kZWZpbmVkID8gcGFyYW0uZGVmYXVsdCA6IGFyZ3NbIGNvdW50KysgXVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgICAgaWYoIHBhcmFtLnR5cGUgPT09ICdvYmonICkge1xuICAgICAgICAgIGxldCBfX3ZhbHVlID0gYXJnc1sgY291bnQrKyBdXG4gICAgICAgICAgcFsgcGFyYW0ubmFtZSBdID0ge1xuICAgICAgICAgICAgZ2V0IHZhbHVlKCkgeyByZXR1cm4gX192YWx1ZSB9LFxuICAgICAgICAgICAgc2V0IHZhbHVlKHYpeyBfX3ZhbHVlID0gdiB9LFxuICAgICAgICAgICAgZW1pdCgpIHtcbiAgICAgICAgICAgICAgY29uc3Qgb3V0cHV0ID0gIHBbIHBhcmFtLm5hbWUgXS52YWx1ZS5lbWl0KClcbiAgICAgICAgICAgICAgcmV0dXJuIG91dHB1dFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVtaXRfZGVjbCgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBbIHBhcmFtLm5hbWUgXS52YWx1ZS5hLmVtaXRfZGVjbCgpICsgcFtwYXJhbS5uYW1lXS52YWx1ZS5iLmVtaXRfZGVjbCgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlcyA9IHBhcmFtLmRlZmF1bHRcbiAgICAgICAgY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoIGRlZmF1bHRWYWx1ZXMgKVxuXG4gICAgICAgIGlmKCBpc0FycmF5ICkge1xuICAgICAgICAgIGxldCB2YWwgPSBhcmdzWyBjb3VudCsrIF0sIF9fdmFyXG5cbiAgICAgICAgICBpZiggdHlwZW9mIHZhbCA9PT0gJ251bWJlcicgKSB7XG4gICAgICAgICAgICBfX3ZhciA9IFZhciggdmFyc1sgcGFyYW0udHlwZSBdKCB2YWwgKSwgbnVsbCwgJ3ZlYzMnIClcbiAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgIF9fdmFyID0gIHBhcmFtX3dyYXAoXG4gICAgICAgICAgICAgIHZhbCxcbiAgICAgICAgICAgICAgZ2Vuc1sgcGFyYW0udHlwZSBdKCAuLi5kZWZhdWx0VmFsdWVzICkgXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gZm9yIGFzc2lnbmluZyBlbnRpcmUgbmV3IHZlY3RvcnMgdG8gcHJvcGVydHlcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHAsIHBhcmFtLm5hbWUsIHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTp0cnVlLFxuICAgICAgICAgICAgZ2V0KCkgeyByZXR1cm4gX192YXIgfSxcbiAgICAgICAgICAgIHNldCh2KSB7XG4gICAgICAgICAgICAgIGlmKCB0eXBlb2YgdiA9PT0gJ29iamVjdCcgKSB7XG4gICAgICAgICAgICAgICAgX192YXIuc2V0KCB2IClcbiAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgX192YXIudmFsdWUueCA9IHZcbiAgICAgICAgICAgICAgICBfX3Zhci52YWx1ZS55ID0gdlxuICAgICAgICAgICAgICAgIF9fdmFyLnZhbHVlLnogPSB2XG4gICAgICAgICAgICAgICAgX192YXIudmFsdWUudyA9IHZcbiAgICAgICAgICAgICAgICBfX3Zhci5kaXJ0eSA9IHRydWVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG5cbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgbGV0IF9fdmFyICA9IHBhcmFtX3dyYXAoIFxuICAgICAgICAgICAgYXJnc1sgY291bnQrKyBdLCBcbiAgICAgICAgICAgIGdlbnNbIHBhcmFtLnR5cGUgXSggZGVmYXVsdFZhbHVlcyApIFxuICAgICAgICAgIClcblxuICAgICAgICAgIC8vX192YXIuc2V0KCBkZWZhdWx0VmFsdWVzIClcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHAsIHBhcmFtLm5hbWUsIHtcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTp0cnVlLFxuICAgICAgICAgICAgZ2V0KCkgeyByZXR1cm4gX192YXIgfSxcbiAgICAgICAgICAgIHNldCh2KSB7XG4gICAgICAgICAgICAgIF9fdmFyLnNldCggdiApXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBwLmlkID0gVmFyQWxsb2MuYWxsb2MoKVxuXG4gICAgICBwLl9fZGVzYyA9IGRlc2NcbiAgICAgIHAuX19zZXRNYXRlcmlhbCA9IGZ1bmN0aW9uKG1hdCkge1xuICAgICAgICBpZiggdHlwZW9mIG1hdCA9PT0gJ3N0cmluZycgKSBtYXQgPSBTREYuTWF0ZXJpYWxbIG1hdCBdXG4gICAgICAgIHRoaXMuX19tYXRlcmlhbCA9IHRoaXMubWF0ID0gU0RGLm1hdGVyaWFscy5hZGRNYXRlcmlhbCggbWF0IClcbiAgICAgIH1cblxuICAgICAgcC5fX3NldFRleHR1cmUgPSBmdW5jdGlvbih0ZXgscHJvcHMpIHtcbiAgICAgICAgaWYoIHR5cGVvZiB0ZXggPT09ICdzdHJpbmcnICkge1xuICAgICAgICAgIHRoaXMudGV4dHVyZSA9IHAudGV4dHVyZS5iaW5kKCB0aGlzIClcbiAgICAgICAgICB0aGlzLl9fdGV4dHVyZU9iaiA9IHRoaXMudGV4ID0gU0RGLlRleHR1cmUoIHRleCxwcm9wcyx0aGlzLnRleHR1cmUgKVxuICAgICAgICAgIHRoaXMuX190ZXh0dXJlSUQgPSB0aGlzLl9fdGV4dHVyZU9iai5pZFxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICB0aGlzLl9fdGV4dHVyZU9iaiA9IHRoaXMudGV4ID0gT2JqZWN0LmFzc2lnbiggdGV4LCBwcm9wcyApXG4gICAgICAgICAgdGhpcy5fX3RleHR1cmVJRCA9IHRoaXMuX190ZXh0dXJlT2JqLmlkXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHAuX19zZXRCdW1wID0gZnVuY3Rpb24odGV4LHByb3BzKSB7XG4gICAgICAgIC8vdGhpcy5idW1wID0gcC5idW1wLmJpbmQoIHRoaXMgKVxuICAgICAgICBjb25zdCBiID0gdGhpcy5idW1wID0gdGhpcy5fX2J1bXBPYmogPSBTREYuQnVtcCggdGhpcywgdGV4LCBwcm9wcyApXG4gICAgICAgIHRoaXMuYnVtcC50ZXh0dXJlID0gdGhpcy5idW1wLmFtb3VudC52YWx1ZVxuICAgICAgICB0aGlzLl9fYnVtcElEID0gdGhpcy5fX2J1bXBPYmouaWRcbiAgICAgICAgdGhpcy5yb3RhdGUgPSB0aGlzLmJ1bXAucm90YXRlXG4gICAgICAgIHRoaXMudHJhbnNsYXRlID0gdGhpcy5idW1wLnRyYW5zbGF0ZVxuICAgICAgICB0aGlzLnNjYWxlID0gdGhpcy5idW1wLnNjYWxlXG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcy5idW1wLCAnc3RyZW5ndGgnLCB7XG4gICAgICAgICAgZ2V0KCkgeyByZXR1cm4gYi5zaXplIH0sXG4gICAgICAgICAgc2V0KHYpeyBiLnNpemUgPSB2IH1cbiAgICAgICAgfSlcbiAgICAgIH1cblxuICAgICAgT2JqZWN0LmFzc2lnbiggcCwge1xuICAgICAgICByZW5kZXJpbmdCdW1wIDogZmFsc2UsXG4gICAgICAgIGVtaXR0aW5nRGVjbCAgOiBmYWxzZSxcbiAgICAgICAgdXBsb2FkaW5nICAgICA6IGZhbHNlLFxuICAgICAgICB1cGRhdGluZyAgICAgIDogZmFsc2VcbiAgICAgIH0pXG5cbiAgICAgIGlmKCBwLl9fbWF0ZXJpYWwgPT09IG51bGwgKSBwLl9fc2V0TWF0ZXJpYWwoKVxuXG4gICAgICBTREYuZ2VvbWV0cmllcy5wdXNoKCBwIClcblxuICAgICAgcmV0dXJuIHBcbiAgICB9XG5cbiAgICAvLyBkZWZpbmUgcHJvdG90eXBlIHRvIHVzZVxuICAgIFByaW1pdGl2ZXNbIG5hbWUgXS5wcm90b3R5cGUgPSBTY2VuZU5vZGUoKVxuICAgIFByaW1pdGl2ZXNbIG5hbWUgXS5wcm90b3R5cGUudHlwZSA9ICdnZW9tZXRyeSdcbiAgICBcbiAgICAvLyBjcmVhdGUgY29kZWdlbiBzdHJpbmdcblxuXG4gICAgUHJpbWl0aXZlc1sgbmFtZSBdLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gKCBfX25hbWUsIHRyYW5zZm9ybSA9IG51bGwsIGJ1bXA9bnVsbCwgc2NhbGU9bnVsbCApIHtcbiAgICAgIGlmKCBTREYubWVtb1sgdGhpcy5pZCBdICE9PSB1bmRlZmluZWQgKSByZXR1cm4geyBwcmVmYWNlOicnLCBvdXQ6bmFtZSt0aGlzLm1hdElkIH1cbiAgICAgIGlmKCB0aGlzLl9fYnVtcE9iaiAhPT0gdW5kZWZpbmVkICYmIHRoaXMucmVuZGVyaW5nQnVtcCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJpbmdCdW1wID0gdHJ1ZVxuICAgICAgICByZXR1cm4gdGhpcy5fX2J1bXBPYmouZW1pdCggX19uYW1lLCB0cmFuc2Zvcm0gKVxuICAgICAgfVxuICAgICAgXG4gICAgICBjb25zdCBzaGFkZXJDb2RlID0gZGVzYy5nbHNsaWZ5LmluZGV4T2YoJyMnKSA+IC0xIFxuICAgICAgICA/IGRlc2MuZ2xzbGlmeS5zbGljZSgxOCkgXG4gICAgICAgIDogZGVzYy5nbHNsaWZ5XG5cbiAgICAgIGlmKCBTREYucmVxdWlyZWRHZW9tZXRyaWVzLmluZGV4T2YoIHNoYWRlckNvZGUgKSA9PT0gLSAxICkge1xuICAgICAgICBTREYucmVxdWlyZWRHZW9tZXRyaWVzLnB1c2goIHNoYWRlckNvZGUgKVxuICAgICAgfSBcblxuICAgICAgaWYoIHRyYW5zZm9ybSAhPT0gbnVsbCApIHRoaXMudHJhbnNmb3JtLmFwcGx5KCB0cmFuc2Zvcm0sIGZhbHNlIClcbiAgICAgIC8vdGhpcy50cmFuc2Zvcm0uaW52ZXJ0KCB0cnVlIClcbiAgICAgIHRoaXMudHJhbnNmb3JtLmludGVybmFsKClcblxuICAgICAgY29uc3QgcG5hbWUgPSB0eXBlb2YgX19uYW1lICE9PSAnc3RyaW5nJyA/ICdwJyA6IF9fbmFtZSxcbiAgICAgICAgICAgIGlkID0gdGhpcy5fX3NkZklELFxuICAgICAgICAgICAgcyA9IHNjYWxlID09PSBudWxsID8gdGhpcy50cmFuc2Zvcm0uZW1pdF9zY2FsZSgpIDogYCR7dGhpcy50cmFuc2Zvcm0uZW1pdF9zY2FsZSgpfSAqICR7c2NhbGV9YCxcbiAgICAgICAgICAgIHRzdHJpbmcgPSBgKCAke3BuYW1lfSAqICR7dGhpcy50cmFuc2Zvcm0uZW1pdCgpfSApLnh5emBcbiAgICAgIFxuICAgICAgY29uc3QgcHJpbWl0aXZlID0gYFxuICAgICAgICB2ZWMyICR7bmFtZX0ke3RoaXMuaWR9ID0gdmVjMiggJHtkZXNjLnByaW1pdGl2ZVN0cmluZy5jYWxsKCB0aGlzLCB0c3RyaW5nLCBidW1wICl9ICogJHtzfSwgJHtpZH0uKTtcbiAgICAgIGBcbiAgICAgIFNERi5tZW1vWyB0aGlzLmlkIF0gPSBuYW1lICsgdGhpcy5pZFxuXG4gICAgICB0aGlzLnJlbmRlcmluZ0J1bXAgPSBmYWxzZVxuICAgICAgcmV0dXJuIHsgcHJlZmFjZTpwcmltaXRpdmUsIG91dDpuYW1lK3RoaXMuaWQgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gZGVjbGFyZSBhbnkgdW5pZm9ybSB2YXJpYWJsZXNcbiAgICBQcmltaXRpdmVzWyBuYW1lIF0ucHJvdG90eXBlLmVtaXRfZGVjbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYoIHRoaXMuX19idW1wT2JqICE9PSB1bmRlZmluZWQgJiYgdGhpcy5lbWl0dGluZ0RlY2wgPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuZW1pdHRpbmdEZWNsID0gdHJ1ZVxuICAgICAgICByZXR1cm4gdGhpcy5fX2J1bXBPYmouZW1pdF9kZWNsKCkgXG4gICAgICB9XG4gICAgICBsZXQgZGVjbCA9ICcnXG4gICAgICBkZWNsICs9IHRoaXMudHJhbnNmb3JtLmVtaXRfZGVjbCgpXG5cbiAgICAgIC8vZGVidWdnZXJcbiAgICAgIGlmKCB0aGlzLl9fcmVwZWF0ICE9PSB1bmRlZmluZWQgKSBkZWNsICs9IHRoaXMuX19yZXBlYXQuZW1pdF9kZWNsKCBmYWxzZSApXG4gICAgICBpZiggdGhpcy5fX3BvbGFyUmVwZWF0ICE9PSB1bmRlZmluZWQgKSBkZWNsICs9IHRoaXMuX19wb2xhclJlcGVhdC5lbWl0X2RlY2woIGZhbHNlIClcblxuICAgICAgZm9yKCBsZXQgcGFyYW0gb2YgcGFyYW1zICkge1xuICAgICAgICBpZiggcGFyYW0ubmFtZSAhPT0gJ21hdGVyaWFsJyApXG4gICAgICAgICAgZGVjbCArPSB0aGlzWyBwYXJhbS5uYW1lIF0uZW1pdF9kZWNsKCApXG4gICAgICB9XG5cbiAgICAgIHRoaXMuZW1pdHRpbmdEZWNsID0gZmFsc2VcbiAgICAgIHJldHVybiBkZWNsXG4gICAgfVxuXG4gICAgUHJpbWl0aXZlc1sgbmFtZSBdLnByb3RvdHlwZS51cGRhdGVfbG9jYXRpb24gPSBmdW5jdGlvbiggZ2wsIHByb2dyYW0gKSB7XG4gICAgICBpZiggdGhpcy5fX2J1bXBPYmogIT09IHVuZGVmaW5lZCAmJiB0aGlzLnVwZGF0aW5nID09PSBmYWxzZSkge1xuICAgICAgICB0aGlzLnVwZGF0aW5nID0gdHJ1ZVxuICAgICAgICByZXR1cm4gdGhpcy5fX2J1bXBPYmoudXBkYXRlX2xvY2F0aW9uKCBnbCwgcHJvZ3JhbSApXG4gICAgICB9XG5cbiAgICAgIGZvciggbGV0IHBhcmFtIG9mIHBhcmFtcyApIHtcbiAgICAgICAgaWYoIHBhcmFtLnR5cGUgIT09ICdvYmonICkge1xuICAgICAgICAgIGlmKCBwYXJhbS5uYW1lICE9PSAnbWF0ZXJpYWwnICkgXG4gICAgICAgICAgICB0aGlzWyBwYXJhbS5uYW1lIF0udXBkYXRlX2xvY2F0aW9uKCBnbCxwcm9ncmFtIClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiggdGhpcy5fX3JlcGVhdCAhPT0gdW5kZWZpbmVkICkgdGhpcy5fX3JlcGVhdC51cGRhdGVfbG9jYXRpb24oIGdsLCBwcm9ncmFtLCBmYWxzZSApXG4gICAgICBpZiggdGhpcy5fX3BvbGFyUmVwZWF0ICE9PSB1bmRlZmluZWQgKSB0aGlzLl9fcG9sYXJSZXBlYXQudXBkYXRlX2xvY2F0aW9uKCBnbCwgcHJvZ3JhbSwgZmFsc2UgKVxuICAgICAgdGhpcy50cmFuc2Zvcm0udXBkYXRlX2xvY2F0aW9uKCBnbCwgcHJvZ3JhbSApXG4gICAgICB0aGlzLnVwZGF0aW5nID0gZmFsc2VcbiAgICB9XG5cbiAgICBQcmltaXRpdmVzWyBuYW1lIF0ucHJvdG90eXBlLnVwbG9hZF9kYXRhID0gZnVuY3Rpb24oIGdsICkge1xuICAgICAgaWYoIHRoaXMuX19idW1wT2JqICE9PSB1bmRlZmluZWQgJiYgdGhpcy51cGxvYWRpbmcgID09PSBmYWxzZSApIHtcbiAgICAgICAgdGhpcy51cGxvYWRpbmcgPSB0cnVlXG4gICAgICAgIHJldHVybiB0aGlzLl9fYnVtcE9iai51cGxvYWRfZGF0YSggZ2wgKVxuICAgICAgfVxuICAgICAgZm9yKCBsZXQgcGFyYW0gb2YgcGFyYW1zICkge1xuICAgICAgICBpZiggcGFyYW0udHlwZSAhPT0gJ29iaicgJiYgcGFyYW0ubmFtZSAhPT0gJ21hdGVyaWFsJyApXG4gICAgICAgICAgdGhpc1sgcGFyYW0ubmFtZSBdLnVwbG9hZF9kYXRhKCBnbCApXG4gICAgICB9XG5cbiAgICAgIGlmKCB0aGlzLl9fcG9sYXJSZXBlYXQgIT09IHVuZGVmaW5lZCApIHRoaXMuX19wb2xhclJlcGVhdC51cGxvYWRfZGF0YSggZ2wsIGZhbHNlIClcbiAgICAgIHRoaXMudHJhbnNmb3JtLnVwbG9hZF9kYXRhKCBnbCApXG4gICAgICB0aGlzLnVwbG9hZGluZyA9IGZhbHNlXG4gICAgfVxuICAgIFxuICAgIHJldHVybiBQcmltaXRpdmVzWyBuYW1lIF1cbiAgfVxuICBcbiAgZm9yKCBsZXQgbmFtZSBpbiBkZXNjcmlwdGlvbnMgKSB7XG4gICAgY29uc3QgZGVzYyA9IGRlc2NyaXB0aW9uc1sgbmFtZSBdXG4gICAgY3JlYXRlUHJpbWl0aXZlKCBuYW1lLCBkZXNjIClcbiAgfVxuXG4gIFByaW1pdGl2ZXMuY3JlYXRlID0gY3JlYXRlUHJpbWl0aXZlXG5cbiAgcmV0dXJuIFByaW1pdGl2ZXNcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVQcmltaXRpdmVzXG4iLCJjb25zdCBnZXRNYWluQ29udGludW91cyA9IGZ1bmN0aW9uKCBzdGVwcywgbWluRGlzdGFuY2UsIG1heERpc3RhbmNlLCBwb3N0cHJvY2Vzc2luZyApIHtcbiAgY29uc3Qgb3V0ID0gYFxuICAvLyBhZGFwdGVkIGZyb20gaHR0cHM6Ly93d3cuc2hhZGVydG95LmNvbS92aWV3L2xkZlNXc1xuICB2ZWMzIGNhbGNOb3JtYWwodmVjMyBwb3MsIGZsb2F0IGVwcykge1xuICAgIGNvbnN0IHZlYzMgdjEgPSB2ZWMzKCAxLjAsLTEuMCwtMS4wKTtcbiAgICBjb25zdCB2ZWMzIHYyID0gdmVjMygtMS4wLC0xLjAsIDEuMCk7XG4gICAgY29uc3QgdmVjMyB2MyA9IHZlYzMoLTEuMCwgMS4wLC0xLjApO1xuICAgIGNvbnN0IHZlYzMgdjQgPSB2ZWMzKCAxLjAsIDEuMCwgMS4wKTtcblxuICAgIHJldHVybiBub3JtYWxpemUoIHYxICogc2NlbmUgKCBwb3MgKyB2MSplcHMgKS54K1xuICAgICAgICAgICAgICAgICAgICAgIHYyICogc2NlbmUgKCBwb3MgKyB2MiplcHMgKS54K1xuICAgICAgICAgICAgICAgICAgICAgIHYzICogc2NlbmUgKCBwb3MgKyB2MyplcHMgKS54K1xuICAgICAgICAgICAgICAgICAgICAgIHY0ICogc2NlbmUgKCBwb3MgKyB2NCplcHMgKS54KTtcbiAgfVxuXG4gIHZlYzMgY2FsY05vcm1hbCh2ZWMzIHBvcykge1xuICAgIHJldHVybiBjYWxjTm9ybWFsKHBvcywgMC4wMDIpO1xuICB9XG5cbiAgLy8gQWRhcHRlZCBmcm9tIGZyb20gaHR0cHM6Ly93d3cuc2hhZGVydG95LmNvbS92aWV3L2xkZlNXc1xuICB2ZWMyIGNhbGNSYXlJbnRlcnNlY3Rpb24oIHZlYzMgcmF5T3JpZ2luLCB2ZWMzIHJheURpciwgZmxvYXQgbWF4ZCwgZmxvYXQgcHJlY2lzICkge1xuICAgIGZsb2F0IGxhdGVzdCA9IHByZWNpcyAqIDIuMDtcbiAgICBmbG9hdCBkaXN0ICAgPSArMC4wO1xuICAgIGZsb2F0IHR5cGUgICA9IC0xLjA7XG4gICAgdmVjMiByZXN1bHQ7XG4gICAgdmVjMiByZXMgPSB2ZWMyKC01MDAwMC4sIC0xLik7O1xuXG4gICAgZm9yIChpbnQgaSA9IDA7IGkgPCAke3N0ZXBzfSA7IGkrKykge1xuICAgICAgaWYgKGxhdGVzdCA8IHByZWNpcyB8fCBkaXN0ID4gbWF4ZCkgYnJlYWs7XG5cbiAgICAgIHJlc3VsdCA9IHNjZW5lKHJheU9yaWdpbiArIHJheURpciAqIGRpc3QpO1xuXG4gICAgICBsYXRlc3QgPSByZXN1bHQueDtcbiAgICAgIGRpc3QgICs9IGxhdGVzdDtcbiAgICB9XG5cbiAgICBpZiggZGlzdCA8IG1heGQgKSB7XG4gICAgICByZXN1bHQueCA9IGRpc3Q7XG4gICAgICByZXMgPSByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfVxuXG4gIGxheW91dChsb2NhdGlvbiA9IDApIG91dCB2ZWM0IGNvbDtcbiAgbGF5b3V0KGxvY2F0aW9uID0gMSkgb3V0IHZlYzQgZGVwdGg7XG4gIHZvaWQgbWFpbigpIHtcbiAgICB2ZWMyIHV2ID0gZ2xfRnJhZ0Nvb3JkLnh5IC8gcmVzb2x1dGlvbjtcbiAgICB2ZWMyIHBvcyA9IHV2ICogMi4wIC0gMS4wO1xuXG4gICAgLy8gbm90IHN1cmUgd2h5IEkgbmVlZCB0aGUgLXkgYXhpcyBidXQgd2l0aG91dCBpdFxuICAgIC8vIGV2ZXJ5dGhpbmcgaXMgZmxpcHBlZCB1c2luZyBwZXJzcGVjdGl2ZS1jYW1lcmFcbiAgICBwb3MueCAqPSAoIHJlc29sdXRpb24ueCAvIC1yZXNvbHV0aW9uLnkgKTtcblxuICAgIHZlYzMgY29sb3IgPSBiZzsgXG4gICAgdmVjMyBybyA9IGNhbWVyYV9wb3M7XG4gICAgdmVjMyByZCA9IG5vcm1hbGl6ZSggbWF0MyhjYW1lcmEpICogdmVjMyggcG9zLCAyLiApICk7IFxuICAgIFxuICAgIHZlYzIgdCA9IGNhbGNSYXlJbnRlcnNlY3Rpb24oIHJvLCByZCwgJHttYXhEaXN0YW5jZX0sICR7bWluRGlzdGFuY2V9ICk7XG5cbiAgICB2ZWMzIHNhbXBsZVBvcyA9IHZlYzMoMTAwLmYpO1xuICAgIC8vZmxvYXQgemRpc3QgPSAxMDAwMDAuOy8vdmVjMygxMDAwMDAuZik7XG4gICAgaWYoIHQueCA+IC0wLjUgKSB7XG4gICAgICBzYW1wbGVQb3MgPSBybyArIHJkICogdC54O1xuICAgICAgLy96ZGlzdCA9IHJkLnogKiB0Lng7XG4gICAgICB2ZWMzIG5vciA9IGNhbGNOb3JtYWwoIHNhbXBsZVBvcyApO1xuXG4gICAgICBjb2xvciA9IGxpZ2h0aW5nKCBzYW1wbGVQb3MsIG5vciwgcm8sIHJkLCB0LnksIHRydWUgKTsgXG4gICAgfVxuXG4gICAgJHtwb3N0cHJvY2Vzc2luZ31cbiAgICBcbiAgICBjb2wgPSBjbGFtcCggdmVjNCggY29sb3IsIDEuMCApLCAwLiwgMS4gKTtcblxuICAgIGZsb2F0IG5vcm1hbGl6ZWREZXB0aCA9IHQueCAvICR7bWF4RGlzdGFuY2V9OyAgLy8xLiAtIGV4cCggLXQueCApOy8vIDEuIC8gKDEuICsgYWJzKHNhbXBsZVBvcy56LXJvLnopICk7XG4gICAgZGVwdGggPSBhYnMoc2FtcGxlUG9zLnogLSByby56ICkgPCAke21heERpc3RhbmNlfSA/IHZlYzQoIHZlYzMoIDEuLW5vcm1hbGl6ZWREZXB0aCApLCAxLiApIDogdmVjNCgwLik7XG4gIH1gXG5cbiAgcmV0dXJuIG91dFxufVxuXG5jb25zdCBnZXRNYWluVm94ZWxzID0gZnVuY3Rpb24oIHN0ZXBzLCBwb3N0cHJvY2Vzc2luZywgdm94ZWxTaXplID0gLjEgKSB7XG4gIGNvbnN0IG91dCA9IGBcbiAgc3RydWN0IFZveGVsRGlzdGFuY2Uge1xuICAgIGJ2ZWMzIG1hc2s7XG4gICAgdmVjMyAgZGlzdGFuY2U7XG4gICAgZmxvYXQgZm9nQ29lZmY7XG4gICAgaW50ICAgaWQ7XG4gIH07XG5cbiAgVm94ZWxEaXN0YW5jZSBjYWxjUmF5SW50ZXJzZWN0aW9uKCB2ZWMzIHJheU9yaWdpbiwgdmVjMyByYXlEaXIgKSB7XG4gICAgdmVjMiByZXN1bHQ7XG5cbiAgICBmbG9hdCBtID0gJHt2b3hlbFNpemV9O1xuICAgIHJheU9yaWdpbiAqPSAxLi9tO1xuICAgIHZlYzMgbWFwUG9zID0gdmVjMyhmbG9vcihyYXlPcmlnaW4pKTtcbiAgICB2ZWMzIGRpZmYgPSBtYXBQb3MgLSByYXlPcmlnaW47XG5cbiAgICB2ZWMzIGRlbHRhRGlzdCA9IGFicyh2ZWMzKGxlbmd0aChyYXlEaXIpKSAvIHJheURpcik7XG4gICAgdmVjMyByYXlTdGVwID0gdmVjMyhzaWduKHJheURpcikpO1xuICAgIHZlYzMgc2lkZURpc3QgPSAoc2lnbihyYXlEaXIpICogZGlmZiArIChzaWduKHJheURpcikgKiAwLjUpICsgMC41KSAqIGRlbHRhRGlzdDsgXG5cbiAgICBidmVjMyBtYXNrO1xuICAgIHZlYzMgZCA9IHZlYzMoLTEwMDAwMC4pO1xuICAgIGZsb2F0IGZvZ0NvZWZmID0gMC47XG5cbiAgICBmb3IgKGludCBpID0gMDsgaSA8ICR7TWF0aC5yb3VuZChzdGVwcyoxL3ZveGVsU2l6ZSl9IDsgaSsrKSB7XG4gICAgICByZXN1bHQgPSBzY2VuZShtYXBQb3MqbSk7XG4gICAgICBpZiggcmVzdWx0LnggPD0gMC4gKSB7XG4gICAgICAgIGQgPSBtYXBQb3MqbStyZXN1bHQueDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIG1hc2sgPSBidmVjMyggbGVzc1RoYW5FcXVhbChzaWRlRGlzdC54eXosIG1pbihzaWRlRGlzdC55engsIHNpZGVEaXN0Lnp4eSkpICk7XG4gICAgICBzaWRlRGlzdCArPSB2ZWMzKCBtYXNrICkgKiBkZWx0YURpc3Q7IFxuICAgICAgbWFwUG9zICs9IHZlYzMobWFzaykgKiByYXlTdGVwO1xuICAgICAgZm9nQ29lZmYgKz0gcmVzdWx0LnggKiBtO1xuICAgIH1cblxuICAgIFZveGVsRGlzdGFuY2UgdmQgPSBWb3hlbERpc3RhbmNlKCBtYXNrLCBkLCBmb2dDb2VmZiwgaW50KHJlc3VsdC55KSApO1xuICAgIHJldHVybiB2ZDtcbiAgfVxuXG4gIG91dCB2ZWM0IGNvbDtcbiAgdm9pZCBtYWluKCkge1xuICAgIHZlYzIgdXYgPSBnbF9GcmFnQ29vcmQueHkgLyByZXNvbHV0aW9uO1xuICAgIHZlYzIgcG9zID0gdXYgKiAyLjAgLSAxLjA7XG5cbiAgICAvLyBub3Qgc3VyZSB3aHkgSSBuZWVkIHRoZSAteSBheGlzIGJ1dCB3aXRob3V0IGl0XG4gICAgLy8gZXZlcnl0aGluZyBpcyBmbGlwcGVkIHVzaW5nIHBlcnNwZWN0aXZlLWNhbWVyYVxuICAgIHBvcy54ICo9ICggcmVzb2x1dGlvbi54IC8gLXJlc29sdXRpb24ueSApO1xuICAgIFxuICAgIHZlYzMgY29sb3IgPSBiZzsgXG4gICAgdmVjMyBybyA9IGNhbWVyYV9wb3M7XG4gICAgdmVjMyByZCA9IG5vcm1hbGl6ZSggbWF0MyhjYW1lcmEpICogdmVjMyggcG9zLCAyLiApICk7IFxuICAgICAgICAgICAgICAgICBcbiAgICBWb3hlbERpc3RhbmNlIHZkID0gY2FsY1JheUludGVyc2VjdGlvbiggcm8sIHJkICk7XG4gICAgYnZlYzMgbWFzayA9IHZkLm1hc2s7XG4gICAgXG4gICAgdmVjMyBub3I7XG4gICAgaWYgKG1hc2sueCkge1xuICAgICAgY29sb3IgPSB2ZWMzKDAuNSk7XG4gICAgICBub3IgPSB2ZWMzKDEuLDAuLDAuKTtcbiAgICB9XG4gICAgaWYgKG1hc2sueSkge1xuICAgICAgY29sb3IgPSB2ZWMzKDEuMCk7XG4gICAgICBub3IgPSB2ZWMzKDAuLDEuLDAuKTtcbiAgICB9XG4gICAgaWYgKG1hc2sueikge1xuICAgICAgY29sb3IgPSB2ZWMzKDAuNzUpO1xuICAgICAgbm9yID0gdmVjMygwLiwwLiwxLik7XG4gICAgfVxuICAgIGlmKCB2ZC5kaXN0YW5jZS54ID09IC0xMDAwMDAuICkge1xuICAgICAgY29sb3IgPSBiZztcbiAgICB9XG4gICAgXG4gICAgZmxvYXQgbW9kQW1vdW50ID0gJHsoMS4vdm94ZWxTaXplKS50b0ZpeGVkKDEpfTtcbiAgICBpZiggY29sb3IgIT0gYmcgKSB7XG4gICAgICB2ZWMzIHBvcyA9IHZkLmRpc3RhbmNlOyBcbiAgICAgIC8vdmVjMyBwb3MgPSBybyArIHJkICogdmQuZm9nQ29lZmY7XG5cbiAgICAgIGNvbG9yICo9IGxpZ2h0aW5nKCBwb3MgKiBtb2RBbW91bnQsIG5vciwgcm8sIHJkLCBmbG9hdCh2ZC5pZCksIGZhbHNlICk7IFxuICAgICAgLy9jb2xvciAqPSBsaWdodGluZyggcG9zLCBub3IsIHJvLCByZCwgZmxvYXQodmQuaWQpLCBmYWxzZSApOyBcbiAgICAgIC8vY29sb3IgPSBtaW4oY29sb3IsMS4pO1xuICAgICAgLy9jb2xvciA9IGdldFRleHR1cmUoIDAsIHBvcyApO1xuICAgICAgXG4gICAgfVxuICAgIFxuICAgIHZlYzIgdCA9IHZlYzIoIHZkLmZvZ0NvZWZmLCB2ZC5pZCApO1xuICAke3Bvc3Rwcm9jZXNzaW5nfTsgXG4gICAgY29sID0gdmVjNCggY29sb3IsIDEuICk7IFxuICB9YFxuXG4gIHJldHVybiBvdXRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiggdmFyaWFibGVzLCBzY2VuZSwgcHJlZmFjZSwgZ2VvbWV0cmllcywgbGlnaHRpbmcsIHBvc3Rwcm9jZXNzaW5nLCBzdGVwcz05MCwgbWluRGlzdGFuY2U9LjAwMSwgbWF4RGlzdGFuY2U9MjAsIG9wcywgdm94ZWxTaXplPTAgKSB7XG5cbiAgY29uc3QgbWFpbiA9IHZveGVsU2l6ZSA9PT0gMFxuICAgID8gZ2V0TWFpbkNvbnRpbnVvdXMoIHN0ZXBzLCBtaW5EaXN0YW5jZSwgbWF4RGlzdGFuY2UsIHBvc3Rwcm9jZXNzaW5nICkgXG4gICAgOiBnZXRNYWluVm94ZWxzKCBzdGVwcywgcG9zdHByb2Nlc3NpbmcsIHZveGVsU2l6ZSApXG5cbiAgICBjb25zdCBmc19zb3VyY2UgPSBgICAgICAjdmVyc2lvbiAzMDAgZXNcbiAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuXG4gICAgICBmbG9hdCBQSSA9IDMuMTQxNTkyNjUzNTg5NzkzO1xuXG5cblxuICAgICAgc3RydWN0IExpZ2h0IHtcbiAgICAgICAgdmVjMyBwb3NpdGlvbjtcbiAgICAgICAgdmVjMyBjb2xvcjtcbiAgICAgICAgZmxvYXQgYXR0ZW51YXRpb247XG4gICAgICB9O1xuXG4gICAgICBpbnQgcm90YXRpb25Db3VudCA9IDE7XG5cbiAgICAgIG1hdDQgcm90YXRpb25zWzRdID0gbWF0NFs0XShcbiAgICAgICAgbWF0NCgwLiksIG1hdDQoMC4pLCBtYXQ0KDAuKSwgbWF0NCgwLilcbiAgICAgICk7XG5cbiAgICAgIHN0cnVjdCBNYXRlcmlhbCB7XG4gICAgICAgIGludCAgbW9kZTtcbiAgICAgICAgdmVjMyBhbWJpZW50O1xuICAgICAgICB2ZWMzIGRpZmZ1c2U7XG4gICAgICAgIHZlYzMgc3BlY3VsYXI7XG4gICAgICAgIGZsb2F0IHNoaW5pbmVzcztcbiAgICAgICAgdmVjMyBmcmVzbmVsO1xuICAgICAgICBpbnQgdGV4dHVyZUlEO1xuICAgICAgfTsgICAgIFxuXG4gICAgICBzdHJ1Y3QgU0RGIHtcbiAgICAgICAgaW50IG1hdGVyaWFsSUQ7XG4gICAgICAgIG1hdDQgdHJhbnNmb3JtO1xuICAgICAgICBpbnQgdGV4dHVyZUlEO1xuICAgICAgICB2ZWMzIHJlcGVhdDtcbiAgICAgICAgbWF0NCByZXBlYXRUcmFuc2Zvcm07XG4gICAgICB9O1xuXG4gICAgICB1bmlmb3JtIGZsb2F0IHRpbWU7XG4gICAgICB1bmlmb3JtIHZlYzIgcmVzb2x1dGlvbjtcbiAgICAgIHVuaWZvcm0gdmVjMyBjYW1lcmFfcG9zO1xuICAgICAgdW5pZm9ybSB2ZWMzIGNhbWVyYV9ub3JtYWw7XG4gICAgICB1bmlmb3JtIGZsb2F0IGNhbWVyYV9yb3Q7XG4gICAgICB1bmlmb3JtIG1hdDQgY2FtZXJhO1xuXG4gICAgICBcblxuICAgICAgJHt2YXJpYWJsZXN9XG5cbiAgICAgIC8vIG11c3QgYmUgYmVmb3JlIGdlb21ldHJpZXMhXG4gICAgICBmbG9hdCBsZW5ndGg4KCB2ZWMyIHAgKSB7IFxuICAgICAgICByZXR1cm4gZmxvYXQoIHBvdyggcG93KHAueCw4LikrcG93KHAueSw4LiksIDEuLzguICkgKTsgXG4gICAgICB9XG5cbiAgICAgICR7b3BzfVxuXG4gICAgICAvKiBHRU9NRVRSSUVTICovXG4gICAgICAke2dlb21ldHJpZXN9XG5cbiAgICAgIHZlYzIgc2NlbmUodmVjMyBwKTtcblxuICAgICAgLy8gWFhYIHRvZG8gcHV0IHRoaXMgaW4gZG9tYWluT3BlcmF0aW9ucy5qc1xuICAgICAgdmVjMyBwb2xhclJlcGVhdCh2ZWMzIHAsIGZsb2F0IHJlcGV0aXRpb25zKSB7XG4gICAgICAgIGZsb2F0IGFuZ2xlID0gMi4qUEkvcmVwZXRpdGlvbnM7XG4gICAgICAgIGZsb2F0IGEgPSBhdGFuKHAueiwgcC54KSArIGFuZ2xlLzIuO1xuICAgICAgICBmbG9hdCByID0gbGVuZ3RoKHAueHopO1xuICAgICAgICBmbG9hdCBjID0gZmxvb3IoYS9hbmdsZSk7XG4gICAgICAgIGEgPSBtb2QoYSxhbmdsZSkgLSBhbmdsZS8yLjtcbiAgICAgICAgdmVjMyBfcCA9IHZlYzMoIGNvcyhhKSAqIHIsIHAueSwgIHNpbihhKSAqIHIgKTtcbiAgICAgICAgLy8gRm9yIGFuIG9kZCBudW1iZXIgb2YgcmVwZXRpdGlvbnMsIGZpeCBjZWxsIGluZGV4IG9mIHRoZSBjZWxsIGluIC14IGRpcmVjdGlvblxuICAgICAgICAvLyAoY2VsbCBpbmRleCB3b3VsZCBiZSBlLmcuIC01IGFuZCA1IGluIHRoZSB0d28gaGFsdmVzIG9mIHRoZSBjZWxsKTpcbiAgICAgICAgaWYgKGFicyhjKSA+PSAocmVwZXRpdGlvbnMvMi4pKSBjID0gYWJzKGMpO1xuICAgICAgICByZXR1cm4gX3A7XG4gICAgICB9XG5cbiAgICAgIC8vIGFkZGVkIGsgdmFsdWUgdG8gZ2xzbC1zZGYtb3BzL3NvZnQtc2hhZG93XG4gICAgICBmbG9hdCBzb2Z0c2hhZG93KCBpbiB2ZWMzIHJvLCBpbiB2ZWMzIHJkLCBpbiBmbG9hdCBtaW50LCBpbiBmbG9hdCB0bWF4LCBpbiBmbG9hdCBrICl7XG4gICAgICAgIGZsb2F0IHJlcyA9IDEuMDtcbiAgICAgICAgZmxvYXQgdCA9IG1pbnQ7XG5cbiAgICAgICAgZm9yKCBpbnQgaSA9IDA7IGkgPCAxMjsgaSsrICkge1xuICAgICAgICAgIGZsb2F0IGggPSBzY2VuZSggcm8gKyByZCAqIHQgKS54O1xuICAgICAgICAgIHJlcyA9IG1pbiggcmVzLCBrICogaCAvIHQgKTtcbiAgICAgICAgICB0ICs9IGNsYW1wKCBoLCAwLjAyLCAwLjEwICk7XG4gICAgICAgICAgaWYoIGg8MC4wMDEgfHwgdD50bWF4ICkgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2xhbXAoIHJlcywgMC4wLCAxLjAgKTtcbiAgICAgIH1cblxuJHtsaWdodGluZ31cblxuICAgIHZlYzIgc2NlbmUodmVjMyBfcCApIHtcbiAgICAgIHZlYzQgcCA9IHZlYzQoIF9wLCAxLiApO1xuJHtwcmVmYWNlfVxuICAgICAgcmV0dXJuICR7c2NlbmV9O1xuICAgIH1cbiBcbiR7bWFpbn1cbmBcblxuICAgIHJldHVybiBmc19zb3VyY2VcbiAgfVxuIiwiY29uc3QgZ2V0Rm9nID0gcmVxdWlyZSggJy4vZm9nLmpzJyApXG5jb25zdCB2aWduZXR0ZSA9IHJlcXVpcmUoICcuL3ZpZ25ldHRlLmpzJyApXG5jb25zdCB7IHBhcmFtX3dyYXAsIE1hdGVyaWFsSUQgfSA9IHJlcXVpcmUoICcuL3V0aWxzLmpzJyApXG5jb25zdCBfX2xpZ2h0aW5nID0gcmVxdWlyZSggJy4vbGlnaHRpbmcuanMnIClcbmNvbnN0IHsgVmFyLCBmbG9hdF92YXJfZ2VuLCB2ZWMyX3Zhcl9nZW4sIHZlYzNfdmFyX2dlbiwgdmVjNF92YXJfZ2VuLCBpbnRfdmFyX2dlbiwgVmFyQWxsb2MgfSA9IHJlcXVpcmUoJy4vdmFyLmpzJylcblxuY29uc3QgZ2V0U2NlbmUgPSBmdW5jdGlvbiggU0RGICkge1xuXG4gIFNjZW5lID0gZnVuY3Rpb24oIG9ianMsIGNhbnZhcywgc3RlcHM9MTAwLCBtaW5EaXN0YW5jZT0uMDAxLCBtYXhEaXN0YW5jZT00MCwgc2l6ZT0yLCBzaG91bGRBbmltYXRlPWZhbHNlICkge1xuICAgIGNvbnN0IHNjZW5lICA9IE9iamVjdC5jcmVhdGUoIFNjZW5lLnByb3RvdHlwZSApXG5cbiAgICBNYXRlcmlhbElELmNsZWFyKClcblxuICAgIFNERi5saWdodGluZy5saWdodHMgPSBbXVxuXG4gICAgc2NlbmUuX19wcmVyZW5kZXIgPSBvYmpzXG4gICAgaWYoIG9ianMubGVuZ3RoID4gMSApIHtcbiAgICAgIC8vIHJlZHVjZSBvYmplY3RzIHRvIG5lc3RlZCBVbmlvbnNcbiAgICAgIHNjZW5lLl9fcHJlcmVuZGVyID0gb2Jqcy5yZWR1Y2UoICggY3VycmVudCwgbmV4dCApID0+IFNERi5VbmlvbiggY3VycmVudCwgbmV4dCApIClcbiAgICB9XG5cbiAgICBPYmplY3QuYXNzaWduKCBzY2VuZSwgeyBcbiAgICAgIG9ianMsIFxuICAgICAgY2FudmFzLFxuICAgICAgcG9zdHByb2Nlc3Npbmc6W10sXG4gICAgICBfX3NoYWRvdzo4LFxuICAgICAgX19mb2xsb3dMaWdodDpudWxsXG4gICAgfSlcblxuICAgIHNjZW5lLmFuaW1hdGUoIHNob3VsZEFuaW1hdGUgKVxuICAgICAgLnN0ZXBzKCBzdGVwcyApXG4gICAgICAudGhyZXNob2xkKCBtaW5EaXN0YW5jZSApXG4gICAgICAuZmFyUGxhbmUoIG1heERpc3RhbmNlIClcbiAgICAgIC5yZXNvbHV0aW9uKCAxIClcblxuICAgIHNjZW5lLnVzZVF1YWxpdHkgPSB0cnVlXG4gICAgc2NlbmUudXNlVm94ZWxzICA9IGZhbHNlXG5cbiAgICBTREYuX19zY2VuZSA9IHNjZW5lXG5cbiAgICByZXR1cm4gc2NlbmVcbiAgfVxuXG4gIFNjZW5lLnByb3RvdHlwZSA9IHtcbiAgICBhbmltYXRlKCB2ICkgeyB0aGlzLl9fYW5pbWF0ZSA9IHY7IHJldHVybiB0aGlzIH0sICBcbiAgICByZXNvbHV0aW9uKCB2ICkgeyBcbiAgICAgIHRoaXMud2lkdGggPSBNYXRoLmZsb29yKCB0aGlzLmNhbnZhcy53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoICogdiApXG4gICAgICB0aGlzLmhlaWdodCA9IE1hdGguZmxvb3IoIHRoaXMuY2FudmFzLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCAqIHYgKVxuICAgICAgXG4gICAgICB0aGlzLl9fcmVzb2x1dGlvbiA9IHY7XG4gICAgICB0aGlzLnVzZVF1YWxpdHkgPSBmYWxzZVxuICAgICAgcmV0dXJuIHRoaXMgXG4gICAgfSwgIFxuICAgIHZveGVsKCB2ID0gLjEgKSB7IFxuICAgICAgdGhpcy51c2VWb3hlbHMgPSB0cnVlXG4gICAgICB0aGlzLl9fdm94ZWxTaXplID0gdlxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuICAgIHRocmVzaG9sZCggdiApIHsgdGhpcy5fX3RocmVzaG9sZCA9IHY7IHRoaXMudXNlUXVhbGl0eSA9IGZhbHNlOyByZXR1cm4gdGhpcyB9LCAgXG4gICAgc3RlcHMoIHYgKSB7IHRoaXMuX19zdGVwcyA9IHY7IHRoaXMudXNlUXVhbGl0eSA9IGZhbHNlOyByZXR1cm4gdGhpcyB9LCAgXG4gICAgZmFyUGxhbmUoIHYgKSB7IHRoaXMuX19mYXJQbGFuZSA9IHY7IHRoaXMudXNlUXVhbGl0eSA9IGZhbHNlOyAgcmV0dXJuIHRoaXMgfSwgIFxuICAgIGNhbWVyYSggeD0wLCB5PTAsIHo9NSwgc3BlZWQ9MSApIHtcbiAgICAgIFNERi5jYW1lcmEuX19jYW1lcmEucG9zaXRpb25bMF0gPSB4XG4gICAgICBTREYuY2FtZXJhLl9fY2FtZXJhLnBvc2l0aW9uWzFdID0geVxuICAgICAgU0RGLmNhbWVyYS5fX2NhbWVyYS5wb3NpdGlvblsyXSA9IHpcbiAgICAgIFNERi5jYW1lcmEuX19jYW1lcmEucm90YXRpb25TcGVlZCA9IHNwZWVkICogLjAxXG4gICAgICBTREYuY2FtZXJhLl9fY2FtZXJhLnBvc2l0aW9uU3BlZWQgPSBzcGVlZCAqIC0uMjVcbiAgICAgIFNERi5jYW1lcmEudXBkYXRlKClcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSxcbiAgICBzaGFkb3coIGs9MCApIHtcbiAgICAgIHRoaXMuX19zaGFkb3cgPSBrO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBxdWFsaXR5KCBxdWFsaXR5PTEwICkge1xuICAgICAgdGhpcy50aHJlc2hvbGQoIC4xIC8gKHF1YWxpdHkgKiBxdWFsaXR5ICogcXVhbGl0eSApIClcbiAgICAgIHRoaXMuc3RlcHMoIHF1YWxpdHkgKiAyMCApXG4gICAgICB0aGlzLmZhclBsYW5lKCBxdWFsaXR5ICogNSApXG4gICAgICB0aGlzLnJlc29sdXRpb24oIE1hdGgubWluKCAuMiAqIHF1YWxpdHksIDIgKSApXG5cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSxcbiAgICBmb2xsb3coIGxpZ2h0LCBkaXN0YW5jZT0zICkge1xuICAgICAgdGhpcy5fX2ZvbGxvd0xpZ2h0ID0gbGlnaHRcbiAgICAgIFNERi5jYW1lcmEub25tb3ZlID0gZnVuY3Rpb24oIGNhbWVyYSApIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gU0RGLmNhbWVyYS5vZmZzZXQoKVxuICAgICAgICBsaWdodC5wb3MueCA9IFNERi5jYW1lcmEuX19jYW1lcmEucG9zaXRpb25bMF0gLSBvZmZzZXRbMF1cbiAgICAgICAgbGlnaHQucG9zLnkgPSBTREYuY2FtZXJhLl9fY2FtZXJhLnBvc2l0aW9uWzFdIC0gb2Zmc2V0WzFdXG4gICAgICAgIGxpZ2h0LnBvcy56ID0gU0RGLmNhbWVyYS5fX2NhbWVyYS5wb3NpdGlvblsyXSAtIG9mZnNldFsyXVxuICAgICAgICBsaWdodC5kaXJ0eSA9IHRydWVcbiAgICAgIH1cbiAgICAgIFNERi5saWdodGluZy5saWdodHMgPSBbbGlnaHRdXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG4gICAgbGlnaHQoIC4uLmxpZ2h0cyApIHtcbiAgICAgIFNERi5saWdodGluZy5saWdodHMgPSBTREYubGlnaHRpbmcubGlnaHRzLmNvbmNhdCggbGlnaHRzIClcbiAgICAgIGlmKCB0aGlzLl9fZm9sbG93TGlnaHQgIT09IG51bGwgKSBTREYubGlnaHRpbmcubGlnaHRzLnB1c2goIHRoaXMuX19mb2xsb3dMaWdodCApXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG4gICAgZm9nOiBnZXRGb2coIFNjZW5lLCBTREYgKSxcbiAgICB2aWduZXR0ZTogdmlnbmV0dGUoIFNjZW5lLCBTREYgKSxcbiAgICBiYWNrZ3JvdW5kOiByZXF1aXJlKCAnLi9iYWNrZ3JvdW5kLmpzJyApKCBTY2VuZSwgU0RGICksXG4gICAgcHJlc2V0czoge1xuICAgICAgJ2ZyYWN0YWwuY2xvc2UnOiB7XG4gICAgICAgIGZhclBsYW5lOjEsXG4gICAgICAgIHJlc29sdXRpb246MSxcbiAgICAgICAgc3RlcHM6MTUwLFxuICAgICAgICBhbmltYXRlZDp0cnVlLFxuICAgICAgICB0aHJlc2hvbGQ6LjAwMDEyNVxuICAgICAgfSxcbiAgICAgICdmcmFjdGFsLmtpbmRhY2xvc2UnOiB7XG4gICAgICAgIGZhclBsYW5lOjIsXG4gICAgICAgIHJlc29sdXRpb246MSxcbiAgICAgICAgc3RlcHM6MjUwLFxuICAgICAgICBhbmltYXRlZDp0cnVlLFxuICAgICAgICB0aHJlc2hvbGQ6LjAwMDEyNS8yXG4gICAgICB9LFxuICAgICAgJ2ZyYWN0YWwubWVkJzoge1xuICAgICAgICBmYXJQbGFuZTo1LFxuICAgICAgICByZXNvbHV0aW9uOi43NSxcbiAgICAgICAgc3RlcHM6ODAsXG4gICAgICAgIGFuaW1hdGVkOnRydWUsXG4gICAgICAgIHRocmVzaG9sZDouMDAxLFxuICAgICAgfSxcbiAgICAgICdmcmFjdGFsLmxvdyc6IHtcbiAgICAgICAgZmFyUGxhbmU6My4wLFxuICAgICAgICByZXNvbHV0aW9uOi41LFxuICAgICAgICBhbmltYXRlZDp0cnVlLFxuICAgICAgICBzdGVwczo1MCxcbiAgICAgICAgdGhyZXNob2xkOi4wMDUsXG4gICAgICB9LFxuICAgICAgJ2ZyYWN0YWwuaGlnaCc6IHtcbiAgICAgICAgZmFyUGxhbmU6MTAsXG4gICAgICAgIHJlc29sdXRpb246MSxcbiAgICAgICAgYW5pbWF0ZWQ6dHJ1ZSxcbiAgICAgICAgc3RlcHM6MTAwLFxuICAgICAgICB0aHJlc2hvbGQ6LjAwMSxcbiAgICAgIH0sXG4gICAgICAncmVwZWF0Lmxvdyc6IHtcbiAgICAgICAgZmFyUGxhbmU6MjUsXG4gICAgICAgIHJlc29sdXRpb246LjUsXG4gICAgICAgIGFuaW1hdGVkOnRydWUsXG4gICAgICAgIHN0ZXBzOjUwXG4gICAgICB9LFxuICAgICAgJ3JlcGVhdC5tZWQnOiB7XG4gICAgICAgIGZhclBsYW5lOjM1LFxuICAgICAgICByZXNvbHV0aW9uOjEsXG4gICAgICAgIGFuaW1hdGVkOnRydWUsXG4gICAgICAgIHN0ZXBzOjc1XG4gICAgICB9LFxuICAgICAgJ3JlcGVhdC5oaWdoJzoge1xuICAgICAgICBmYXJQbGFuZTo0MCxcbiAgICAgICAgcmVzb2x1dGlvbjoxLFxuICAgICAgICBhbmltYXRlZDp0cnVlLFxuICAgICAgICBzdGVwczoxMDBcbiAgICAgIH0sXG4gICAgICAndm94ZWwuaGlnaCc6IHtcbiAgICAgICAgcmVzb2x1dGlvbjoxLFxuICAgICAgICBhbmltYXRlZDp0cnVlLFxuICAgICAgICBzdGVwczozMFxuICAgICAgfSxcbiAgICAgICd2b3hlbC5tZWQnOiB7XG4gICAgICAgIHJlc29sdXRpb246MSxcbiAgICAgICAgYW5pbWF0ZWQ6dHJ1ZSxcbiAgICAgICAgc3RlcHM6MjBcbiAgICAgIH0sXG4gICAgICAndm94ZWwubG93Jzoge1xuICAgICAgICByZXNvbHV0aW9uOi41LFxuICAgICAgICBhbmltYXRlZDp0cnVlLFxuICAgICAgICBzdGVwczoxMFxuICAgICAgfSxcbiAgICAgIGxvdzoge1xuICAgICAgICB0aHJlc2hvbGQ6LjA1LFxuICAgICAgICBzdGVwczo0NSxcbiAgICAgICAgZmFyUGxhbmU6MTIsXG4gICAgICAgIHJlc29sdXRpb246LjQsXG4gICAgICAgIGFuaW1hdGVkOnRydWVcbiAgICAgIH0sXG4gICAgICBtZWRpdW06IHtcbiAgICAgICAgdGhyZXNob2xkOi4wMSxcbiAgICAgICAgc3RlcHM6ODAsXG4gICAgICAgIGZhclBsYW5lOjE4LFxuICAgICAgICByZXNvbHV0aW9uOi41LFxuICAgICAgICBhbmltYXRlZDp0cnVlXG4gICAgICB9LFxuICAgICAgbWVkOiB7XG4gICAgICAgIHRocmVzaG9sZDouMDEsXG4gICAgICAgIHN0ZXBzOjgwLFxuICAgICAgICBmYXJQbGFuZToxOCxcbiAgICAgICAgcmVzb2x1dGlvbjouNSxcbiAgICAgICAgYW5pbWF0ZWQ6dHJ1ZVxuICAgICAgfSxcbiAgICAgIGhpZ2g6IHtcbiAgICAgICAgdGhyZXNob2xkOi4wMDUsXG4gICAgICAgIHN0ZXBzOjkwLFxuICAgICAgICBmYXJQbGFuZToyMCxcbiAgICAgICAgcmVzb2x1dGlvbjoxLFxuICAgICAgICBhbmltYXRlZDp0cnVlXG4gICAgICB9XG4gICAgfSxcblxuICAgIGFwcGx5UHJlc2V0KCBwcmVzZXROYW1lICkge1xuICAgICAgY29uc3QgcHJlc2V0ID0gdGhpcy5wcmVzZXRzWyBwcmVzZXROYW1lIF1cbiAgICAgIGlmKCBwcmVzZXQuZmFyUGxhbmUgIT09IHVuZGVmaW5lZCApIHRoaXMuZmFyUGxhbmUoIHByZXNldC5mYXJQbGFuZSApXG4gICAgICB0aGlzLnN0ZXBzKCBwcmVzZXQuc3RlcHMgKVxuICAgICAgdGhpcy5yZXNvbHV0aW9uKCBwcmVzZXQucmVzb2x1dGlvbiApXG4gICAgICB0aGlzLnRocmVzaG9sZCggcHJlc2V0LnRocmVzaG9sZCB8fCAuMDAxIClcblxuICAgICAgcmV0dXJuIHByZXNldC5hbmltYXRlZFxuICAgIH0sXG5cbiAgICBwb3N0KCAuLi5meCApIHtcbiAgICAgIFNERi5meC5wb3N0KCAuLi5meCApXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH0sXG5cbiAgICByZW5kZXIoIHF1YWxpdHk9MTAsIGFuaW1hdGU9ZmFsc2UsIHVzZVF1YWxpdHk9dHJ1ZSApIHtcbiAgICAgIHRoaXMuYmFja2dyb3VuZCgpIC8vIGFkZHMgZGVmYXVsdCBpZiBub25lIGhhcyBiZWVuIHNwZWNpZmllZFxuICAgICAgaWYoIHR5cGVvZiBxdWFsaXR5ID09PSAnc3RyaW5nJyApIHtcbiAgICAgICAgYW5pbWF0ZSA9IHRoaXMuYXBwbHlQcmVzZXQoIHF1YWxpdHkgKVxuICAgICAgfWVsc2UgaWYoIHRoaXMudXNlUXVhbGl0eSA9PT0gdHJ1ZSApIHtcbiAgICAgICAgdGhpcy5xdWFsaXR5KCBxdWFsaXR5IClcbiAgICAgIH1cbiAgICAgIHRoaXMuYW5pbWF0ZSggYW5pbWF0ZSApXG5cbiAgICAgIFNERi5kaXN0YW5jZU9wcy5fX2NsZWFyKClcbiAgICAgIFNERi50ZXh0dXJlcy5jbGVhcigpXG4gICAgICBjb25zdCBnZW9tZXRyaWVzID0gU0RGLnByaW1pdGl2ZXMuZW1pdF9nZW9tZXRyaWVzKClcblxuICAgICAgbGV0IFsgdmFyaWFibGVzRGVjbGFyYXRpb24sIHNjZW5lUmVuZGVyaW5nLCBwb3N0cHJvY2Vzc2luZyBdID0gU0RGLmdlbmVyYXRlU0RGKCB0aGlzIClcblxuICAgICAgY29uc3QgbGlnaHRpbmcgPSBTREYubGlnaHRpbmcuZ2VuKCB0aGlzLl9fc2hhZG93LCBnZW9tZXRyaWVzIClcbiAgICAgIHZhcmlhYmxlc0RlY2xhcmF0aW9uICs9IFNERi5tYXRlcmlhbHMuZW1pdF9kZWNsKCkgXG4gICAgICB2YXJpYWJsZXNEZWNsYXJhdGlvbiArPSBTREYudGV4dHVyZXMuZW1pdF9kZWNsKCkgXG4gICAgICB2YXJpYWJsZXNEZWNsYXJhdGlvbiArPSBTREYubGlnaHRpbmcuZW1pdF9kZWNsKCkgXG5cbiAgICAgIHRoaXMuZnMgPSBTREYucmVuZGVyRnJhZ21lbnRTaGFkZXIoIFxuICAgICAgICB2YXJpYWJsZXNEZWNsYXJhdGlvbiwgXG4gICAgICAgIHNjZW5lUmVuZGVyaW5nLm91dCwgXG4gICAgICAgIHNjZW5lUmVuZGVyaW5nLnByZWZhY2UsXG4gICAgICAgIFNERi5yZXF1aXJlZEdlb21ldHJpZXMuam9pbignXFxuJykgKyBTREYucmVxdWlyZWRPcHMuam9pbignXFxuJyksXG4gICAgICAgIGxpZ2h0aW5nLFxuICAgICAgICBwb3N0cHJvY2Vzc2luZywgXG4gICAgICAgIHRoaXMuX19zdGVwcywgdGhpcy5fX3RocmVzaG9sZCwgdGhpcy5fX2ZhclBsYW5lLnRvRml4ZWQoMSksXG4gICAgICAgIFNERi5kaXN0YW5jZU9wcy5fX2dldEdMU0woKSxcbiAgICAgICAgdGhpcy51c2VWb3hlbHMgPyB0aGlzLl9fdm94ZWxTaXplIDogMFxuICAgICAgKVxuXG4gICAgICBTREYuc3RhcnQoIHRoaXMuZnMsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB0aGlzLl9fYW5pbWF0ZSApXG5cbiAgICAgIC8vU0RGLm1hdGVyaWFscy5tYXRlcmlhbHMubGVuZ3RoID0gMFxuXG4gICAgICB0aGlzLnVzZVF1YWxpdHkgPSB0cnVlXG5cbiAgICAgIHJldHVybiB0aGlzXG4gICAgfSxcblxuICB9XG5cbiAgcmV0dXJuIFNjZW5lXG5cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRTY2VuZSBcbiIsImNvbnN0IFNjZW5lTm9kZSA9ICgpPT4gT2JqZWN0LmNyZWF0ZSggU2NlbmVOb2RlLnByb3RvdHlwZSApXG5jb25zdCBNYXRyaXggPSByZXF1aXJlKCAnLi9leHRlcm5hbC9tYXRyaXguanMnIClcblxuU2NlbmVOb2RlLnByb3RvdHlwZSA9IHtcblx0ZW1pdCgpIHsgcmV0dXJuIFwiI05vdEltcGxlbWVudGVkI1wiOyB9LFxuXG5cdGVtaXRfZGVjbCgpIHsgcmV0dXJuIFwiXCI7IH0sXG5cblx0dXBkYXRlX2xvY2F0aW9uKGdsLCBwcm9ncmFtKSB7fSxcblxuICB1cGxvYWRfZGF0YShnbCkge30sXG5cbiAgZ2V0SUQoKSB7XG4gICAgbGV0IGlkID0gdGhpcy5pZFxuXG4gICAgaWYoIGlkID09PSB1bmRlZmluZWQgJiYgdGhpcy5zZGYgIT09IHVuZGVmaW5lZCApIHtcbiAgICAgIGlkID0gdGhpcy5zZGYuZ2V0SUQoKVxuICAgIH1cblxuICAgIHJldHVybiBpZFxuICB9LFxuXG4gIGdldENlbnRlcigpIHtcbiAgICBsZXQgY2VudGVyID0gdGhpcy5jZW50ZXJcblxuICAgIGlmKCBjZW50ZXIgPT09IHVuZGVmaW5lZCAmJiB0aGlzLnNkZiAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgaWYoIHRoaXMuc2RmLmdldENlbnRlciA9PT0gdW5kZWZpbmVkICkge1xuICAgICAgICBjZW50ZXIgPSB0aGlzLnNkZi5fX3dyYXBwZWQuZ2V0Q2VudGVyKClcbiAgICAgIH1lbHNle1xuICAgICAgICBjZW50ZXIgPSB0aGlzLnNkZi5nZXRDZW50ZXIoKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjZW50ZXJcbiAgfSxcblxuICBtb3ZlKCAuLi5hcmdzICkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zbGF0ZSggLi4uYXJncyApXG4gIH0sXG5cbiAgcm90YXRlKCBhbmdsZSwgeCx5LHogKSB7XG4gICAgdGhpcy50cmFuc2Zvcm0ucm90YXRpb24uYW5nbGUgPSBhbmdsZVxuICAgIGlmKCB4ICE9PSB1bmRlZmluZWQgKSB0aGlzLnRyYW5zZm9ybS5yb3RhdGlvbi5heGlzLnggPSB4XG4gICAgaWYoIHkgIT09IHVuZGVmaW5lZCApIHRoaXMudHJhbnNmb3JtLnJvdGF0aW9uLmF4aXMueSA9IHlcbiAgICBpZiggeiAhPT0gdW5kZWZpbmVkICkgdGhpcy50cmFuc2Zvcm0ucm90YXRpb24uYXhpcy56ID0gelxuICBcbiAgICByZXR1cm4gdGhpc1xuICB9LFxuXG4gIHJvdGF0ZUJ5KCBhbmdsZSx4LHkseiApIHtcbiAgICB0aGlzLnRyYW5zZm9ybS5fX3JvdGF0aW9ucy5wdXNoKCBNYXRyaXgucm90YXRlKCBhbmdsZSx4LHkseiApIClcbiAgICByZXR1cm4gdGhpc1xuICB9LFxuXG4gIHRyYW5zbGF0ZSggeCx5LHogKSB7XG4gICAgaWYoIHggIT09IHVuZGVmaW5lZCAmJiB4ICE9PSBudWxsICkgdGhpcy50cmFuc2Zvcm0udHJhbnNsYXRpb24ueCA9IHhcbiAgICBpZiggeSAhPT0gdW5kZWZpbmVkICYmIHkgIT09IG51bGwgKSB0aGlzLnRyYW5zZm9ybS50cmFuc2xhdGlvbi55ID0geVxuICAgIGlmKCB6ICE9PSB1bmRlZmluZWQgJiYgeiAhPT0gbnVsbCApIHRoaXMudHJhbnNmb3JtLnRyYW5zbGF0aW9uLnogPSB6XG4gIFxuICAgIHJldHVybiB0aGlzXG4gIH0sXG5cbiAgc2NhbGUoIGFtb3VudCApIHtcbiAgICBpZiggYW1vdW50ICE9PSB1bmRlZmluZWQgKSB0aGlzLnRyYW5zZm9ybS5zY2FsZSA9IGFtb3VudFxuICAgIHJldHVybiB0aGlzXG4gIH0sXG5cbiAgbWF0ZXJpYWwoIG1hdCApIHtcbiAgICB0aGlzLl9fc2V0TWF0ZXJpYWwoIG1hdCApXG4gICAgcmV0dXJuIHRoaXNcbiAgfSxcblxuICB0ZXh0dXJlKCB0ZXgscHJvcHMgKSB7XG4gICAgdGhpcy5fX3NldFRleHR1cmUoIHRleCxwcm9wcyApXG4gICAgcmV0dXJuIHRoaXNcbiAgfSxcblxuICBidW1wKCB0ZXgsc3RyZW5ndGggKSB7XG4gICAgdGhpcy5fX3NldEJ1bXAoIHRleCxzdHJlbmd0aCApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxufVxuXG5jb25zdCBvcHMgPSBbICdyZXBlYXQnLCAncG9sYXJSZXBlYXQnLCAnZWxvbmdhdGlvbicgXVxuXG5vcHMuZm9yRWFjaCggb3AgPT4ge1xuICBjb25zdCBjb25zdHJ1Y3Rvck5hbWUgPSBvcFswXS50b1VwcGVyQ2FzZSgpICsgb3Auc2xpY2UoMSlcbiAgU2NlbmVOb2RlLnByb3RvdHlwZVsgb3AgXSA9IGZ1bmN0aW9uKCAuLi5hcmdzICkge1xuICAgIHRoaXNbIG9wIF0gPSB0aGlzWyBvcCBdLmJpbmQoIHRoaXMgKVxuICAgIE9iamVjdC5hc3NpZ24oIHRoaXNbIG9wIF0sIFNjZW5lTm9kZS5wcm90b3R5cGUgKVxuICAgIHRoaXMuX190YXJnZXQgPSB0aGlzWyBvcCBdXG4gICAgdGhpc1sgJ19fJytvcCBdID0gTWFyY2hpbmdbIGNvbnN0cnVjdG9yTmFtZSBdKCB0aGlzLCAuLi5hcmdzLCB0aGlzWyBvcCBdIClcbiAgICB0aGlzWyBvcCBdLnRyYW5zZm9ybSA9IHRoaXNbICdfXycrb3AgXS50cmFuc2Zvcm1cbiAgICByZXR1cm4gdGhpc1xuICB9XG59KVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNjZW5lTm9kZVxuIiwiY29uc3QgU2NlbmVOb2RlID0gcmVxdWlyZSggJy4vc2NlbmVOb2RlLmpzJyApLFxuICAgICAgZ2V0UGl4ZWxzID0gcmVxdWlyZSggJ2dldC1waXhlbHMnICksXG4gICAgICBjcmVhdGVUZXh0dXJlID0gcmVxdWlyZSggJ2dsLXRleHR1cmUyZCcgKSxcbiAgICAgIHsgcGFyYW1fd3JhcCwgTWF0ZXJpYWxJRCB9ID0gcmVxdWlyZSggJy4vdXRpbHMuanMnICksXG4gICAgICB7IFZhciwgZmxvYXRfdmFyX2dlbiwgdmVjMl92YXJfZ2VuLCB2ZWMzX3Zhcl9nZW4sIHZlYzRfdmFyX2dlbiwgaW50X3Zhcl9nZW4sIFZhckFsbG9jIH0gID0gcmVxdWlyZSggJy4vdmFyLmpzJyApLCBcbiAgICAgIHsgVmVjMiwgVmVjMywgVmVjNCB9ID0gcmVxdWlyZSggJy4vdmVjLmpzJyApXG5cblxuY29uc3QgX19UZXh0dXJlcyA9IGZ1bmN0aW9uKCBTREYgKSB7XG4gIGNvbnN0IGdlbnMgPSB7IFxuICAgIGludDogICBpbnRfdmFyX2dlbixcbiAgICBmbG9hdDogZmxvYXRfdmFyX2dlbixcbiAgICB2ZWMyOiB2ZWMyX3Zhcl9nZW4sXG4gICAgdmVjMzogdmVjM192YXJfZ2VuLFxuICAgIHZlYzQ6IHZlYzRfdmFyX2dlbixcbiAgfVxuXG4gIGNvbnN0IHZhcnMgPSB7IFxuICAgIHZlYzI6IFZlYzIsXG4gICAgdmVjMzogVmVjMyxcbiAgICB2ZWM0OiBWZWM0XG4gIH1cblxuICBjb25zdCBUZXh0dXJlcyA9IHtcbiAgICB0ZXh0dXJlczpbXSxcbiAgICBfX3RleHR1cmVzOltdLFxuXG4gICAgX190ZXh0dXJlUHJlZmFjZXM6W10sXG4gICAgX190ZXh0dXJlQm9kaWVzOiAgW10sXG5cbiAgICBfX3R5cGVzOiByZXF1aXJlKCAnLi90ZXh0dXJlRGVzY3JpcHRpb25zLmpzJyApLFxuICAgIF9fd3JhcCA6IHJlcXVpcmUoICcuL3RleHR1cmVXcmFwLmpzJyApLCBcbiAgICBcbiAgICBfX2VtaXRGdW5jdGlvbigpIHtcbiAgICAgIGxldCBwdXNoZWRXcmFwID0gZmFsc2VcblxuICAgICAgbGV0IGRlY2wgPSBgXG4gICAgICB2ZWMzIGdldFRleHR1cmUoIGludCBpZCwgdmVjMyBwb3MgKSB7XG4gICAgICAgIHZlYzMgdGV4O1xuICAgICAgICB2ZWMyIHBvczI7XG5cbiAgICAgICAgc3dpdGNoKCBpZCApIHtcXG5gXG4gICAgICBcbiAgICAgIFRleHR1cmVzLl9fdGV4dHVyZUJvZGllcy5sZW5ndGggPSAwXG5cbiAgICAgIGxldCBmdW5jZGVmcyA9ICcnXG4gICAgICB0aGlzLnRleHR1cmVzLmZvckVhY2goICh0LGkpID0+IHtcbiAgICAgICAgY29uc3QgbW9kZSA9IHQubW9kZSAhPT0gJzJkJyAmJiB0Lmdsc2wgIT09IHVuZGVmaW5lZCA/ICczZCcgOiAnMmQnXG5cbiAgICAgICAgLy8gYWRkIHRleHR1cmUgd3JhcCBmdW5jdGlvbiBpZiBuZWVkZWRcbiAgICAgICAgaWYoIG1vZGUgPT09ICcyZCcgJiYgcHVzaGVkV3JhcCA9PT0gZmFsc2UgKSB7XG4gICAgICAgICAgVGV4dHVyZXMuX190ZXh0dXJlQm9kaWVzLnB1c2goIFRleHR1cmVzLl9fd3JhcCApXG4gICAgICAgICAgcHVzaGVkV3JhcCA9IHRydWVcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGdsc2wgPSBtb2RlID09PSAnM2QnID8gdC5nbHNsIDogdC5nbHNsMmQgXG4gICAgICAgIGlmKCBUZXh0dXJlcy5fX3RleHR1cmVCb2RpZXMuaW5kZXhPZiggZ2xzbCApID09PSAtMSApIHsgXG4gICAgICAgICAgVGV4dHVyZXMuX190ZXh0dXJlQm9kaWVzLnB1c2goIGdsc2wgKVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYXJncyA9IHQucGFyYW1ldGVycy5tYXAoIHAgPT4gdC5fX3RhcmdldFsgcC5uYW1lIF0uZW1pdCgpICkgXG4gICAgICAgIGNvbnN0IGZ1bmN0aW9uTmFtZSA9IG1vZGUgPT09ICcyZCcgPyB0Lm5hbWUgKyAnMmQnIDogdC5uYW1lIFxuXG4gICAgICAgIC8vZGVjbCArPSBgXG4gICAgICAgIC8vICBjYXNlICR7aX06XG4gICAgICAgIC8vICAgICAgJHttb2RlID09PSAnMmQnIFxuICAgICAgICAvLyAgICAgID8gYCAgICBcbiAgICAgICAgLy8gICAgICB2ZWMzIG4gPSBub3JtYWxpemUoIHBvcyApO1xuICAgICAgICAvLyAgICAgIHZlYzQgdGV4eCA9ICB2ZWM0KCR7ZnVuY3Rpb25OYW1lfSggLjUqbi55eisuNSAkeyBhcmdzLmxlbmd0aCA+IDAgPyAnLCcgKyBhcmdzLmpvaW4oJywnKSA6ICcnfSApLCAxLik7XG4gICAgICAgIC8vICAgICAgdmVjNCB0ZXh5ID0gIHZlYzQoJHtmdW5jdGlvbk5hbWV9KCAuNSpuLnp4Ky41ICR7IGFyZ3MubGVuZ3RoID4gMCA/ICcsJyArIGFyZ3Muam9pbignLCcpIDogJyd9ICksIDEuKTtcbiAgICAgICAgLy8gICAgICB2ZWM0IHRleHogPSAgdmVjNCgke2Z1bmN0aW9uTmFtZX0oIC41Km4ueHkrLjUgJHsgYXJncy5sZW5ndGggPiAwID8gJywnICsgYXJncy5qb2luKCcsJykgOiAnJ30gKSwgMS4pO1xuICAgICAgICAvLyAgICAgIHRleCA9IHRyaXBsYW5hciggbiwgdGV4eCwgdGV4eSx0ZXh6LGZhbHNlLGZhbHNlICkueHl6O2BcbiAgICAgICAgLy8gICAgICA6IGAgXG4gICAgICAgIC8vICAgICAgdGV4ID0gJHtmdW5jdGlvbk5hbWV9KCBwb3MgJHsgYXJncy5sZW5ndGggPiAwID8gJywnICsgYXJncy5qb2luKCcsJykgOiAnJ30gKTtcbiAgICAgICAgLy8gICBgfVxuICAgICAgICAvLyAgICBicmVhaztcXG5gXG5cblxuICAgICAgICBkZWNsICs9YFxuICAgICAgICAgIGNhc2UgJHtpfTpcbiAgICAgICAgICAgICR7bW9kZSA9PT0gJzJkJyA/IGAgICAgIHBvczIgPSBnZXRVVkN1YmljKCBwb3MgKTtcXG5gIDogJyd9IFxuICAgICAgICAgICAgdGV4ID0gJHtmdW5jdGlvbk5hbWV9KCAke21vZGUgPT09ICcyZCcgPydwb3MyJzoncG9zJ30gJHsgYXJncy5sZW5ndGggPiAwID8gJywnICsgYXJncy5qb2luKCcsJykgOiAnJ30gKTtcbiAgICAgICAgICAgIGJyZWFrO1xcbmAgICAgICAgICAgICBcblxuICAgICAgfSlcblxuICAgICAgZGVjbCArPSBgXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRleCA9IHZlYzMoMC4pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGV4O1xuICAgICAgfVxuXG4gICAgICB2ZWMzIGdldFRleHR1cmUoIGludCBpZCwgdmVjMyBwb3MsIHZlYzMgbm9yLCBTREYgc2RmLCBib29sIHVzZVRyYW5zZm9ybSApIHtcbiAgICAgICAgdmVjMyB0ZXg7XG4gICAgICAgIHZlYzIgcG9zMjtcbiAgICAgICAgdmVjMyB0cG9zID0gcG9zO1xuICAgICAgICBpZiggdXNlVHJhbnNmb3JtID09IHRydWUgKSB7XG4gICAgICAgICAgaWYoIGxlbmd0aChzZGYucmVwZWF0KSAhPSAwLiApIHtcbiAgICAgICAgICAgIHRwb3MgPSBtb2QoICh2ZWM0KHBvcywxLikgKiBzZGYucmVwZWF0VHJhbnNmb3JtKS54eXosIHNkZi5yZXBlYXQpIC0gLjUgKiBzZGYucmVwZWF0O1xuICAgICAgICAgICAgdHBvcyA9ICggdmVjNCh0cG9zLCAxLikgKiBzZGYudHJhbnNmb3JtKS54eXo7XG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICB0cG9zID0gKHZlYzQodHBvcywxLikgKiBzZGYudHJhbnNmb3JtKS54eXo7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldFRleHR1cmUoIGlkLCB0cG9zICk7XG4gICAgICB9XG4gICAgICBgXG4gICAgIFxuICAgICAgcmV0dXJuIHsgZ2xzbGRlZnM6IFRleHR1cmVzLl9fdGV4dHVyZUJvZGllcy5qb2luKCAnXFxuJyApLCBtYWluZnVuYzpkZWNsIH1cbiAgICB9LFxuXG4gICAgY2xlYXIoKSB7XG4gICAgICBUZXh0dXJlcy50ZXh0dXJlcy5sZW5ndGggPSAwXG4gICAgfSxcblxuICAgIGFkZFRleHR1cmUoIHRleCApIHtcbiAgICAgIC8vIHdlIGhhdmUgdG8gZGlydHkgdGhlIHRleHR1cmUgc28gdGhhdCBpdHMgZGF0YVxuICAgICAgLy8gd2lsbCBiZSB1cGxvYWRlZCB0byBuZXcgc2hhZGVycywgb3RoZXJ3aXNlIHRoZVxuICAgICAgLy8gdGV4dHVyZSB3aWxsIG9ubHkgd29yayB0aGUgZmlyc3QgdGltZSBpdCdzIHVzZWQsIHdoZW5cbiAgICAgIC8vIGl0J3MgZGlydHkgb24gaW5pdGlhbGl6YXRpb24uXG4gICAgICBUZXh0dXJlcy5kaXJ0eSggdGV4IClcblxuICAgICAgLy8gaWYgdGV4dHVyZSB3aXRoIHNhbWUgbmFtZSBpcyBhbHJlYWR5IGZvdW5kLCByZXBsYWNlIGl0LFxuICAgICAgLy8gb3RoZXJ3aXNlIHB1c2ggdGV4dHVyZVxuICAgICAgLy9jb25zdCBvbGRUZXggPSBUZXh0dXJlcy50ZXh0dXJlcy5maW5kKCBfX3RleCA9PiB0ZXgubmFtZSA9PT0gX190ZXgubmFtZSApXG4gICAgICAvL2lmKCBvbGRUZXggIT09IHVuZGVmaW5lZCApIHtcbiAgICAgIC8vICBjb25zdCBpZHggPSBUZXh0dXJlcy50ZXh0dXJlcy5pbmRleE9mKCBvbGRUZXggKVxuICAgICAgLy8gIFRleHR1cmVzLnRleHR1cmVzLnNwbGljZSggaWR4LCAxLCB0ZXggKVxuXG4gICAgICAvLyAgdGV4LmlkID0gaWR4IFxuICAgICAgLy99ZWxzZXtcbiAgICAgICAgdGV4LmlkID0gVGV4dHVyZXMudGV4dHVyZXMubGVuZ3RoXG4gICAgICAgIFRleHR1cmVzLnRleHR1cmVzLnB1c2goIHRleCApXG4gICAgICAvL31cblxuICAgICAgcmV0dXJuIHRleFxuICAgIH0sXG5cbiAgICB0ZXh0dXJlKCBwcmVzZXROYW1lPSdub2lzZScsIHByb3BzPXt9LCB0YXJnZXQ9bnVsbCApe1xuICAgICAgLy9jb25zdCBpc1ByZXNldCA9IGZpbGVuYW1lT3JQcmVzZXQuaW5kZXhPZiggJy4nICkgPT09IC0xXG4gICAgICAvL2NvbnN0IGRlZmF1bHRzID0geyB3cmFwOlNERi5nbC5NSVJST1JFRF9SRVBFQVQgfVxuXG4gICAgICBpZiggVGV4dHVyZXMuX190eXBlc1sgcHJlc2V0TmFtZSBdID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCBgdGhlIHRleHR1cmUgdHlwZSAnJHtwcmVzZXROYW1lfScgZG9lcyBub3QgZXhpc3QuYCApXG4gICAgICB9XG4gICAgICBjb25zdCB0ZXggPSBPYmplY3QuYXNzaWduKCB7IG1vZGU6JzNkJyB9LCBUZXh0dXJlcy5fX3R5cGVzWyBwcmVzZXROYW1lIF0sIHByb3BzIClcblxuICAgICAgaWYoIHRhcmdldCA9PT0gbnVsbCApIHRhcmdldCA9IHRleFxuICAgICAgdGV4Ll9fdGFyZ2V0ID0gdGFyZ2V0XG5cbiAgICAgIGZvciggbGV0IHBhcmFtIG9mIHRleC5wYXJhbWV0ZXJzICkge1xuICAgICAgICBjb25zdCBkZWZhdWx0VmFsdWVzID0gcGFyYW0uZGVmYXVsdFxuICAgICAgICBjb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSggZGVmYXVsdFZhbHVlcyApXG5cbiAgICAgICAgbGV0IGNvdW50ID0gMFxuICAgICAgICBpZiggaXNBcnJheSApIHtcbiAgICAgICAgICBsZXQgdmFsID0gcHJvcHNbIHBhcmFtLm5hbWUgXSwgX192YXJcblxuICAgICAgICAgIGlmKCB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyApIHtcbiAgICAgICAgICAgIF9fdmFyID0gVmFyKCB2YXJzWyBwYXJhbS50eXBlIF0oIHZhbCApLCBudWxsLCAndmVjMycgKVxuICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgY29uc3QgaW5pdHZhbHVlcyA9IHZhbCAhPT0gdW5kZWZpbmVkID8gdmFsIDogZGVmYXVsdFZhbHVlc1xuICAgICAgICAgICAgX192YXIgPSBWYXIoIHZhcnNbIHBhcmFtLnR5cGUgXSggLi4uaW5pdHZhbHVlcyApLCBudWxsLCBwYXJhbS50eXBlIClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBmb3IgYXNzaWduaW5nIGVudGlyZSBuZXcgdmVjdG9ycyB0byBwcm9wZXJ0eVxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGFyZ2V0LCBwYXJhbS5uYW1lLCB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6dHJ1ZSxcbiAgICAgICAgICAgIGdldCgpIHsgcmV0dXJuIF9fdmFyIH0sXG4gICAgICAgICAgICBzZXQodikge1xuICAgICAgICAgICAgICBpZiggdHlwZW9mIHYgPT09ICdvYmplY3QnICkge1xuICAgICAgICAgICAgICAgIF9fdmFyLnNldCggdiApXG4gICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIF9fdmFyLnZhbHVlLnggPSB2XG4gICAgICAgICAgICAgICAgX192YXIudmFsdWUueSA9IHZcbiAgICAgICAgICAgICAgICBfX3Zhci52YWx1ZS56ID0gdlxuICAgICAgICAgICAgICAgIF9fdmFyLnZhbHVlLncgPSB2XG4gICAgICAgICAgICAgICAgX192YXIuZGlydHkgPSB0cnVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuXG4gICAgICAgIH1lbHNle1xuICAgICAgICAgIGxldCBfX3ZhciAgPSBwYXJhbV93cmFwKCBcbiAgICAgICAgICAgIHByb3BzWyBwYXJhbS5uYW1lIF0sIFxuICAgICAgICAgICAgZ2Vuc1sgcGFyYW0udHlwZSBdKCBkZWZhdWx0VmFsdWVzICkgXG4gICAgICAgICAgKVxuXG4gICAgICAgICAgLy9fX3Zhci5zZXQoIGRlZmF1bHRWYWx1ZXMgKVxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGFyZ2V0LCBwYXJhbS5uYW1lLCB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6dHJ1ZSxcbiAgICAgICAgICAgIGdldCgpIHsgcmV0dXJuIF9fdmFyIH0sXG4gICAgICAgICAgICBzZXQodikge1xuICAgICAgICAgICAgICBfX3Zhci5zZXQoIHYgKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYoIHByZXNldE5hbWUgPT09ICdpbWFnZScgKSB7XG4gICAgICAgIGlmKCBwcm9wcy5maWxlbmFtZSAhPT0gdW5kZWZpbmVkICkge1xuICAgICAgICAgIHRleC5pbWFnZSA9IGdldFBpeGVscyggcHJvcHMuZmlsZW5hbWUsIChlcnIscGl4ZWxzKSA9PiB7XG4gICAgICAgICAgICBpZiggZXJyICE9PSBudWxsICkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCBlcnIgKVxuICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRleC5waXhlbHMgPSBwaXhlbHNcbiAgICAgICAgICAgIHRleC5nbHRleHR1cmUgPSBjcmVhdGVUZXh0dXJlKCBTREYuZ2wsIHBpeGVscyApXG4gICAgICAgICAgICB0ZXguZ2x0ZXh0dXJlLndyYXAgPSBwcm9wcy53cmFwID09PSB1bmRlZmluZWQgPyBNYXJjaGluZy5nbC5SRVBFQVQgOiBwcm9wcy53cmFwXG4gICAgICAgICAgfSlcbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgdGV4LmltYWdlID0gbnVsbFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1lvdSBtdXN0IHNwZWNpZnkgYSBmaWxlbmFtZSB3aGVuIHVzaW5nIHRoZSBpYW1nZSBwcmVzZXQuJylcbiAgICAgICAgfVxuICAgICAgfWVsc2UgaWYoIHByZXNldE5hbWUgPT09ICdjYW52YXMnICkge1xuICAgICAgICBpZiggcHJvcHMuY2FudmFzID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgICAgdGV4LmNhbnZhcyA9IHRleC5pbWFnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpXG4gICAgICAgICAgdGV4LmN0eCAgICA9IHRleC5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKVxuICAgICAgICB9ZWxzZXtcbiAgICAgICAgICB0ZXguaW1hZ2UgPSBwcm9wcy5jYW52YXNcbiAgICAgICAgfVxuXG4gICAgICAgIHRleC51cGRhdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICB0ZXguZ2x0ZXh0dXJlLnNldFBpeGVscyggdGV4LmltYWdlIClcbiAgICAgICAgfVxuXG4gICAgICAgIHRleC5nbHRleHR1cmUgPSBjcmVhdGVUZXh0dXJlKCBTREYuZ2wsIHRleC5pbWFnZSApXG4gICAgICAgIHRleC5nbHRleHR1cmUud3JhcCA9IHByb3BzLndyYXAgPT09IHVuZGVmaW5lZCA/IE1hcmNoaW5nLmdsLlJFUEVBVCA6IHByb3BzLndyYXBcblxuICAgICAgICB0ZXgudXBkYXRlKClcbiAgICAgIH1cblxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoIHRleCwgJ3dyYXAnLCB7XG4gICAgICAgIGdldCgpIHsgcmV0dXJuIHRoaXMuZ2x0ZXh0dXJlLndyYXAgfSxcbiAgICAgICAgc2V0KHYpeyB0aGlzLmdsdGV4dHVyZS53cmFwID0gdiB9XG4gICAgICB9KVxuXG4gICAgICB0ZXgubmFtZSA9IHByZXNldE5hbWVcblxuICAgICAgcmV0dXJuIHRleCBcbiAgICB9LFxuXG4gICAgZGlydHkoIHRleCApIHt9LFxuICAgXG4gICAgZW1pdF9kZWNsKCkge1xuICAgICAgaWYoIHRoaXMudGV4dHVyZXMubGVuZ3RoID09PSAwICkgcmV0dXJuICcnIFxuXG4gICAgICBsZXQgZGVjbCA9ICcnXG5cbiAgICAgIGNvbnN0IG1lbW8gPSBbXVxuICAgICAgbGV0IGltYWdlQ291bnQgPSAwO1xuICAgICAgdGhpcy50ZXh0dXJlcy5mb3JFYWNoKCAodGV4LGkpID0+IHtcbiAgICAgICAgaWYoIG1lbW8uaW5kZXhPZiggdGV4ICkgPT09IC0xICkge1xuICAgICAgICAgIGZvciggbGV0IHBhcmFtIG9mIHRleC5wYXJhbWV0ZXJzICkge1xuICAgICAgICAgICAgaWYoIHBhcmFtLm5hbWUgIT09ICdtYXRlcmlhbCcgKVxuICAgICAgICAgICAgICBkZWNsICs9IHRleC5fX3RhcmdldFsgcGFyYW0ubmFtZSBdLmVtaXRfZGVjbCgpXG4gICAgICAgICAgfVxuICAgICAgICAgIG1lbW8ucHVzaCggdGV4IClcbiAgICAgICAgfVxuICAgICAgICBpZiggdGV4Lm5hbWUgPT09ICdpbWFnZScgfHwgdGV4Lm5hbWUgPT09ICdjYW52YXMnICkge1xuICAgICAgICAgIGltYWdlQ291bnQrK1xuXG4gICAgICAgICAgLy8gZm9yIHNvbWUgcmVhc29uIGNhbid0IGltbWVkaWF0ZWx5IGNhbGwgdXBkYXRlLi4uIFxuICAgICAgICAgIC8vIGhhdmUgdG8gd2FpdCBmb3Igc29tZSB0eXBlIG9mIGRvbSBpbml0aWFsaXphdGlvbj9cbiAgICAgICAgICAvLyBzbyBjYWxsIGhlcmVcbiAgICAgICAgICBpZiggdGV4LnVwZGF0ZSApIHRleC51cGRhdGUoKVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgICBpZiggaW1hZ2VDb3VudCA+IDAgKSB7XG4gICAgICAgIGRlY2wgKz0gYFxcbiAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHRleHR1cmVzWyR7aW1hZ2VDb3VudH1dO1xcbmBcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWNsXG4gICAgfSxcbiAgICBcbiAgICB1cGRhdGVfbG9jYXRpb24oIGdsLCBwcm9ncmFtICkge1xuICAgICAgaWYoIHRoaXMudGV4dHVyZXMubGVuZ3RoID4gMCApIHtcbiAgICAgICAgdGhpcy50ZXh0dXJlcy5mb3JFYWNoKCAodGV4LGkpID0+IHtcbiAgICAgICAgICBmb3IoIGxldCBwYXJhbSBvZiB0ZXgucGFyYW1ldGVycyApIHtcbiAgICAgICAgICAgIGlmKCBwYXJhbS50eXBlICE9PSAnb2JqJyApIHtcbiAgICAgICAgICAgICAgaWYoIHBhcmFtLm5hbWUgIT09ICdtYXRlcmlhbCcgKSBcbiAgICAgICAgICAgICAgICB0ZXguX190YXJnZXRbIHBhcmFtLm5hbWUgXS51cGRhdGVfbG9jYXRpb24oIGdsLHByb2dyYW0gKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiggdGV4Lm5hbWUgPT09ICdpbWFnZScgfHwgdGV4Lm5hbWUgPT09ICdjYW52YXMnICkge1xuICAgICAgICAgICAgdGV4LmxvYyA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgYHRleHR1cmVzWyR7dGV4LmlkfV1gIClcbiAgICAgICAgICAgIHRleC5nbHRleHR1cmUuYmluZCggaSApXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuXG4gICAgICAvL2lmKCB0aGlzLnRleHR1cmVzLmxlbmd0aCA+IDAgKSB7XG4gICAgICAvLyAgdGhpcy50ZXh0dXJlcy5zb3J0KCAoYSxiKSA9PiBhLmlkID4gYi5pZCA/IDEgOiAtMSApIFxuXG4gICAgICAvLyAgZm9yKCBsZXQgdGV4IG9mIHRoaXMudGV4dHVyZXMgKSB7XG4gICAgICAvLyAgICB0ZXgubG9jID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKCBwcm9ncmFtLCBgdGV4dHVyZXNbJHt0ZXguaWR9XWAgKVxuICAgICAgLy8gICAgdGV4LmdsdGV4dHVyZS5iaW5kKCB0ZXguaWQgKVxuICAgICAgLy8gIH1cblxuICAgICAgLy8gIHRoaXMuX190ZXh0dXJlcyA9IHRoaXMudGV4dHVyZXMuc2xpY2UoIDAgKVxuICAgICAgLy8gIHRoaXMudGV4dHVyZXMubGVuZ3RoID0gMFxuICAgICAgLy99XG4gICAgfSxcblxuICAgIHVwbG9hZF9kYXRhKCBnbCwgcHJvZ3JhbSApIHtcbiAgICAgIGlmKCB0aGlzLnRleHR1cmVzLmxlbmd0aCA+IDAgKSB7XG4gICAgICAgIHRoaXMudGV4dHVyZXMuZm9yRWFjaCggKHRleCxpKSA9PiB7XG4gICAgICAgICAgZm9yKCBsZXQgcGFyYW0gb2YgdGV4LnBhcmFtZXRlcnMgKSB7XG4gICAgICAgICAgICBpZiggcGFyYW0udHlwZSAhPT0gJ29iaicgJiYgcGFyYW0ubmFtZSAhPT0gJ21hdGVyaWFsJyApXG4gICAgICAgICAgICAgIHRleC5fX3RhcmdldFsgcGFyYW0ubmFtZSBdLnVwbG9hZF9kYXRhKCBnbCApXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmKCB0ZXgubmFtZSA9PT0gJ2ltYWdlJyB8fCB0ZXgubmFtZSA9PT0gJ2NhbnZhcycgKSB7XG4gICAgICAgICAgICBnbC51bmlmb3JtMWkoIHRleC5sb2MsIGkgKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICB9XG5cbiAgfVxuXG4gIFRleHR1cmVzLnRleHR1cmUuY3JlYXRlID0gZnVuY3Rpb24oIHByb3BzICkge1xuICAgIFRleHR1cmVzLl9fdHlwZXNbIHByb3BzLm5hbWUgXSA9IHByb3BzXG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggVGV4dHVyZXMudGV4dHVyZSwge1xuICAgICdyZXBlYXQnOiB7IGdldCgpIHsgcmV0dXJuIE1hcmNoaW5nLmdsLlJFUEVBVCB9IH0sXG4gICAgJ21pcnJvcic6IHsgZ2V0KCkgeyByZXR1cm4gTWFyY2hpbmcuZ2wuTUlSUk9SRURfUkVQRUFUIH0gfSxcbiAgICAnY2xhbXAnOiB7IGdldCgpIHsgcmV0dXJuIE1hcmNoaW5nLmdsLkNMQU1QX1RPX0VER0UgfSB9LFxuICB9KVxuXG4gIGNvbnN0IGYgPSB2YWx1ZSA9PiB2YWx1ZSAlIDEgPT09IDAgPyB2YWx1ZS50b0ZpeGVkKDEpIDogdmFsdWUgXG5cbiAgcmV0dXJuIFRleHR1cmVzXG59XG5cbm1vZHVsZS5leHBvcnRzID0gX19UZXh0dXJlc1xuIiwiY29uc3QgZ2xzbCA9IHJlcXVpcmUoICdnbHNsaWZ5JyApXG5cbmNvbnN0IHRleHR1cmVzID0ge1xuICBpbWFnZToge1xuICAgIG5hbWU6J2ltYWdlJyxcbiAgICBnbHNsMmQ6YFxuICAgICAgdmVjMyBpbWFnZTJkKCB2ZWMyIHV2LCBmbG9hdCBzY2FsZSwgZmxvYXQgc3RyZW5ndGggKSB7XG4gICAgICAgIHJldHVybiB0ZXh0dXJlKCB0ZXh0dXJlc1sgMCBdLCB1dipzY2FsZSApLnh5eiAqIHN0cmVuZ3RoO1xuICAgICAgfVxuICAgIGAsXG4gICAgcGFyYW1ldGVyczpbXG4gICAgICB7IG5hbWU6J3NjYWxlJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjEgfSxcbiAgICAgIHsgbmFtZTonc3RyZW5ndGgnLCB0eXBlOidmbG9hdCcsIGRlZmF1bHQ6MSB9LCAgIFxuICAgIF1cbiAgfSxcbiAgY2FudmFzOiB7XG4gICAgbmFtZTonY2FudmFzJyxcbiAgICBnbHNsMmQ6YFxuICAgICAgdmVjMyBjYW52YXMyZCggdmVjMiB1diwgZmxvYXQgc2NhbGUsIGZsb2F0IHN0cmVuZ3RoICkge1xuICAgICAgICByZXR1cm4gdGV4dHVyZSggdGV4dHVyZXNbIDAgXSwgdXYqc2NhbGUgKS54eXogKiBzdHJlbmd0aDtcbiAgICAgIH1cbiAgICBgLFxuICAgIHBhcmFtZXRlcnM6W1xuICAgICAgeyBuYW1lOidzY2FsZScsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDoxIH0sXG4gICAgICB7IG5hbWU6J3N0cmVuZ3RoJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjEgfSwgICBcbiAgICBdXG4gIH0sXG4gIHJhaW5ib3c6IHtcbiAgICBuYW1lOidyYWluYm93JyxcbiAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICB7IG5hbWU6J3N0cmVuZ3RoJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjEgfSxcbiAgICAgIHsgbmFtZTonc2hpZnQnLCB0eXBlOidmbG9hdCcsIGRlZmF1bHQ6MCB9LFxuICAgICAgeyBuYW1lOidzY2FsZScsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDoxIH0sXG4gICAgXSxcbiAgICBnbHNsOmAgXG4gICAgdmVjMyByYWluYm93KCB2ZWMzIHBvcywgZmxvYXQgc3RyZW5ndGgsIGZsb2F0IHNoaWZ0LCBmbG9hdCBzY2FsZSApIHtcbiAgICAgIHBvcyA9IHBvcyAqIHNjYWxlO1xuICAgICAgdmVjMyBhID0gdmVjMygwLjUsMC41LDAuNSksIGIgPSB2ZWMzKDAuNSwwLjUsMC41KSwgYyA9IHZlYzMoMS4wLDEuMCwxLjApLGQgPSB2ZWMzKDAuMCwwLjMzLDAuNjcpO1xuICAgICAgcmV0dXJuIGEgKyBiICogY29zKCA2LjI4MzgxOCAqICggYyAqIG1vZChsZW5ndGgocG9zKSArIHNoaWZ0LCAxLiApICsgZCApICkgKiBzdHJlbmd0aDtcbiAgICB9YCBcbiAgfSxcbiAgY2hlY2tlcnM6IHtcbiAgICBuYW1lOidjaGVja2VycycsXG4gICAgZ2xzbDpgICAgICAgICAgIFxuICAgICAgICB2ZWMzIGNoZWNrZXJzKCB2ZWMzIHBvcywgZmxvYXQgc2l6ZSwgdmVjMyBjb2xvcjEsIHZlYzMgY29sb3IyICkge1xuICAgICAgICAgIHZlYzMgdGV4O1xuICAgICAgICAgIHBvcyAgPSBwb3MgKiBzaXplO1xuICAgICAgICAgIGlmICgoaW50KGZsb29yKHBvcy54KSArIGZsb29yKHBvcy55KSArIGZsb29yKHBvcy56KSkgJiAxKSA9PSAwKSB7XG4gICAgICAgICAgICB0ZXggPSBjb2xvcjE7XG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICB0ZXggPSBjb2xvcjI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHRleDtcbiAgICAgICAgfWAsXG4gICAgZ2xzbDJkOmBcbiAgICAgICAgdmVjMyBjaGVja2VyczJkKCB2ZWMyIHV2LCBmbG9hdCBzaXplLCB2ZWMzIGNvbG9yMSwgdmVjMyBjb2xvcjIgKSB7XG4gICAgICAgICAgZmxvYXQgZm1vZFJlc3VsdCA9IG1vZChmbG9vcihzaXplICogdXYueCkgKyBmbG9vcihzaXplICogdXYueSksIDIuMCk7XG4gICAgICAgICAgZmxvYXQgZmluID0gbWF4KHNpZ24oZm1vZFJlc3VsdCksIDAuMCk7IFxuXG4gICAgICAgICAgcmV0dXJuIHZlYzMoZmluKTtcbiAgICAgICAgfVxuICAgIGAsXG4gICAgcGFyYW1ldGVyczogW1xuICAgICAgeyBuYW1lOidzY2FsZScsICB0eXBlOidmbG9hdCcsIGRlZmF1bHQ6NSB9LFxuICAgICAgeyBuYW1lOidjb2xvcjEnLCB0eXBlOid2ZWMzJywgZGVmYXVsdDpbMSwxLDFdIH0sXG4gICAgICB7IG5hbWU6J2NvbG9yMicsIHR5cGU6J3ZlYzMnLCBkZWZhdWx0OlswLDAsMF0gfVxuICAgIF0sXG4gIH0sXG4gIG5vaXNlOiB7XG4gICAgbmFtZTonbm9pc2UnLFxuICAgIGdsc2w6Z2xzbChbXCIjZGVmaW5lIEdMU0xJRlkgMVxcbiAgICAgICAgICBcXG4gICAgICAgIC8vXFxuLy8gRGVzY3JpcHRpb24gOiBBcnJheSBhbmQgdGV4dHVyZWxlc3MgR0xTTCAyRC8zRC80RCBzaW1wbGV4XFxuLy8gICAgICAgICAgICAgICBub2lzZSBmdW5jdGlvbnMuXFxuLy8gICAgICBBdXRob3IgOiBJYW4gTWNFd2FuLCBBc2hpbWEgQXJ0cy5cXG4vLyAgTWFpbnRhaW5lciA6IGlqbVxcbi8vICAgICBMYXN0bW9kIDogMjAxMTA4MjIgKGlqbSlcXG4vLyAgICAgTGljZW5zZSA6IENvcHlyaWdodCAoQykgMjAxMSBBc2hpbWEgQXJ0cy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cXG4vLyAgICAgICAgICAgICAgIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZS5cXG4vLyAgICAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9hc2hpbWEvd2ViZ2wtbm9pc2VcXG4vL1xcblxcbnZlYzQgbW9kMjg5KHZlYzQgeCkge1xcbiAgcmV0dXJuIHggLSBmbG9vcih4ICogKDEuMCAvIDI4OS4wKSkgKiAyODkuMDsgfVxcblxcbmZsb2F0IG1vZDI4OShmbG9hdCB4KSB7XFxuICByZXR1cm4geCAtIGZsb29yKHggKiAoMS4wIC8gMjg5LjApKSAqIDI4OS4wOyB9XFxuXFxudmVjNCBwZXJtdXRlKHZlYzQgeCkge1xcbiAgICAgcmV0dXJuIG1vZDI4OSgoKHgqMzQuMCkrMS4wKSp4KTtcXG59XFxuXFxuZmxvYXQgcGVybXV0ZShmbG9hdCB4KSB7XFxuICAgICByZXR1cm4gbW9kMjg5KCgoeCozNC4wKSsxLjApKngpO1xcbn1cXG5cXG52ZWM0IHRheWxvckludlNxcnQodmVjNCByKVxcbntcXG4gIHJldHVybiAxLjc5Mjg0MjkxNDAwMTU5IC0gMC44NTM3MzQ3MjA5NTMxNCAqIHI7XFxufVxcblxcbmZsb2F0IHRheWxvckludlNxcnQoZmxvYXQgcilcXG57XFxuICByZXR1cm4gMS43OTI4NDI5MTQwMDE1OSAtIDAuODUzNzM0NzIwOTUzMTQgKiByO1xcbn1cXG5cXG52ZWM0IGdyYWQ0KGZsb2F0IGosIHZlYzQgaXApXFxuICB7XFxuICBjb25zdCB2ZWM0IG9uZXMgPSB2ZWM0KDEuMCwgMS4wLCAxLjAsIC0xLjApO1xcbiAgdmVjNCBwLHM7XFxuXFxuICBwLnh5eiA9IGZsb29yKCBmcmFjdCAodmVjMyhqKSAqIGlwLnh5eikgKiA3LjApICogaXAueiAtIDEuMDtcXG4gIHAudyA9IDEuNSAtIGRvdChhYnMocC54eXopLCBvbmVzLnh5eik7XFxuICBzID0gdmVjNChsZXNzVGhhbihwLCB2ZWM0KDAuMCkpKTtcXG4gIHAueHl6ID0gcC54eXogKyAocy54eXoqMi4wIC0gMS4wKSAqIHMud3d3O1xcblxcbiAgcmV0dXJuIHA7XFxuICB9XFxuXFxuLy8gKHNxcnQoNSkgLSAxKS80ID0gRjQsIHVzZWQgb25jZSBiZWxvd1xcbiNkZWZpbmUgRjQgMC4zMDkwMTY5OTQzNzQ5NDc0NTFcXG5cXG5mbG9hdCBzbm9pc2UodmVjNCB2KVxcbiAge1xcbiAgY29uc3QgdmVjNCAgQyA9IHZlYzQoIDAuMTM4MTk2NjAxMTI1MDExLCAgLy8gKDUgLSBzcXJ0KDUpKS8yMCAgRzRcXG4gICAgICAgICAgICAgICAgICAgICAgICAwLjI3NjM5MzIwMjI1MDAyMSwgIC8vIDIgKiBHNFxcbiAgICAgICAgICAgICAgICAgICAgICAgIDAuNDE0NTg5ODAzMzc1MDMyLCAgLy8gMyAqIEc0XFxuICAgICAgICAgICAgICAgICAgICAgICAtMC40NDcyMTM1OTU0OTk5NTgpOyAvLyAtMSArIDQgKiBHNFxcblxcbi8vIEZpcnN0IGNvcm5lclxcbiAgdmVjNCBpICA9IGZsb29yKHYgKyBkb3QodiwgdmVjNChGNCkpICk7XFxuICB2ZWM0IHgwID0gdiAtICAgaSArIGRvdChpLCBDLnh4eHgpO1xcblxcbi8vIE90aGVyIGNvcm5lcnNcXG5cXG4vLyBSYW5rIHNvcnRpbmcgb3JpZ2luYWxseSBjb250cmlidXRlZCBieSBCaWxsIExpY2VhLUthbmUsIEFNRCAoZm9ybWVybHkgQVRJKVxcbiAgdmVjNCBpMDtcXG4gIHZlYzMgaXNYID0gc3RlcCggeDAueXp3LCB4MC54eHggKTtcXG4gIHZlYzMgaXNZWiA9IHN0ZXAoIHgwLnp3dywgeDAueXl6ICk7XFxuLy8gIGkwLnggPSBkb3QoIGlzWCwgdmVjMyggMS4wICkgKTtcXG4gIGkwLnggPSBpc1gueCArIGlzWC55ICsgaXNYLno7XFxuICBpMC55encgPSAxLjAgLSBpc1g7XFxuLy8gIGkwLnkgKz0gZG90KCBpc1laLnh5LCB2ZWMyKCAxLjAgKSApO1xcbiAgaTAueSArPSBpc1laLnggKyBpc1laLnk7XFxuICBpMC56dyArPSAxLjAgLSBpc1laLnh5O1xcbiAgaTAueiArPSBpc1laLno7XFxuICBpMC53ICs9IDEuMCAtIGlzWVouejtcXG5cXG4gIC8vIGkwIG5vdyBjb250YWlucyB0aGUgdW5pcXVlIHZhbHVlcyAwLDEsMiwzIGluIGVhY2ggY2hhbm5lbFxcbiAgdmVjNCBpMyA9IGNsYW1wKCBpMCwgMC4wLCAxLjAgKTtcXG4gIHZlYzQgaTIgPSBjbGFtcCggaTAtMS4wLCAwLjAsIDEuMCApO1xcbiAgdmVjNCBpMSA9IGNsYW1wKCBpMC0yLjAsIDAuMCwgMS4wICk7XFxuXFxuICAvLyAgeDAgPSB4MCAtIDAuMCArIDAuMCAqIEMueHh4eFxcbiAgLy8gIHgxID0geDAgLSBpMSAgKyAxLjAgKiBDLnh4eHhcXG4gIC8vICB4MiA9IHgwIC0gaTIgICsgMi4wICogQy54eHh4XFxuICAvLyAgeDMgPSB4MCAtIGkzICArIDMuMCAqIEMueHh4eFxcbiAgLy8gIHg0ID0geDAgLSAxLjAgKyA0LjAgKiBDLnh4eHhcXG4gIHZlYzQgeDEgPSB4MCAtIGkxICsgQy54eHh4O1xcbiAgdmVjNCB4MiA9IHgwIC0gaTIgKyBDLnl5eXk7XFxuICB2ZWM0IHgzID0geDAgLSBpMyArIEMuenp6ejtcXG4gIHZlYzQgeDQgPSB4MCArIEMud3d3dztcXG5cXG4vLyBQZXJtdXRhdGlvbnNcXG4gIGkgPSBtb2QyODkoaSk7XFxuICBmbG9hdCBqMCA9IHBlcm11dGUoIHBlcm11dGUoIHBlcm11dGUoIHBlcm11dGUoaS53KSArIGkueikgKyBpLnkpICsgaS54KTtcXG4gIHZlYzQgajEgPSBwZXJtdXRlKCBwZXJtdXRlKCBwZXJtdXRlKCBwZXJtdXRlIChcXG4gICAgICAgICAgICAgaS53ICsgdmVjNChpMS53LCBpMi53LCBpMy53LCAxLjAgKSlcXG4gICAgICAgICAgICsgaS56ICsgdmVjNChpMS56LCBpMi56LCBpMy56LCAxLjAgKSlcXG4gICAgICAgICAgICsgaS55ICsgdmVjNChpMS55LCBpMi55LCBpMy55LCAxLjAgKSlcXG4gICAgICAgICAgICsgaS54ICsgdmVjNChpMS54LCBpMi54LCBpMy54LCAxLjAgKSk7XFxuXFxuLy8gR3JhZGllbnRzOiA3eDd4NiBwb2ludHMgb3ZlciBhIGN1YmUsIG1hcHBlZCBvbnRvIGEgNC1jcm9zcyBwb2x5dG9wZVxcbi8vIDcqNyo2ID0gMjk0LCB3aGljaCBpcyBjbG9zZSB0byB0aGUgcmluZyBzaXplIDE3KjE3ID0gMjg5LlxcbiAgdmVjNCBpcCA9IHZlYzQoMS4wLzI5NC4wLCAxLjAvNDkuMCwgMS4wLzcuMCwgMC4wKSA7XFxuXFxuICB2ZWM0IHAwID0gZ3JhZDQoajAsICAgaXApO1xcbiAgdmVjNCBwMSA9IGdyYWQ0KGoxLngsIGlwKTtcXG4gIHZlYzQgcDIgPSBncmFkNChqMS55LCBpcCk7XFxuICB2ZWM0IHAzID0gZ3JhZDQoajEueiwgaXApO1xcbiAgdmVjNCBwNCA9IGdyYWQ0KGoxLncsIGlwKTtcXG5cXG4vLyBOb3JtYWxpc2UgZ3JhZGllbnRzXFxuICB2ZWM0IG5vcm0gPSB0YXlsb3JJbnZTcXJ0KHZlYzQoZG90KHAwLHAwKSwgZG90KHAxLHAxKSwgZG90KHAyLCBwMiksIGRvdChwMyxwMykpKTtcXG4gIHAwICo9IG5vcm0ueDtcXG4gIHAxICo9IG5vcm0ueTtcXG4gIHAyICo9IG5vcm0uejtcXG4gIHAzICo9IG5vcm0udztcXG4gIHA0ICo9IHRheWxvckludlNxcnQoZG90KHA0LHA0KSk7XFxuXFxuLy8gTWl4IGNvbnRyaWJ1dGlvbnMgZnJvbSB0aGUgZml2ZSBjb3JuZXJzXFxuICB2ZWMzIG0wID0gbWF4KDAuNiAtIHZlYzMoZG90KHgwLHgwKSwgZG90KHgxLHgxKSwgZG90KHgyLHgyKSksIDAuMCk7XFxuICB2ZWMyIG0xID0gbWF4KDAuNiAtIHZlYzIoZG90KHgzLHgzKSwgZG90KHg0LHg0KSAgICAgICAgICAgICksIDAuMCk7XFxuICBtMCA9IG0wICogbTA7XFxuICBtMSA9IG0xICogbTE7XFxuICByZXR1cm4gNDkuMCAqICggZG90KG0wKm0wLCB2ZWMzKCBkb3QoIHAwLCB4MCApLCBkb3QoIHAxLCB4MSApLCBkb3QoIHAyLCB4MiApKSlcXG4gICAgICAgICAgICAgICArIGRvdChtMSptMSwgdmVjMiggZG90KCBwMywgeDMgKSwgZG90KCBwNCwgeDQgKSApICkgKSA7XFxuXFxuICB9XFxuXFxuICAgICAgICB2ZWMzIG5vaXNlKCB2ZWMzIHBvcywgZmxvYXQgc2NhbGUsIGZsb2F0IHN0cmVuZ3RoLCBmbG9hdCB0aW1lICkge1xcbiAgICAgICAgICBmbG9hdCBuID0gc25vaXNlKCB2ZWM0KHBvcypzY2FsZSwgdGltZSkgKTtcXG4gICAgICAgICAgcmV0dXJuIHZlYzMoIG4gKSAqIHN0cmVuZ3RoO1xcbiAgICAgICAgfVwiLFwiXCJdKSxcbiAgICBnbHNsMmQ6Z2xzbChbXCIjZGVmaW5lIEdMU0xJRlkgMVxcbiAgICBcXG4gICAgICAgIC8vXFxuLy8gRGVzY3JpcHRpb24gOiBBcnJheSBhbmQgdGV4dHVyZWxlc3MgR0xTTCAyRC8zRC80RCBzaW1wbGV4XFxuLy8gICAgICAgICAgICAgICBub2lzZSBmdW5jdGlvbnMuXFxuLy8gICAgICBBdXRob3IgOiBJYW4gTWNFd2FuLCBBc2hpbWEgQXJ0cy5cXG4vLyAgTWFpbnRhaW5lciA6IGlqbVxcbi8vICAgICBMYXN0bW9kIDogMjAxMTA4MjIgKGlqbSlcXG4vLyAgICAgTGljZW5zZSA6IENvcHlyaWdodCAoQykgMjAxMSBBc2hpbWEgQXJ0cy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cXG4vLyAgICAgICAgICAgICAgIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZS5cXG4vLyAgICAgICAgICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9hc2hpbWEvd2ViZ2wtbm9pc2VcXG4vL1xcblxcbnZlYzMgbW9kMjg5KHZlYzMgeCkge1xcbiAgcmV0dXJuIHggLSBmbG9vcih4ICogKDEuMCAvIDI4OS4wKSkgKiAyODkuMDtcXG59XFxuXFxudmVjNCBtb2QyODkodmVjNCB4KSB7XFxuICByZXR1cm4geCAtIGZsb29yKHggKiAoMS4wIC8gMjg5LjApKSAqIDI4OS4wO1xcbn1cXG5cXG52ZWM0IHBlcm11dGUodmVjNCB4KSB7XFxuICAgICByZXR1cm4gbW9kMjg5KCgoeCozNC4wKSsxLjApKngpO1xcbn1cXG5cXG52ZWM0IHRheWxvckludlNxcnQodmVjNCByKVxcbntcXG4gIHJldHVybiAxLjc5Mjg0MjkxNDAwMTU5IC0gMC44NTM3MzQ3MjA5NTMxNCAqIHI7XFxufVxcblxcbmZsb2F0IHNub2lzZSh2ZWMzIHYpXFxuICB7XFxuICBjb25zdCB2ZWMyICBDID0gdmVjMigxLjAvNi4wLCAxLjAvMy4wKSA7XFxuICBjb25zdCB2ZWM0ICBEID0gdmVjNCgwLjAsIDAuNSwgMS4wLCAyLjApO1xcblxcbi8vIEZpcnN0IGNvcm5lclxcbiAgdmVjMyBpICA9IGZsb29yKHYgKyBkb3QodiwgQy55eXkpICk7XFxuICB2ZWMzIHgwID0gICB2IC0gaSArIGRvdChpLCBDLnh4eCkgO1xcblxcbi8vIE90aGVyIGNvcm5lcnNcXG4gIHZlYzMgZyA9IHN0ZXAoeDAueXp4LCB4MC54eXopO1xcbiAgdmVjMyBsID0gMS4wIC0gZztcXG4gIHZlYzMgaTEgPSBtaW4oIGcueHl6LCBsLnp4eSApO1xcbiAgdmVjMyBpMiA9IG1heCggZy54eXosIGwuenh5ICk7XFxuXFxuICAvLyAgIHgwID0geDAgLSAwLjAgKyAwLjAgKiBDLnh4eDtcXG4gIC8vICAgeDEgPSB4MCAtIGkxICArIDEuMCAqIEMueHh4O1xcbiAgLy8gICB4MiA9IHgwIC0gaTIgICsgMi4wICogQy54eHg7XFxuICAvLyAgIHgzID0geDAgLSAxLjAgKyAzLjAgKiBDLnh4eDtcXG4gIHZlYzMgeDEgPSB4MCAtIGkxICsgQy54eHg7XFxuICB2ZWMzIHgyID0geDAgLSBpMiArIEMueXl5OyAvLyAyLjAqQy54ID0gMS8zID0gQy55XFxuICB2ZWMzIHgzID0geDAgLSBELnl5eTsgICAgICAvLyAtMS4wKzMuMCpDLnggPSAtMC41ID0gLUQueVxcblxcbi8vIFBlcm11dGF0aW9uc1xcbiAgaSA9IG1vZDI4OShpKTtcXG4gIHZlYzQgcCA9IHBlcm11dGUoIHBlcm11dGUoIHBlcm11dGUoXFxuICAgICAgICAgICAgIGkueiArIHZlYzQoMC4wLCBpMS56LCBpMi56LCAxLjAgKSlcXG4gICAgICAgICAgICsgaS55ICsgdmVjNCgwLjAsIGkxLnksIGkyLnksIDEuMCApKVxcbiAgICAgICAgICAgKyBpLnggKyB2ZWM0KDAuMCwgaTEueCwgaTIueCwgMS4wICkpO1xcblxcbi8vIEdyYWRpZW50czogN3g3IHBvaW50cyBvdmVyIGEgc3F1YXJlLCBtYXBwZWQgb250byBhbiBvY3RhaGVkcm9uLlxcbi8vIFRoZSByaW5nIHNpemUgMTcqMTcgPSAyODkgaXMgY2xvc2UgdG8gYSBtdWx0aXBsZSBvZiA0OSAoNDkqNiA9IDI5NClcXG4gIGZsb2F0IG5fID0gMC4xNDI4NTcxNDI4NTc7IC8vIDEuMC83LjBcXG4gIHZlYzMgIG5zID0gbl8gKiBELnd5eiAtIEQueHp4O1xcblxcbiAgdmVjNCBqID0gcCAtIDQ5LjAgKiBmbG9vcihwICogbnMueiAqIG5zLnopOyAgLy8gIG1vZChwLDcqNylcXG5cXG4gIHZlYzQgeF8gPSBmbG9vcihqICogbnMueik7XFxuICB2ZWM0IHlfID0gZmxvb3IoaiAtIDcuMCAqIHhfICk7ICAgIC8vIG1vZChqLE4pXFxuXFxuICB2ZWM0IHggPSB4XyAqbnMueCArIG5zLnl5eXk7XFxuICB2ZWM0IHkgPSB5XyAqbnMueCArIG5zLnl5eXk7XFxuICB2ZWM0IGggPSAxLjAgLSBhYnMoeCkgLSBhYnMoeSk7XFxuXFxuICB2ZWM0IGIwID0gdmVjNCggeC54eSwgeS54eSApO1xcbiAgdmVjNCBiMSA9IHZlYzQoIHguencsIHkuencgKTtcXG5cXG4gIC8vdmVjNCBzMCA9IHZlYzQobGVzc1RoYW4oYjAsMC4wKSkqMi4wIC0gMS4wO1xcbiAgLy92ZWM0IHMxID0gdmVjNChsZXNzVGhhbihiMSwwLjApKSoyLjAgLSAxLjA7XFxuICB2ZWM0IHMwID0gZmxvb3IoYjApKjIuMCArIDEuMDtcXG4gIHZlYzQgczEgPSBmbG9vcihiMSkqMi4wICsgMS4wO1xcbiAgdmVjNCBzaCA9IC1zdGVwKGgsIHZlYzQoMC4wKSk7XFxuXFxuICB2ZWM0IGEwID0gYjAueHp5dyArIHMwLnh6eXcqc2gueHh5eSA7XFxuICB2ZWM0IGExID0gYjEueHp5dyArIHMxLnh6eXcqc2guenp3dyA7XFxuXFxuICB2ZWMzIHAwID0gdmVjMyhhMC54eSxoLngpO1xcbiAgdmVjMyBwMSA9IHZlYzMoYTAuencsaC55KTtcXG4gIHZlYzMgcDIgPSB2ZWMzKGExLnh5LGgueik7XFxuICB2ZWMzIHAzID0gdmVjMyhhMS56dyxoLncpO1xcblxcbi8vTm9ybWFsaXNlIGdyYWRpZW50c1xcbiAgdmVjNCBub3JtID0gdGF5bG9ySW52U3FydCh2ZWM0KGRvdChwMCxwMCksIGRvdChwMSxwMSksIGRvdChwMiwgcDIpLCBkb3QocDMscDMpKSk7XFxuICBwMCAqPSBub3JtLng7XFxuICBwMSAqPSBub3JtLnk7XFxuICBwMiAqPSBub3JtLno7XFxuICBwMyAqPSBub3JtLnc7XFxuXFxuLy8gTWl4IGZpbmFsIG5vaXNlIHZhbHVlXFxuICB2ZWM0IG0gPSBtYXgoMC42IC0gdmVjNChkb3QoeDAseDApLCBkb3QoeDEseDEpLCBkb3QoeDIseDIpLCBkb3QoeDMseDMpKSwgMC4wKTtcXG4gIG0gPSBtICogbTtcXG4gIHJldHVybiA0Mi4wICogZG90KCBtKm0sIHZlYzQoIGRvdChwMCx4MCksIGRvdChwMSx4MSksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb3QocDIseDIpLCBkb3QocDMseDMpICkgKTtcXG4gIH1cXG5cXG4gICAgICAgIHZlYzMgbm9pc2UyZCggdmVjMiBzdCwgZmxvYXQgc2NhbGUsIGZsb2F0IHN0cmVuZ3RoLCBmbG9hdCB0aW1lICkge1xcbiAgICAgICAgICBmbG9hdCBjb2wgPSBzbm9pc2UoIHZlYzMoIHN0LCB0aW1lICkgKiBzY2FsZSApO1xcblxcbiAgICAgICAgICByZXR1cm4gdmVjMyhjb2wpICogc3RyZW5ndGg7XFxuICAgICAgICB9XFxuXCIsXCJcIl0pICxcbiAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICB7IG5hbWU6J3NjYWxlJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjIgfSxcbiAgICAgIHsgbmFtZTonc3RyZW5ndGgnLCB0eXBlOidmbG9hdCcsIGRlZmF1bHQ6LjEgfSxcbiAgICAgIHsgbmFtZTondGltZScsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDoxIH1cbiAgICBdLFxuICB9LFxuICAvLyBhZGFwdGVkIGZyb20gaHR0cHM6Ly90aGVib29rb2ZzaGFkZXJzLmNvbS8xMC9cbiAgdHJ1Y2hldDoge1xuICAgIG5hbWU6J3RydWNoZXQnLFxuICAgIGdsc2wyZDpgICAgIFxuICAgICAgICBmbG9hdCByYW5kb21fdHJ1Y2hldChpbiB2ZWMyIF9zdCkge1xuICAgICAgICAgIHJldHVybiBmcmFjdChzaW4oZG90KF9zdC54eSxcbiAgICAgICAgICAgICAgICAgICAgICAgICB2ZWMyKDEyLjk4OTgsNzguMjMzKSkpKlxuICAgICAgICAgICAgICAgICAgICAgICAgNDM3NTguNTQ1MzEyMyk7XG4gICAgICAgIH1cblxuICAgICAgICB2ZWMyIHRydWNoZXRQYXR0ZXJuKGluIHZlYzIgX3N0LCBpbiBmbG9hdCBfaW5kZXgpe1xuICAgICAgICAgICAgX2luZGV4ID0gZnJhY3QoKChfaW5kZXgtMC41KSoyLjApKTtcbiAgICAgICAgICAgIGlmIChfaW5kZXggPiAwLjc1KSB7XG4gICAgICAgICAgICAgICAgX3N0ID0gdmVjMigxLjApIC0gX3N0O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChfaW5kZXggPiAwLjUpIHtcbiAgICAgICAgICAgICAgICBfc3QgPSB2ZWMyKDEuMC1fc3QueCxfc3QueSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKF9pbmRleCA+IDAuMjUpIHtcbiAgICAgICAgICAgICAgICBfc3QgPSAxLjAtdmVjMigxLjAtX3N0LngsX3N0LnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9zdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZlYzMgdHJ1Y2hldDJkKCB2ZWMyIHN0LCBmbG9hdCBzY2FsZSwgdmVjMyBjb2xvciApIHtcbiAgICAgICAgICAgIHN0ID0gc3QgKiBzY2FsZTtcbiAgICAgICAgICAgIHZlYzIgaXBvcyA9IGZsb29yKHN0KTsgIC8vIGludGVnZXJcbiAgICAgICAgICAgIHZlYzIgZnBvcyA9IGZyYWN0KHN0KTsgIC8vIGZyYWN0aW9uXG5cbiAgICAgICAgICAgIHZlYzIgdGlsZSA9IHRydWNoZXRQYXR0ZXJuKGZwb3MsIHJhbmRvbV90cnVjaGV0KCBpcG9zICkpO1xuXG4gICAgICAgICAgICBmbG9hdCBjb2wgPSBzbW9vdGhzdGVwKHRpbGUueC0wLjMsdGlsZS54LHRpbGUueSktc21vb3Roc3RlcCh0aWxlLngsdGlsZS54Ky4zLHRpbGUueSk7XG4gICAgICAgICAgICByZXR1cm4gY29sb3IgKiBjb2w7XG4gICAgICAgIH1cblxuYCAsXG4gICAgcGFyYW1ldGVyczogW1xuICAgICAgeyBuYW1lOidzY2FsZScsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDoxMCB9LFxuICAgICAgeyBuYW1lOidjb2xvcicsIHR5cGU6J3ZlYzMnLCBkZWZhdWx0OlsxLDEsMV0gfVxuICAgIF0sXG4gIH0sXG4gIGRvdHM6IHtcbiAgICBuYW1lOidkb3RzJyxcbiAgICBnbHNsOmAgICAgICAgICAgXG4gICAgICAgIHZlYzMgZG90cyggdmVjMyBwb3MsIGZsb2F0IGNvdW50LCBmbG9hdCByYWRpdXMsIHZlYzMgY29sb3IgKSB7XG4gICAgICAgICAgdmVjMyB0ZXg7XG4gICAgICAgICAgdGV4ID0gdmVjMyggY29sb3IgLSBzbW9vdGhzdGVwKCByYWRpdXMsIHJhZGl1cysuMDIsIGxlbmd0aChmcmFjdChwb3MqKHJvdW5kKGNvdW50LzIuKSsuNSkpIC0uNSApKSApO1xuICAgICAgICAgIHJldHVybiB0ZXg7XG4gICAgICAgIH1gICxcbiAgICBnbHNsMmQ6YFxuICAgICAgdmVjMiB0aWxlKHZlYzIgX3N0LCBmbG9hdCBfem9vbSl7XG4gICAgICAgIF9zdCAqPSBfem9vbTtcbiAgICAgICAgcmV0dXJuIGZyYWN0KF9zdCk7XG4gICAgICB9XG5cbiAgICAgIGZsb2F0IGNpcmNsZSh2ZWMyIF9zdCwgZmxvYXQgX3JhZGl1cyl7XG4gICAgICAgIHZlYzIgcG9zID0gdmVjMigwLjUpLV9zdDtcbiAgICAgICAgX3JhZGl1cyAqPSAwLjc1O1xuICAgICAgICByZXR1cm4gMS4tc21vb3Roc3RlcChfcmFkaXVzLShfcmFkaXVzKjAuMDUpLF9yYWRpdXMrKF9yYWRpdXMqMC4wNSksZG90KHBvcyxwb3MpKjMuMTQpO1xuICAgICAgfVxuICAgIFxuICAgICAgdmVjMyBkb3RzMmQoIHZlYzIgX3N0LCBmbG9hdCBzY2FsZSwgZmxvYXQgcmFkaXVzLCB2ZWMzIGNvbG9yICkge1xuICAgICAgICB2ZWMyIHN0ID0gdGlsZShfc3Qsc2NhbGUpO1xuICAgICAgICB2ZWMzIGZpbiA9IHZlYzMoY2lyY2xlKHN0LCByYWRpdXMpKSAqIGNvbG9yO1xuICAgICAgICByZXR1cm4gZmluO1xuICAgICAgfVxuICAgIGAsXG4gICAgcGFyYW1ldGVyczogW1xuICAgICAgeyBuYW1lOidzY2FsZScsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDo1IH0sXG4gICAgICB7IG5hbWU6J3JhZGl1cycsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDouMyB9LFxuICAgICAgeyBuYW1lOidjb2xvcicsIHR5cGU6J3ZlYzMnLCBkZWZhdWx0OlsxLDEsMV0gfVxuICAgIF0sXG4gIH0sXG4gIHN0cmlwZXM6IHtcbiAgICBuYW1lOidzdHJpcGVzJyxcbiAgICBnbHNsOmAgICAgICAgICAgXG4gICAgICAgIHZlYzMgc3RyaXBlcyggdmVjMyBwb3MsIGZsb2F0IHNjYWxlLCB2ZWMzIGNvbG9yICkge1xuICAgICAgICAgIHZlYzMgdGV4O1xuICAgICAgICAgIHRleCA9IHZlYzMoIGNvbG9yIC0gc21vb3Roc3RlcCgwLjMsIDAuMzIsIGxlbmd0aChmcmFjdCgocG9zLngrcG9zLnkrcG9zLnopKnNjYWxlKSAtLjUgKSkgKTtcbiAgICAgICAgICByZXR1cm4gdGV4O1xuICAgICAgICB9YCAsXG4gICAgcGFyYW1ldGVyczogW1xuICAgICAgeyBuYW1lOidzY2FsZScsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDo1IH0sXG4gICAgICB7IG5hbWU6J2NvbG9yJywgdHlwZTondmVjMycsIGRlZmF1bHQ6WzEsMSwxXSB9XG4gICAgXSxcbiAgfSxcbiAgY2VsbHVsYXI6IHtcbiAgICBuYW1lOidjZWxsdWxhcicsXG4gICAgZ2xzbDpnbHNsKFtcIiNkZWZpbmUgR0xTTElGWSAxXFxuXFxuICAgICAgICAvLyBQZXJtdXRhdGlvbiBwb2x5bm9taWFsOiAoMzR4XjIgKyB4KSBtb2QgMjg5XFxudmVjMyBwZXJtdXRlKHZlYzMgeCkge1xcbiAgcmV0dXJuIG1vZCgoMzQuMCAqIHggKyAxLjApICogeCwgMjg5LjApO1xcbn1cXG5cXG52ZWMzIGRpc3QodmVjMyB4LCB2ZWMzIHksIHZlYzMgeiwgIGJvb2wgbWFuaGF0dGFuRGlzdGFuY2UpIHtcXG4gIHJldHVybiBtYW5oYXR0YW5EaXN0YW5jZSA/ICBhYnMoeCkgKyBhYnMoeSkgKyBhYnMoeikgOiAgKHggKiB4ICsgeSAqIHkgKyB6ICogeik7XFxufVxcblxcbnZlYzIgd29ybGV5KHZlYzMgUCwgZmxvYXQgaml0dGVyLCBib29sIG1hbmhhdHRhbkRpc3RhbmNlKSB7XFxuZmxvYXQgSyA9IDAuMTQyODU3MTQyODU3OyAvLyAxLzdcXG5mbG9hdCBLbyA9IDAuNDI4NTcxNDI4NTcxOyAvLyAxLzItSy8yXFxuZmxvYXQgIEsyID0gMC4wMjA0MDgxNjMyNjUzMDY7IC8vIDEvKDcqNylcXG5mbG9hdCBLeiA9IDAuMTY2NjY2NjY2NjY3OyAvLyAxLzZcXG5mbG9hdCBLem8gPSAwLjQxNjY2NjY2NjY2NzsgLy8gMS8yLTEvNioyXFxuXFxuXFx0dmVjMyBQaSA9IG1vZChmbG9vcihQKSwgMjg5LjApO1xcbiBcXHR2ZWMzIFBmID0gZnJhY3QoUCkgLSAwLjU7XFxuXFxuXFx0dmVjMyBQZnggPSBQZi54ICsgdmVjMygxLjAsIDAuMCwgLTEuMCk7XFxuXFx0dmVjMyBQZnkgPSBQZi55ICsgdmVjMygxLjAsIDAuMCwgLTEuMCk7XFxuXFx0dmVjMyBQZnogPSBQZi56ICsgdmVjMygxLjAsIDAuMCwgLTEuMCk7XFxuXFxuXFx0dmVjMyBwID0gcGVybXV0ZShQaS54ICsgdmVjMygtMS4wLCAwLjAsIDEuMCkpO1xcblxcdHZlYzMgcDEgPSBwZXJtdXRlKHAgKyBQaS55IC0gMS4wKTtcXG5cXHR2ZWMzIHAyID0gcGVybXV0ZShwICsgUGkueSk7XFxuXFx0dmVjMyBwMyA9IHBlcm11dGUocCArIFBpLnkgKyAxLjApO1xcblxcblxcdHZlYzMgcDExID0gcGVybXV0ZShwMSArIFBpLnogLSAxLjApO1xcblxcdHZlYzMgcDEyID0gcGVybXV0ZShwMSArIFBpLnopO1xcblxcdHZlYzMgcDEzID0gcGVybXV0ZShwMSArIFBpLnogKyAxLjApO1xcblxcblxcdHZlYzMgcDIxID0gcGVybXV0ZShwMiArIFBpLnogLSAxLjApO1xcblxcdHZlYzMgcDIyID0gcGVybXV0ZShwMiArIFBpLnopO1xcblxcdHZlYzMgcDIzID0gcGVybXV0ZShwMiArIFBpLnogKyAxLjApO1xcblxcblxcdHZlYzMgcDMxID0gcGVybXV0ZShwMyArIFBpLnogLSAxLjApO1xcblxcdHZlYzMgcDMyID0gcGVybXV0ZShwMyArIFBpLnopO1xcblxcdHZlYzMgcDMzID0gcGVybXV0ZShwMyArIFBpLnogKyAxLjApO1xcblxcblxcdHZlYzMgb3gxMSA9IGZyYWN0KHAxMSpLKSAtIEtvO1xcblxcdHZlYzMgb3kxMSA9IG1vZChmbG9vcihwMTEqSyksIDcuMCkqSyAtIEtvO1xcblxcdHZlYzMgb3oxMSA9IGZsb29yKHAxMSpLMikqS3ogLSBLem87IC8vIHAxMSA8IDI4OSBndWFyYW50ZWVkXFxuXFxuXFx0dmVjMyBveDEyID0gZnJhY3QocDEyKkspIC0gS287XFxuXFx0dmVjMyBveTEyID0gbW9kKGZsb29yKHAxMipLKSwgNy4wKSpLIC0gS287XFxuXFx0dmVjMyBvejEyID0gZmxvb3IocDEyKksyKSpLeiAtIEt6bztcXG5cXG5cXHR2ZWMzIG94MTMgPSBmcmFjdChwMTMqSykgLSBLbztcXG5cXHR2ZWMzIG95MTMgPSBtb2QoZmxvb3IocDEzKkspLCA3LjApKksgLSBLbztcXG5cXHR2ZWMzIG96MTMgPSBmbG9vcihwMTMqSzIpKkt6IC0gS3pvO1xcblxcblxcdHZlYzMgb3gyMSA9IGZyYWN0KHAyMSpLKSAtIEtvO1xcblxcdHZlYzMgb3kyMSA9IG1vZChmbG9vcihwMjEqSyksIDcuMCkqSyAtIEtvO1xcblxcdHZlYzMgb3oyMSA9IGZsb29yKHAyMSpLMikqS3ogLSBLem87XFxuXFxuXFx0dmVjMyBveDIyID0gZnJhY3QocDIyKkspIC0gS287XFxuXFx0dmVjMyBveTIyID0gbW9kKGZsb29yKHAyMipLKSwgNy4wKSpLIC0gS287XFxuXFx0dmVjMyBvejIyID0gZmxvb3IocDIyKksyKSpLeiAtIEt6bztcXG5cXG5cXHR2ZWMzIG94MjMgPSBmcmFjdChwMjMqSykgLSBLbztcXG5cXHR2ZWMzIG95MjMgPSBtb2QoZmxvb3IocDIzKkspLCA3LjApKksgLSBLbztcXG5cXHR2ZWMzIG96MjMgPSBmbG9vcihwMjMqSzIpKkt6IC0gS3pvO1xcblxcblxcdHZlYzMgb3gzMSA9IGZyYWN0KHAzMSpLKSAtIEtvO1xcblxcdHZlYzMgb3kzMSA9IG1vZChmbG9vcihwMzEqSyksIDcuMCkqSyAtIEtvO1xcblxcdHZlYzMgb3ozMSA9IGZsb29yKHAzMSpLMikqS3ogLSBLem87XFxuXFxuXFx0dmVjMyBveDMyID0gZnJhY3QocDMyKkspIC0gS287XFxuXFx0dmVjMyBveTMyID0gbW9kKGZsb29yKHAzMipLKSwgNy4wKSpLIC0gS287XFxuXFx0dmVjMyBvejMyID0gZmxvb3IocDMyKksyKSpLeiAtIEt6bztcXG5cXG5cXHR2ZWMzIG94MzMgPSBmcmFjdChwMzMqSykgLSBLbztcXG5cXHR2ZWMzIG95MzMgPSBtb2QoZmxvb3IocDMzKkspLCA3LjApKksgLSBLbztcXG5cXHR2ZWMzIG96MzMgPSBmbG9vcihwMzMqSzIpKkt6IC0gS3pvO1xcblxcblxcdHZlYzMgZHgxMSA9IFBmeCArIGppdHRlcipveDExO1xcblxcdHZlYzMgZHkxMSA9IFBmeS54ICsgaml0dGVyKm95MTE7XFxuXFx0dmVjMyBkejExID0gUGZ6LnggKyBqaXR0ZXIqb3oxMTtcXG5cXG5cXHR2ZWMzIGR4MTIgPSBQZnggKyBqaXR0ZXIqb3gxMjtcXG5cXHR2ZWMzIGR5MTIgPSBQZnkueCArIGppdHRlcipveTEyO1xcblxcdHZlYzMgZHoxMiA9IFBmei55ICsgaml0dGVyKm96MTI7XFxuXFxuXFx0dmVjMyBkeDEzID0gUGZ4ICsgaml0dGVyKm94MTM7XFxuXFx0dmVjMyBkeTEzID0gUGZ5LnggKyBqaXR0ZXIqb3kxMztcXG5cXHR2ZWMzIGR6MTMgPSBQZnoueiArIGppdHRlcipvejEzO1xcblxcblxcdHZlYzMgZHgyMSA9IFBmeCArIGppdHRlcipveDIxO1xcblxcdHZlYzMgZHkyMSA9IFBmeS55ICsgaml0dGVyKm95MjE7XFxuXFx0dmVjMyBkejIxID0gUGZ6LnggKyBqaXR0ZXIqb3oyMTtcXG5cXG5cXHR2ZWMzIGR4MjIgPSBQZnggKyBqaXR0ZXIqb3gyMjtcXG5cXHR2ZWMzIGR5MjIgPSBQZnkueSArIGppdHRlcipveTIyO1xcblxcdHZlYzMgZHoyMiA9IFBmei55ICsgaml0dGVyKm96MjI7XFxuXFxuXFx0dmVjMyBkeDIzID0gUGZ4ICsgaml0dGVyKm94MjM7XFxuXFx0dmVjMyBkeTIzID0gUGZ5LnkgKyBqaXR0ZXIqb3kyMztcXG5cXHR2ZWMzIGR6MjMgPSBQZnoueiArIGppdHRlcipvejIzO1xcblxcblxcdHZlYzMgZHgzMSA9IFBmeCArIGppdHRlcipveDMxO1xcblxcdHZlYzMgZHkzMSA9IFBmeS56ICsgaml0dGVyKm95MzE7XFxuXFx0dmVjMyBkejMxID0gUGZ6LnggKyBqaXR0ZXIqb3ozMTtcXG5cXG5cXHR2ZWMzIGR4MzIgPSBQZnggKyBqaXR0ZXIqb3gzMjtcXG5cXHR2ZWMzIGR5MzIgPSBQZnkueiArIGppdHRlcipveTMyO1xcblxcdHZlYzMgZHozMiA9IFBmei55ICsgaml0dGVyKm96MzI7XFxuXFxuXFx0dmVjMyBkeDMzID0gUGZ4ICsgaml0dGVyKm94MzM7XFxuXFx0dmVjMyBkeTMzID0gUGZ5LnogKyBqaXR0ZXIqb3kzMztcXG5cXHR2ZWMzIGR6MzMgPSBQZnoueiArIGppdHRlcipvejMzO1xcblxcblxcdHZlYzMgZDExID0gZGlzdChkeDExLCBkeTExLCBkejExLCBtYW5oYXR0YW5EaXN0YW5jZSk7XFxuXFx0dmVjMyBkMTIgPWRpc3QoZHgxMiwgZHkxMiwgZHoxMiwgbWFuaGF0dGFuRGlzdGFuY2UpO1xcblxcdHZlYzMgZDEzID0gZGlzdChkeDEzLCBkeTEzLCBkejEzLCBtYW5oYXR0YW5EaXN0YW5jZSk7XFxuXFx0dmVjMyBkMjEgPSBkaXN0KGR4MjEsIGR5MjEsIGR6MjEsIG1hbmhhdHRhbkRpc3RhbmNlKTtcXG5cXHR2ZWMzIGQyMiA9IGRpc3QoZHgyMiwgZHkyMiwgZHoyMiwgbWFuaGF0dGFuRGlzdGFuY2UpO1xcblxcdHZlYzMgZDIzID0gZGlzdChkeDIzLCBkeTIzLCBkejIzLCBtYW5oYXR0YW5EaXN0YW5jZSk7XFxuXFx0dmVjMyBkMzEgPSBkaXN0KGR4MzEsIGR5MzEsIGR6MzEsIG1hbmhhdHRhbkRpc3RhbmNlKTtcXG5cXHR2ZWMzIGQzMiA9IGRpc3QoZHgzMiwgZHkzMiwgZHozMiwgbWFuaGF0dGFuRGlzdGFuY2UpO1xcblxcdHZlYzMgZDMzID0gZGlzdChkeDMzLCBkeTMzLCBkejMzLCBtYW5oYXR0YW5EaXN0YW5jZSk7XFxuXFxuXFx0dmVjMyBkMWEgPSBtaW4oZDExLCBkMTIpO1xcblxcdGQxMiA9IG1heChkMTEsIGQxMik7XFxuXFx0ZDExID0gbWluKGQxYSwgZDEzKTsgLy8gU21hbGxlc3Qgbm93IG5vdCBpbiBkMTIgb3IgZDEzXFxuXFx0ZDEzID0gbWF4KGQxYSwgZDEzKTtcXG5cXHRkMTIgPSBtaW4oZDEyLCBkMTMpOyAvLyAybmQgc21hbGxlc3Qgbm93IG5vdCBpbiBkMTNcXG5cXHR2ZWMzIGQyYSA9IG1pbihkMjEsIGQyMik7XFxuXFx0ZDIyID0gbWF4KGQyMSwgZDIyKTtcXG5cXHRkMjEgPSBtaW4oZDJhLCBkMjMpOyAvLyBTbWFsbGVzdCBub3cgbm90IGluIGQyMiBvciBkMjNcXG5cXHRkMjMgPSBtYXgoZDJhLCBkMjMpO1xcblxcdGQyMiA9IG1pbihkMjIsIGQyMyk7IC8vIDJuZCBzbWFsbGVzdCBub3cgbm90IGluIGQyM1xcblxcdHZlYzMgZDNhID0gbWluKGQzMSwgZDMyKTtcXG5cXHRkMzIgPSBtYXgoZDMxLCBkMzIpO1xcblxcdGQzMSA9IG1pbihkM2EsIGQzMyk7IC8vIFNtYWxsZXN0IG5vdyBub3QgaW4gZDMyIG9yIGQzM1xcblxcdGQzMyA9IG1heChkM2EsIGQzMyk7XFxuXFx0ZDMyID0gbWluKGQzMiwgZDMzKTsgLy8gMm5kIHNtYWxsZXN0IG5vdyBub3QgaW4gZDMzXFxuXFx0dmVjMyBkYSA9IG1pbihkMTEsIGQyMSk7XFxuXFx0ZDIxID0gbWF4KGQxMSwgZDIxKTtcXG5cXHRkMTEgPSBtaW4oZGEsIGQzMSk7IC8vIFNtYWxsZXN0IG5vdyBpbiBkMTFcXG5cXHRkMzEgPSBtYXgoZGEsIGQzMSk7IC8vIDJuZCBzbWFsbGVzdCBub3cgbm90IGluIGQzMVxcblxcdGQxMS54eSA9IChkMTEueCA8IGQxMS55KSA/IGQxMS54eSA6IGQxMS55eDtcXG5cXHRkMTEueHogPSAoZDExLnggPCBkMTEueikgPyBkMTEueHogOiBkMTEueng7IC8vIGQxMS54IG5vdyBzbWFsbGVzdFxcblxcdGQxMiA9IG1pbihkMTIsIGQyMSk7IC8vIDJuZCBzbWFsbGVzdCBub3cgbm90IGluIGQyMVxcblxcdGQxMiA9IG1pbihkMTIsIGQyMik7IC8vIG5vciBpbiBkMjJcXG5cXHRkMTIgPSBtaW4oZDEyLCBkMzEpOyAvLyBub3IgaW4gZDMxXFxuXFx0ZDEyID0gbWluKGQxMiwgZDMyKTsgLy8gbm9yIGluIGQzMlxcblxcdGQxMS55eiA9IG1pbihkMTEueXosZDEyLnh5KTsgLy8gbm9yIGluIGQxMi55elxcblxcdGQxMS55ID0gbWluKGQxMS55LGQxMi56KTsgLy8gT25seSB0d28gbW9yZSB0byBnb1xcblxcdGQxMS55ID0gbWluKGQxMS55LGQxMS56KTsgLy8gRG9uZSEgKFBoZXchKVxcblxcdHJldHVybiBzcXJ0KGQxMS54eSk7IC8vIEYxLCBGMlxcblxcbn1cXG5cXG4gICAgICAgIHZlYzMgY2VsbHVsYXIoIHZlYzMgcG9zLCBmbG9hdCBzY2FsZSwgZmxvYXQgaml0dGVyLCBmbG9hdCBtb2RlLCBmbG9hdCBzdHJlbmd0aCwgZmxvYXQgdGltZSApIHtcXG4gICAgICAgICAgdmVjMiB3ID0gd29ybGV5KCBwb3MgKiBzY2FsZSArIHRpbWUsIGppdHRlciwgZmFsc2UgKTtcXG4gICAgICAgICAgdmVjMyBvO1xcbiAgICAgICAgICBpZiggbW9kZSA9PSAwLiApIHtcXG4gICAgICAgICAgICBvID0gdmVjMyggdy54ICk7XFxuICAgICAgICAgIH0gZWxzZSBpZiAoIG1vZGUgPT0gMS4gKSB7XFxuICAgICAgICAgICAgbyA9IHZlYzMoIHcueSApO1xcbiAgICAgICAgICB9IGVsc2V7XFxuICAgICAgICAgICAgbyA9IHZlYzMoIHcueSAtIHcueCApO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHJldHVybiBvICogc3RyZW5ndGg7XFxuICAgICAgICB9XFxuICAgIFwiLFwiXCJdKSxcbiAgICBnbHNsMmQ6Z2xzbChbXCIjZGVmaW5lIEdMU0xJRlkgMVxcblxcbiAgICAgICAgLy8gUGVybXV0YXRpb24gcG9seW5vbWlhbDogKDM0eF4yICsgeCkgbW9kIDI4OVxcbnZlYzMgcGVybXV0ZSh2ZWMzIHgpIHtcXG4gIHJldHVybiBtb2QoKDM0LjAgKiB4ICsgMS4wKSAqIHgsIDI4OS4wKTtcXG59XFxuXFxudmVjMyBkaXN0KHZlYzMgeCwgdmVjMyB5LCB2ZWMzIHosICBib29sIG1hbmhhdHRhbkRpc3RhbmNlKSB7XFxuICByZXR1cm4gbWFuaGF0dGFuRGlzdGFuY2UgPyAgYWJzKHgpICsgYWJzKHkpICsgYWJzKHopIDogICh4ICogeCArIHkgKiB5ICsgeiAqIHopO1xcbn1cXG5cXG52ZWMyIHdvcmxleSh2ZWMzIFAsIGZsb2F0IGppdHRlciwgYm9vbCBtYW5oYXR0YW5EaXN0YW5jZSkge1xcbmZsb2F0IEsgPSAwLjE0Mjg1NzE0Mjg1NzsgLy8gMS83XFxuZmxvYXQgS28gPSAwLjQyODU3MTQyODU3MTsgLy8gMS8yLUsvMlxcbmZsb2F0ICBLMiA9IDAuMDIwNDA4MTYzMjY1MzA2OyAvLyAxLyg3KjcpXFxuZmxvYXQgS3ogPSAwLjE2NjY2NjY2NjY2NzsgLy8gMS82XFxuZmxvYXQgS3pvID0gMC40MTY2NjY2NjY2Njc7IC8vIDEvMi0xLzYqMlxcblxcblxcdHZlYzMgUGkgPSBtb2QoZmxvb3IoUCksIDI4OS4wKTtcXG4gXFx0dmVjMyBQZiA9IGZyYWN0KFApIC0gMC41O1xcblxcblxcdHZlYzMgUGZ4ID0gUGYueCArIHZlYzMoMS4wLCAwLjAsIC0xLjApO1xcblxcdHZlYzMgUGZ5ID0gUGYueSArIHZlYzMoMS4wLCAwLjAsIC0xLjApO1xcblxcdHZlYzMgUGZ6ID0gUGYueiArIHZlYzMoMS4wLCAwLjAsIC0xLjApO1xcblxcblxcdHZlYzMgcCA9IHBlcm11dGUoUGkueCArIHZlYzMoLTEuMCwgMC4wLCAxLjApKTtcXG5cXHR2ZWMzIHAxID0gcGVybXV0ZShwICsgUGkueSAtIDEuMCk7XFxuXFx0dmVjMyBwMiA9IHBlcm11dGUocCArIFBpLnkpO1xcblxcdHZlYzMgcDMgPSBwZXJtdXRlKHAgKyBQaS55ICsgMS4wKTtcXG5cXG5cXHR2ZWMzIHAxMSA9IHBlcm11dGUocDEgKyBQaS56IC0gMS4wKTtcXG5cXHR2ZWMzIHAxMiA9IHBlcm11dGUocDEgKyBQaS56KTtcXG5cXHR2ZWMzIHAxMyA9IHBlcm11dGUocDEgKyBQaS56ICsgMS4wKTtcXG5cXG5cXHR2ZWMzIHAyMSA9IHBlcm11dGUocDIgKyBQaS56IC0gMS4wKTtcXG5cXHR2ZWMzIHAyMiA9IHBlcm11dGUocDIgKyBQaS56KTtcXG5cXHR2ZWMzIHAyMyA9IHBlcm11dGUocDIgKyBQaS56ICsgMS4wKTtcXG5cXG5cXHR2ZWMzIHAzMSA9IHBlcm11dGUocDMgKyBQaS56IC0gMS4wKTtcXG5cXHR2ZWMzIHAzMiA9IHBlcm11dGUocDMgKyBQaS56KTtcXG5cXHR2ZWMzIHAzMyA9IHBlcm11dGUocDMgKyBQaS56ICsgMS4wKTtcXG5cXG5cXHR2ZWMzIG94MTEgPSBmcmFjdChwMTEqSykgLSBLbztcXG5cXHR2ZWMzIG95MTEgPSBtb2QoZmxvb3IocDExKkspLCA3LjApKksgLSBLbztcXG5cXHR2ZWMzIG96MTEgPSBmbG9vcihwMTEqSzIpKkt6IC0gS3pvOyAvLyBwMTEgPCAyODkgZ3VhcmFudGVlZFxcblxcblxcdHZlYzMgb3gxMiA9IGZyYWN0KHAxMipLKSAtIEtvO1xcblxcdHZlYzMgb3kxMiA9IG1vZChmbG9vcihwMTIqSyksIDcuMCkqSyAtIEtvO1xcblxcdHZlYzMgb3oxMiA9IGZsb29yKHAxMipLMikqS3ogLSBLem87XFxuXFxuXFx0dmVjMyBveDEzID0gZnJhY3QocDEzKkspIC0gS287XFxuXFx0dmVjMyBveTEzID0gbW9kKGZsb29yKHAxMypLKSwgNy4wKSpLIC0gS287XFxuXFx0dmVjMyBvejEzID0gZmxvb3IocDEzKksyKSpLeiAtIEt6bztcXG5cXG5cXHR2ZWMzIG94MjEgPSBmcmFjdChwMjEqSykgLSBLbztcXG5cXHR2ZWMzIG95MjEgPSBtb2QoZmxvb3IocDIxKkspLCA3LjApKksgLSBLbztcXG5cXHR2ZWMzIG96MjEgPSBmbG9vcihwMjEqSzIpKkt6IC0gS3pvO1xcblxcblxcdHZlYzMgb3gyMiA9IGZyYWN0KHAyMipLKSAtIEtvO1xcblxcdHZlYzMgb3kyMiA9IG1vZChmbG9vcihwMjIqSyksIDcuMCkqSyAtIEtvO1xcblxcdHZlYzMgb3oyMiA9IGZsb29yKHAyMipLMikqS3ogLSBLem87XFxuXFxuXFx0dmVjMyBveDIzID0gZnJhY3QocDIzKkspIC0gS287XFxuXFx0dmVjMyBveTIzID0gbW9kKGZsb29yKHAyMypLKSwgNy4wKSpLIC0gS287XFxuXFx0dmVjMyBvejIzID0gZmxvb3IocDIzKksyKSpLeiAtIEt6bztcXG5cXG5cXHR2ZWMzIG94MzEgPSBmcmFjdChwMzEqSykgLSBLbztcXG5cXHR2ZWMzIG95MzEgPSBtb2QoZmxvb3IocDMxKkspLCA3LjApKksgLSBLbztcXG5cXHR2ZWMzIG96MzEgPSBmbG9vcihwMzEqSzIpKkt6IC0gS3pvO1xcblxcblxcdHZlYzMgb3gzMiA9IGZyYWN0KHAzMipLKSAtIEtvO1xcblxcdHZlYzMgb3kzMiA9IG1vZChmbG9vcihwMzIqSyksIDcuMCkqSyAtIEtvO1xcblxcdHZlYzMgb3ozMiA9IGZsb29yKHAzMipLMikqS3ogLSBLem87XFxuXFxuXFx0dmVjMyBveDMzID0gZnJhY3QocDMzKkspIC0gS287XFxuXFx0dmVjMyBveTMzID0gbW9kKGZsb29yKHAzMypLKSwgNy4wKSpLIC0gS287XFxuXFx0dmVjMyBvejMzID0gZmxvb3IocDMzKksyKSpLeiAtIEt6bztcXG5cXG5cXHR2ZWMzIGR4MTEgPSBQZnggKyBqaXR0ZXIqb3gxMTtcXG5cXHR2ZWMzIGR5MTEgPSBQZnkueCArIGppdHRlcipveTExO1xcblxcdHZlYzMgZHoxMSA9IFBmei54ICsgaml0dGVyKm96MTE7XFxuXFxuXFx0dmVjMyBkeDEyID0gUGZ4ICsgaml0dGVyKm94MTI7XFxuXFx0dmVjMyBkeTEyID0gUGZ5LnggKyBqaXR0ZXIqb3kxMjtcXG5cXHR2ZWMzIGR6MTIgPSBQZnoueSArIGppdHRlcipvejEyO1xcblxcblxcdHZlYzMgZHgxMyA9IFBmeCArIGppdHRlcipveDEzO1xcblxcdHZlYzMgZHkxMyA9IFBmeS54ICsgaml0dGVyKm95MTM7XFxuXFx0dmVjMyBkejEzID0gUGZ6LnogKyBqaXR0ZXIqb3oxMztcXG5cXG5cXHR2ZWMzIGR4MjEgPSBQZnggKyBqaXR0ZXIqb3gyMTtcXG5cXHR2ZWMzIGR5MjEgPSBQZnkueSArIGppdHRlcipveTIxO1xcblxcdHZlYzMgZHoyMSA9IFBmei54ICsgaml0dGVyKm96MjE7XFxuXFxuXFx0dmVjMyBkeDIyID0gUGZ4ICsgaml0dGVyKm94MjI7XFxuXFx0dmVjMyBkeTIyID0gUGZ5LnkgKyBqaXR0ZXIqb3kyMjtcXG5cXHR2ZWMzIGR6MjIgPSBQZnoueSArIGppdHRlcipvejIyO1xcblxcblxcdHZlYzMgZHgyMyA9IFBmeCArIGppdHRlcipveDIzO1xcblxcdHZlYzMgZHkyMyA9IFBmeS55ICsgaml0dGVyKm95MjM7XFxuXFx0dmVjMyBkejIzID0gUGZ6LnogKyBqaXR0ZXIqb3oyMztcXG5cXG5cXHR2ZWMzIGR4MzEgPSBQZnggKyBqaXR0ZXIqb3gzMTtcXG5cXHR2ZWMzIGR5MzEgPSBQZnkueiArIGppdHRlcipveTMxO1xcblxcdHZlYzMgZHozMSA9IFBmei54ICsgaml0dGVyKm96MzE7XFxuXFxuXFx0dmVjMyBkeDMyID0gUGZ4ICsgaml0dGVyKm94MzI7XFxuXFx0dmVjMyBkeTMyID0gUGZ5LnogKyBqaXR0ZXIqb3kzMjtcXG5cXHR2ZWMzIGR6MzIgPSBQZnoueSArIGppdHRlcipvejMyO1xcblxcblxcdHZlYzMgZHgzMyA9IFBmeCArIGppdHRlcipveDMzO1xcblxcdHZlYzMgZHkzMyA9IFBmeS56ICsgaml0dGVyKm95MzM7XFxuXFx0dmVjMyBkejMzID0gUGZ6LnogKyBqaXR0ZXIqb3ozMztcXG5cXG5cXHR2ZWMzIGQxMSA9IGRpc3QoZHgxMSwgZHkxMSwgZHoxMSwgbWFuaGF0dGFuRGlzdGFuY2UpO1xcblxcdHZlYzMgZDEyID1kaXN0KGR4MTIsIGR5MTIsIGR6MTIsIG1hbmhhdHRhbkRpc3RhbmNlKTtcXG5cXHR2ZWMzIGQxMyA9IGRpc3QoZHgxMywgZHkxMywgZHoxMywgbWFuaGF0dGFuRGlzdGFuY2UpO1xcblxcdHZlYzMgZDIxID0gZGlzdChkeDIxLCBkeTIxLCBkejIxLCBtYW5oYXR0YW5EaXN0YW5jZSk7XFxuXFx0dmVjMyBkMjIgPSBkaXN0KGR4MjIsIGR5MjIsIGR6MjIsIG1hbmhhdHRhbkRpc3RhbmNlKTtcXG5cXHR2ZWMzIGQyMyA9IGRpc3QoZHgyMywgZHkyMywgZHoyMywgbWFuaGF0dGFuRGlzdGFuY2UpO1xcblxcdHZlYzMgZDMxID0gZGlzdChkeDMxLCBkeTMxLCBkejMxLCBtYW5oYXR0YW5EaXN0YW5jZSk7XFxuXFx0dmVjMyBkMzIgPSBkaXN0KGR4MzIsIGR5MzIsIGR6MzIsIG1hbmhhdHRhbkRpc3RhbmNlKTtcXG5cXHR2ZWMzIGQzMyA9IGRpc3QoZHgzMywgZHkzMywgZHozMywgbWFuaGF0dGFuRGlzdGFuY2UpO1xcblxcblxcdHZlYzMgZDFhID0gbWluKGQxMSwgZDEyKTtcXG5cXHRkMTIgPSBtYXgoZDExLCBkMTIpO1xcblxcdGQxMSA9IG1pbihkMWEsIGQxMyk7IC8vIFNtYWxsZXN0IG5vdyBub3QgaW4gZDEyIG9yIGQxM1xcblxcdGQxMyA9IG1heChkMWEsIGQxMyk7XFxuXFx0ZDEyID0gbWluKGQxMiwgZDEzKTsgLy8gMm5kIHNtYWxsZXN0IG5vdyBub3QgaW4gZDEzXFxuXFx0dmVjMyBkMmEgPSBtaW4oZDIxLCBkMjIpO1xcblxcdGQyMiA9IG1heChkMjEsIGQyMik7XFxuXFx0ZDIxID0gbWluKGQyYSwgZDIzKTsgLy8gU21hbGxlc3Qgbm93IG5vdCBpbiBkMjIgb3IgZDIzXFxuXFx0ZDIzID0gbWF4KGQyYSwgZDIzKTtcXG5cXHRkMjIgPSBtaW4oZDIyLCBkMjMpOyAvLyAybmQgc21hbGxlc3Qgbm93IG5vdCBpbiBkMjNcXG5cXHR2ZWMzIGQzYSA9IG1pbihkMzEsIGQzMik7XFxuXFx0ZDMyID0gbWF4KGQzMSwgZDMyKTtcXG5cXHRkMzEgPSBtaW4oZDNhLCBkMzMpOyAvLyBTbWFsbGVzdCBub3cgbm90IGluIGQzMiBvciBkMzNcXG5cXHRkMzMgPSBtYXgoZDNhLCBkMzMpO1xcblxcdGQzMiA9IG1pbihkMzIsIGQzMyk7IC8vIDJuZCBzbWFsbGVzdCBub3cgbm90IGluIGQzM1xcblxcdHZlYzMgZGEgPSBtaW4oZDExLCBkMjEpO1xcblxcdGQyMSA9IG1heChkMTEsIGQyMSk7XFxuXFx0ZDExID0gbWluKGRhLCBkMzEpOyAvLyBTbWFsbGVzdCBub3cgaW4gZDExXFxuXFx0ZDMxID0gbWF4KGRhLCBkMzEpOyAvLyAybmQgc21hbGxlc3Qgbm93IG5vdCBpbiBkMzFcXG5cXHRkMTEueHkgPSAoZDExLnggPCBkMTEueSkgPyBkMTEueHkgOiBkMTEueXg7XFxuXFx0ZDExLnh6ID0gKGQxMS54IDwgZDExLnopID8gZDExLnh6IDogZDExLnp4OyAvLyBkMTEueCBub3cgc21hbGxlc3RcXG5cXHRkMTIgPSBtaW4oZDEyLCBkMjEpOyAvLyAybmQgc21hbGxlc3Qgbm93IG5vdCBpbiBkMjFcXG5cXHRkMTIgPSBtaW4oZDEyLCBkMjIpOyAvLyBub3IgaW4gZDIyXFxuXFx0ZDEyID0gbWluKGQxMiwgZDMxKTsgLy8gbm9yIGluIGQzMVxcblxcdGQxMiA9IG1pbihkMTIsIGQzMik7IC8vIG5vciBpbiBkMzJcXG5cXHRkMTEueXogPSBtaW4oZDExLnl6LGQxMi54eSk7IC8vIG5vciBpbiBkMTIueXpcXG5cXHRkMTEueSA9IG1pbihkMTEueSxkMTIueik7IC8vIE9ubHkgdHdvIG1vcmUgdG8gZ29cXG5cXHRkMTEueSA9IG1pbihkMTEueSxkMTEueik7IC8vIERvbmUhIChQaGV3ISlcXG5cXHRyZXR1cm4gc3FydChkMTEueHkpOyAvLyBGMSwgRjJcXG5cXG59XFxuXFxuICAgICAgICB2ZWMzIGNlbGx1bGFyKCB2ZWMzIHBvcywgZmxvYXQgc2NhbGUsIGZsb2F0IGppdHRlciwgZmxvYXQgbW9kZSwgZmxvYXQgc3RyZW5ndGggKSB7XFxuICAgICAgICAgIHZlYzIgdyA9IHdvcmxleSggcG9zLCBqaXR0ZXIsIGZhbHNlICk7XFxuICAgICAgICAgIHZlYzMgbztcXG4gICAgICAgICAgaWYoIG1vZGUgPT0gMC4gKSB7XFxuICAgICAgICAgICAgbyA9IHZlYzMoIHcueCApO1xcbiAgICAgICAgICB9IGVsc2UgaWYgKCBtb2RlID09IDEuICkge1xcbiAgICAgICAgICAgIG8gPSB2ZWMzKCB3LnkgKTtcXG4gICAgICAgICAgfSBlbHNle1xcbiAgICAgICAgICAgIG8gPSB2ZWMzKCB3LnkgLSB3LnggKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICByZXR1cm4gbyAqIHN0cmVuZ3RoO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmVjMyBjZWxsdWxhcjJkKCB2ZWMyIHN0LCBmbG9hdCBzY2FsZSwgZmxvYXQgaml0dGVyLCBmbG9hdCBtb2RlLCBmbG9hdCBzdHJlbmd0aCwgZmxvYXQgdGltZSApIHtcXG4gICAgICAgICAgcmV0dXJuIGNlbGx1bGFyKCB2ZWMzKHN0ICogc2NhbGUsIHRpbWUpLCBub3IsIHNjYWxlLCBqaXR0ZXIsIG1vZGUsIHN0cmVuZ3RoICk7XFxuICAgICAgICB9XFxuICAgIFwiLFwiXCJdKSxcbiAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICB7IG5hbWU6J3NjYWxlJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjEgfSxcbiAgICAgIHsgbmFtZTonaml0dGVyJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjEgfSxcbiAgICAgIHsgbmFtZTondHlwZScsICB0eXBlOidmbG9hdCcsIGRlZmF1bHQ6IDAgfSxcbiAgICAgIHsgbmFtZTonc3RyZW5ndGgnLCB0eXBlOidmbG9hdCcsIGRlZmF1bHQ6MiB9LFxuICAgICAgeyBuYW1lOid0aW1lJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjEgfVxuICAgIF0sICAgICBcbiAgfSxcblxuICB2b3Jvbm9pOiB7XG4gICAgbmFtZTondm9yb25vaScsXG4gICAgcGFyYW1ldGVyczogW1xuICAgICAgeyBuYW1lOidzY2FsZScsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDoxIH0sXG4gICAgICB7IG5hbWU6J3JlcycsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDoxMDAgfSxcbiAgICAgIHsgbmFtZTondGltZScsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDoxIH0sXG4gICAgICB7IG5hbWU6J21vZGUnLCB0eXBlOidmbG9hdCcsIGRlZmF1bHQ6MCB9XG4gICAgXSxcbiAgICBnbHNsOmBcbiAgICB2ZWMzIHZvcm9ub2lfaGFzaCh2ZWMzIHApIHtcbiAgICAgIHJldHVybiBmcmFjdChcbiAgICAgICAgICBzaW4odmVjMyhkb3QocCwgdmVjMygxLjAsIDU3LjAsIDExMy4wKSksIGRvdChwLCB2ZWMzKDU3LjAsIDExMy4wLCAxLjApKSxcbiAgICAgICAgICAgICAgICAgICBkb3QocCwgdmVjMygxMTMuMCwgMS4wLCA1Ny4wKSkpKSAqXG4gICAgICAgICAgNDM3NTguNTQ1Myk7XG4gICAgfVxuXG4gICAgdmVjMyB2b3Jvbm9pXzNkKGNvbnN0IGluIHZlYzMgeCwgZmxvYXQgX3JlcyApIHtcbiAgICAgIHZlYzMgcCA9IGZsb29yKHgpO1xuICAgICAgdmVjMyBmID0gZnJhY3QoeCk7XG5cbiAgICAgIGZsb2F0IGlkID0gMC4wO1xuICAgICAgdmVjMiByZXMgPSB2ZWMyKCBfcmVzICk7XG4gICAgICBmb3IgKGludCBrID0gLTE7IGsgPD0gMTsgaysrKSB7XG4gICAgICAgIGZvciAoaW50IGogPSAtMTsgaiA8PSAxOyBqKyspIHtcbiAgICAgICAgICBmb3IgKGludCBpID0gLTE7IGkgPD0gMTsgaSsrKSB7XG4gICAgICAgICAgICB2ZWMzIGIgPSB2ZWMzKGZsb2F0KGkpLCBmbG9hdChqKSwgZmxvYXQoaykpO1xuICAgICAgICAgICAgdmVjMyByID0gdmVjMyhiKSAtIGYgKyB2b3Jvbm9pX2hhc2gocCArIGIpO1xuICAgICAgICAgICAgZmxvYXQgZCA9IGRvdChyLCByKTtcblxuICAgICAgICAgICAgZmxvYXQgY29uZCA9IG1heChzaWduKHJlcy54IC0gZCksIDAuMCk7XG4gICAgICAgICAgICBmbG9hdCBuQ29uZCA9IDEuMCAtIGNvbmQ7XG5cbiAgICAgICAgICAgIGZsb2F0IGNvbmQyID0gbkNvbmQgKiBtYXgoc2lnbihyZXMueSAtIGQpLCAwLjApO1xuICAgICAgICAgICAgZmxvYXQgbkNvbmQyID0gMS4wIC0gY29uZDI7XG5cbiAgICAgICAgICAgIGlkID0gKGRvdChwICsgYiwgdmVjMygxLjAsIDU3LjAsIDExMy4wKSkgKiBjb25kKSArIChpZCAqIG5Db25kKTtcbiAgICAgICAgICAgIHJlcyA9IHZlYzIoZCwgcmVzLngpICogY29uZCArIHJlcyAqIG5Db25kO1xuXG4gICAgICAgICAgICByZXMueSA9IGNvbmQyICogZCArIG5Db25kMiAqIHJlcy55O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdmVjMyhzcXJ0KHJlcyksIGFicyhpZCkpO1xuICAgIH1cblxuICAgIHZlYzMgdm9yb25vaSggdmVjMyBwb3MsIGZsb2F0IHNjYWxlLCBmbG9hdCByZXMsIGZsb2F0IHRpbWUsIGZsb2F0IG1vZGUgKSB7XG4gICAgICB2ZWMzIHYgPSB2b3Jvbm9pXzNkKCBwb3MgKiBzY2FsZSwgcmVzICk7XG4gICAgICB2ZWMzIGZpbjtcbiAgICAgIGlmKCBtb2RlID09IDAuICkgZmluID0gdmVjMyh2LngpO1xuICAgICAgaWYoIG1vZGUgPT0gMS4gKSBmaW4gPSB2ZWMzKHYueSk7XG4gICAgICBpZiggbW9kZSA9PSAyLiApIGZpbiA9IHZlYzModi55IC0gdi54KTsgXG5cbiAgICAgIHJldHVybiBmaW47XG4gICAgfVxuYCxcbiAgICBnbHNsMmQ6Z2xzbChbXCIjZGVmaW5lIEdMU0xJRlkgMVxcbiAgICBcXG4gICAgdmVjMyB2b3Jvbm9pX2hhc2godmVjMyBwKSB7XFxuICAgICAgcmV0dXJuIGZyYWN0KFxcbiAgICAgICAgICBzaW4odmVjMyhkb3QocCwgdmVjMygxLjAsIDU3LjAsIDExMy4wKSksIGRvdChwLCB2ZWMzKDU3LjAsIDExMy4wLCAxLjApKSxcXG4gICAgICAgICAgICAgICAgICAgZG90KHAsIHZlYzMoMTEzLjAsIDEuMCwgNTcuMCkpKSkgKiA0Mzc1OC41NDUzKTtcXG4gICAgfVxcblxcbiAgICB2ZWMzIHZvcm9ub2lfM2QoY29uc3QgaW4gdmVjMyB4LCBmbG9hdCBfcmVzICkge1xcbiAgICAgIHZlYzMgcCA9IGZsb29yKHgpO1xcbiAgICAgIHZlYzMgZiA9IGZyYWN0KHgpO1xcblxcbiAgICAgIGZsb2F0IGlkID0gMC4wO1xcbiAgICAgIHZlYzIgcmVzID0gdmVjMiggX3JlcyApO1xcbiAgICAgIGZvciAoaW50IGsgPSAtMTsgayA8PSAxOyBrKyspIHtcXG4gICAgICAgIGZvciAoaW50IGogPSAtMTsgaiA8PSAxOyBqKyspIHtcXG4gICAgICAgICAgZm9yIChpbnQgaSA9IC0xOyBpIDw9IDE7IGkrKykge1xcbiAgICAgICAgICAgIHZlYzMgYiA9IHZlYzMoZmxvYXQoaSksIGZsb2F0KGopLCBmbG9hdChrKSk7XFxuICAgICAgICAgICAgdmVjMyByID0gdmVjMyhiKSAtIGYgKyB2b3Jvbm9pX2hhc2gocCArIGIpO1xcbiAgICAgICAgICAgIGZsb2F0IGQgPSBkb3Qociwgcik7XFxuXFxuICAgICAgICAgICAgZmxvYXQgY29uZCA9IG1heChzaWduKHJlcy54IC0gZCksIDAuMCk7XFxuICAgICAgICAgICAgZmxvYXQgbkNvbmQgPSAxLjAgLSBjb25kO1xcblxcbiAgICAgICAgICAgIGZsb2F0IGNvbmQyID0gbkNvbmQgKiBtYXgoc2lnbihyZXMueSAtIGQpLCAwLjApO1xcbiAgICAgICAgICAgIGZsb2F0IG5Db25kMiA9IDEuMCAtIGNvbmQyO1xcblxcbiAgICAgICAgICAgIGlkID0gKGRvdChwICsgYiwgdmVjMygxLjAsIDU3LjAsIDExMy4wKSkgKiBjb25kKSArIChpZCAqIG5Db25kKTtcXG4gICAgICAgICAgICByZXMgPSB2ZWMyKGQsIHJlcy54KSAqIGNvbmQgKyByZXMgKiBuQ29uZDtcXG5cXG4gICAgICAgICAgICByZXMueSA9IGNvbmQyICogZCArIG5Db25kMiAqIHJlcy55O1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiB2ZWMzKHNxcnQocmVzKSwgYWJzKGlkKSk7XFxuICAgIH1cXG5cXG4gICAgdmVjMyB2b3Jvbm9pMmQoIHZlYzIgc3QsIGZsb2F0IHNjYWxlLCBmbG9hdCByZXMsIGZsb2F0IHRpbWUsIGZsb2F0IG1vZGUgKSB7XFxuICAgICAgdmVjMyB2ID0gdm9yb25vaV8zZCggdmVjMyhzdCogc2NhbGUsIHRpbWUpLCByZXMgKTtcXG4gICAgICB2ZWMzIGZpbjtcXG4gICAgICBpZiggbW9kZSA9PSAwLiApIGZpbiA9IHZlYzModi54KTtcXG4gICAgICBpZiggbW9kZSA9PSAxLiApIGZpbiA9IHZlYzModi55KTtcXG4gICAgICBpZiggbW9kZSA9PSAyLiApIGZpbiA9IHZlYzModi55IC0gdi54KTsgXFxuXFxuICAgICAgcmV0dXJuIGZpbjtcXG4gICAgfVxcblxcblwiLFwiXCJdKSAsXG4gIH0sXG4gIC8vIGFkYXB0ZWQgZnJvbSBodHRwczovL3RoZWJvb2tvZnNoYWRlcnMuY29tL2VkaXQucGhwIzA5L3ppZ3phZy5mcmFnXG4gIHppZ3phZzoge1xuICAgIG5hbWU6J3ppZ3phZycsXG4gICAgZ2xzbDJkOmAgICAgXG4gICAgICAgdmVjMiBtaXJyb3JUaWxlKHZlYzIgX3N0LCBmbG9hdCBfem9vbSl7XG4gICAgICAgICBfc3QgKj0gX3pvb207XG4gICAgICAgICBpZiAoZnJhY3QoX3N0LnkgKiAwLjUpID4gMC41KXtcbiAgICAgICAgICAgX3N0LnggPSBfc3QueCswLjU7XG4gICAgICAgICAgIF9zdC55ID0gMS4wLV9zdC55O1xuICAgICAgICAgfVxuICAgICAgICAgcmV0dXJuIGZyYWN0KF9zdCk7XG4gICAgICAgfVxuXG4gICAgICAgZmxvYXQgZmlsbFkodmVjMiBfc3QsIGZsb2F0IF9wY3QsZmxvYXQgX2FudGlhKXtcbiAgICAgICAgIHJldHVybiBzbW9vdGhzdGVwKCBfcGN0LV9hbnRpYSwgX3BjdCwgX3N0LnkpO1xuICAgICAgIH1cblxuICAgICAgIHZlYzMgemlnemFnMmQoIHZlYzIgc3QsIGZsb2F0IHNjYWxlLCBmbG9hdCB0aW1lICkge1xuICAgICAgICAgc3QgPSBtaXJyb3JUaWxlKHN0KnZlYzIoMS4sMi4pLHNjYWxlKTtcbiAgICAgICAgIGZsb2F0IHggPSBzdC54KjIuO1xuICAgICAgICAgZmxvYXQgYSA9IGZsb29yKDEuK3Npbih4KjMuMTQpKTtcbiAgICAgICAgIGZsb2F0IGIgPSBmbG9vcigxLitzaW4oKHgrMS4pKjMuMTQpKTtcbiAgICAgICAgIGZsb2F0IGYgPSBmcmFjdCh4KTtcblxuICAgICAgICAgdmVjMyBjb2xvciA9IHZlYzMoIGZpbGxZKHN0LG1peChhLGIsZiksMC4wMSkgKTsgXG5cbiAgICAgICAgIHJldHVybiB2ZWMzKGNvbG9yKTtcbiAgICAgICB9XG5gICxcbiAgICBwYXJhbWV0ZXJzOiBbXG4gICAgICB7IG5hbWU6J3NjYWxlJywgdHlwZTonZmxvYXQnLCBkZWZhdWx0OjUgfSxcbiAgICAgIHsgbmFtZTondGltZScsIHR5cGU6J2Zsb2F0JywgZGVmYXVsdDoxIH1cbiAgICBdLFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdGV4dHVyZXNcbiIsIm1vZHVsZS5leHBvcnRzID0gYFxuICAgIC8vIHAgPSBwb2ludCBvbiBzdXJmYWNlLCBwMCA9IG9iamVjdCBjZW50ZXJcbiAgICB2ZWMyIGdldFVWQ3ViaWModmVjMyBwICl7XG4gICAgICB2ZWMzIGFic3AgPSBhYnMocCk7XG4gICAgICAgIFxuICAgICAgLy8gRmlyc3QgY29uZGl0aW9uYWw6IElmIHRoZSBwb2ludCBpcyBpbiBvbmUgb2YgdGhlIHNleHRhbnRzIHRvIHRoZSBcbiAgICAgIC8vIGxlZnQgb3IgcmlnaHQgb2YgdGhlIHgtYXhpcywgdGhlIHV2IGNvcmRpbmF0ZSB3aWxsIGJlICgwLjUqcC56eSkvKHAueCkuXG4gICAgICAvLyBJZiB5b3UgdHJhY2UgYSBsaW5lIG91dCB0byBhIHp5IHBsYW5lIHRoYXQgaXMgMC41IHVuaXRzIGZyb20gdGhlIHplcm8gb3JpZ2luLCAgXG4gICAgICAvLyAoMC41KnAueHl6KS8ocC54KSB3aWxsIGJlIHRoZSByZXN1bHQsIGFuZFxuICAgICAgLy8gdGhlIHl6IGNvbXBvbmVudHMgd2lsbCBiZSBvdXIgdXYgY29vcmRpbmF0ZXMsIGhlbmNlICgwLjUqcC56eSkvKHAueCkuXG5cbiAgICAgIHZlYzIgdXYgPSAoKGFic3AueD49YWJzcC55KSYmKGFic3AueD49YWJzcC56KSkgXG4gICAgICAgID8gKDAuNSpwLnp5KS8ocC54KSBcbiAgICAgICAgOiAoKGFic3AueT49YWJzcC56KSYmKGFic3AueT49YWJzcC54KSkgPyAoMC41KnAueHopLyhwLnkpIDogKC0wLjUqcC54eSkvKHAueik7XG5cbiAgICAgIC8vV2Ugc3RpbGwgbmVlZCB0byBkZXRlcm1pbmUgd2hpY2ggc2lkZSBvdXIgdXYgY29yZGluYXRlcyBhcmUgb24gc29cbiAgICAgIC8vdGhhdCB0aGUgdGV4dHVyZSBvcmllbnRzIHRoZSByaWdodCB3YXkuIE5vdGUgdGhhdCB0aGVyZSdzIHNvbWUgXG4gICAgICAvLyByZWR1bmRhbmN5IHRoZXJlLCB3aGljaCBJJ2xsIGZpeCBhdCBzb21lIHN0YWdlLiBGb3Igbm93LCBpdCB3b3Jrcywgc28gSSdtIG5vdCB0b3VjaGluZyBpdC4gOilcbiAgICAgIGlmKCAoKHAueDwwLikmJihhYnNwLng+PWFic3AueSkmJihhYnNwLng+PWFic3AueikpIFxuICAgICAgIHx8ICgocC55PDAuKSYmKGFic3AueT49YWJzcC56KSYmKGFic3AueT49YWJzcC54KSkgXG4gICAgICAgfHwgKChwLno+MC4pJiYoYWJzcC56Pj1hYnNwLngpJiYoYWJzcC56Pj1hYnNwLnkpKSApIHV2LnkqPS0xLjtcbiAgICAgICAgICAgICBcbiAgICAgIC8vIE1hcHBpbmcgdGhlIHV2IHJhbmdlIGZyb20gWy0wLjUsIDAuNV0gdG8gWzAuMCwgMS4wXS5cbiAgICAgIHJldHVybiAodXYrMC41KTtcbiAgICB9XG4gICAgdmVjNCB0cmlwbGFuYXIodmVjMyBuLCB2ZWM0IHRleHgsIHZlYzQgdGV4eSwgdmVjNCB0ZXh6LCBib29sIGFkanVzdDNkLCBib29sIHJlc2NhbGUpIHtcbiAgICAgIC8vaWYgKGRvZmxpcHopIG4ueiA9IC1uLno7XG4gICAgICBpZiAocmVzY2FsZSkge1xuICAgICAgICB0ZXh4ID0gMi4wKnRleHggLSAxLjA7XG4gICAgICAgIHRleHkgPSAyLjAqdGV4eSAtIDEuMDtcbiAgICAgICAgdGV4eiA9IDIuMCp0ZXh6IC0gMS4wO1xuICAgICAgfVxuICAgICAgaWYgKGFkanVzdDNkKSB7XG4gICAgICAgIHRleHgueCAqPSBzaWduKG4ueCk7XG4gICAgICAgIHRleHkueSAqPSBzaWduKG4ueSk7XG4gICAgICAgIHRleHoueiAqPSBzaWduKG4ueik7XG4gICAgICB9XG4gICAgICAvL2lmIChqdXN0dGV4eSkgcmV0dXJuIHRleHk7XG4gICAgICB2ZWMzIHdlaWdodHMgPSBhYnMobik7XG4gICAgICAvL2lmIChkb3dlaWdodGNvcnJlY3Rpb24pIHdlaWdodHMgLz0gZG90KHdlaWdodHMsdmVjMygxKSk7IC8vIEtlZXAgc3BoZXJpY2FsIVxuICAgICAgICByZXR1cm4gbWF0NCh0ZXh4LHRleHksdGV4eix2ZWM0KDApKSp2ZWM0KHdlaWdodHMsMCk7XG4gICAgfSBcbiAgICBgXG4vKlxubW9kdWxlLmV4cG9ydHMgPSBgdmVjMyB0MyhzYW1wbGVyMkQgdGV4LCB2ZWMzIHAsIHZlYzMgbilcbntcbiAgbWF0MyBSID0gbWF0Myh2ZWMzKGNvcyhUKSxzaW4oVCksMCksdmVjMygtc2luKFQpLGNvcyhUKSwwKSx2ZWMzKDAsMCwtMSkpO1xuICBwICo9IFIvOC4wO1xuICBuICo9IFI7XG4gICNpZmRlZiBTbW9vdGhcbiAgcmV0dXJuICAodGV4dHVyZSh0ZXgscC54eSkucmdiKm4ueipuLnpcbiAgICArdGV4dHVyZSh0ZXgscC56eSkucmdiKm4ueCpuLnhcbiAgICArdGV4dHVyZSh0ZXgscC54eikucmdiKm4ueSpuLnkpO1xuICAjZWxzZVxuICAgIHJldHVybiAodGV4dHVyZSh0ZXgscC54eSkucmdiXG4gICAgICArdGV4dHVyZSh0ZXgscC56eSkucmdiXG4gICAgICArdGV4dHVyZSh0ZXgscC54eikucmdiKS8zLjA7XG4gICAgI2VuZGlmXG4gICAgfWBcbiAgICAqL1xuIiwiY29uc3QgeyBwYXJhbV93cmFwLCBNYXRlcmlhbElEIH0gPSByZXF1aXJlKCAnLi91dGlscy5qcycgKVxuY29uc3QgeyBWYXIsIGZsb2F0X3Zhcl9nZW4sIHZlYzJfdmFyX2dlbiwgdmVjM192YXJfZ2VuLCB2ZWM0X3Zhcl9nZW4sIGludF92YXJfZ2VuLCBWYXJBbGxvYyB9ICA9IHJlcXVpcmUoICcuL3Zhci5qcycgKVxuY29uc3QgTWF0cml4ID0gcmVxdWlyZSggJy4vZXh0ZXJuYWwvbWF0cml4LmpzJyApXG53aW5kb3cuTWF0cml4ID0gTWF0cml4XG5jb25zdCBNYXRyaXhXcmFwID0gZnVuY3Rpb24gKCBzaG91bGRJbnZlcnQgPSBmYWxzZSApIHtcbiAgY29uc3QgbSA9IE9iamVjdC5jcmVhdGUoIE1hdHJpeFdyYXAucHJvdG90eXBlIClcbiAgbS5kaXJ0eSA9IHRydWVcbiAgbS50cmFuc2xhdGlvbiA9IHt9XG4gIG0uc2NhbGUgPSB7fVxuICBtLnNob3VsZEludmVydCA9IHNob3VsZEludmVydFxuICBtLnJvdGF0aW9uID0ge1xuICAgIGF4aXM6IHt9XG4gIH1cbiAgbS5wYXJlbnQgPSBudWxsXG5cbiAgbGV0IHR4ID0gMCwgdHkgPSAwLCB0eiA9IDBcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIG0udHJhbnNsYXRpb24sIHtcbiAgICB4OiB7XG4gICAgICBnZXQoKSB7IHJldHVybiB0eCB9LFxuICAgICAgc2V0KHYpe1xuICAgICAgICB0eCA9IHZcbiAgICAgICAgLy9tLl9fZGF0YSA9IG0uX19kYXRhLm11bHRpcGx5KCBNYXRyaXgudHJhbnNsYXRlKCB0eCwgdHksIHR6ICkgKVxuICAgICAgICBtLmRpcnR5ID0gdHJ1ZVxuICAgICAgfVxuICAgIH0sXG4gICAgeToge1xuICAgICAgZ2V0KCkgeyByZXR1cm4gdHkgfSxcbiAgICAgIHNldCh2KXtcbiAgICAgICAgdHkgPSB2XG4gICAgICAgIC8vbS5fX2RhdGEgPSBtLl9fZGF0YS5tdWx0aXBseSggTWF0cml4LnRyYW5zbGF0ZSggdHgsIHR5LCB0eiApIClcbiAgICAgICAgbS5kaXJ0eSA9IHRydWVcbiAgICAgIH1cbiAgICB9LFxuICAgIHo6IHtcbiAgICAgIGdldCgpIHsgcmV0dXJuIHR6IH0sXG4gICAgICBzZXQodil7XG4gICAgICAgIHR6ID0gdlxuICAgICAgICAvL20uX19kYXRhID0gbS5fX2RhdGEubXVsdGlwbHkoIE1hdHJpeC50cmFuc2xhdGUoIHR4LCB0eSwgdHogKSApXG4gICAgICAgIG0uZGlydHkgPSB0cnVlXG4gICAgICB9XG4gICAgfSxcbiAgfSlcblxuICAvLyBzY2FsaW5nIG11c3QgYmUgc2VudCBhcyBzZXBhcmF0ZSB1bmlmb3JtIHRvIGF2b2lkIHNkZiBvdmVyIGVzdGltYXRpb24gXG4gIGxldCBzY2FsZSA9IDFcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBtLCdzY2FsZScsIHtcbiAgICBnZXQoKSB7IHJldHVybiBzY2FsZSB9LFxuICAgIHNldCh2KXtcbiAgICAgIHNjYWxlID0gdlxuICAgICAgLy9tLl9fZGF0YSA9IG0uX19kYXRhLm11bHRpcGx5KCBNYXRyaXgucm90YXRlKCBhbmdsZSwgcngsIHJ5LCByeiApIClcbiAgICAgIG0uZGlydHkgPSB0cnVlXG4gICAgfSBcbiAgfSlcblxuICAvKiBGT1IgTk9OLVVOSUZPUk0gU0NBTElORzpcbiAgICpcbiAgICogMS4gY29tbWVudCBvdXQgc2NhbGUgcHJvcGVydHkgYWJvdmVcbiAgICogMi4gdW5jb21tZW50IHNjYWxlIHByb3BlcnR5IGJlbG93XG4gICAqIDMuIGNoYW5nZSBlbWl0X2RlY2wgdG8gdXNlIGEgdmVjMyBmb3Igc2NhbGVcbiAgICogNC4gY2hhbmdlIHVwbG9hZF9kYXRhIHRvIHVwbG9hZCBhIDNmXG4gICAqIDUuIEluIFwicHJpbWl0aXZlcy5qc1wiLCByZXBsYWNlIGxpbmUgMTU1IChwYXJ0IG9mIGVtaXQpIHRvIHVzZSBjb21wZW5zYXRlZCBzY2FsaW5nXG4gICAqLyBcblxuICAvL2xldCBzeCA9IDEsIHN5ID0gMSwgc3ogPSAxXG4gIC8vT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIG0uc2NhbGUsIHtcbiAgLy8gIHg6IHtcbiAgLy8gICAgZ2V0KCkgeyByZXR1cm4gc3ggfSxcbiAgLy8gICAgc2V0KHYpe1xuICAvLyAgICAgIHN4ID0gdlxuICAvLyAgICAgIC8vbS5fX2RhdGEgPSBtLl9fZGF0YS5tdWx0aXBseSggTWF0cml4LnNjYWxlKCBzeCwgc3ksIHN6ICkgKVxuICAvLyAgICAgIG0uZGlydHkgPSB0cnVlXG4gIC8vICAgIH1cbiAgLy8gIH0sXG4gIC8vICB5OiB7XG4gIC8vICAgIGdldCgpIHsgcmV0dXJuIHN5IH0sXG4gIC8vICAgIHNldCh2KXtcbiAgLy8gICAgICBzeSA9IHZcbiAgLy8gICAgICAvL20uX19kYXRhID0gbS5fX2RhdGEubXVsdGlwbHkoIE1hdHJpeC5zY2FsZSggc3gsIHN5LCBzeiApIClcbiAgLy8gICAgICBtLmRpcnR5ID0gdHJ1ZVxuICAvLyAgICB9XG4gIC8vICB9LFxuICAvLyAgejoge1xuICAvLyAgICBnZXQoKSB7IHJldHVybiBzeiB9LFxuICAvLyAgICBzZXQodil7XG4gIC8vICAgICAgc3ogPSB2XG4gIC8vICAgICAgLy9tLl9fZGF0YSA9IG0uX19kYXRhLm11bHRpcGx5KCBNYXRyaXguc2NhbGUoIHN4LCBzeSwgc3ogKSApXG4gIC8vICAgICAgbS5kaXJ0eSA9IHRydWVcbiAgLy8gICAgfVxuICAvLyAgfSxcbiAgLy99KVxuXG4gIGxldCBhbmdsZSA9IDBcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCBtLnJvdGF0aW9uLCAnYW5nbGUnLCB7XG4gICAgZ2V0KCkgeyByZXR1cm4gYW5nbGUgfSxcbiAgICBzZXQodil7XG4gICAgICBhbmdsZSA9IHZcbiAgICAgIC8vbS5fX2RhdGEgPSBtLl9fZGF0YS5tdWx0aXBseSggTWF0cml4LnJvdGF0ZSggYW5nbGUsIHJ4LCByeSwgcnogKSApXG4gICAgICBtLmRpcnR5ID0gdHJ1ZVxuICAgIH0gXG4gIH0pXG5cbiAgbGV0IHJ4ID0gMCwgcnkgPSAwLCByeiA9IDBcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIG0ucm90YXRpb24uYXhpcywge1xuICAgIHg6IHtcbiAgICAgIGdldCgpIHsgcmV0dXJuIHJ4IH0sXG4gICAgICBzZXQodil7XG4gICAgICAgIHJ4ID0gdlxuICAgICAgICAvL20uX19kYXRhID0gbS5fX2RhdGEgPSBNYXRyaXgucm90YXRlKCBhbmdsZSwgcngsIHJ5LCByeiwgbS5fX2RhdGEgKVxuICAgICAgICBtLmRpcnR5ID0gdHJ1ZVxuICAgICAgfVxuICAgIH0sXG4gICAgeToge1xuICAgICAgZ2V0KCkgeyByZXR1cm4gcnkgfSxcbiAgICAgIHNldCh2KXtcbiAgICAgICAgcnkgPSB2XG4gICAgICAgIC8vbS5fX2RhdGEgPSBtLl9fZGF0YSA9IE1hdHJpeC5yb3RhdGUoIGFuZ2xlLCByeCwgcnksIHJ6LCBtLl9fZGF0YSApXG4gICAgICAgIG0uZGlydHkgPSB0cnVlXG4gICAgICB9XG4gICAgfSxcbiAgICB6OiB7XG4gICAgICBnZXQoKSB7IHJldHVybiByeiB9LFxuICAgICAgc2V0KHYpe1xuICAgICAgICByeiA9IHZcbiAgICAgICAgLy9tLl9fZGF0YSA9IG0uX19kYXRhID0gTWF0cml4LnJvdGF0ZSggYW5nbGUsIHJ4LCByeSwgcnosIG0uX19kYXRhIClcbiAgICAgICAgbS5kaXJ0eSA9IHRydWVcbiAgICAgIH1cbiAgICB9LFxuICB9KVxuXG4gIG0uX19yb3RhdGlvbnMgPSBbXVxuICBtLl9faWQgICA9IFZhckFsbG9jLmFsbG9jKCkgIFxuICBtLl9fZGlydHkgPSBmdW5jdGlvbigpIHt9XG4gIG0uX19kYXRhID0gTWF0cml4LmlkZW50aXR5KClcbiAgbS5fX01hdHJpeCA9IE1hdHJpeFxuICBtLnZhck5hbWUgPSAndHJhbnNmb3JtJyArIG0uX19pZFxuXG4gIHJldHVybiBtXG59XG5cbk1hdHJpeFdyYXAucHJvdG90eXBlID0ge1xuICB0eXBlOiAnbWF0cml4JyxcblxuICBlbWl0KCkgeyByZXR1cm4gdGhpcy52YXJOYW1lIH0sXG5cbiAgZW1pdF9zY2FsZSgpIHsgcmV0dXJuIHRoaXMudmFyTmFtZSArICdfc2NhbGUnIH0sXG5cbiAgZW1pdF9kZWNsKCkgeyBcbiAgICBjb25zdCBkZWNsID0gIGAgICAgdW5pZm9ybSBtYXQ0ICR7dGhpcy52YXJOYW1lfTtcbiAgICB1bmlmb3JtIGZsb2F0ICR7dGhpcy52YXJOYW1lfV9zY2FsZTtcbiAgICBgIFxuXG4gICAgcmV0dXJuIGRlY2xcbiAgfSxcblxuXHR1cGRhdGVfbG9jYXRpb24oZ2wsIHByb2dyYW0pIHtcblx0XHR0aGlzLmxvYyA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgdGhpcy52YXJOYW1lIClcblx0XHR0aGlzLmxvY19zY2FsZSA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbiggcHJvZ3JhbSwgdGhpcy52YXJOYW1lKydfc2NhbGUnIClcblx0fSxcdFxuXG5cdHVwbG9hZF9kYXRhKGdsKSB7XG5cdFx0aWYoICF0aGlzLmRpcnR5ICkgcmV0dXJuXG5cdFx0XG4gICAgdGhpcy5pbnRlcm5hbCgpXG5cbiAgICBpZiggdGhpcy5zaG91bGRJbnZlcnQgPT09IHRydWUgKSB7XG4gICAgICBjb25zdCBpbnZlcnNlID0gTWF0cml4LmludmVyc2UoIHRoaXMuX19kYXRhIClcbiAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYoIHRoaXMubG9jLCBmYWxzZSwgaW52ZXJzZS5tIClcbiAgICB9ZWxzZXtcbiAgICAgIGdsLnVuaWZvcm1NYXRyaXg0ZnYoIHRoaXMubG9jLCBmYWxzZSwgdGhpcy5fX2RhdGEubSApXG4gICAgfVxuICAgIC8vZ2wudW5pZm9ybTNmKHRoaXMubG9jX3NjYWxlLCB0aGlzLnNjYWxlLngsIHRoaXMuc2NhbGUueSwgdGhpcy5zY2FsZS56IClcbiAgICBcbiAgICAvLyBzY2FsaW5nIG11c3QgYmUgc2VudCBhcyBzZXBhcmF0ZSB1bmlmb3JtIHRvIGF2b2lkIHNkZiBvdmVyLWVzdGltYXRpb24gXG4gICAgZ2wudW5pZm9ybTFmKHRoaXMubG9jX3NjYWxlLCB0aGlzLnNjYWxlIClcblxuXHRcdHRoaXMuZGlydHkgPSBmYWxzZVxuICB9LFxuXG5cbiAgaW50ZXJuYWwoKSB7XG4gICAgdGhpcy5fX2RhdGEgPSBNYXRyaXguaWRlbnRpdHkoKVxuICAgIGlmKCB0aGlzLnBhcmVudCAhPSBudWxsICkgdGhpcy5fX2RhdGEgPSB0aGlzLnBhcmVudC5fX2RhdGFcblxuICAgIHRoaXMuX19kYXRhID0gdGhpcy5fX2RhdGEubXVsdGlwbHkoIE1hdHJpeC50cmFuc2xhdGUoIHRoaXMudHJhbnNsYXRpb24ueCwgdGhpcy50cmFuc2xhdGlvbi55LCB0aGlzLnRyYW5zbGF0aW9uLnogKSApIFxuXG4gICAgLy8gaGFuZGxlIGN1bXVsYXRpdmUgcm90YXRpb25zIHZpYSAucm90YXRlQnkoKSBtZXRob2RcbiAgICB0aGlzLl9fcm90YXRpb25zLmZvckVhY2goIHIgPT4gdGhpcy5fX2RhdGEgPSB0aGlzLl9fZGF0YS5tdWx0aXBseSggciApIClcblxuICAgIC8vIGhhbmRsZSBhYnNvbHV0ZSByb3RhdGlvbnMgdmlhIC5yb3RhdGUoKSBtZXRob2QuLi4gc2hvdWxkIHRoaXMgYmUgYWxpYXNlZCB0byByb3RhdGVUbygpID9cbiAgICB0aGlzLl9fZGF0YSA9IHRoaXMuX19kYXRhLm11bHRpcGx5KCBNYXRyaXgucm90YXRlKCB0aGlzLnJvdGF0aW9uLmFuZ2xlLCB0aGlzLnJvdGF0aW9uLmF4aXMueCwgdGhpcy5yb3RhdGlvbi5heGlzLnksIHRoaXMucm90YXRpb24uYXhpcy56ICkgKVxuXG4gICAgdGhpcy5fX2RhdGEgPSB0aGlzLl9fZGF0YS5tdWx0aXBseSggTWF0cml4LnNjYWxlKCB0aGlzLnNjYWxlLCB0aGlzLnNjYWxlLCB0aGlzLnNjYWxlICkgKVxuICB9LFxuXG4gIGludmVydCggc2hvdWxkSW52ZXJ0ID0gdHJ1ZSkge1xuICAgIHRoaXMuc2hvdWxkSW52ZXJ0ID0gc2hvdWxkSW52ZXJ0XG4gICAgdGhpcy5kaXJ0eSA9IHRydWVcbiAgfSxcblxuICBhcHBseSggdHJhbnNmb3JtID0gbnVsbCwgc2hvdWxkSW52ZXJ0ID0gZmFsc2UgKSB7XG4gICAgdGhpcy5wYXJlbnQgPSB0cmFuc2Zvcm1cbiAgICB0aGlzLmRpcnR5ID0gdHJ1ZVxuICB9IFxuXG59XG5cbm1vZHVsZS5leHBvcnRzID0gTWF0cml4V3JhcFxuIiwiY29uc3QgVmFyID0gcmVxdWlyZSgnLi92YXIuanMnKS5WYXJcbmNvbnN0IHsgVmVjMiwgVmVjMywgVmVjNCB9ID0gcmVxdWlyZSggJy4vdmVjLmpzJyApXG5cbi8vIFdyYXBwZXJcbmZ1bmN0aW9uIHBhcmFtX3dyYXAoIHYsIF9fZGVmYXVsdCwgbmFtZT1udWxsICkge1xuXHRpZiggdiA9PT0gdW5kZWZpbmVkIHx8IHYgPT09IG51bGwgKSByZXR1cm4gX19kZWZhdWx0KClcblx0aWYoIHYuX19pc1ZhciA9PT0gdHJ1ZSApIHJldHVybiB2XG5cdFxuXHRyZXR1cm4gVmFyKCB2LCBuYW1lIClcbn1cblxuY29uc3QgTWF0ZXJpYWxJRCA9IHtcblx0Y3VycmVudDogMCxcblx0YWxsb2MoKSB7XG5cdFx0cmV0dXJuIE1hdGVyaWFsSUQuY3VycmVudCsrXG4gIH0sXG4gIGNsZWFyKCkge1xuICAgIE1hdGVyaWFsSUQuY3VycmVudCA9IDBcbiAgfVxufVxuXG5jb25zdCBwcm9jZXNzVmVjMiA9IGZ1bmN0aW9uKCB2YWwgKSB7XG4gIGlmKCB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyApIFxuICAgIHZhbCA9IFZlYzIoIGNvbG9yIClcbiAgZWxzZSBpZiggQXJyYXkuaXNBcnJheSggdmFsICkgKSBcbiAgICB2YWwgPSBWZWMyKCB2YWxbMF0sIHZhbFsxXSApXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5jb25zdCBwcm9jZXNzVmVjMyA9IGZ1bmN0aW9uKCB2YWwgKSB7XG4gIGlmKCB0eXBlb2YgdmFsID09PSAnbnVtYmVyJyApIFxuICAgIHZhbCA9IFZlYzMoIHZhbCApXG4gIGVsc2UgaWYoIEFycmF5LmlzQXJyYXkoIHZhbCApICkgXG4gICAgdmFsID0gVmVjMyggdmFsWzBdLCB2YWxbMV0sIHZhbFsyXSApXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgcGFyYW1fd3JhcCwgTWF0ZXJpYWxJRCwgcHJvY2Vzc1ZlYzIsIHByb2Nlc3NWZWMzIH1cbiIsImNvbnN0IHsgVmVjMiwgVmVjMywgVmVjNCB9ID0gcmVxdWlyZSggJy4vdmVjLmpzJyApXG5jb25zdCBmbG9hdCA9IHJlcXVpcmUoICcuL2Zsb2F0LmpzJyApXG5jb25zdCBpbnQgICA9IHJlcXVpcmUoICcuL2ludC5qcycgKVxuXG4vLyBWYXJcbmNvbnN0IFZhckFsbG9jID0ge1xuXHRjdXJyZW50OiAwLFxuICBjbGVhcigpIHtcbiAgICBWYXJBbGxvYy5jdXJyZW50ID0gMFxuICB9LFxuXHRhbGxvYygpIHtcblx0XHRyZXR1cm4gVmFyQWxsb2MuY3VycmVudCsrXG5cdH1cbn1cblxuY29uc3QgVmFyID0gZnVuY3Rpb24oIHZhbHVlLCBmaXhlZE5hbWUgPSBudWxsLCBfX3R5cGUgKSB7XG4gIGNvbnN0IHYgPSBPYmplY3QuY3JlYXRlKCBWYXIucHJvdG90eXBlIClcblx0di52YXJOYW1lID0gZml4ZWROYW1lICE9PSBudWxsID8gZml4ZWROYW1lIDogJ3ZhcicgKyBWYXJBbGxvYy5hbGxvYygpXG4gIHYudmFsdWUgPSB2YWx1ZVxuICB2LnR5cGUgPSB2LnZhbHVlLnR5cGVcbiAgaWYoIHYudHlwZSA9PT0gdW5kZWZpbmVkICkgdi50eXBlID0gX190eXBlIHx8ICdmbG9hdCcgXG5cbiAgdmFsdWUudmFyID0gdlxuXG4gIGlmKCB2LnR5cGUgIT09ICdmbG9hdCcgJiYgdi50eXBlICE9PSAnaW50JyApIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggdiwge1xuICAgICAgeDoge1xuICAgICAgICBnZXQoKSB7IHJldHVybiB0aGlzLnZhbHVlLnggfSxcbiAgICAgICAgc2V0KHYpeyB0aGlzLnZhbHVlLnggPSB2OyB0aGlzLmRpcnR5ID0gdHJ1ZSB9XG4gICAgICB9LFxuICAgICAgeToge1xuICAgICAgICBnZXQoKSB7IHJldHVybiB0aGlzLnZhbHVlLnkgfSxcbiAgICAgICAgc2V0KHYpeyB0aGlzLnZhbHVlLnkgPSB2OyB0aGlzLmRpcnR5ID0gdHJ1ZSB9XG4gICAgICB9LFxuICAgICAgejoge1xuICAgICAgICBnZXQoKSB7IHJldHVybiB0aGlzLnZhbHVlLnogfSxcbiAgICAgICAgc2V0KHYpeyB0aGlzLnZhbHVlLnogPSB2OyB0aGlzLmRpcnR5ID0gdHJ1ZSB9XG4gICAgICB9LFxuICAgICAgdzoge1xuICAgICAgICBnZXQoKSB7IHJldHVybiB0aGlzLnZhbHVlLncgfSxcbiAgICAgICAgc2V0KHYpeyB0aGlzLnZhbHVlLncgPSB2OyB0aGlzLmRpcnR5ID0gdHJ1ZSB9XG4gICAgICB9LFxuICAgICAgcjoge1xuICAgICAgICBnZXQoKSB7IHJldHVybiB0aGlzLnZhbHVlLnggfSxcbiAgICAgICAgc2V0KHYpeyB0aGlzLnZhbHVlLnggPSB2OyB0aGlzLmRpcnR5ID0gdHJ1ZSB9XG4gICAgICB9LFxuICAgICAgZzoge1xuICAgICAgICBnZXQoKSB7IHJldHVybiB0aGlzLnZhbHVlLnkgfSxcbiAgICAgICAgc2V0KHYpeyB0aGlzLnZhbHVlLnkgPSB2OyB0aGlzLmRpcnR5ID0gdHJ1ZSB9XG4gICAgICB9LFxuICAgICAgYjoge1xuICAgICAgICBnZXQoKSB7IHJldHVybiB0aGlzLnZhbHVlLnogfSxcbiAgICAgICAgc2V0KHYpeyB0aGlzLnZhbHVlLnogPSB2OyB0aGlzLmRpcnR5ID0gdHJ1ZSB9XG4gICAgICB9LFxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gdlxufVxuXG5WYXIuaGFyZGNvZGUgPSBmYWxzZVxuY29uc3QgZW1pdF9mbG9hdCA9IGZ1bmN0aW9uKCBhICkge1xuXHRpZiAoYSAlIDEgPT09IDApXG5cdFx0cmV0dXJuIGEudG9GaXhlZCggMSApXG5cdGVsc2Vcblx0XHRyZXR1cm4gYVxufVxuXG5WYXIucHJvdG90eXBlID0ge1xuXHRkaXJ0eTogdHJ1ZSxcblxuXHRsb2M6IC0xLFxuXG4gIGVtaXQoKSB7IFxuICAgIGxldCBvdXRcbiAgICBpZiggdGhpcy52YWx1ZS5pc0dlbiApIHtcbiAgICAgIGNvbnN0IHZlY091dCA9IHRoaXMudmFsdWUuZW1pdCgpIFxuICAgICAgb3V0ID0gdmVjT3V0LnByZWZhY2UgKyB2ZWNPdXQub3V0XG4gICAgICAgIFxuICAgIH1lbHNle1xuICAgICAgb3V0ID0gdGhpcy52YXJOYW1lIFxuICAgIH0gXG5cbiAgICByZXR1cm4gb3V0XG4gIH0sXG5cbiAgZW1pdF9kZWNsKCkgeyBcbiAgICBsZXQgb3V0ID0gJydcbiAgICBpZiggdGhpcy52YWx1ZS5pc0dlbiApIHtcbiAgICAgIG91dCA9IHRoaXMudmFsdWUuZW1pdF9kZWNsKClcbiAgICB9ZWxzZXtcbiAgICAgIGlmKCBWYXIuaGFyZGNvZGUgPT09IHRydWUgKSB7XG5cbiAgICAgICAgaWYoIHR5cGVvZiB0aGlzLnZhbHVlLmVtaXQgIT09ICdmdW5jdGlvbicgKSB7XG4gICAgICAgICAgaWYoIHRoaXMudHlwZSA9PT0gJ2Zsb2F0JyApIHtcbiAgICAgICAgICAgIG91dCA9IGAke3RoaXMudHlwZX0gJHt0aGlzLnZhck5hbWV9ID0gJHtlbWl0X2Zsb2F0KHRoaXMudmFsdWUpfTtcXG5gXG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICBvdXQgPSBgJHt0aGlzLnR5cGV9ICR7dGhpcy52YXJOYW1lfSA9ICR7dGhpcy52YWx1ZX07XFxuYFxuICAgICAgICAgIH1cbiAgICAgICAgfWVsc2V7XG4gICAgICAgICAgbGV0IHZhbCA9IHRoaXMudmFsdWUuZW1pdCgpXG4gICAgICAgICAgaWYoIHR5cGVvZiB2YWwgIT09ICdzdHJpbmcnICkgdmFsID0gdmFsLm91dFxuICAgICAgICAgIG91dCA9IHZhbCAhPT0gdW5kZWZpbmVkID8gYCR7dGhpcy50eXBlfSAke3RoaXMudmFyTmFtZX0gPSAke3ZhbH07XFxuYCA6ICcnXG4gICAgICAgIH1cbiAgICAgIH1lbHNle1xuICAgICAgICBvdXQgPSBgdW5pZm9ybSAke3RoaXMudHlwZX0gJHt0aGlzLnZhck5hbWV9O1xcbmBcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dFxuICB9LFxuXG5cdHNldCh2KSB7IHRoaXMudmFsdWUgPSB2OyB0aGlzLmRpcnR5ID0gdHJ1ZTsgfSxcblxuXHR1cGRhdGVfbG9jYXRpb24oZ2wsIHByb2dyYW0pIHtcbiAgICBpZiggdGhpcy52YWx1ZS5pc0dlbiApIHtcbiAgICAgIHRoaXMudmFsdWUudXBkYXRlX2xvY2F0aW9uKCBnbCwgcHJvZ3JhbSApXG4gICAgICByZXR1cm5cbiAgICB9XG5cdFx0dGhpcy5sb2MgPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgdGhpcy52YXJOYW1lKVxuXHR9LFx0XG5cblx0dXBsb2FkX2RhdGEoZ2wpIHtcblx0XHRpZiggIXRoaXMuZGlydHkgKSByZXR1cm5cblx0XHRcbiAgICBpZiggdGhpcy52YWx1ZS5pc0dlbiApIHtcbiAgICAgIHRoaXMudmFsdWUudXBsb2FkX2RhdGEoIGdsICApXG4gICAgICB0aGlzLmRpcnR5ID0gZmFsc2VcbiAgICAgIHJldHVyblxuICAgIH1cblx0XHRsZXQgdiA9IHRoaXMudmFsdWVcblx0XHRpZiAodHlwZW9mIHYgPT09ICdudW1iZXInICkge1xuXHRcdFx0Z2wudW5pZm9ybTFmKCB0aGlzLmxvYywgdiApXG5cdFx0fWVsc2UgaWYgKCB2IGluc3RhbmNlb2YgVmVjMiApIHtcblx0XHRcdGdsLnVuaWZvcm0yZih0aGlzLmxvYywgdi54LCB2LnkgKVxuXHRcdH0gZWxzZSBpZiggdiBpbnN0YW5jZW9mIFZlYzMgKSB7XG5cdFx0XHRnbC51bmlmb3JtM2YodGhpcy5sb2MsIHYueCwgdi55LCB2LnogKVxuXHRcdH0gZWxzZSBpZiggdiBpbnN0YW5jZW9mIFZlYzQgKSB7XG5cdFx0XHRnbC51bmlmb3JtNGYodGhpcy5sb2MsIHYueCwgdi55LCB2LnosIHYudyApXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZvciBjb2xvciB2YXJpYWJsZXNcbiAgICAgIGlmKCB0aGlzLnR5cGUgPT09ICdmbG9hdCcgKSB7XG4gICAgICAgIGdsLnVuaWZvcm0xZiggdGhpcy5sb2MsIHYueCApXG4gICAgICB9ZWxzZXtcbiAgICAgICAgZ2wudW5pZm9ybTFpKCB0aGlzLmxvYywgdi54IClcbiAgICAgIH1cbiAgICB9XG5cblx0XHR0aGlzLmRpcnR5ID0gZmFsc2Vcblx0fVxufVxuXG5cbmZ1bmN0aW9uIGludF92YXJfZ2VuKHgsbmFtZT1udWxsKSB7IFxuICBsZXQgb3V0cHV0ID0gKCk9PiB7XG4gICAgbGV0IG91dCA9IFZhciggaW50KHgpLCBuYW1lLCAnaW50JyApIFxuICAgIHJldHVybiBvdXRcbiAgfVxuXG4gIHJldHVybiBvdXRwdXRcbn1cbmZ1bmN0aW9uIGZsb2F0X3Zhcl9nZW4oeCxuYW1lPW51bGwpIHsgcmV0dXJuICgpPT4geyByZXR1cm4gVmFyKCBmbG9hdCh4KSwgbmFtZSwgJ2Zsb2F0JyApIH0gfVxuXG5mdW5jdGlvbiB2ZWMyX3Zhcl9nZW4oeCwgeSxuYW1lPW51bGwpIHsgXG4gIHJldHVybiAoKT0+IFZhciggVmVjMih4LCB5KSwgbmFtZSAgKSBcbn1cblxuZnVuY3Rpb24gdmVjM192YXJfZ2VuKHg9MCwgeSwgeixuYW1lPW51bGwpIHsgXG4gIHJldHVybiAoKT0+IFZhciggVmVjMyh4LCB5LCB6KSwgbmFtZSApIFxufVxuXG5mdW5jdGlvbiB2ZWM0X3Zhcl9nZW4oIHgsIHksIHosIHcsIG5hbWU9bnVsbCApIHsgXG4gIHJldHVybiBWYXIoIFZlYzQoIHgsIHksIHosIHcgKSwgbmFtZSApIFxufVxuLy9mdW5jdGlvbiBmbG9hdF92YXJfZ2VuKHgsbmFtZT1udWxsKSB7IHJldHVybiAoKT0+IHsgcmV0dXJuIFZhciggZmxvYXQoeCksIG5hbWUsICdmbG9hdCcgKSB9IH1cblxuLy9mdW5jdGlvbiB2ZWMyX3Zhcl9nZW4oeCwgeSxuYW1lPW51bGwpIHsgcmV0dXJuICgpPT4gVmFyKCBWZWMyKHgsIHkpLCBuYW1lICApIH1cblxuLy9mdW5jdGlvbiB2ZWMzX3Zhcl9nZW4oeCwgeSwgeixuYW1lPW51bGwpIHsgcmV0dXJuICgpPT4gVmFyKCBWZWMzKHgsIHksIHopLCBuYW1lICkgfVxuXG4vL2Z1bmN0aW9uIHZlYzRfdmFyX2dlbiggeCwgeSwgeiwgdywgbmFtZT1udWxsICkgeyByZXR1cm4gVmFyKCBWZWM0KCB4LCB5LCB6LCB3ICksIG5hbWUgKSB9XG5cbm1vZHVsZS5leHBvcnRzID0geyBWYXIsIGZsb2F0X3Zhcl9nZW4sIHZlYzJfdmFyX2dlbiwgdmVjM192YXJfZ2VuLCB2ZWM0X3Zhcl9nZW4sIGludF92YXJfZ2VuLCBWYXJBbGxvYyB9XG5cbi8qZnVuY3Rpb24gZmxvYXRfdmFyX2dlbih4LG5hbWU9bnVsbCkgeyByZXR1cm4gKCk9PiB7IHJldHVybiBWYXIoIGZsb2F0KHgpLCBuYW1lLCAnZmxvYXQnICkgfSB9XG5cbmZ1bmN0aW9uIHZlYzJfdmFyX2dlbih4LCB5LG5hbWU9bnVsbCkgeyBcbiAgaWYoIHkgPT09IHVuZGVmaW5lZCApIHkgPSB4XG4gIHJldHVybiAoKT0+IFZhciggVmVjMih4LCB5KSwgbmFtZSAgKSBcbn1cblxuZnVuY3Rpb24gdmVjM192YXJfZ2VuKHgsIHksIHosbmFtZT1udWxsKSB7IFxuICBpZiggeSA9PT0gdW5kZWZpbmVkICkgeSA9IHhcbiAgaWYoIHogPT09IHVuZGVmaW5lZCApIHogPSB4XG4gIHJldHVybiAoKT0+IFZhciggVmVjMyh4LCB5LCB6KSwgbmFtZSApIFxufVxuXG5mdW5jdGlvbiB2ZWM0X3Zhcl9nZW4oIHgsIHksIHosIHcsIG5hbWU9bnVsbCApIHsgXG4gIGlmKCB5ID09PSB1bmRlZmluZWQgKSB5ID0geFxuICBpZiggeiA9PT0gdW5kZWZpbmVkICkgeiA9IHhcbiAgaWYoIHcgPT09IHVuZGVmaW5lZCApIHcgPSB4XG4gIHJldHVybiBWYXIoIFZlYzQoIHgsIHksIHosIHcgKSwgbmFtZSApIFxufVxuKi9cbiIsImNvbnN0IFZlYzIgPSBmdW5jdGlvbiAoeD0wLCB5PTApIHtcbiAgaWYoIHgudHlwZSA9PT0gJ3ZlYzInICkgcmV0dXJuIHggIFxuICBjb25zdCB2ID0gT2JqZWN0LmNyZWF0ZSggVmVjMi5wcm90b3R5cGUgKVxuICBpZiggQXJyYXkuaXNBcnJheSggeCApICkge1xuICAgIHYueCA9IHhbMF07IHYueSA9IHhbMV07IFxuICB9IGVsc2UgaWYoIHkgPT09IHVuZGVmaW5lZCApIHtcbiAgICB2LnggPSB2LnkgPSB4XG4gIH1lbHNle1xuICAgIHYueCA9IHg7IHYueSA9IHk7IFxuICB9XG5cbiAgcmV0dXJuIHZcbn1cblxuVmVjMi5wcm90b3R5cGUgPSB7XG4gIHR5cGU6ICd2ZWMyJyxcblx0ZW1pdCgpIHsgcmV0dXJuIFwidmVjMihcIiArIHRoaXMueCArIFwiLFwiICsgdGhpcy55ICsgXCIpXCIgfSxcbiAgZW1pdF9kZWNsKCkgeyByZXR1cm4gXCJcIjsgfSxcbiAgY29weSgpIHtcbiAgICByZXR1cm4gVmVjMiggdGhpcy54LCB0aGlzLnkgKVxuICB9XG59XG5cbmNvbnN0IFZlYzMgPSBmdW5jdGlvbiAoeD0wLCB5LCB6KSB7XG4gIGlmKCB4LnR5cGUgPT09ICd2ZWMzJyApIHJldHVybiB4ICBcbiAgY29uc3QgdiA9IE9iamVjdC5jcmVhdGUoIFZlYzMucHJvdG90eXBlIClcbiAgbGV0IHZ4ID0wLHZ5PTAsdno9MFxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyggdiwge1xuICAgIHg6IHtcbiAgICAgIGdldCgpICB7IHJldHVybiB2eCB9LFxuICAgICAgc2V0KHYpIHsgdnggPSB2OyB0aGlzLmRpcnR5ID0gdHJ1ZTsgfVxuICAgIH0sXG5cbiAgICB5OiB7XG4gICAgICBnZXQoKSAgeyByZXR1cm4gdnkgfSxcbiAgICAgIHNldCh2KSB7IHZ5ID0gdjsgdGhpcy5kaXJ0eSA9IHRydWU7IH1cbiAgICB9LFxuXG4gICAgejoge1xuICAgICAgZ2V0KCkgIHsgcmV0dXJuIHZ6IH0sXG4gICAgICBzZXQodikgeyB2eiA9IHY7IHRoaXMuZGlydHkgPSB0cnVlOyB9XG4gICAgfSxcbiAgICByOiB7XG4gICAgICBnZXQoKSAgeyByZXR1cm4gdnggfSxcbiAgICAgIHNldCh2KSB7IHZ4ID0gdjsgdGhpcy5kaXJ0eSA9IHRydWU7IH1cbiAgICB9LFxuXG4gICAgZzoge1xuICAgICAgZ2V0KCkgIHsgcmV0dXJuIHZ5IH0sXG4gICAgICBzZXQodikgeyB2eSA9IHY7IHRoaXMuZGlydHkgPSB0cnVlOyB9XG4gICAgfSxcblxuICAgIGI6IHtcbiAgICAgIGdldCgpICB7IHJldHVybiB2eiB9LFxuICAgICAgc2V0KHYpIHsgdnogPSB2OyB0aGlzLmRpcnR5ID0gdHJ1ZTsgfVxuICAgIH0sXG5cbiAgfSlcblxuICBpZiggQXJyYXkuaXNBcnJheSggeCApICkge1xuICAgIHYueCA9IHhbMF07IHYueSA9IHhbMV07IHYueiA9IHhbMl07IFxuICB9IGVsc2UgaWYoIHkgPT09IHVuZGVmaW5lZCAmJiB6ID09PSB1bmRlZmluZWQpIHtcbiAgICB2LnggPSB2LnkgPSB2LnogPSB4XG4gIH1lbHNle1xuICAgIHYueCA9IHg7IHYueSA9IHk7IHYueiA9IHo7XG4gIH1cbiBcbiAgdi5pc0dlbiA9IHYueC50eXBlID09PSAnc3RyaW5nJyB8fCB2LnkudHlwZSA9PT0gJ3N0cmluZycgfHwgdi56LnR5cGUgPT09ICdzdHJpbmcnXG4gIHJldHVybiB2XG59O1xuXG5WZWMzLnByb3RvdHlwZSA9IHtcbiAgdHlwZTogJ3ZlYzMnLFxuICBlbWl0KCkgeyBcbiAgICBsZXQgb3V0ID0gYHZlYzMoYFxuICAgIGxldCBwcmVmYWNlID0gJydcblxuICAgIGlmKCB0aGlzLngudHlwZSA9PT0gJ3N0cmluZycgKSB7XG4gICAgICBjb25zdCB4b3V0ID0gdGhpcy54LmVtaXQoKVxuICAgICAgb3V0ICs9IHhvdXQub3V0ICsgJywnXG4gICAgfWVsc2V7XG4gICAgICBvdXQgKz0gdGhpcy54ICsgJywnXG4gICAgfVxuXG4gICAgaWYoIHRoaXMueS50eXBlID09PSAnc3RyaW5nJyApIHtcbiAgICAgIGNvbnN0IHlvdXQgPSB0aGlzLnkuZW1pdCgpXG4gICAgICBvdXQgKz0geW91dC5vdXQgKyAnLCcgXG4gICAgfWVsc2V7XG4gICAgICBvdXQgKz0gdGhpcy55ICsgJywnXG4gICAgfVxuICAgIGlmKCB0aGlzLnoudHlwZSA9PT0gJ3N0cmluZycgKSB7XG4gICAgICBjb25zdCB6b3V0ID0gdGhpcy56LmVtaXQoKVxuICAgICAgb3V0ICs9IHpvdXQub3V0XG4gICAgfWVsc2V7XG4gICAgICBvdXQgKz0gdGhpcy56IFxuICAgIH1cblxuICAgIG91dCArPSAnKSdcblxuICAgIHJldHVybiB7IG91dCwgcHJlZmFjZSB9XG4gIH0sXG4gIGVtaXRfZGVjbCgpIHsgXG4gICAgbGV0IG91dCA9ICcnXG4gICAgaWYoIHRoaXMueC50eXBlID09PSAnc3RyaW5nJyApIHtcbiAgICAgIG91dCArPSB0aGlzLnguZW1pdF9kZWNsKClcbiAgICB9IFxuICAgIGlmKCB0aGlzLnkudHlwZSA9PT0gJ3N0cmluZycgJiYgdGhpcy54ICE9PSB0aGlzLnkgICkge1xuICAgICAgb3V0ICs9IHRoaXMueS5lbWl0X2RlY2woKVxuICAgIH0gXG4gICAgaWYoIHRoaXMuei50eXBlID09PSAnc3RyaW5nJyAmJiB0aGlzLnogIT09IHRoaXMueSAmJiB0aGlzLnogIT09IHRoaXMueCApIHtcbiAgICAgIG91dCArPSB0aGlzLnouZW1pdF9kZWNsKClcbiAgICB9IFxuICAgIHJldHVybiBvdXRcbiAgfSxcblxuXHR1cGRhdGVfbG9jYXRpb24oZ2wsIHByb2dyYW0pIHtcbiAgICBpZiggdGhpcy5pc0dlbiApIHtcbiAgICAgIGlmKCB0aGlzLngudHlwZSA9PT0gJ3N0cmluZycgKSB7XG4gICAgICAgIHRoaXMueC51cGRhdGVfbG9jYXRpb24oZ2wscHJvZ3JhbSlcbiAgICAgIH0gXG4gICAgICBpZiggdGhpcy55LnR5cGUgPT09ICdzdHJpbmcnICYmIHRoaXMueCAhPT0gdGhpcy55ICApIHtcbiAgICAgICAgdGhpcy55LnVwZGF0ZV9sb2NhdGlvbihnbCxwcm9ncmFtKVxuICAgICAgfSBcbiAgICAgIGlmKCB0aGlzLnoudHlwZSA9PT0gJ3N0cmluZycgJiYgdGhpcy56ICE9PSB0aGlzLnkgJiYgdGhpcy56ICE9PSB0aGlzLnggKSB7XG4gICAgICAgIHRoaXMuei51cGRhdGVfbG9jYXRpb24oZ2wscHJvZ3JhbSlcbiAgICAgIH0gICAgICBcbiAgICB9XG4gIH0sXG4gIFxuICB1cGxvYWRfZGF0YShnbCkge1xuICAgIGlmKCB0aGlzLmlzR2VuICkge1xuICAgICAgaWYoIHRoaXMueC50eXBlID09PSAnc3RyaW5nJyApIHtcbiAgICAgICAgdGhpcy54LnVwbG9hZF9kYXRhKGdsKVxuICAgICAgfSBcbiAgICAgIGlmKCB0aGlzLnkudHlwZSA9PT0gJ3N0cmluZycgJiYgdGhpcy54ICE9PSB0aGlzLnkgICkge1xuICAgICAgICB0aGlzLnkudXBsb2FkX2RhdGEoZ2wpXG4gICAgICB9IFxuICAgICAgaWYoIHRoaXMuei50eXBlID09PSAnc3RyaW5nJyAmJiB0aGlzLnogIT09IHRoaXMueSAmJiB0aGlzLnogIT09IHRoaXMueCApIHtcbiAgICAgICAgdGhpcy56LnVwbG9hZF9kYXRhKGdsKVxuICAgICAgfSAgICAgIFxuICAgIH1cbiAgfSxcblxuICBjb3B5KCkge1xuICAgIHJldHVybiBWZWMzKCB0aGlzLngsIHRoaXMueSwgdGhpcy56IClcbiAgfVxuXG59XG5cbmNvbnN0IFZlYzQgPSBmdW5jdGlvbiAoeD0wLCB5LCB6LCB3KSB7XG4gIGlmKCB4LnR5cGUgPT09ICd2ZWM0JyApIHJldHVybiB4XG4gIGNvbnN0IHYgPSBPYmplY3QuY3JlYXRlKCBWZWM0LnByb3RvdHlwZSApXG5cbiAgaWYoIEFycmF5LmlzQXJyYXkoIHggKSApIHtcbiAgICB2LnggPSB4WzBdOyB2LnkgPSB4WzFdOyB2LnogPSB4WzJdOyB2LncgPSB4WzNdIFxuICB9IGVsc2UgaWYoIHkgPT09IHVuZGVmaW5lZCAmJiB6ID09PSB1bmRlZmluZWQpIHtcbiAgICB2LnggPSB2LnkgPSB2LnogPSB2LncgPSB4XG4gIH1lbHNle1xuICAgIHYueCA9IHg7IHYueSA9IHk7IHYueiA9IHo7IHYudyA9IHc7O1xuICB9XG5cbiAgdi5pc0dlbiA9IHYueC50eXBlID09PSAnc3RyaW5nJyB8fCB2LnkudHlwZSA9PT0gJ3N0cmluZycgfHwgdi56LnR5cGUgPT09ICdzdHJpbmcnXG5cbiAgcmV0dXJuIHZcbn07XG5cblZlYzQucHJvdG90eXBlID0ge1xuICB0eXBlOiAndmVjNCcsXG4gIGVtaXQoKSB7IFxuICAgIGxldCBvdXQgPSBgdmVjNChgXG4gICAgbGV0IHByZWZhY2UgPSAnJ1xuXG4gICAgaWYoIHRoaXMueC50eXBlID09PSAnc3RyaW5nJyApIHtcbiAgICAgIGNvbnN0IHhvdXQgPSB0aGlzLnguZW1pdCgpXG4gICAgICBvdXQgKz0geG91dC5vdXQgKyAnLCdcbiAgICB9ZWxzZXtcbiAgICAgIG91dCArPSB0aGlzLnggKyAnLCdcbiAgICB9XG5cbiAgICBpZiggdGhpcy55LnR5cGUgPT09ICdzdHJpbmcnICkge1xuICAgICAgY29uc3QgeW91dCA9IHRoaXMueS5lbWl0KClcbiAgICAgIG91dCArPSB5b3V0Lm91dCArICcsJyBcbiAgICB9ZWxzZXtcbiAgICAgIG91dCArPSB0aGlzLnkgKyAnLCdcbiAgICB9XG5cbiAgICBpZiggdGhpcy56LnR5cGUgPT09ICdzdHJpbmcnICkge1xuICAgICAgY29uc3Qgem91dCA9IHRoaXMuei5lbWl0KClcbiAgICAgIG91dCArPSB6b3V0Lm91dFxuICAgIH1lbHNle1xuICAgICAgb3V0ICs9IHRoaXMueiBcbiAgICB9XG4gICAgXG4gICAgaWYoIHRoaXMudy50eXBlID09PSAnc3RyaW5nJyApIHtcbiAgICAgIGNvbnN0IHdvdXQgPSB0aGlzLncuZW1pdCgpXG4gICAgICBvdXQgKz0gd291dC5vdXRcbiAgICB9ZWxzZXtcbiAgICAgIG91dCArPSB0aGlzLncgXG4gICAgfVxuXG4gICAgb3V0ICs9ICcpJ1xuXG4gICAgcmV0dXJuIHsgb3V0LCBwcmVmYWNlIH1cbiAgfSxcbiAgZW1pdF9kZWNsKCkgeyBcbiAgICBsZXQgb3V0ID0gJydcbiAgICBpZiggdGhpcy54LnR5cGUgPT09ICdzdHJpbmcnICkge1xuICAgICAgb3V0ICs9IHRoaXMueC5lbWl0X2RlY2woKVxuICAgIH0gXG4gICAgaWYoIHRoaXMueS50eXBlID09PSAnc3RyaW5nJyAmJiB0aGlzLnggIT09IHRoaXMueSAgKSB7XG4gICAgICBvdXQgKz0gdGhpcy55LmVtaXRfZGVjbCgpXG4gICAgfSBcbiAgICBpZiggdGhpcy56LnR5cGUgPT09ICdzdHJpbmcnICYmIHRoaXMueiAhPT0gdGhpcy55ICYmIHRoaXMueiAhPT0gdGhpcy54ICkge1xuICAgICAgb3V0ICs9IHRoaXMuei5lbWl0X2RlY2woKVxuICAgIH0gXG4gICAgaWYoIHRoaXMudy50eXBlID09PSAnc3RyaW5nJyAmJiB0aGlzLncgIT09IHRoaXMueSAmJiB0aGlzLncgIT09IHRoaXMueCAmJiB0aGlzLncgIT09IHRoaXMueiApIHtcbiAgICAgIG91dCArPSB0aGlzLncuZW1pdF9kZWNsKClcbiAgICB9XG4gICAgcmV0dXJuIG91dFxuICB9LFxuXG5cdHVwZGF0ZV9sb2NhdGlvbihnbCwgcHJvZ3JhbSkge1xuICAgIGlmKCB0aGlzLmlzR2VuICkge1xuICAgICAgaWYoIHRoaXMueC50eXBlID09PSAnc3RyaW5nJyApIHtcbiAgICAgICAgdGhpcy54LnVwZGF0ZV9sb2NhdGlvbihnbCxwcm9ncmFtKVxuICAgICAgfSBcbiAgICAgIGlmKCB0aGlzLnkudHlwZSA9PT0gJ3N0cmluZycgJiYgdGhpcy54ICE9PSB0aGlzLnkgICkge1xuICAgICAgICB0aGlzLnkudXBkYXRlX2xvY2F0aW9uKGdsLHByb2dyYW0pXG4gICAgICB9IFxuICAgICAgaWYoIHRoaXMuei50eXBlID09PSAnc3RyaW5nJyAmJiB0aGlzLnogIT09IHRoaXMueSAmJiB0aGlzLnogIT09IHRoaXMueCApIHtcbiAgICAgICAgdGhpcy56LnVwZGF0ZV9sb2NhdGlvbihnbCxwcm9ncmFtKVxuICAgICAgfSAgICAgIFxuICAgICAgaWYoIHRoaXMudy50eXBlID09PSAnc3RyaW5nJyAmJiB0aGlzLncgIT09IHRoaXMueSAmJiB0aGlzLncgIT09IHRoaXMueCAmJiB0aGlzLncgIT09IHRoaXMueiApIHtcbiAgICAgICAgdGhpcy53LnVwZGF0ZV9sb2NhdGlvbihnbCxwcm9ncmFtKVxuICAgICAgfSAgXG4gICAgfVxuICB9LFxuICBcbiAgdXBsb2FkX2RhdGEoZ2wpIHtcbiAgICBpZiggdGhpcy5pc0dlbiApIHtcbiAgICAgIGlmKCB0aGlzLngudHlwZSA9PT0gJ3N0cmluZycgKSB7XG4gICAgICAgIHRoaXMueC51cGxvYWRfZGF0YShnbClcbiAgICAgIH0gXG4gICAgICBpZiggdGhpcy55LnR5cGUgPT09ICdzdHJpbmcnICYmIHRoaXMueCAhPT0gdGhpcy55ICApIHtcbiAgICAgICAgdGhpcy55LnVwbG9hZF9kYXRhKGdsKVxuICAgICAgfSBcbiAgICAgIGlmKCB0aGlzLnoudHlwZSA9PT0gJ3N0cmluZycgJiYgdGhpcy56ICE9PSB0aGlzLnkgJiYgdGhpcy56ICE9PSB0aGlzLnggKSB7XG4gICAgICAgIHRoaXMuei51cGxvYWRfZGF0YShnbClcbiAgICAgIH0gXG4gICAgICBpZiggdGhpcy53LnR5cGUgPT09ICdzdHJpbmcnICYmIHRoaXMudyAhPT0gdGhpcy55ICYmIHRoaXMudyAhPT0gdGhpcy54ICYmIHRoaXMudyAhPT0gdGhpcy56ICkge1xuICAgICAgICB0aGlzLncudXBsb2FkX2RhdGEoZ2wpXG4gICAgICB9ICAgICAgXG4gICAgfVxuICB9LFxuXG4gIGNvcHkoKSB7XG4gICAgcmV0dXJuIFZlYzQoIHRoaXMueCwgdGhpcy55LCB0aGlzLnosIHRoaXMudyApXG4gIH1cbn1cbi8vIFZlYzRcblxuLy9sZXQgVmVjNCA9IGZ1bmN0aW9uICh4LCB5LCB6LCB3KSB7XG4vLyAgY29uc3QgdiA9IE9iamVjdC5jcmVhdGUoIFZlYzQucHJvdG90eXBlIClcbi8vICB2LnggPSB4OyB2LnkgPSB5OyB2LnogPSB6OyB2LncgPSB3XG5cbi8vICByZXR1cm4gdlxuLy99O1xuXG4vL1ZlYzQucHJvdG90eXBlID0ge1xuLy8gIHR5cGU6ICd2ZWM0Jyxcbi8vICBlbWl0KCkgeyByZXR1cm4gXCJ2ZWM0KFwiICsgdGhpcy54ICsgXCIsXCIgKyB0aGlzLnkgKyBcIixcIiArIHRoaXMueiArIFwiLFwiICsgdGhpcy53ICsgXCIpXCI7IH0sXG4vLyAgZW1pdF9kZWNsKCkgeyByZXR1cm4gXCJcIjsgfVxuLy99XG5cblxuXG5cblxubW9kdWxlLmV4cG9ydHMgPSB7IFZlYzIsIFZlYzMsIFZlYzQgfSBcbiIsImNvbnN0IFNjZW5lTm9kZSA9IHJlcXVpcmUoICcuL3NjZW5lTm9kZS5qcycgKSxcbiAgICAgIHsgcGFyYW1fd3JhcCwgTWF0ZXJpYWxJRCB9ID0gcmVxdWlyZSggJy4vdXRpbHMuanMnICksXG4gICAgICB7IFZhciwgZmxvYXRfdmFyX2dlbiwgdmVjMl92YXJfZ2VuLCB2ZWMzX3Zhcl9nZW4sIHZlYzRfdmFyX2dlbiwgaW50X3Zhcl9nZW4sIFZhckFsbG9jIH0gPSByZXF1aXJlKCAnLi92YXIuanMnIClcblxuY29uc3QgVmlnbmV0dGUgPSBmdW5jdGlvbiggU2NlbmUsIFNERiApIHtcblxuICBjb25zdCBWZ24gPSBmdW5jdGlvbiggcmFkaXVzPTAuMSwgc21vb3RobmVzcz0uMSApIHtcbiAgICBjb25zdCB2Z24gPSBPYmplY3QuY3JlYXRlKCBWZ24ucHJvdG90eXBlIClcbiAgICBjb25zdCBfX3JhZGl1cyA9IHBhcmFtX3dyYXAoIHJhZGl1cywgZmxvYXRfdmFyX2dlbiggcmFkaXVzICkgKSAgXG4gICAgXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCB2Z24sICdyYWRpdXMnLCB7XG4gICAgICBnZXQoKSB7IHJldHVybiBfX3JhZGl1cyB9LFxuICAgICAgc2V0KCB2ICkge1xuICAgICAgICBfX3JhZGl1cy5zZXQoIHYgKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICBjb25zdCBfX3Ntb290aG5lc3MgPSBwYXJhbV93cmFwKCBzbW9vdGhuZXNzLCBmbG9hdF92YXJfZ2VuKCBzbW9vdGhuZXNzICkgKSAgXG4gICAgXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KCB2Z24sICdzbW9vdGhuZXNzJywge1xuICAgICAgZ2V0KCkgeyByZXR1cm4gX19zbW9vdGhuZXNzIH0sXG4gICAgICBzZXQoIHYgKSB7XG4gICAgICAgIF9fc21vb3RobmVzcy5zZXQoIHYgKVxuICAgICAgfVxuICAgIH0pXG4gICAgXG4gICAgLy8gdGhpcyByZWZlcnMgdG8gdGhlIGN1cnJlbnQgc2NlbmUgdmlhIGltcGxpY2l0IGJpbmRpbmcgaW4gc2NlbmUuanNcbiAgICB0aGlzLnBvc3Rwcm9jZXNzaW5nLnB1c2goIHZnbiApXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgVmduLnByb3RvdHlwZSA9IFNjZW5lTm9kZSgpXG4gXG4gIE9iamVjdC5hc3NpZ24oIFZnbi5wcm90b3R5cGUsIHtcbiAgICBlbWl0KCkge1xuICAgICAgcmV0dXJuIGAgIGNvbG9yICo9IHZpZ25ldHRlKCB2X3V2LCAke3RoaXMucmFkaXVzLmVtaXQoKX0sICR7dGhpcy5zbW9vdGhuZXNzLmVtaXQoKX0gKTtgXG4gICAgfSxcbiAgIFxuICAgIGVtaXRfZGVjbCgpIHtcbiAgICAgIGxldCBzdHIgPSB0aGlzLnJhZGl1cy5lbWl0X2RlY2woKSArIHRoaXMuc21vb3RobmVzcy5lbWl0X2RlY2woKVxuICAgICAgLy8gdGFrZW4gZnJvbSBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9yLWx5ZWgtYXJjaGl2ZWQvMTcwYjUzZmNkYzBlMTdhZmNmMTVcbiAgICAgIC8vIG9yaWdpbmFsbHkgaXFcbiAgICAgIGNvbnN0IHByZWZhY2UgPSBgICBmbG9hdCB2aWduZXR0ZSh2ZWMyIHV2LCBmbG9hdCByYWRpdXMsIGZsb2F0IHNtb290aG5lc3MpIHtcbiAgICAgICAgcmV0dXJuIHJhZGl1cyArIDAuNSoxNi4wKnV2LngqdXYueSooMS4wLXV2LngpKigxLjAtdXYueSk7IFxuICAgICAgfVxuICBgXG4gICAgICBpZiggU0RGLm1lbW8udmduID09PSB1bmRlZmluZWQgKSB7XG4gICAgICAgIHN0ciA9IHN0ciArIHByZWZhY2VcbiAgICAgICAgU0RGLm1lbW8udmduID0gdHJ1ZVxuICAgICAgfWVsc2V7XG4gICAgICAgIHN0ciA9ICcnXG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzdHJcbiAgICB9LFxuXG4gICAgdXBkYXRlX2xvY2F0aW9uKCBnbCwgcHJvZ3JhbSApIHtcbiAgICAgIHRoaXMucmFkaXVzLnVwZGF0ZV9sb2NhdGlvbiggZ2wsIHByb2dyYW0gKVxuICAgICAgdGhpcy5zbW9vdGhuZXNzLnVwZGF0ZV9sb2NhdGlvbiggZ2wsIHByb2dyYW0gKVxuICAgIH0sXG5cbiAgICB1cGxvYWRfZGF0YSggZ2wgKSB7XG4gICAgICB0aGlzLnJhZGl1cy51cGxvYWRfZGF0YSggZ2wgKVxuICAgICAgdGhpcy5zbW9vdGhuZXNzLnVwbG9hZF9kYXRhKCBnbCApXG4gICAgfVxuICB9KVxuXG4gIHJldHVybiBWZ25cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBWaWduZXR0ZSBcbiIsIid1c2Ugc3RyaWN0J1xuXG5leHBvcnRzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcblxudmFyIGxvb2t1cCA9IFtdXG52YXIgcmV2TG9va3VwID0gW11cbnZhciBBcnIgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcgPyBVaW50OEFycmF5IDogQXJyYXlcblxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcbmZvciAodmFyIGkgPSAwLCBsZW4gPSBjb2RlLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXG59XG5cbi8vIFN1cHBvcnQgZGVjb2RpbmcgVVJMLXNhZmUgYmFzZTY0IHN0cmluZ3MsIGFzIE5vZGUuanMgZG9lcy5cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQmFzZTY0I1VSTF9hcHBsaWNhdGlvbnNcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxucmV2TG9va3VwWydfJy5jaGFyQ29kZUF0KDApXSA9IDYzXG5cbmZ1bmN0aW9uIGdldExlbnMgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyBUcmltIG9mZiBleHRyYSBieXRlcyBhZnRlciBwbGFjZWhvbGRlciBieXRlcyBhcmUgZm91bmRcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vYmVhdGdhbW1pdC9iYXNlNjQtanMvaXNzdWVzLzQyXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9JylcbiAgaWYgKHZhbGlkTGVuID09PSAtMSkgdmFsaWRMZW4gPSBsZW5cblxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlblxuICAgID8gMFxuICAgIDogNCAtICh2YWxpZExlbiAlIDQpXG5cbiAgcmV0dXJuIFt2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuXVxufVxuXG4vLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKGI2NCkge1xuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxufVxuXG5mdW5jdGlvbiB0b0J5dGVBcnJheSAoYjY0KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuXG4gIHZhciBhcnIgPSBuZXcgQXJyKF9ieXRlTGVuZ3RoKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikpXG5cbiAgdmFyIGN1ckJ5dGUgPSAwXG5cbiAgLy8gaWYgdGhlcmUgYXJlIHBsYWNlaG9sZGVycywgb25seSBnZXQgdXAgdG8gdGhlIGxhc3QgY29tcGxldGUgNCBjaGFyc1xuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMFxuICAgID8gdmFsaWRMZW4gLSA0XG4gICAgOiB2YWxpZExlblxuXG4gIHZhciBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDEyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxuICAgICAgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDIpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAxKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID1cbiAgICAgICgodWludDhbaV0gPDwgMTYpICYgMHhGRjAwMDApICtcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXG4gICAgICAodWludDhbaSArIDJdICYgMHhGRilcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayhcbiAgICAgIHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aClcbiAgICApKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iLCIvKipcbiAqIEJpdCB0d2lkZGxpbmcgaGFja3MgZm9yIEphdmFTY3JpcHQuXG4gKlxuICogQXV0aG9yOiBNaWtvbGEgTHlzZW5rb1xuICpcbiAqIFBvcnRlZCBmcm9tIFN0YW5mb3JkIGJpdCB0d2lkZGxpbmcgaGFjayBsaWJyYXJ5OlxuICogICAgaHR0cDovL2dyYXBoaWNzLnN0YW5mb3JkLmVkdS9+c2VhbmRlci9iaXRoYWNrcy5odG1sXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7IFwidXNlIHJlc3RyaWN0XCI7XG5cbi8vTnVtYmVyIG9mIGJpdHMgaW4gYW4gaW50ZWdlclxudmFyIElOVF9CSVRTID0gMzI7XG5cbi8vQ29uc3RhbnRzXG5leHBvcnRzLklOVF9CSVRTICA9IElOVF9CSVRTO1xuZXhwb3J0cy5JTlRfTUFYICAgPSAgMHg3ZmZmZmZmZjtcbmV4cG9ydHMuSU5UX01JTiAgID0gLTE8PChJTlRfQklUUy0xKTtcblxuLy9SZXR1cm5zIC0xLCAwLCArMSBkZXBlbmRpbmcgb24gc2lnbiBvZiB4XG5leHBvcnRzLnNpZ24gPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiAodiA+IDApIC0gKHYgPCAwKTtcbn1cblxuLy9Db21wdXRlcyBhYnNvbHV0ZSB2YWx1ZSBvZiBpbnRlZ2VyXG5leHBvcnRzLmFicyA9IGZ1bmN0aW9uKHYpIHtcbiAgdmFyIG1hc2sgPSB2ID4+IChJTlRfQklUUy0xKTtcbiAgcmV0dXJuICh2IF4gbWFzaykgLSBtYXNrO1xufVxuXG4vL0NvbXB1dGVzIG1pbmltdW0gb2YgaW50ZWdlcnMgeCBhbmQgeVxuZXhwb3J0cy5taW4gPSBmdW5jdGlvbih4LCB5KSB7XG4gIHJldHVybiB5IF4gKCh4IF4geSkgJiAtKHggPCB5KSk7XG59XG5cbi8vQ29tcHV0ZXMgbWF4aW11bSBvZiBpbnRlZ2VycyB4IGFuZCB5XG5leHBvcnRzLm1heCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgcmV0dXJuIHggXiAoKHggXiB5KSAmIC0oeCA8IHkpKTtcbn1cblxuLy9DaGVja3MgaWYgYSBudW1iZXIgaXMgYSBwb3dlciBvZiB0d29cbmV4cG9ydHMuaXNQb3cyID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gISh2ICYgKHYtMSkpICYmICghIXYpO1xufVxuXG4vL0NvbXB1dGVzIGxvZyBiYXNlIDIgb2YgdlxuZXhwb3J0cy5sb2cyID0gZnVuY3Rpb24odikge1xuICB2YXIgciwgc2hpZnQ7XG4gIHIgPSAgICAgKHYgPiAweEZGRkYpIDw8IDQ7IHYgPj4+PSByO1xuICBzaGlmdCA9ICh2ID4gMHhGRiAgKSA8PCAzOyB2ID4+Pj0gc2hpZnQ7IHIgfD0gc2hpZnQ7XG4gIHNoaWZ0ID0gKHYgPiAweEYgICApIDw8IDI7IHYgPj4+PSBzaGlmdDsgciB8PSBzaGlmdDtcbiAgc2hpZnQgPSAodiA+IDB4MyAgICkgPDwgMTsgdiA+Pj49IHNoaWZ0OyByIHw9IHNoaWZ0O1xuICByZXR1cm4gciB8ICh2ID4+IDEpO1xufVxuXG4vL0NvbXB1dGVzIGxvZyBiYXNlIDEwIG9mIHZcbmV4cG9ydHMubG9nMTAgPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiAgKHYgPj0gMTAwMDAwMDAwMCkgPyA5IDogKHYgPj0gMTAwMDAwMDAwKSA/IDggOiAodiA+PSAxMDAwMDAwMCkgPyA3IDpcbiAgICAgICAgICAodiA+PSAxMDAwMDAwKSA/IDYgOiAodiA+PSAxMDAwMDApID8gNSA6ICh2ID49IDEwMDAwKSA/IDQgOlxuICAgICAgICAgICh2ID49IDEwMDApID8gMyA6ICh2ID49IDEwMCkgPyAyIDogKHYgPj0gMTApID8gMSA6IDA7XG59XG5cbi8vQ291bnRzIG51bWJlciBvZiBiaXRzXG5leHBvcnRzLnBvcENvdW50ID0gZnVuY3Rpb24odikge1xuICB2ID0gdiAtICgodiA+Pj4gMSkgJiAweDU1NTU1NTU1KTtcbiAgdiA9ICh2ICYgMHgzMzMzMzMzMykgKyAoKHYgPj4+IDIpICYgMHgzMzMzMzMzMyk7XG4gIHJldHVybiAoKHYgKyAodiA+Pj4gNCkgJiAweEYwRjBGMEYpICogMHgxMDEwMTAxKSA+Pj4gMjQ7XG59XG5cbi8vQ291bnRzIG51bWJlciBvZiB0cmFpbGluZyB6ZXJvc1xuZnVuY3Rpb24gY291bnRUcmFpbGluZ1plcm9zKHYpIHtcbiAgdmFyIGMgPSAzMjtcbiAgdiAmPSAtdjtcbiAgaWYgKHYpIGMtLTtcbiAgaWYgKHYgJiAweDAwMDBGRkZGKSBjIC09IDE2O1xuICBpZiAodiAmIDB4MDBGRjAwRkYpIGMgLT0gODtcbiAgaWYgKHYgJiAweDBGMEYwRjBGKSBjIC09IDQ7XG4gIGlmICh2ICYgMHgzMzMzMzMzMykgYyAtPSAyO1xuICBpZiAodiAmIDB4NTU1NTU1NTUpIGMgLT0gMTtcbiAgcmV0dXJuIGM7XG59XG5leHBvcnRzLmNvdW50VHJhaWxpbmdaZXJvcyA9IGNvdW50VHJhaWxpbmdaZXJvcztcblxuLy9Sb3VuZHMgdG8gbmV4dCBwb3dlciBvZiAyXG5leHBvcnRzLm5leHRQb3cyID0gZnVuY3Rpb24odikge1xuICB2ICs9IHYgPT09IDA7XG4gIC0tdjtcbiAgdiB8PSB2ID4+PiAxO1xuICB2IHw9IHYgPj4+IDI7XG4gIHYgfD0gdiA+Pj4gNDtcbiAgdiB8PSB2ID4+PiA4O1xuICB2IHw9IHYgPj4+IDE2O1xuICByZXR1cm4gdiArIDE7XG59XG5cbi8vUm91bmRzIGRvd24gdG8gcHJldmlvdXMgcG93ZXIgb2YgMlxuZXhwb3J0cy5wcmV2UG93MiA9IGZ1bmN0aW9uKHYpIHtcbiAgdiB8PSB2ID4+PiAxO1xuICB2IHw9IHYgPj4+IDI7XG4gIHYgfD0gdiA+Pj4gNDtcbiAgdiB8PSB2ID4+PiA4O1xuICB2IHw9IHYgPj4+IDE2O1xuICByZXR1cm4gdiAtICh2Pj4+MSk7XG59XG5cbi8vQ29tcHV0ZXMgcGFyaXR5IG9mIHdvcmRcbmV4cG9ydHMucGFyaXR5ID0gZnVuY3Rpb24odikge1xuICB2IF49IHYgPj4+IDE2O1xuICB2IF49IHYgPj4+IDg7XG4gIHYgXj0gdiA+Pj4gNDtcbiAgdiAmPSAweGY7XG4gIHJldHVybiAoMHg2OTk2ID4+PiB2KSAmIDE7XG59XG5cbnZhciBSRVZFUlNFX1RBQkxFID0gbmV3IEFycmF5KDI1Nik7XG5cbihmdW5jdGlvbih0YWIpIHtcbiAgZm9yKHZhciBpPTA7IGk8MjU2OyArK2kpIHtcbiAgICB2YXIgdiA9IGksIHIgPSBpLCBzID0gNztcbiAgICBmb3IgKHYgPj4+PSAxOyB2OyB2ID4+Pj0gMSkge1xuICAgICAgciA8PD0gMTtcbiAgICAgIHIgfD0gdiAmIDE7XG4gICAgICAtLXM7XG4gICAgfVxuICAgIHRhYltpXSA9IChyIDw8IHMpICYgMHhmZjtcbiAgfVxufSkoUkVWRVJTRV9UQUJMRSk7XG5cbi8vUmV2ZXJzZSBiaXRzIGluIGEgMzIgYml0IHdvcmRcbmV4cG9ydHMucmV2ZXJzZSA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuICAoUkVWRVJTRV9UQUJMRVsgdiAgICAgICAgICYgMHhmZl0gPDwgMjQpIHxcbiAgICAgICAgICAoUkVWRVJTRV9UQUJMRVsodiA+Pj4gOCkgICYgMHhmZl0gPDwgMTYpIHxcbiAgICAgICAgICAoUkVWRVJTRV9UQUJMRVsodiA+Pj4gMTYpICYgMHhmZl0gPDwgOCkgIHxcbiAgICAgICAgICAgUkVWRVJTRV9UQUJMRVsodiA+Pj4gMjQpICYgMHhmZl07XG59XG5cbi8vSW50ZXJsZWF2ZSBiaXRzIG9mIDIgY29vcmRpbmF0ZXMgd2l0aCAxNiBiaXRzLiAgVXNlZnVsIGZvciBmYXN0IHF1YWR0cmVlIGNvZGVzXG5leHBvcnRzLmludGVybGVhdmUyID0gZnVuY3Rpb24oeCwgeSkge1xuICB4ICY9IDB4RkZGRjtcbiAgeCA9ICh4IHwgKHggPDwgOCkpICYgMHgwMEZGMDBGRjtcbiAgeCA9ICh4IHwgKHggPDwgNCkpICYgMHgwRjBGMEYwRjtcbiAgeCA9ICh4IHwgKHggPDwgMikpICYgMHgzMzMzMzMzMztcbiAgeCA9ICh4IHwgKHggPDwgMSkpICYgMHg1NTU1NTU1NTtcblxuICB5ICY9IDB4RkZGRjtcbiAgeSA9ICh5IHwgKHkgPDwgOCkpICYgMHgwMEZGMDBGRjtcbiAgeSA9ICh5IHwgKHkgPDwgNCkpICYgMHgwRjBGMEYwRjtcbiAgeSA9ICh5IHwgKHkgPDwgMikpICYgMHgzMzMzMzMzMztcbiAgeSA9ICh5IHwgKHkgPDwgMSkpICYgMHg1NTU1NTU1NTtcblxuICByZXR1cm4geCB8ICh5IDw8IDEpO1xufVxuXG4vL0V4dHJhY3RzIHRoZSBudGggaW50ZXJsZWF2ZWQgY29tcG9uZW50XG5leHBvcnRzLmRlaW50ZXJsZWF2ZTIgPSBmdW5jdGlvbih2LCBuKSB7XG4gIHYgPSAodiA+Pj4gbikgJiAweDU1NTU1NTU1O1xuICB2ID0gKHYgfCAodiA+Pj4gMSkpICAmIDB4MzMzMzMzMzM7XG4gIHYgPSAodiB8ICh2ID4+PiAyKSkgICYgMHgwRjBGMEYwRjtcbiAgdiA9ICh2IHwgKHYgPj4+IDQpKSAgJiAweDAwRkYwMEZGO1xuICB2ID0gKHYgfCAodiA+Pj4gMTYpKSAmIDB4MDAwRkZGRjtcbiAgcmV0dXJuICh2IDw8IDE2KSA+PiAxNjtcbn1cblxuXG4vL0ludGVybGVhdmUgYml0cyBvZiAzIGNvb3JkaW5hdGVzLCBlYWNoIHdpdGggMTAgYml0cy4gIFVzZWZ1bCBmb3IgZmFzdCBvY3RyZWUgY29kZXNcbmV4cG9ydHMuaW50ZXJsZWF2ZTMgPSBmdW5jdGlvbih4LCB5LCB6KSB7XG4gIHggJj0gMHgzRkY7XG4gIHggID0gKHggfCAoeDw8MTYpKSAmIDQyNzgxOTAzMzU7XG4gIHggID0gKHggfCAoeDw8OCkpICAmIDI1MTcxOTY5NTtcbiAgeCAgPSAoeCB8ICh4PDw0KSkgICYgMzI3MjM1NjAzNTtcbiAgeCAgPSAoeCB8ICh4PDwyKSkgICYgMTIyNzEzMzUxMztcblxuICB5ICY9IDB4M0ZGO1xuICB5ICA9ICh5IHwgKHk8PDE2KSkgJiA0Mjc4MTkwMzM1O1xuICB5ICA9ICh5IHwgKHk8PDgpKSAgJiAyNTE3MTk2OTU7XG4gIHkgID0gKHkgfCAoeTw8NCkpICAmIDMyNzIzNTYwMzU7XG4gIHkgID0gKHkgfCAoeTw8MikpICAmIDEyMjcxMzM1MTM7XG4gIHggfD0gKHkgPDwgMSk7XG4gIFxuICB6ICY9IDB4M0ZGO1xuICB6ICA9ICh6IHwgKHo8PDE2KSkgJiA0Mjc4MTkwMzM1O1xuICB6ICA9ICh6IHwgKHo8PDgpKSAgJiAyNTE3MTk2OTU7XG4gIHogID0gKHogfCAoejw8NCkpICAmIDMyNzIzNTYwMzU7XG4gIHogID0gKHogfCAoejw8MikpICAmIDEyMjcxMzM1MTM7XG4gIFxuICByZXR1cm4geCB8ICh6IDw8IDIpO1xufVxuXG4vL0V4dHJhY3RzIG50aCBpbnRlcmxlYXZlZCBjb21wb25lbnQgb2YgYSAzLXR1cGxlXG5leHBvcnRzLmRlaW50ZXJsZWF2ZTMgPSBmdW5jdGlvbih2LCBuKSB7XG4gIHYgPSAodiA+Pj4gbikgICAgICAgJiAxMjI3MTMzNTEzO1xuICB2ID0gKHYgfCAodj4+PjIpKSAgICYgMzI3MjM1NjAzNTtcbiAgdiA9ICh2IHwgKHY+Pj40KSkgICAmIDI1MTcxOTY5NTtcbiAgdiA9ICh2IHwgKHY+Pj44KSkgICAmIDQyNzgxOTAzMzU7XG4gIHYgPSAodiB8ICh2Pj4+MTYpKSAgJiAweDNGRjtcbiAgcmV0dXJuICh2PDwyMik+PjIyO1xufVxuXG4vL0NvbXB1dGVzIG5leHQgY29tYmluYXRpb24gaW4gY29sZXhpY29ncmFwaGljIG9yZGVyICh0aGlzIGlzIG1pc3Rha2VubHkgY2FsbGVkIG5leHRQZXJtdXRhdGlvbiBvbiB0aGUgYml0IHR3aWRkbGluZyBoYWNrcyBwYWdlKVxuZXhwb3J0cy5uZXh0Q29tYmluYXRpb24gPSBmdW5jdGlvbih2KSB7XG4gIHZhciB0ID0gdiB8ICh2IC0gMSk7XG4gIHJldHVybiAodCArIDEpIHwgKCgofnQgJiAtfnQpIC0gMSkgPj4+IChjb3VudFRyYWlsaW5nWmVyb3ModikgKyAxKSk7XG59XG5cbiIsIiIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBjdXN0b21JbnNwZWN0U3ltYm9sID1cbiAgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC5mb3IgPT09ICdmdW5jdGlvbicpXG4gICAgPyBTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXG4gICAgOiBudWxsXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxudmFyIEtfTUFYX0xFTkdUSCA9IDB4N2ZmZmZmZmZcbmV4cG9ydHMua01heExlbmd0aCA9IEtfTUFYX0xFTkdUSFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBQcmludCB3YXJuaW5nIGFuZCByZWNvbW1lbmQgdXNpbmcgYGJ1ZmZlcmAgdjQueCB3aGljaCBoYXMgYW4gT2JqZWN0XG4gKiAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBXZSByZXBvcnQgdGhhdCB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBpZiB0aGUgYXJlIG5vdCBzdWJjbGFzc2FibGVcbiAqIHVzaW5nIF9fcHJvdG9fXy4gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWBcbiAqIChTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOCkuIElFIDEwIGxhY2tzIHN1cHBvcnRcbiAqIGZvciBfX3Byb3RvX18gYW5kIGhhcyBhIGJ1Z2d5IHR5cGVkIGFycmF5IGltcGxlbWVudGF0aW9uLlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICBjb25zb2xlLmVycm9yKFxuICAgICdUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgJyArXG4gICAgJ2BidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuJ1xuICApXG59XG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgLy8gQ2FuIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkP1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIHZhciBwcm90byA9IHsgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9IH1cbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YocHJvdG8sIFVpbnQ4QXJyYXkucHJvdG90eXBlKVxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihhcnIsIHByb3RvKVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ3BhcmVudCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5idWZmZXJcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdvZmZzZXQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnl0ZU9mZnNldFxuICB9XG59KVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAobGVuZ3RoID4gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBsZW5ndGggKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYnVmLCBCdWZmZXIucHJvdG90eXBlKVxuICByZXR1cm4gYnVmXG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuZnVuY3Rpb24gZnJvbSAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh2YWx1ZSlcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgICApXG4gIH1cblxuICBpZiAoaXNJbnN0YW5jZSh2YWx1ZSwgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIEFycmF5QnVmZmVyKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgKGlzSW5zdGFuY2UodmFsdWUsIFNoYXJlZEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBTaGFyZWRBcnJheUJ1ZmZlcikpKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICApXG4gIH1cblxuICB2YXIgdmFsdWVPZiA9IHZhbHVlLnZhbHVlT2YgJiYgdmFsdWUudmFsdWVPZigpXG4gIGlmICh2YWx1ZU9mICE9IG51bGwgJiYgdmFsdWVPZiAhPT0gdmFsdWUpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWVPZiwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgdmFyIGIgPSBmcm9tT2JqZWN0KHZhbHVlKVxuICBpZiAoYikgcmV0dXJuIGJcblxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvUHJpbWl0aXZlICE9IG51bGwgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKFxuICAgICAgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSgnc3RyaW5nJyksIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aFxuICAgIClcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIE5vdGU6IENoYW5nZSBwcm90b3R5cGUgKmFmdGVyKiBCdWZmZXIuZnJvbSBpcyBkZWZpbmVkIHRvIHdvcmthcm91bmQgQ2hyb21lIGJ1Zzpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvMTQ4XG5PYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLnByb3RvdHlwZSwgVWludDhBcnJheS5wcm90b3R5cGUpXG5PYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLCBVaW50OEFycmF5KVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgc2l6ZSArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSBidWYud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIGJ1ZiA9IGJ1Zi5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICBidWZbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyIChhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcIm9mZnNldFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wibGVuZ3RoXCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIHZhciBidWZcbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlci5wcm90b3R5cGUpXG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0IChvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW4pXG5cbiAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJ1ZlxuICAgIH1cblxuICAgIG9iai5jb3B5KGJ1ZiwgMCwgMCwgbGVuKVxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGlmIChvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IG51bWJlcklzTmFOKG9iai5sZW5ndGgpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApXG4gICAgfVxuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iailcbiAgfVxuXG4gIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgQXJyYXkuaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmouZGF0YSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwgS19NQVhfTEVOR1RIYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgPT09IHRydWUgJiZcbiAgICBiICE9PSBCdWZmZXIucHJvdG90eXBlIC8vIHNvIEJ1ZmZlci5pc0J1ZmZlcihCdWZmZXIucHJvdG90eXBlKSB3aWxsIGJlIGZhbHNlXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoaXNJbnN0YW5jZShhLCBVaW50OEFycmF5KSkgYSA9IEJ1ZmZlci5mcm9tKGEsIGEub2Zmc2V0LCBhLmJ5dGVMZW5ndGgpXG4gIGlmIChpc0luc3RhbmNlKGIsIFVpbnQ4QXJyYXkpKSBiID0gQnVmZmVyLmZyb20oYiwgYi5vZmZzZXQsIGIuYnl0ZUxlbmd0aClcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwiYnVmMVwiLCBcImJ1ZjJcIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheSdcbiAgICApXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoaXNJbnN0YW5jZShidWYsIFVpbnQ4QXJyYXkpKSB7XG4gICAgICBidWYgPSBCdWZmZXIuZnJvbShidWYpXG4gICAgfVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IGlzSW5zdGFuY2Uoc3RyaW5nLCBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIG9yIEFycmF5QnVmZmVyLiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2Ygc3RyaW5nXG4gICAgKVxuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIG11c3RNYXRjaCA9IChhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gPT09IHRydWUpXG4gIGlmICghbXVzdE1hdGNoICYmIGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkge1xuICAgICAgICAgIHJldHVybiBtdXN0TWF0Y2ggPyAtMSA6IHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgKGFuZCB0aGUgYGlzLWJ1ZmZlcmAgbnBtIHBhY2thZ2UpXG4vLyB0byBkZXRlY3QgYSBCdWZmZXIgaW5zdGFuY2UuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBgaW5zdGFuY2VvZiBCdWZmZXJgXG4vLyByZWxpYWJseSBpbiBhIGJyb3dzZXJpZnkgY29udGV4dCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIGRpZmZlcmVudFxuLy8gY29waWVzIG9mIHRoZSAnYnVmZmVyJyBwYWNrYWdlIGluIHVzZS4gVGhpcyBtZXRob2Qgd29ya3MgZXZlbiBmb3IgQnVmZmVyXG4vLyBpbnN0YW5jZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZnJvbSBhbm90aGVyIGNvcHkgb2YgdGhlIGBidWZmZXJgIHBhY2thZ2UuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNTRcbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcgPSBCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nXG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkucmVwbGFjZSgvKC57Mn0pL2csICckMSAnKS50cmltKClcbiAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuaWYgKGN1c3RvbUluc3BlY3RTeW1ib2wpIHtcbiAgQnVmZmVyLnByb3RvdHlwZVtjdXN0b21JbnNwZWN0U3ltYm9sXSA9IEJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoaXNJbnN0YW5jZSh0YXJnZXQsIFVpbnQ4QXJyYXkpKSB7XG4gICAgdGFyZ2V0ID0gQnVmZmVyLmZyb20odGFyZ2V0LCB0YXJnZXQub2Zmc2V0LCB0YXJnZXQuYnl0ZUxlbmd0aClcbiAgfVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ0YXJnZXRcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHRhcmdldClcbiAgICApXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0IC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChudW1iZXJJc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFt2YWxdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAobnVtYmVySXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggPj4+IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gaGV4U2xpY2VMb29rdXBUYWJsZVtidWZbaV1dXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIChieXRlc1tpICsgMV0gKiAyNTYpKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihuZXdCdWYsIEJ1ZmZlci5wcm90b3R5cGUpXG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlcicpXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVXNlIGJ1aWx0LWluIHdoZW4gYXZhaWxhYmxlLCBtaXNzaW5nIGZyb20gSUUxMVxuICAgIHRoaXMuY29weVdpdGhpbih0YXJnZXRTdGFydCwgc3RhcnQsIGVuZClcbiAgfSBlbHNlIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKChlbmNvZGluZyA9PT0gJ3V0ZjgnICYmIGNvZGUgPCAxMjgpIHx8XG4gICAgICAgICAgZW5jb2RpbmcgPT09ICdsYXRpbjEnKSB7XG4gICAgICAgIC8vIEZhc3QgcGF0aDogSWYgYHZhbGAgZml0cyBpbnRvIGEgc2luZ2xlIGJ5dGUsIHVzZSB0aGF0IG51bWVyaWMgdmFsdWUuXG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnYm9vbGVhbicpIHtcbiAgICB2YWwgPSBOdW1iZXIodmFsKVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyB2YWwgK1xuICAgICAgICAnXCIgaXMgaW52YWxpZCBmb3IgYXJndW1lbnQgXCJ2YWx1ZVwiJylcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSB0YWtlcyBlcXVhbCBzaWducyBhcyBlbmQgb2YgdGhlIEJhc2U2NCBlbmNvZGluZ1xuICBzdHIgPSBzdHIuc3BsaXQoJz0nKVswXVxuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyLnRyaW0oKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG4vLyBBcnJheUJ1ZmZlciBvciBVaW50OEFycmF5IG9iamVjdHMgZnJvbSBvdGhlciBjb250ZXh0cyAoaS5lLiBpZnJhbWVzKSBkbyBub3QgcGFzc1xuLy8gdGhlIGBpbnN0YW5jZW9mYCBjaGVjayBidXQgdGhleSBzaG91bGQgYmUgdHJlYXRlZCBhcyBvZiB0aGF0IHR5cGUuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNjZcbmZ1bmN0aW9uIGlzSW5zdGFuY2UgKG9iaiwgdHlwZSkge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgdHlwZSB8fFxuICAgIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSAhPSBudWxsICYmXG4gICAgICBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gdHlwZS5uYW1lKVxufVxuZnVuY3Rpb24gbnVtYmVySXNOYU4gKG9iaikge1xuICAvLyBGb3IgSUUxMSBzdXBwb3J0XG4gIHJldHVybiBvYmogIT09IG9iaiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuXG4vLyBDcmVhdGUgbG9va3VwIHRhYmxlIGZvciBgdG9TdHJpbmcoJ2hleCcpYFxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMjE5XG52YXIgaGV4U2xpY2VMb29rdXBUYWJsZSA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBhbHBoYWJldCA9ICcwMTIzNDU2Nzg5YWJjZGVmJ1xuICB2YXIgdGFibGUgPSBuZXcgQXJyYXkoMjU2KVxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICB2YXIgaTE2ID0gaSAqIDE2XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCAxNjsgKytqKSB7XG4gICAgICB0YWJsZVtpMTYgKyBqXSA9IGFscGhhYmV0W2ldICsgYWxwaGFiZXRbal1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhYmxlXG59KSgpXG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gTk9URTogVGhlc2UgdHlwZSBjaGVja2luZyBmdW5jdGlvbnMgaW50ZW50aW9uYWxseSBkb24ndCB1c2UgYGluc3RhbmNlb2ZgXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cblxuZnVuY3Rpb24gaXNBcnJheShhcmcpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShhcmcpO1xuICB9XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcblxuZnVuY3Rpb24gaXNCb29sZWFuKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xufVxuZXhwb3J0cy5pc0Jvb2xlYW4gPSBpc0Jvb2xlYW47XG5cbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xuXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuZXhwb3J0cy5pc051bWJlciA9IGlzTnVtYmVyO1xuXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xufVxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZChhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xufVxuZXhwb3J0cy5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gKG9iamVjdFRvU3RyaW5nKGUpID09PSAnW29iamVjdCBFcnJvcl0nIHx8IGUgaW5zdGFuY2VvZiBFcnJvcik7XG59XG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdudW1iZXInIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICd1bmRlZmluZWQnO1xufVxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xuXG5leHBvcnRzLmlzQnVmZmVyID0gQnVmZmVyLmlzQnVmZmVyO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG4iLCJcInVzZSBzdHJpY3RcIlxuXG52YXIgY3JlYXRlVGh1bmsgPSByZXF1aXJlKFwiLi9saWIvdGh1bmsuanNcIilcblxuZnVuY3Rpb24gUHJvY2VkdXJlKCkge1xuICB0aGlzLmFyZ1R5cGVzID0gW11cbiAgdGhpcy5zaGltQXJncyA9IFtdXG4gIHRoaXMuYXJyYXlBcmdzID0gW11cbiAgdGhpcy5hcnJheUJsb2NrSW5kaWNlcyA9IFtdXG4gIHRoaXMuc2NhbGFyQXJncyA9IFtdXG4gIHRoaXMub2Zmc2V0QXJncyA9IFtdXG4gIHRoaXMub2Zmc2V0QXJnSW5kZXggPSBbXVxuICB0aGlzLmluZGV4QXJncyA9IFtdXG4gIHRoaXMuc2hhcGVBcmdzID0gW11cbiAgdGhpcy5mdW5jTmFtZSA9IFwiXCJcbiAgdGhpcy5wcmUgPSBudWxsXG4gIHRoaXMuYm9keSA9IG51bGxcbiAgdGhpcy5wb3N0ID0gbnVsbFxuICB0aGlzLmRlYnVnID0gZmFsc2Vcbn1cblxuZnVuY3Rpb24gY29tcGlsZUN3aXNlKHVzZXJfYXJncykge1xuICAvL0NyZWF0ZSBwcm9jZWR1cmVcbiAgdmFyIHByb2MgPSBuZXcgUHJvY2VkdXJlKClcbiAgXG4gIC8vUGFyc2UgYmxvY2tzXG4gIHByb2MucHJlICAgID0gdXNlcl9hcmdzLnByZVxuICBwcm9jLmJvZHkgICA9IHVzZXJfYXJncy5ib2R5XG4gIHByb2MucG9zdCAgID0gdXNlcl9hcmdzLnBvc3RcblxuICAvL1BhcnNlIGFyZ3VtZW50c1xuICB2YXIgcHJvY19hcmdzID0gdXNlcl9hcmdzLmFyZ3Muc2xpY2UoMClcbiAgcHJvYy5hcmdUeXBlcyA9IHByb2NfYXJnc1xuICBmb3IodmFyIGk9MDsgaTxwcm9jX2FyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYXJnX3R5cGUgPSBwcm9jX2FyZ3NbaV1cbiAgICBpZihhcmdfdHlwZSA9PT0gXCJhcnJheVwiIHx8ICh0eXBlb2YgYXJnX3R5cGUgPT09IFwib2JqZWN0XCIgJiYgYXJnX3R5cGUuYmxvY2tJbmRpY2VzKSkge1xuICAgICAgcHJvYy5hcmdUeXBlc1tpXSA9IFwiYXJyYXlcIlxuICAgICAgcHJvYy5hcnJheUFyZ3MucHVzaChpKVxuICAgICAgcHJvYy5hcnJheUJsb2NrSW5kaWNlcy5wdXNoKGFyZ190eXBlLmJsb2NrSW5kaWNlcyA/IGFyZ190eXBlLmJsb2NrSW5kaWNlcyA6IDApXG4gICAgICBwcm9jLnNoaW1BcmdzLnB1c2goXCJhcnJheVwiICsgaSlcbiAgICAgIGlmKGkgPCBwcm9jLnByZS5hcmdzLmxlbmd0aCAmJiBwcm9jLnByZS5hcmdzW2ldLmNvdW50PjApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHByZSgpIGJsb2NrIG1heSBub3QgcmVmZXJlbmNlIGFycmF5IGFyZ3NcIilcbiAgICAgIH1cbiAgICAgIGlmKGkgPCBwcm9jLnBvc3QuYXJncy5sZW5ndGggJiYgcHJvYy5wb3N0LmFyZ3NbaV0uY291bnQ+MCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogcG9zdCgpIGJsb2NrIG1heSBub3QgcmVmZXJlbmNlIGFycmF5IGFyZ3NcIilcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYoYXJnX3R5cGUgPT09IFwic2NhbGFyXCIpIHtcbiAgICAgIHByb2Muc2NhbGFyQXJncy5wdXNoKGkpXG4gICAgICBwcm9jLnNoaW1BcmdzLnB1c2goXCJzY2FsYXJcIiArIGkpXG4gICAgfSBlbHNlIGlmKGFyZ190eXBlID09PSBcImluZGV4XCIpIHtcbiAgICAgIHByb2MuaW5kZXhBcmdzLnB1c2goaSlcbiAgICAgIGlmKGkgPCBwcm9jLnByZS5hcmdzLmxlbmd0aCAmJiBwcm9jLnByZS5hcmdzW2ldLmNvdW50ID4gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogcHJlKCkgYmxvY2sgbWF5IG5vdCByZWZlcmVuY2UgYXJyYXkgaW5kZXhcIilcbiAgICAgIH1cbiAgICAgIGlmKGkgPCBwcm9jLmJvZHkuYXJncy5sZW5ndGggJiYgcHJvYy5ib2R5LmFyZ3NbaV0ubHZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBib2R5KCkgYmxvY2sgbWF5IG5vdCB3cml0ZSB0byBhcnJheSBpbmRleFwiKVxuICAgICAgfVxuICAgICAgaWYoaSA8IHByb2MucG9zdC5hcmdzLmxlbmd0aCAmJiBwcm9jLnBvc3QuYXJnc1tpXS5jb3VudCA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHBvc3QoKSBibG9jayBtYXkgbm90IHJlZmVyZW5jZSBhcnJheSBpbmRleFwiKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZihhcmdfdHlwZSA9PT0gXCJzaGFwZVwiKSB7XG4gICAgICBwcm9jLnNoYXBlQXJncy5wdXNoKGkpXG4gICAgICBpZihpIDwgcHJvYy5wcmUuYXJncy5sZW5ndGggJiYgcHJvYy5wcmUuYXJnc1tpXS5sdmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHByZSgpIGJsb2NrIG1heSBub3Qgd3JpdGUgdG8gYXJyYXkgc2hhcGVcIilcbiAgICAgIH1cbiAgICAgIGlmKGkgPCBwcm9jLmJvZHkuYXJncy5sZW5ndGggJiYgcHJvYy5ib2R5LmFyZ3NbaV0ubHZhbHVlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBib2R5KCkgYmxvY2sgbWF5IG5vdCB3cml0ZSB0byBhcnJheSBzaGFwZVwiKVxuICAgICAgfVxuICAgICAgaWYoaSA8IHByb2MucG9zdC5hcmdzLmxlbmd0aCAmJiBwcm9jLnBvc3QuYXJnc1tpXS5sdmFsdWUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IHBvc3QoKSBibG9jayBtYXkgbm90IHdyaXRlIHRvIGFycmF5IHNoYXBlXCIpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmKHR5cGVvZiBhcmdfdHlwZSA9PT0gXCJvYmplY3RcIiAmJiBhcmdfdHlwZS5vZmZzZXQpIHtcbiAgICAgIHByb2MuYXJnVHlwZXNbaV0gPSBcIm9mZnNldFwiXG4gICAgICBwcm9jLm9mZnNldEFyZ3MucHVzaCh7IGFycmF5OiBhcmdfdHlwZS5hcnJheSwgb2Zmc2V0OmFyZ190eXBlLm9mZnNldCB9KVxuICAgICAgcHJvYy5vZmZzZXRBcmdJbmRleC5wdXNoKGkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBVbmtub3duIGFyZ3VtZW50IHR5cGUgXCIgKyBwcm9jX2FyZ3NbaV0pXG4gICAgfVxuICB9XG4gIFxuICAvL01ha2Ugc3VyZSBhdCBsZWFzdCBvbmUgYXJyYXkgYXJndW1lbnQgd2FzIHNwZWNpZmllZFxuICBpZihwcm9jLmFycmF5QXJncy5sZW5ndGggPD0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBObyBhcnJheSBhcmd1bWVudHMgc3BlY2lmaWVkXCIpXG4gIH1cbiAgXG4gIC8vTWFrZSBzdXJlIGFyZ3VtZW50cyBhcmUgY29ycmVjdFxuICBpZihwcm9jLnByZS5hcmdzLmxlbmd0aCA+IHByb2NfYXJncy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjd2lzZTogVG9vIG1hbnkgYXJndW1lbnRzIGluIHByZSgpIGJsb2NrXCIpXG4gIH1cbiAgaWYocHJvYy5ib2R5LmFyZ3MubGVuZ3RoID4gcHJvY19hcmdzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBUb28gbWFueSBhcmd1bWVudHMgaW4gYm9keSgpIGJsb2NrXCIpXG4gIH1cbiAgaWYocHJvYy5wb3N0LmFyZ3MubGVuZ3RoID4gcHJvY19hcmdzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImN3aXNlOiBUb28gbWFueSBhcmd1bWVudHMgaW4gcG9zdCgpIGJsb2NrXCIpXG4gIH1cblxuICAvL0NoZWNrIGRlYnVnIGZsYWdcbiAgcHJvYy5kZWJ1ZyA9ICEhdXNlcl9hcmdzLnByaW50Q29kZSB8fCAhIXVzZXJfYXJncy5kZWJ1Z1xuICBcbiAgLy9SZXRyaWV2ZSBuYW1lXG4gIHByb2MuZnVuY05hbWUgPSB1c2VyX2FyZ3MuZnVuY05hbWUgfHwgXCJjd2lzZVwiXG4gIFxuICAvL1JlYWQgaW4gYmxvY2sgc2l6ZVxuICBwcm9jLmJsb2NrU2l6ZSA9IHVzZXJfYXJncy5ibG9ja1NpemUgfHwgNjRcblxuICByZXR1cm4gY3JlYXRlVGh1bmsocHJvYylcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb21waWxlQ3dpc2VcbiIsIlwidXNlIHN0cmljdFwiXG5cbnZhciB1bmlxID0gcmVxdWlyZShcInVuaXFcIilcblxuLy8gVGhpcyBmdW5jdGlvbiBnZW5lcmF0ZXMgdmVyeSBzaW1wbGUgbG9vcHMgYW5hbG9nb3VzIHRvIGhvdyB5b3UgdHlwaWNhbGx5IHRyYXZlcnNlIGFycmF5cyAodGhlIG91dGVybW9zdCBsb29wIGNvcnJlc3BvbmRzIHRvIHRoZSBzbG93ZXN0IGNoYW5naW5nIGluZGV4LCB0aGUgaW5uZXJtb3N0IGxvb3AgdG8gdGhlIGZhc3Rlc3QgY2hhbmdpbmcgaW5kZXgpXG4vLyBUT0RPOiBJZiB0d28gYXJyYXlzIGhhdmUgdGhlIHNhbWUgc3RyaWRlcyAoYW5kIG9mZnNldHMpIHRoZXJlIGlzIHBvdGVudGlhbCBmb3IgZGVjcmVhc2luZyB0aGUgbnVtYmVyIG9mIFwicG9pbnRlcnNcIiBhbmQgcmVsYXRlZCB2YXJpYWJsZXMuIFRoZSBkcmF3YmFjayBpcyB0aGF0IHRoZSB0eXBlIHNpZ25hdHVyZSB3b3VsZCBiZWNvbWUgbW9yZSBzcGVjaWZpYyBhbmQgdGhhdCB0aGVyZSB3b3VsZCB0aHVzIGJlIGxlc3MgcG90ZW50aWFsIGZvciBjYWNoaW5nLCBidXQgaXQgbWlnaHQgc3RpbGwgYmUgd29ydGggaXQsIGVzcGVjaWFsbHkgd2hlbiBkZWFsaW5nIHdpdGggbGFyZ2UgbnVtYmVycyBvZiBhcmd1bWVudHMuXG5mdW5jdGlvbiBpbm5lckZpbGwob3JkZXIsIHByb2MsIGJvZHkpIHtcbiAgdmFyIGRpbWVuc2lvbiA9IG9yZGVyLmxlbmd0aFxuICAgICwgbmFyZ3MgPSBwcm9jLmFycmF5QXJncy5sZW5ndGhcbiAgICAsIGhhc19pbmRleCA9IHByb2MuaW5kZXhBcmdzLmxlbmd0aD4wXG4gICAgLCBjb2RlID0gW11cbiAgICAsIHZhcnMgPSBbXVxuICAgICwgaWR4PTAsIHBpZHg9MCwgaSwgalxuICBmb3IoaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7IC8vIEl0ZXJhdGlvbiB2YXJpYWJsZXNcbiAgICB2YXJzLnB1c2goW1wiaVwiLGksXCI9MFwiXS5qb2luKFwiXCIpKVxuICB9XG4gIC8vQ29tcHV0ZSBzY2FuIGRlbHRhc1xuICBmb3Ioaj0wOyBqPG5hcmdzOyArK2opIHtcbiAgICBmb3IoaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgICBwaWR4ID0gaWR4XG4gICAgICBpZHggPSBvcmRlcltpXVxuICAgICAgaWYoaSA9PT0gMCkgeyAvLyBUaGUgaW5uZXJtb3N0L2Zhc3Rlc3QgZGltZW5zaW9uJ3MgZGVsdGEgaXMgc2ltcGx5IGl0cyBzdHJpZGVcbiAgICAgICAgdmFycy5wdXNoKFtcImRcIixqLFwic1wiLGksXCI9dFwiLGosXCJwXCIsaWR4XS5qb2luKFwiXCIpKVxuICAgICAgfSBlbHNlIHsgLy8gRm9yIG90aGVyIGRpbWVuc2lvbnMgdGhlIGRlbHRhIGlzIGJhc2ljYWxseSB0aGUgc3RyaWRlIG1pbnVzIHNvbWV0aGluZyB3aGljaCBlc3NlbnRpYWxseSBcInJld2luZHNcIiB0aGUgcHJldmlvdXMgKG1vcmUgaW5uZXIpIGRpbWVuc2lvblxuICAgICAgICB2YXJzLnB1c2goW1wiZFwiLGosXCJzXCIsaSxcIj0odFwiLGosXCJwXCIsaWR4LFwiLXNcIixwaWR4LFwiKnRcIixqLFwicFwiLHBpZHgsXCIpXCJdLmpvaW4oXCJcIikpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh2YXJzLmxlbmd0aCA+IDApIHtcbiAgICBjb2RlLnB1c2goXCJ2YXIgXCIgKyB2YXJzLmpvaW4oXCIsXCIpKVxuICB9ICBcbiAgLy9TY2FuIGxvb3BcbiAgZm9yKGk9ZGltZW5zaW9uLTE7IGk+PTA7IC0taSkgeyAvLyBTdGFydCBhdCBsYXJnZXN0IHN0cmlkZSBhbmQgd29yayB5b3VyIHdheSBpbndhcmRzXG4gICAgaWR4ID0gb3JkZXJbaV1cbiAgICBjb2RlLnB1c2goW1wiZm9yKGlcIixpLFwiPTA7aVwiLGksXCI8c1wiLGlkeCxcIjsrK2lcIixpLFwiKXtcIl0uam9pbihcIlwiKSlcbiAgfVxuICAvL1B1c2ggYm9keSBvZiBpbm5lciBsb29wXG4gIGNvZGUucHVzaChib2R5KVxuICAvL0FkdmFuY2Ugc2NhbiBwb2ludGVyc1xuICBmb3IoaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgcGlkeCA9IGlkeFxuICAgIGlkeCA9IG9yZGVyW2ldXG4gICAgZm9yKGo9MDsgajxuYXJnczsgKytqKSB7XG4gICAgICBjb2RlLnB1c2goW1wicFwiLGosXCIrPWRcIixqLFwic1wiLGldLmpvaW4oXCJcIikpXG4gICAgfVxuICAgIGlmKGhhc19pbmRleCkge1xuICAgICAgaWYoaSA+IDApIHtcbiAgICAgICAgY29kZS5wdXNoKFtcImluZGV4W1wiLHBpZHgsXCJdLT1zXCIscGlkeF0uam9pbihcIlwiKSlcbiAgICAgIH1cbiAgICAgIGNvZGUucHVzaChbXCIrK2luZGV4W1wiLGlkeCxcIl1cIl0uam9pbihcIlwiKSlcbiAgICB9XG4gICAgY29kZS5wdXNoKFwifVwiKVxuICB9XG4gIHJldHVybiBjb2RlLmpvaW4oXCJcXG5cIilcbn1cblxuLy8gR2VuZXJhdGUgXCJvdXRlclwiIGxvb3BzIHRoYXQgbG9vcCBvdmVyIGJsb2NrcyBvZiBkYXRhLCBhcHBseWluZyBcImlubmVyXCIgbG9vcHMgdG8gdGhlIGJsb2NrcyBieSBtYW5pcHVsYXRpbmcgdGhlIGxvY2FsIHZhcmlhYmxlcyBpbiBzdWNoIGEgd2F5IHRoYXQgdGhlIGlubmVyIGxvb3Agb25seSBcInNlZXNcIiB0aGUgY3VycmVudCBibG9jay5cbi8vIFRPRE86IElmIHRoaXMgaXMgdXNlZCwgdGhlbiB0aGUgcHJldmlvdXMgZGVjbGFyYXRpb24gKGRvbmUgYnkgZ2VuZXJhdGVDd2lzZU9wKSBvZiBzKiBpcyBlc3NlbnRpYWxseSB1bm5lY2Vzc2FyeS5cbi8vICAgICAgIEkgYmVsaWV2ZSB0aGUgcyogYXJlIG5vdCB1c2VkIGVsc2V3aGVyZSAoaW4gcGFydGljdWxhciwgSSBkb24ndCB0aGluayB0aGV5J3JlIHVzZWQgaW4gdGhlIHByZS9wb3N0IHBhcnRzIGFuZCBcInNoYXBlXCIgaXMgZGVmaW5lZCBpbmRlcGVuZGVudGx5KSwgc28gaXQgd291bGQgYmUgcG9zc2libGUgdG8gbWFrZSBkZWZpbmluZyB0aGUgcyogZGVwZW5kZW50IG9uIHdoYXQgbG9vcCBtZXRob2QgaXMgYmVpbmcgdXNlZC5cbmZ1bmN0aW9uIG91dGVyRmlsbChtYXRjaGVkLCBvcmRlciwgcHJvYywgYm9keSkge1xuICB2YXIgZGltZW5zaW9uID0gb3JkZXIubGVuZ3RoXG4gICAgLCBuYXJncyA9IHByb2MuYXJyYXlBcmdzLmxlbmd0aFxuICAgICwgYmxvY2tTaXplID0gcHJvYy5ibG9ja1NpemVcbiAgICAsIGhhc19pbmRleCA9IHByb2MuaW5kZXhBcmdzLmxlbmd0aCA+IDBcbiAgICAsIGNvZGUgPSBbXVxuICBmb3IodmFyIGk9MDsgaTxuYXJnczsgKytpKSB7XG4gICAgY29kZS5wdXNoKFtcInZhciBvZmZzZXRcIixpLFwiPXBcIixpXS5qb2luKFwiXCIpKVxuICB9XG4gIC8vR2VuZXJhdGUgbG9vcHMgZm9yIHVubWF0Y2hlZCBkaW1lbnNpb25zXG4gIC8vIFRoZSBvcmRlciBpbiB3aGljaCB0aGVzZSBkaW1lbnNpb25zIGFyZSB0cmF2ZXJzZWQgaXMgZmFpcmx5IGFyYml0cmFyeSAoZnJvbSBzbWFsbCBzdHJpZGUgdG8gbGFyZ2Ugc3RyaWRlLCBmb3IgdGhlIGZpcnN0IGFyZ3VtZW50KVxuICAvLyBUT0RPOiBJdCB3b3VsZCBiZSBuaWNlIGlmIHRoZSBvcmRlciBpbiB3aGljaCB0aGVzZSBsb29wcyBhcmUgcGxhY2VkIHdvdWxkIGFsc28gYmUgc29tZWhvdyBcIm9wdGltYWxcIiAoYXQgdGhlIHZlcnkgbGVhc3Qgd2Ugc2hvdWxkIGNoZWNrIHRoYXQgaXQgcmVhbGx5IGRvZXNuJ3QgaHVydCB1cyBpZiB0aGV5J3JlIG5vdCkuXG4gIGZvcih2YXIgaT1tYXRjaGVkOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgY29kZS5wdXNoKFtcImZvcih2YXIgalwiK2krXCI9U1NbXCIsIG9yZGVyW2ldLCBcIl18MDtqXCIsIGksIFwiPjA7KXtcIl0uam9pbihcIlwiKSkgLy8gSXRlcmF0ZSBiYWNrIHRvIGZyb250XG4gICAgY29kZS5wdXNoKFtcImlmKGpcIixpLFwiPFwiLGJsb2NrU2l6ZSxcIil7XCJdLmpvaW4oXCJcIikpIC8vIEVpdGhlciBkZWNyZWFzZSBqIGJ5IGJsb2NrU2l6ZSAocyA9IGJsb2NrU2l6ZSksIG9yIHNldCBpdCB0byB6ZXJvIChhZnRlciBzZXR0aW5nIHMgPSBqKS5cbiAgICBjb2RlLnB1c2goW1wic1wiLG9yZGVyW2ldLFwiPWpcIixpXS5qb2luKFwiXCIpKVxuICAgIGNvZGUucHVzaChbXCJqXCIsaSxcIj0wXCJdLmpvaW4oXCJcIikpXG4gICAgY29kZS5wdXNoKFtcIn1lbHNle3NcIixvcmRlcltpXSxcIj1cIixibG9ja1NpemVdLmpvaW4oXCJcIikpXG4gICAgY29kZS5wdXNoKFtcImpcIixpLFwiLT1cIixibG9ja1NpemUsXCJ9XCJdLmpvaW4oXCJcIikpXG4gICAgaWYoaGFzX2luZGV4KSB7XG4gICAgICBjb2RlLnB1c2goW1wiaW5kZXhbXCIsb3JkZXJbaV0sXCJdPWpcIixpXS5qb2luKFwiXCIpKVxuICAgIH1cbiAgfVxuICBmb3IodmFyIGk9MDsgaTxuYXJnczsgKytpKSB7XG4gICAgdmFyIGluZGV4U3RyID0gW1wib2Zmc2V0XCIraV1cbiAgICBmb3IodmFyIGo9bWF0Y2hlZDsgajxkaW1lbnNpb247ICsraikge1xuICAgICAgaW5kZXhTdHIucHVzaChbXCJqXCIsaixcIip0XCIsaSxcInBcIixvcmRlcltqXV0uam9pbihcIlwiKSlcbiAgICB9XG4gICAgY29kZS5wdXNoKFtcInBcIixpLFwiPShcIixpbmRleFN0ci5qb2luKFwiK1wiKSxcIilcIl0uam9pbihcIlwiKSlcbiAgfVxuICBjb2RlLnB1c2goaW5uZXJGaWxsKG9yZGVyLCBwcm9jLCBib2R5KSlcbiAgZm9yKHZhciBpPW1hdGNoZWQ7IGk8ZGltZW5zaW9uOyArK2kpIHtcbiAgICBjb2RlLnB1c2goXCJ9XCIpXG4gIH1cbiAgcmV0dXJuIGNvZGUuam9pbihcIlxcblwiKVxufVxuXG4vL0NvdW50IHRoZSBudW1iZXIgb2YgY29tcGF0aWJsZSBpbm5lciBvcmRlcnNcbi8vIFRoaXMgaXMgdGhlIGxlbmd0aCBvZiB0aGUgbG9uZ2VzdCBjb21tb24gcHJlZml4IG9mIHRoZSBhcnJheXMgaW4gb3JkZXJzLlxuLy8gRWFjaCBhcnJheSBpbiBvcmRlcnMgbGlzdHMgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIGNvcnJlc3BvbmQgbmRhcnJheSBpbiBvcmRlciBvZiBpbmNyZWFzaW5nIHN0cmlkZS5cbi8vIFRoaXMgaXMgdGh1cyB0aGUgbWF4aW11bSBudW1iZXIgb2YgZGltZW5zaW9ucyB0aGF0IGNhbiBiZSBlZmZpY2llbnRseSB0cmF2ZXJzZWQgYnkgc2ltcGxlIG5lc3RlZCBsb29wcyBmb3IgYWxsIGFycmF5cy5cbmZ1bmN0aW9uIGNvdW50TWF0Y2hlcyhvcmRlcnMpIHtcbiAgdmFyIG1hdGNoZWQgPSAwLCBkaW1lbnNpb24gPSBvcmRlcnNbMF0ubGVuZ3RoXG4gIHdoaWxlKG1hdGNoZWQgPCBkaW1lbnNpb24pIHtcbiAgICBmb3IodmFyIGo9MTsgajxvcmRlcnMubGVuZ3RoOyArK2opIHtcbiAgICAgIGlmKG9yZGVyc1tqXVttYXRjaGVkXSAhPT0gb3JkZXJzWzBdW21hdGNoZWRdKSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVkXG4gICAgICB9XG4gICAgfVxuICAgICsrbWF0Y2hlZFxuICB9XG4gIHJldHVybiBtYXRjaGVkXG59XG5cbi8vUHJvY2Vzc2VzIGEgYmxvY2sgYWNjb3JkaW5nIHRvIHRoZSBnaXZlbiBkYXRhIHR5cGVzXG4vLyBSZXBsYWNlcyB2YXJpYWJsZSBuYW1lcyBieSBkaWZmZXJlbnQgb25lcywgZWl0aGVyIFwibG9jYWxcIiBvbmVzICh0aGF0IGFyZSB0aGVuIGZlcnJpZWQgaW4gYW5kIG91dCBvZiB0aGUgZ2l2ZW4gYXJyYXkpIG9yIG9uZXMgbWF0Y2hpbmcgdGhlIGFyZ3VtZW50cyB0aGF0IHRoZSBmdW5jdGlvbiBwZXJmb3JtaW5nIHRoZSB1bHRpbWF0ZSBsb29wIHdpbGwgYWNjZXB0LlxuZnVuY3Rpb24gcHJvY2Vzc0Jsb2NrKGJsb2NrLCBwcm9jLCBkdHlwZXMpIHtcbiAgdmFyIGNvZGUgPSBibG9jay5ib2R5XG4gIHZhciBwcmUgPSBbXVxuICB2YXIgcG9zdCA9IFtdXG4gIGZvcih2YXIgaT0wOyBpPGJsb2NrLmFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgY2FyZyA9IGJsb2NrLmFyZ3NbaV1cbiAgICBpZihjYXJnLmNvdW50IDw9IDApIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIHZhciByZSA9IG5ldyBSZWdFeHAoY2FyZy5uYW1lLCBcImdcIilcbiAgICB2YXIgcHRyU3RyID0gXCJcIlxuICAgIHZhciBhcnJOdW0gPSBwcm9jLmFycmF5QXJncy5pbmRleE9mKGkpXG4gICAgc3dpdGNoKHByb2MuYXJnVHlwZXNbaV0pIHtcbiAgICAgIGNhc2UgXCJvZmZzZXRcIjpcbiAgICAgICAgdmFyIG9mZkFyZ0luZGV4ID0gcHJvYy5vZmZzZXRBcmdJbmRleC5pbmRleE9mKGkpXG4gICAgICAgIHZhciBvZmZBcmcgPSBwcm9jLm9mZnNldEFyZ3Nbb2ZmQXJnSW5kZXhdXG4gICAgICAgIGFyck51bSA9IG9mZkFyZy5hcnJheVxuICAgICAgICBwdHJTdHIgPSBcIitxXCIgKyBvZmZBcmdJbmRleCAvLyBBZGRzIG9mZnNldCB0byB0aGUgXCJwb2ludGVyXCIgaW4gdGhlIGFycmF5XG4gICAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgICAgcHRyU3RyID0gXCJwXCIgKyBhcnJOdW0gKyBwdHJTdHJcbiAgICAgICAgdmFyIGxvY2FsU3RyID0gXCJsXCIgKyBpXG4gICAgICAgIHZhciBhcnJTdHIgPSBcImFcIiArIGFyck51bVxuICAgICAgICBpZiAocHJvYy5hcnJheUJsb2NrSW5kaWNlc1thcnJOdW1dID09PSAwKSB7IC8vIEFyZ3VtZW50IHRvIGJvZHkgaXMganVzdCBhIHNpbmdsZSB2YWx1ZSBmcm9tIHRoaXMgYXJyYXlcbiAgICAgICAgICBpZihjYXJnLmNvdW50ID09PSAxKSB7IC8vIEFyZ3VtZW50L2FycmF5IHVzZWQgb25seSBvbmNlKD8pXG4gICAgICAgICAgICBpZihkdHlwZXNbYXJyTnVtXSA9PT0gXCJnZW5lcmljXCIpIHtcbiAgICAgICAgICAgICAgaWYoY2FyZy5sdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBwcmUucHVzaChbXCJ2YXIgXCIsIGxvY2FsU3RyLCBcIj1cIiwgYXJyU3RyLCBcIi5nZXQoXCIsIHB0clN0ciwgXCIpXCJdLmpvaW4oXCJcIikpIC8vIElzIHRoaXMgbmVjZXNzYXJ5IGlmIHRoZSBhcmd1bWVudCBpcyBPTkxZIHVzZWQgYXMgYW4gbHZhbHVlPyAoa2VlcCBpbiBtaW5kIHRoYXQgd2UgY2FuIGhhdmUgYSArPSBzb21ldGhpbmcsIHNvIHdlIHdvdWxkIGFjdHVhbGx5IG5lZWQgdG8gY2hlY2sgY2FyZy5ydmFsdWUpXG4gICAgICAgICAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgbG9jYWxTdHIpXG4gICAgICAgICAgICAgICAgcG9zdC5wdXNoKFthcnJTdHIsIFwiLnNldChcIiwgcHRyU3RyLCBcIixcIiwgbG9jYWxTdHIsXCIpXCJdLmpvaW4oXCJcIikpXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgW2FyclN0ciwgXCIuZ2V0KFwiLCBwdHJTdHIsIFwiKVwiXS5qb2luKFwiXCIpKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBbYXJyU3RyLCBcIltcIiwgcHRyU3RyLCBcIl1cIl0uam9pbihcIlwiKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYoZHR5cGVzW2Fyck51bV0gPT09IFwiZ2VuZXJpY1wiKSB7XG4gICAgICAgICAgICBwcmUucHVzaChbXCJ2YXIgXCIsIGxvY2FsU3RyLCBcIj1cIiwgYXJyU3RyLCBcIi5nZXQoXCIsIHB0clN0ciwgXCIpXCJdLmpvaW4oXCJcIikpIC8vIFRPRE86IENvdWxkIHdlIG9wdGltaXplIGJ5IGNoZWNraW5nIGZvciBjYXJnLnJ2YWx1ZT9cbiAgICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIGxvY2FsU3RyKVxuICAgICAgICAgICAgaWYoY2FyZy5sdmFsdWUpIHtcbiAgICAgICAgICAgICAgcG9zdC5wdXNoKFthcnJTdHIsIFwiLnNldChcIiwgcHRyU3RyLCBcIixcIiwgbG9jYWxTdHIsXCIpXCJdLmpvaW4oXCJcIikpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByZS5wdXNoKFtcInZhciBcIiwgbG9jYWxTdHIsIFwiPVwiLCBhcnJTdHIsIFwiW1wiLCBwdHJTdHIsIFwiXVwiXS5qb2luKFwiXCIpKSAvLyBUT0RPOiBDb3VsZCB3ZSBvcHRpbWl6ZSBieSBjaGVja2luZyBmb3IgY2FyZy5ydmFsdWU/XG4gICAgICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBsb2NhbFN0cilcbiAgICAgICAgICAgIGlmKGNhcmcubHZhbHVlKSB7XG4gICAgICAgICAgICAgIHBvc3QucHVzaChbYXJyU3RyLCBcIltcIiwgcHRyU3RyLCBcIl09XCIsIGxvY2FsU3RyXS5qb2luKFwiXCIpKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHsgLy8gQXJndW1lbnQgdG8gYm9keSBpcyBhIFwiYmxvY2tcIlxuICAgICAgICAgIHZhciByZVN0ckFyciA9IFtjYXJnLm5hbWVdLCBwdHJTdHJBcnIgPSBbcHRyU3RyXVxuICAgICAgICAgIGZvcih2YXIgaj0wOyBqPE1hdGguYWJzKHByb2MuYXJyYXlCbG9ja0luZGljZXNbYXJyTnVtXSk7IGorKykge1xuICAgICAgICAgICAgcmVTdHJBcnIucHVzaChcIlxcXFxzKlxcXFxbKFteXFxcXF1dKylcXFxcXVwiKVxuICAgICAgICAgICAgcHRyU3RyQXJyLnB1c2goXCIkXCIgKyAoaisxKSArIFwiKnRcIiArIGFyck51bSArIFwiYlwiICsgaikgLy8gTWF0Y2hlZCBpbmRleCB0aW1lcyBzdHJpZGVcbiAgICAgICAgICB9XG4gICAgICAgICAgcmUgPSBuZXcgUmVnRXhwKHJlU3RyQXJyLmpvaW4oXCJcIiksIFwiZ1wiKVxuICAgICAgICAgIHB0clN0ciA9IHB0clN0ckFyci5qb2luKFwiK1wiKVxuICAgICAgICAgIGlmKGR0eXBlc1thcnJOdW1dID09PSBcImdlbmVyaWNcIikge1xuICAgICAgICAgICAgLyppZihjYXJnLmx2YWx1ZSkge1xuICAgICAgICAgICAgICBwcmUucHVzaChbXCJ2YXIgXCIsIGxvY2FsU3RyLCBcIj1cIiwgYXJyU3RyLCBcIi5nZXQoXCIsIHB0clN0ciwgXCIpXCJdLmpvaW4oXCJcIikpIC8vIElzIHRoaXMgbmVjZXNzYXJ5IGlmIHRoZSBhcmd1bWVudCBpcyBPTkxZIHVzZWQgYXMgYW4gbHZhbHVlPyAoa2VlcCBpbiBtaW5kIHRoYXQgd2UgY2FuIGhhdmUgYSArPSBzb21ldGhpbmcsIHNvIHdlIHdvdWxkIGFjdHVhbGx5IG5lZWQgdG8gY2hlY2sgY2FyZy5ydmFsdWUpXG4gICAgICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIGxvY2FsU3RyKVxuICAgICAgICAgICAgICBwb3N0LnB1c2goW2FyclN0ciwgXCIuc2V0KFwiLCBwdHJTdHIsIFwiLFwiLCBsb2NhbFN0cixcIilcIl0uam9pbihcIlwiKSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIFthcnJTdHIsIFwiLmdldChcIiwgcHRyU3RyLCBcIilcIl0uam9pbihcIlwiKSlcbiAgICAgICAgICAgIH0qL1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY3dpc2U6IEdlbmVyaWMgYXJyYXlzIG5vdCBzdXBwb3J0ZWQgaW4gY29tYmluYXRpb24gd2l0aCBibG9ja3MhXCIpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoaXMgZG9lcyBub3QgcHJvZHVjZSBhbnkgbG9jYWwgdmFyaWFibGVzLCBldmVuIGlmIHZhcmlhYmxlcyBhcmUgdXNlZCBtdWx0aXBsZSB0aW1lcy4gSXQgd291bGQgYmUgcG9zc2libGUgdG8gZG8gc28sIGJ1dCBpdCB3b3VsZCBjb21wbGljYXRlIHRoaW5ncyBxdWl0ZSBhIGJpdC5cbiAgICAgICAgICAgIGNvZGUgPSBjb2RlLnJlcGxhY2UocmUsIFthcnJTdHIsIFwiW1wiLCBwdHJTdHIsIFwiXVwiXS5qb2luKFwiXCIpKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgYnJlYWtcbiAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgXCJZXCIgKyBwcm9jLnNjYWxhckFyZ3MuaW5kZXhPZihpKSlcbiAgICAgIGJyZWFrXG4gICAgICBjYXNlIFwiaW5kZXhcIjpcbiAgICAgICAgY29kZSA9IGNvZGUucmVwbGFjZShyZSwgXCJpbmRleFwiKVxuICAgICAgYnJlYWtcbiAgICAgIGNhc2UgXCJzaGFwZVwiOlxuICAgICAgICBjb2RlID0gY29kZS5yZXBsYWNlKHJlLCBcInNoYXBlXCIpXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuICByZXR1cm4gW3ByZS5qb2luKFwiXFxuXCIpLCBjb2RlLCBwb3N0LmpvaW4oXCJcXG5cIildLmpvaW4oXCJcXG5cIikudHJpbSgpXG59XG5cbmZ1bmN0aW9uIHR5cGVTdW1tYXJ5KGR0eXBlcykge1xuICB2YXIgc3VtbWFyeSA9IG5ldyBBcnJheShkdHlwZXMubGVuZ3RoKVxuICB2YXIgYWxsRXF1YWwgPSB0cnVlXG4gIGZvcih2YXIgaT0wOyBpPGR0eXBlcy5sZW5ndGg7ICsraSkge1xuICAgIHZhciB0ID0gZHR5cGVzW2ldXG4gICAgdmFyIGRpZ2l0cyA9IHQubWF0Y2goL1xcZCsvKVxuICAgIGlmKCFkaWdpdHMpIHtcbiAgICAgIGRpZ2l0cyA9IFwiXCJcbiAgICB9IGVsc2Uge1xuICAgICAgZGlnaXRzID0gZGlnaXRzWzBdXG4gICAgfVxuICAgIGlmKHQuY2hhckF0KDApID09PSAwKSB7XG4gICAgICBzdW1tYXJ5W2ldID0gXCJ1XCIgKyB0LmNoYXJBdCgxKSArIGRpZ2l0c1xuICAgIH0gZWxzZSB7XG4gICAgICBzdW1tYXJ5W2ldID0gdC5jaGFyQXQoMCkgKyBkaWdpdHNcbiAgICB9XG4gICAgaWYoaSA+IDApIHtcbiAgICAgIGFsbEVxdWFsID0gYWxsRXF1YWwgJiYgc3VtbWFyeVtpXSA9PT0gc3VtbWFyeVtpLTFdXG4gICAgfVxuICB9XG4gIGlmKGFsbEVxdWFsKSB7XG4gICAgcmV0dXJuIHN1bW1hcnlbMF1cbiAgfVxuICByZXR1cm4gc3VtbWFyeS5qb2luKFwiXCIpXG59XG5cbi8vR2VuZXJhdGVzIGEgY3dpc2Ugb3BlcmF0b3JcbmZ1bmN0aW9uIGdlbmVyYXRlQ1dpc2VPcChwcm9jLCB0eXBlc2lnKSB7XG5cbiAgLy9Db21wdXRlIGRpbWVuc2lvblxuICAvLyBBcnJheXMgZ2V0IHB1dCBmaXJzdCBpbiB0eXBlc2lnLCBhbmQgdGhlcmUgYXJlIHR3byBlbnRyaWVzIHBlciBhcnJheSAoZHR5cGUgYW5kIG9yZGVyKSwgc28gdGhpcyBnZXRzIHRoZSBudW1iZXIgb2YgZGltZW5zaW9ucyBpbiB0aGUgZmlyc3QgYXJyYXkgYXJnLlxuICB2YXIgZGltZW5zaW9uID0gKHR5cGVzaWdbMV0ubGVuZ3RoIC0gTWF0aC5hYnMocHJvYy5hcnJheUJsb2NrSW5kaWNlc1swXSkpfDBcbiAgdmFyIG9yZGVycyA9IG5ldyBBcnJheShwcm9jLmFycmF5QXJncy5sZW5ndGgpXG4gIHZhciBkdHlwZXMgPSBuZXcgQXJyYXkocHJvYy5hcnJheUFyZ3MubGVuZ3RoKVxuICBmb3IodmFyIGk9MDsgaTxwcm9jLmFycmF5QXJncy5sZW5ndGg7ICsraSkge1xuICAgIGR0eXBlc1tpXSA9IHR5cGVzaWdbMippXVxuICAgIG9yZGVyc1tpXSA9IHR5cGVzaWdbMippKzFdXG4gIH1cbiAgXG4gIC8vRGV0ZXJtaW5lIHdoZXJlIGJsb2NrIGFuZCBsb29wIGluZGljZXMgc3RhcnQgYW5kIGVuZFxuICB2YXIgYmxvY2tCZWdpbiA9IFtdLCBibG9ja0VuZCA9IFtdIC8vIFRoZXNlIGluZGljZXMgYXJlIGV4cG9zZWQgYXMgYmxvY2tzXG4gIHZhciBsb29wQmVnaW4gPSBbXSwgbG9vcEVuZCA9IFtdIC8vIFRoZXNlIGluZGljZXMgYXJlIGl0ZXJhdGVkIG92ZXJcbiAgdmFyIGxvb3BPcmRlcnMgPSBbXSAvLyBvcmRlcnMgcmVzdHJpY3RlZCB0byB0aGUgbG9vcCBpbmRpY2VzXG4gIGZvcih2YXIgaT0wOyBpPHByb2MuYXJyYXlBcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKHByb2MuYXJyYXlCbG9ja0luZGljZXNbaV08MCkge1xuICAgICAgbG9vcEJlZ2luLnB1c2goMClcbiAgICAgIGxvb3BFbmQucHVzaChkaW1lbnNpb24pXG4gICAgICBibG9ja0JlZ2luLnB1c2goZGltZW5zaW9uKVxuICAgICAgYmxvY2tFbmQucHVzaChkaW1lbnNpb24rcHJvYy5hcnJheUJsb2NrSW5kaWNlc1tpXSlcbiAgICB9IGVsc2Uge1xuICAgICAgbG9vcEJlZ2luLnB1c2gocHJvYy5hcnJheUJsb2NrSW5kaWNlc1tpXSkgLy8gTm9uLW5lZ2F0aXZlXG4gICAgICBsb29wRW5kLnB1c2gocHJvYy5hcnJheUJsb2NrSW5kaWNlc1tpXStkaW1lbnNpb24pXG4gICAgICBibG9ja0JlZ2luLnB1c2goMClcbiAgICAgIGJsb2NrRW5kLnB1c2gocHJvYy5hcnJheUJsb2NrSW5kaWNlc1tpXSlcbiAgICB9XG4gICAgdmFyIG5ld09yZGVyID0gW11cbiAgICBmb3IodmFyIGo9MDsgajxvcmRlcnNbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgIGlmIChsb29wQmVnaW5baV08PW9yZGVyc1tpXVtqXSAmJiBvcmRlcnNbaV1bal08bG9vcEVuZFtpXSkge1xuICAgICAgICBuZXdPcmRlci5wdXNoKG9yZGVyc1tpXVtqXS1sb29wQmVnaW5baV0pIC8vIElmIHRoaXMgaXMgYSBsb29wIGluZGV4LCBwdXQgaXQgaW4gbmV3T3JkZXIsIHN1YnRyYWN0aW5nIGxvb3BCZWdpbiwgdG8gbWFrZSBzdXJlIHRoYXQgYWxsIGxvb3BPcmRlcnMgYXJlIHVzaW5nIGEgY29tbW9uIHNldCBvZiBpbmRpY2VzLlxuICAgICAgfVxuICAgIH1cbiAgICBsb29wT3JkZXJzLnB1c2gobmV3T3JkZXIpXG4gIH1cblxuICAvL0ZpcnN0IGNyZWF0ZSBhcmd1bWVudHMgZm9yIHByb2NlZHVyZVxuICB2YXIgYXJnbGlzdCA9IFtcIlNTXCJdIC8vIFNTIGlzIHRoZSBvdmVyYWxsIHNoYXBlIG92ZXIgd2hpY2ggd2UgaXRlcmF0ZVxuICB2YXIgY29kZSA9IFtcIid1c2Ugc3RyaWN0J1wiXVxuICB2YXIgdmFycyA9IFtdXG4gIFxuICBmb3IodmFyIGo9MDsgajxkaW1lbnNpb247ICsraikge1xuICAgIHZhcnMucHVzaChbXCJzXCIsIGosIFwiPVNTW1wiLCBqLCBcIl1cIl0uam9pbihcIlwiKSkgLy8gVGhlIGxpbWl0cyBmb3IgZWFjaCBkaW1lbnNpb24uXG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8cHJvYy5hcnJheUFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICBhcmdsaXN0LnB1c2goXCJhXCIraSkgLy8gQWN0dWFsIGRhdGEgYXJyYXlcbiAgICBhcmdsaXN0LnB1c2goXCJ0XCIraSkgLy8gU3RyaWRlc1xuICAgIGFyZ2xpc3QucHVzaChcInBcIitpKSAvLyBPZmZzZXQgaW4gdGhlIGFycmF5IGF0IHdoaWNoIHRoZSBkYXRhIHN0YXJ0cyAoYWxzbyB1c2VkIGZvciBpdGVyYXRpbmcgb3ZlciB0aGUgZGF0YSlcbiAgICBcbiAgICBmb3IodmFyIGo9MDsgajxkaW1lbnNpb247ICsraikgeyAvLyBVbnBhY2sgdGhlIHN0cmlkZXMgaW50byB2YXJzIGZvciBsb29waW5nXG4gICAgICB2YXJzLnB1c2goW1widFwiLGksXCJwXCIsaixcIj10XCIsaSxcIltcIixsb29wQmVnaW5baV0raixcIl1cIl0uam9pbihcIlwiKSlcbiAgICB9XG4gICAgXG4gICAgZm9yKHZhciBqPTA7IGo8TWF0aC5hYnMocHJvYy5hcnJheUJsb2NrSW5kaWNlc1tpXSk7ICsraikgeyAvLyBVbnBhY2sgdGhlIHN0cmlkZXMgaW50byB2YXJzIGZvciBibG9jayBpdGVyYXRpb25cbiAgICAgIHZhcnMucHVzaChbXCJ0XCIsaSxcImJcIixqLFwiPXRcIixpLFwiW1wiLGJsb2NrQmVnaW5baV0raixcIl1cIl0uam9pbihcIlwiKSlcbiAgICB9XG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8cHJvYy5zY2FsYXJBcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgYXJnbGlzdC5wdXNoKFwiWVwiICsgaSlcbiAgfVxuICBpZihwcm9jLnNoYXBlQXJncy5sZW5ndGggPiAwKSB7XG4gICAgdmFycy5wdXNoKFwic2hhcGU9U1Muc2xpY2UoMClcIikgLy8gTWFrZXMgdGhlIHNoYXBlIG92ZXIgd2hpY2ggd2UgaXRlcmF0ZSBhdmFpbGFibGUgdG8gdGhlIHVzZXIgZGVmaW5lZCBmdW5jdGlvbnMgKHNvIHlvdSBjYW4gdXNlIHdpZHRoL2hlaWdodCBmb3IgZXhhbXBsZSlcbiAgfVxuICBpZihwcm9jLmluZGV4QXJncy5sZW5ndGggPiAwKSB7XG4gICAgLy8gUHJlcGFyZSBhbiBhcnJheSB0byBrZWVwIHRyYWNrIG9mIHRoZSAobG9naWNhbCkgaW5kaWNlcywgaW5pdGlhbGl6ZWQgdG8gZGltZW5zaW9uIHplcm9lcy5cbiAgICB2YXIgemVyb3MgPSBuZXcgQXJyYXkoZGltZW5zaW9uKVxuICAgIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgICB6ZXJvc1tpXSA9IFwiMFwiXG4gICAgfVxuICAgIHZhcnMucHVzaChbXCJpbmRleD1bXCIsIHplcm9zLmpvaW4oXCIsXCIpLCBcIl1cIl0uam9pbihcIlwiKSlcbiAgfVxuICBmb3IodmFyIGk9MDsgaTxwcm9jLm9mZnNldEFyZ3MubGVuZ3RoOyArK2kpIHsgLy8gT2Zmc2V0IGFyZ3VtZW50cyB1c2VkIGZvciBzdGVuY2lsIG9wZXJhdGlvbnNcbiAgICB2YXIgb2ZmX2FyZyA9IHByb2Mub2Zmc2V0QXJnc1tpXVxuICAgIHZhciBpbml0X3N0cmluZyA9IFtdXG4gICAgZm9yKHZhciBqPTA7IGo8b2ZmX2FyZy5vZmZzZXQubGVuZ3RoOyArK2opIHtcbiAgICAgIGlmKG9mZl9hcmcub2Zmc2V0W2pdID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9IGVsc2UgaWYob2ZmX2FyZy5vZmZzZXRbal0gPT09IDEpIHtcbiAgICAgICAgaW5pdF9zdHJpbmcucHVzaChbXCJ0XCIsIG9mZl9hcmcuYXJyYXksIFwicFwiLCBqXS5qb2luKFwiXCIpKSAgICAgIFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5pdF9zdHJpbmcucHVzaChbb2ZmX2FyZy5vZmZzZXRbal0sIFwiKnRcIiwgb2ZmX2FyZy5hcnJheSwgXCJwXCIsIGpdLmpvaW4oXCJcIikpXG4gICAgICB9XG4gICAgfVxuICAgIGlmKGluaXRfc3RyaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdmFycy5wdXNoKFwicVwiICsgaSArIFwiPTBcIilcbiAgICB9IGVsc2Uge1xuICAgICAgdmFycy5wdXNoKFtcInFcIiwgaSwgXCI9XCIsIGluaXRfc3RyaW5nLmpvaW4oXCIrXCIpXS5qb2luKFwiXCIpKVxuICAgIH1cbiAgfVxuXG4gIC8vUHJlcGFyZSB0aGlzIHZhcmlhYmxlc1xuICB2YXIgdGhpc1ZhcnMgPSB1bmlxKFtdLmNvbmNhdChwcm9jLnByZS50aGlzVmFycylcbiAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHByb2MuYm9keS50aGlzVmFycylcbiAgICAgICAgICAgICAgICAgICAgICAuY29uY2F0KHByb2MucG9zdC50aGlzVmFycykpXG4gIHZhcnMgPSB2YXJzLmNvbmNhdCh0aGlzVmFycylcbiAgaWYgKHZhcnMubGVuZ3RoID4gMCkge1xuICAgIGNvZGUucHVzaChcInZhciBcIiArIHZhcnMuam9pbihcIixcIikpXG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8cHJvYy5hcnJheUFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlLnB1c2goXCJwXCIraStcInw9MFwiKVxuICB9XG4gIFxuICAvL0lubGluZSBwcmVsdWRlXG4gIGlmKHByb2MucHJlLmJvZHkubGVuZ3RoID4gMykge1xuICAgIGNvZGUucHVzaChwcm9jZXNzQmxvY2socHJvYy5wcmUsIHByb2MsIGR0eXBlcykpXG4gIH1cblxuICAvL1Byb2Nlc3MgYm9keVxuICB2YXIgYm9keSA9IHByb2Nlc3NCbG9jayhwcm9jLmJvZHksIHByb2MsIGR0eXBlcylcbiAgdmFyIG1hdGNoZWQgPSBjb3VudE1hdGNoZXMobG9vcE9yZGVycylcbiAgaWYobWF0Y2hlZCA8IGRpbWVuc2lvbikge1xuICAgIGNvZGUucHVzaChvdXRlckZpbGwobWF0Y2hlZCwgbG9vcE9yZGVyc1swXSwgcHJvYywgYm9keSkpIC8vIFRPRE86IFJhdGhlciB0aGFuIHBhc3NpbmcgbG9vcE9yZGVyc1swXSwgaXQgbWlnaHQgYmUgaW50ZXJlc3RpbmcgdG8gbG9vayBhdCBwYXNzaW5nIGFuIG9yZGVyIHRoYXQgcmVwcmVzZW50cyB0aGUgbWFqb3JpdHkgb2YgdGhlIGFyZ3VtZW50cyBmb3IgZXhhbXBsZS5cbiAgfSBlbHNlIHtcbiAgICBjb2RlLnB1c2goaW5uZXJGaWxsKGxvb3BPcmRlcnNbMF0sIHByb2MsIGJvZHkpKVxuICB9XG5cbiAgLy9JbmxpbmUgZXBpbG9nXG4gIGlmKHByb2MucG9zdC5ib2R5Lmxlbmd0aCA+IDMpIHtcbiAgICBjb2RlLnB1c2gocHJvY2Vzc0Jsb2NrKHByb2MucG9zdCwgcHJvYywgZHR5cGVzKSlcbiAgfVxuICBcbiAgaWYocHJvYy5kZWJ1Zykge1xuICAgIGNvbnNvbGUubG9nKFwiLS0tLS1HZW5lcmF0ZWQgY3dpc2Ugcm91dGluZSBmb3IgXCIsIHR5cGVzaWcsIFwiOlxcblwiICsgY29kZS5qb2luKFwiXFxuXCIpICsgXCJcXG4tLS0tLS0tLS0tXCIpXG4gIH1cbiAgXG4gIHZhciBsb29wTmFtZSA9IFsocHJvYy5mdW5jTmFtZXx8XCJ1bm5hbWVkXCIpLCBcIl9jd2lzZV9sb29wX1wiLCBvcmRlcnNbMF0uam9pbihcInNcIiksXCJtXCIsbWF0Y2hlZCx0eXBlU3VtbWFyeShkdHlwZXMpXS5qb2luKFwiXCIpXG4gIHZhciBmID0gbmV3IEZ1bmN0aW9uKFtcImZ1bmN0aW9uIFwiLGxvb3BOYW1lLFwiKFwiLCBhcmdsaXN0LmpvaW4oXCIsXCIpLFwiKXtcIiwgY29kZS5qb2luKFwiXFxuXCIpLFwifSByZXR1cm4gXCIsIGxvb3BOYW1lXS5qb2luKFwiXCIpKVxuICByZXR1cm4gZigpXG59XG5tb2R1bGUuZXhwb3J0cyA9IGdlbmVyYXRlQ1dpc2VPcFxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxuLy8gVGhlIGZ1bmN0aW9uIGJlbG93IGlzIGNhbGxlZCB3aGVuIGNvbnN0cnVjdGluZyBhIGN3aXNlIGZ1bmN0aW9uIG9iamVjdCwgYW5kIGRvZXMgdGhlIGZvbGxvd2luZzpcbi8vIEEgZnVuY3Rpb24gb2JqZWN0IGlzIGNvbnN0cnVjdGVkIHdoaWNoIGFjY2VwdHMgYXMgYXJndW1lbnQgYSBjb21waWxhdGlvbiBmdW5jdGlvbiBhbmQgcmV0dXJucyBhbm90aGVyIGZ1bmN0aW9uLlxuLy8gSXQgaXMgdGhpcyBvdGhlciBmdW5jdGlvbiB0aGF0IGlzIGV2ZW50dWFsbHkgcmV0dXJuZWQgYnkgY3JlYXRlVGh1bmssIGFuZCB0aGlzIGZ1bmN0aW9uIGlzIHRoZSBvbmUgdGhhdCBhY3R1YWxseVxuLy8gY2hlY2tzIHdoZXRoZXIgYSBjZXJ0YWluIHBhdHRlcm4gb2YgYXJndW1lbnRzIGhhcyBhbHJlYWR5IGJlZW4gdXNlZCBiZWZvcmUgYW5kIGNvbXBpbGVzIG5ldyBsb29wcyBhcyBuZWVkZWQuXG4vLyBUaGUgY29tcGlsYXRpb24gcGFzc2VkIHRvIHRoZSBmaXJzdCBmdW5jdGlvbiBvYmplY3QgaXMgdXNlZCBmb3IgY29tcGlsaW5nIG5ldyBmdW5jdGlvbnMuXG4vLyBPbmNlIHRoaXMgZnVuY3Rpb24gb2JqZWN0IGlzIGNyZWF0ZWQsIGl0IGlzIGNhbGxlZCB3aXRoIGNvbXBpbGUgYXMgYXJndW1lbnQsIHdoZXJlIHRoZSBmaXJzdCBhcmd1bWVudCBvZiBjb21waWxlXG4vLyBpcyBib3VuZCB0byBcInByb2NcIiAoZXNzZW50aWFsbHkgY29udGFpbmluZyBhIHByZXByb2Nlc3NlZCB2ZXJzaW9uIG9mIHRoZSB1c2VyIGFyZ3VtZW50cyB0byBjd2lzZSkuXG4vLyBTbyBjcmVhdGVUaHVuayByb3VnaGx5IHdvcmtzIGxpa2UgdGhpczpcbi8vIGZ1bmN0aW9uIGNyZWF0ZVRodW5rKHByb2MpIHtcbi8vICAgdmFyIHRodW5rID0gZnVuY3Rpb24oY29tcGlsZUJvdW5kKSB7XG4vLyAgICAgdmFyIENBQ0hFRCA9IHt9XG4vLyAgICAgcmV0dXJuIGZ1bmN0aW9uKGFycmF5cyBhbmQgc2NhbGFycykge1xuLy8gICAgICAgaWYgKGR0eXBlIGFuZCBvcmRlciBvZiBhcnJheXMgaW4gQ0FDSEVEKSB7XG4vLyAgICAgICAgIHZhciBmdW5jID0gQ0FDSEVEW2R0eXBlIGFuZCBvcmRlciBvZiBhcnJheXNdXG4vLyAgICAgICB9IGVsc2Uge1xuLy8gICAgICAgICB2YXIgZnVuYyA9IENBQ0hFRFtkdHlwZSBhbmQgb3JkZXIgb2YgYXJyYXlzXSA9IGNvbXBpbGVCb3VuZChkdHlwZSBhbmQgb3JkZXIgb2YgYXJyYXlzKVxuLy8gICAgICAgfVxuLy8gICAgICAgcmV0dXJuIGZ1bmMoYXJyYXlzIGFuZCBzY2FsYXJzKVxuLy8gICAgIH1cbi8vICAgfVxuLy8gICByZXR1cm4gdGh1bmsoY29tcGlsZS5iaW5kMShwcm9jKSlcbi8vIH1cblxudmFyIGNvbXBpbGUgPSByZXF1aXJlKFwiLi9jb21waWxlLmpzXCIpXG5cbmZ1bmN0aW9uIGNyZWF0ZVRodW5rKHByb2MpIHtcbiAgdmFyIGNvZGUgPSBbXCIndXNlIHN0cmljdCdcIiwgXCJ2YXIgQ0FDSEVEPXt9XCJdXG4gIHZhciB2YXJzID0gW11cbiAgdmFyIHRodW5rTmFtZSA9IHByb2MuZnVuY05hbWUgKyBcIl9jd2lzZV90aHVua1wiXG4gIFxuICAvL0J1aWxkIHRodW5rXG4gIGNvZGUucHVzaChbXCJyZXR1cm4gZnVuY3Rpb24gXCIsIHRodW5rTmFtZSwgXCIoXCIsIHByb2Muc2hpbUFyZ3Muam9pbihcIixcIiksIFwiKXtcIl0uam9pbihcIlwiKSlcbiAgdmFyIHR5cGVzaWcgPSBbXVxuICB2YXIgc3RyaW5nX3R5cGVzaWcgPSBbXVxuICB2YXIgcHJvY19hcmdzID0gW1tcImFycmF5XCIscHJvYy5hcnJheUFyZ3NbMF0sXCIuc2hhcGUuc2xpY2UoXCIsIC8vIFNsaWNlIHNoYXBlIHNvIHRoYXQgd2Ugb25seSByZXRhaW4gdGhlIHNoYXBlIG92ZXIgd2hpY2ggd2UgaXRlcmF0ZSAod2hpY2ggZ2V0cyBwYXNzZWQgdG8gdGhlIGN3aXNlIG9wZXJhdG9yIGFzIFNTKS5cbiAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoMCxwcm9jLmFycmF5QmxvY2tJbmRpY2VzWzBdKSxwcm9jLmFycmF5QmxvY2tJbmRpY2VzWzBdPDA/KFwiLFwiK3Byb2MuYXJyYXlCbG9ja0luZGljZXNbMF0rXCIpXCIpOlwiKVwiXS5qb2luKFwiXCIpXVxuICB2YXIgc2hhcGVMZW5ndGhDb25kaXRpb25zID0gW10sIHNoYXBlQ29uZGl0aW9ucyA9IFtdXG4gIC8vIFByb2Nlc3MgYXJyYXkgYXJndW1lbnRzXG4gIGZvcih2YXIgaT0wOyBpPHByb2MuYXJyYXlBcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGogPSBwcm9jLmFycmF5QXJnc1tpXVxuICAgIHZhcnMucHVzaChbXCJ0XCIsIGosIFwiPWFycmF5XCIsIGosIFwiLmR0eXBlLFwiLFxuICAgICAgICAgICAgICAgXCJyXCIsIGosIFwiPWFycmF5XCIsIGosIFwiLm9yZGVyXCJdLmpvaW4oXCJcIikpXG4gICAgdHlwZXNpZy5wdXNoKFwidFwiICsgailcbiAgICB0eXBlc2lnLnB1c2goXCJyXCIgKyBqKVxuICAgIHN0cmluZ190eXBlc2lnLnB1c2goXCJ0XCIrailcbiAgICBzdHJpbmdfdHlwZXNpZy5wdXNoKFwiclwiK2orXCIuam9pbigpXCIpXG4gICAgcHJvY19hcmdzLnB1c2goXCJhcnJheVwiICsgaiArIFwiLmRhdGFcIilcbiAgICBwcm9jX2FyZ3MucHVzaChcImFycmF5XCIgKyBqICsgXCIuc3RyaWRlXCIpXG4gICAgcHJvY19hcmdzLnB1c2goXCJhcnJheVwiICsgaiArIFwiLm9mZnNldHwwXCIpXG4gICAgaWYgKGk+MCkgeyAvLyBHYXRoZXIgY29uZGl0aW9ucyB0byBjaGVjayBmb3Igc2hhcGUgZXF1YWxpdHkgKGlnbm9yaW5nIGJsb2NrIGluZGljZXMpXG4gICAgICBzaGFwZUxlbmd0aENvbmRpdGlvbnMucHVzaChcImFycmF5XCIgKyBwcm9jLmFycmF5QXJnc1swXSArIFwiLnNoYXBlLmxlbmd0aD09PWFycmF5XCIgKyBqICsgXCIuc2hhcGUubGVuZ3RoK1wiICsgKE1hdGguYWJzKHByb2MuYXJyYXlCbG9ja0luZGljZXNbMF0pLU1hdGguYWJzKHByb2MuYXJyYXlCbG9ja0luZGljZXNbaV0pKSlcbiAgICAgIHNoYXBlQ29uZGl0aW9ucy5wdXNoKFwiYXJyYXlcIiArIHByb2MuYXJyYXlBcmdzWzBdICsgXCIuc2hhcGVbc2hhcGVJbmRleCtcIiArIE1hdGgubWF4KDAscHJvYy5hcnJheUJsb2NrSW5kaWNlc1swXSkgKyBcIl09PT1hcnJheVwiICsgaiArIFwiLnNoYXBlW3NoYXBlSW5kZXgrXCIgKyBNYXRoLm1heCgwLHByb2MuYXJyYXlCbG9ja0luZGljZXNbaV0pICsgXCJdXCIpXG4gICAgfVxuICB9XG4gIC8vIENoZWNrIGZvciBzaGFwZSBlcXVhbGl0eVxuICBpZiAocHJvYy5hcnJheUFyZ3MubGVuZ3RoID4gMSkge1xuICAgIGNvZGUucHVzaChcImlmICghKFwiICsgc2hhcGVMZW5ndGhDb25kaXRpb25zLmpvaW4oXCIgJiYgXCIpICsgXCIpKSB0aHJvdyBuZXcgRXJyb3IoJ2N3aXNlOiBBcnJheXMgZG8gbm90IGFsbCBoYXZlIHRoZSBzYW1lIGRpbWVuc2lvbmFsaXR5IScpXCIpXG4gICAgY29kZS5wdXNoKFwiZm9yKHZhciBzaGFwZUluZGV4PWFycmF5XCIgKyBwcm9jLmFycmF5QXJnc1swXSArIFwiLnNoYXBlLmxlbmd0aC1cIiArIE1hdGguYWJzKHByb2MuYXJyYXlCbG9ja0luZGljZXNbMF0pICsgXCI7IHNoYXBlSW5kZXgtLT4wOykge1wiKVxuICAgIGNvZGUucHVzaChcImlmICghKFwiICsgc2hhcGVDb25kaXRpb25zLmpvaW4oXCIgJiYgXCIpICsgXCIpKSB0aHJvdyBuZXcgRXJyb3IoJ2N3aXNlOiBBcnJheXMgZG8gbm90IGFsbCBoYXZlIHRoZSBzYW1lIHNoYXBlIScpXCIpXG4gICAgY29kZS5wdXNoKFwifVwiKVxuICB9XG4gIC8vIFByb2Nlc3Mgc2NhbGFyIGFyZ3VtZW50c1xuICBmb3IodmFyIGk9MDsgaTxwcm9jLnNjYWxhckFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICBwcm9jX2FyZ3MucHVzaChcInNjYWxhclwiICsgcHJvYy5zY2FsYXJBcmdzW2ldKVxuICB9XG4gIC8vIENoZWNrIGZvciBjYWNoZWQgZnVuY3Rpb24gKGFuZCBpZiBub3QgcHJlc2VudCwgZ2VuZXJhdGUgaXQpXG4gIHZhcnMucHVzaChbXCJ0eXBlPVtcIiwgc3RyaW5nX3R5cGVzaWcuam9pbihcIixcIiksIFwiXS5qb2luKClcIl0uam9pbihcIlwiKSlcbiAgdmFycy5wdXNoKFwicHJvYz1DQUNIRURbdHlwZV1cIilcbiAgY29kZS5wdXNoKFwidmFyIFwiICsgdmFycy5qb2luKFwiLFwiKSlcbiAgXG4gIGNvZGUucHVzaChbXCJpZighcHJvYyl7XCIsXG4gICAgICAgICAgICAgXCJDQUNIRURbdHlwZV09cHJvYz1jb21waWxlKFtcIiwgdHlwZXNpZy5qb2luKFwiLFwiKSwgXCJdKX1cIixcbiAgICAgICAgICAgICBcInJldHVybiBwcm9jKFwiLCBwcm9jX2FyZ3Muam9pbihcIixcIiksIFwiKX1cIl0uam9pbihcIlwiKSlcblxuICBpZihwcm9jLmRlYnVnKSB7XG4gICAgY29uc29sZS5sb2coXCItLS0tLUdlbmVyYXRlZCB0aHVuazpcXG5cIiArIGNvZGUuam9pbihcIlxcblwiKSArIFwiXFxuLS0tLS0tLS0tLVwiKVxuICB9XG4gIFxuICAvL0NvbXBpbGUgdGh1bmtcbiAgdmFyIHRodW5rID0gbmV3IEZ1bmN0aW9uKFwiY29tcGlsZVwiLCBjb2RlLmpvaW4oXCJcXG5cIikpXG4gIHJldHVybiB0aHVuayhjb21waWxlLmJpbmQodW5kZWZpbmVkLCBwcm9jKSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVUaHVua1xuIiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZGF0YVVyaVRvQnVmZmVyO1xuXG4vKipcbiAqIFJldHVybnMgYSBgQnVmZmVyYCBpbnN0YW5jZSBmcm9tIHRoZSBnaXZlbiBkYXRhIFVSSSBgdXJpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJpIERhdGEgVVJJIHRvIHR1cm4gaW50byBhIEJ1ZmZlciBpbnN0YW5jZVxuICogQHJldHVybiB7QnVmZmVyfSBCdWZmZXIgaW5zdGFuY2UgZnJvbSBEYXRhIFVSSVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkYXRhVXJpVG9CdWZmZXIgKHVyaSkge1xuICBpZiAoIS9eZGF0YVxcOi9pLnRlc3QodXJpKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2B1cmlgIGRvZXMgbm90IGFwcGVhciB0byBiZSBhIERhdGEgVVJJIChtdXN0IGJlZ2luIHdpdGggXCJkYXRhOlwiKScpO1xuICB9XG5cbiAgLy8gc3RyaXAgbmV3bGluZXNcbiAgdXJpID0gdXJpLnJlcGxhY2UoL1xccj9cXG4vZywgJycpO1xuXG4gIC8vIHNwbGl0IHRoZSBVUkkgdXAgaW50byB0aGUgXCJtZXRhZGF0YVwiIGFuZCB0aGUgXCJkYXRhXCIgcG9ydGlvbnNcbiAgdmFyIGZpcnN0Q29tbWEgPSB1cmkuaW5kZXhPZignLCcpO1xuICBpZiAoLTEgPT09IGZpcnN0Q29tbWEgfHwgZmlyc3RDb21tYSA8PSA0KSB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYWxmb3JtZWQgZGF0YTogVVJJJyk7XG5cbiAgLy8gcmVtb3ZlIHRoZSBcImRhdGE6XCIgc2NoZW1lIGFuZCBwYXJzZSB0aGUgbWV0YWRhdGFcbiAgdmFyIG1ldGEgPSB1cmkuc3Vic3RyaW5nKDUsIGZpcnN0Q29tbWEpLnNwbGl0KCc7Jyk7XG5cbiAgdmFyIGJhc2U2NCA9IGZhbHNlO1xuICB2YXIgY2hhcnNldCA9ICdVUy1BU0NJSSc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWV0YS5sZW5ndGg7IGkrKykge1xuICAgIGlmICgnYmFzZTY0JyA9PSBtZXRhW2ldKSB7XG4gICAgICBiYXNlNjQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoMCA9PSBtZXRhW2ldLmluZGV4T2YoJ2NoYXJzZXQ9JykpIHtcbiAgICAgIGNoYXJzZXQgPSBtZXRhW2ldLnN1YnN0cmluZyg4KTtcbiAgICB9XG4gIH1cblxuICAvLyBnZXQgdGhlIGVuY29kZWQgZGF0YSBwb3J0aW9uIGFuZCBkZWNvZGUgVVJJLWVuY29kZWQgY2hhcnNcbiAgdmFyIGRhdGEgPSB1bmVzY2FwZSh1cmkuc3Vic3RyaW5nKGZpcnN0Q29tbWEgKyAxKSk7XG5cbiAgdmFyIGVuY29kaW5nID0gYmFzZTY0ID8gJ2Jhc2U2NCcgOiAnYXNjaWknO1xuICB2YXIgYnVmZmVyID0gbmV3IEJ1ZmZlcihkYXRhLCBlbmNvZGluZyk7XG5cbiAgLy8gc2V0IGAudHlwZWAgcHJvcGVydHkgdG8gTUlNRSB0eXBlXG4gIGJ1ZmZlci50eXBlID0gbWV0YVswXSB8fCAndGV4dC9wbGFpbic7XG5cbiAgLy8gc2V0IHRoZSBgLmNoYXJzZXRgIHByb3BlcnR5XG4gIGJ1ZmZlci5jaGFyc2V0ID0gY2hhcnNldDtcblxuICByZXR1cm4gYnVmZmVyO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCJcblxuZnVuY3Rpb24gZHVwZV9hcnJheShjb3VudCwgdmFsdWUsIGkpIHtcbiAgdmFyIGMgPSBjb3VudFtpXXwwXG4gIGlmKGMgPD0gMCkge1xuICAgIHJldHVybiBbXVxuICB9XG4gIHZhciByZXN1bHQgPSBuZXcgQXJyYXkoYyksIGpcbiAgaWYoaSA9PT0gY291bnQubGVuZ3RoLTEpIHtcbiAgICBmb3Ioaj0wOyBqPGM7ICsraikge1xuICAgICAgcmVzdWx0W2pdID0gdmFsdWVcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yKGo9MDsgajxjOyArK2opIHtcbiAgICAgIHJlc3VsdFtqXSA9IGR1cGVfYXJyYXkoY291bnQsIHZhbHVlLCBpKzEpXG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gZHVwZV9udW1iZXIoY291bnQsIHZhbHVlKSB7XG4gIHZhciByZXN1bHQsIGlcbiAgcmVzdWx0ID0gbmV3IEFycmF5KGNvdW50KVxuICBmb3IoaT0wOyBpPGNvdW50OyArK2kpIHtcbiAgICByZXN1bHRbaV0gPSB2YWx1ZVxuICB9XG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gZHVwZShjb3VudCwgdmFsdWUpIHtcbiAgaWYodHlwZW9mIHZhbHVlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdmFsdWUgPSAwXG4gIH1cbiAgc3dpdGNoKHR5cGVvZiBjb3VudCkge1xuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgIGlmKGNvdW50ID4gMCkge1xuICAgICAgICByZXR1cm4gZHVwZV9udW1iZXIoY291bnR8MCwgdmFsdWUpXG4gICAgICB9XG4gICAgYnJlYWtcbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICBpZih0eXBlb2YgKGNvdW50Lmxlbmd0aCkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIGR1cGVfYXJyYXkoY291bnQsIHZhbHVlLCAwKVxuICAgICAgfVxuICAgIGJyZWFrXG4gIH1cbiAgcmV0dXJuIFtdXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZHVwZSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuICgnICsgZXIgKyAnKScpO1xuICAgICAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAodGhpcy5fZXZlbnRzKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgICBpZiAoaXNGdW5jdGlvbihldmxpc3RlbmVyKSlcbiAgICAgIHJldHVybiAxO1xuICAgIGVsc2UgaWYgKGV2bGlzdGVuZXIpXG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIDA7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbiIsIid1c2Ugc3RyaWN0J1xuXG52YXIgcGF0aCAgICAgICAgICA9IHJlcXVpcmUoJ3BhdGgnKVxudmFyIG5kYXJyYXkgICAgICAgPSByZXF1aXJlKCduZGFycmF5JylcbnZhciBHaWZSZWFkZXIgICAgID0gcmVxdWlyZSgnb21nZ2lmJykuR2lmUmVhZGVyXG52YXIgcGFjayAgICAgICAgICA9IHJlcXVpcmUoJ25kYXJyYXktcGFjaycpXG52YXIgdGhyb3VnaCAgICAgICA9IHJlcXVpcmUoJ3Rocm91Z2gnKVxudmFyIHBhcnNlRGF0YVVSSSAgPSByZXF1aXJlKCdkYXRhLXVyaS10by1idWZmZXInKVxuXG5mdW5jdGlvbiBkZWZhdWx0SW1hZ2UodXJsLCBjYikge1xuICB2YXIgaW1nID0gbmV3IEltYWdlKClcbiAgaW1nLmNyb3NzT3JpZ2luID0gXCJBbm9ueW1vdXNcIlxuICBpbWcub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpXG4gICAgY2FudmFzLndpZHRoID0gaW1nLndpZHRoXG4gICAgY2FudmFzLmhlaWdodCA9IGltZy5oZWlnaHRcbiAgICB2YXIgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpXG4gICAgY29udGV4dC5kcmF3SW1hZ2UoaW1nLCAwLCAwKVxuICAgIHZhciBwaXhlbHMgPSBjb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLCBpbWcud2lkdGgsIGltZy5oZWlnaHQpXG4gICAgY2IobnVsbCwgbmRhcnJheShuZXcgVWludDhBcnJheShwaXhlbHMuZGF0YSksIFtpbWcud2lkdGgsIGltZy5oZWlnaHQsIDRdLCBbNCwgNCppbWcud2lkdGgsIDFdLCAwKSlcbiAgfVxuICBpbWcub25lcnJvciA9IGZ1bmN0aW9uKGVycikge1xuICAgIGNiKGVycilcbiAgfVxuICBpbWcuc3JjID0gdXJsXG59XG5cbi8vQW5pbWF0ZWQgZ2lmIGxvYWRpbmdcbmZ1bmN0aW9uIGhhbmRsZUdpZihkYXRhLCBjYikge1xuICB2YXIgcmVhZGVyXG4gIHRyeSB7XG4gICAgcmVhZGVyID0gbmV3IEdpZlJlYWRlcihkYXRhKVxuICB9IGNhdGNoKGVycikge1xuICAgIGNiKGVycilcbiAgICByZXR1cm5cbiAgfVxuICBpZihyZWFkZXIubnVtRnJhbWVzKCkgPiAwKSB7XG4gICAgdmFyIG5zaGFwZSA9IFtyZWFkZXIubnVtRnJhbWVzKCksIHJlYWRlci5oZWlnaHQsIHJlYWRlci53aWR0aCwgNF1cbiAgICB2YXIgbmRhdGEgPSBuZXcgVWludDhBcnJheShuc2hhcGVbMF0gKiBuc2hhcGVbMV0gKiBuc2hhcGVbMl0gKiBuc2hhcGVbM10pXG4gICAgdmFyIHJlc3VsdCA9IG5kYXJyYXkobmRhdGEsIG5zaGFwZSlcbiAgICB0cnkge1xuICAgICAgZm9yKHZhciBpPTA7IGk8cmVhZGVyLm51bUZyYW1lcygpOyArK2kpIHtcbiAgICAgICAgcmVhZGVyLmRlY29kZUFuZEJsaXRGcmFtZVJHQkEoaSwgbmRhdGEuc3ViYXJyYXkoXG4gICAgICAgICAgcmVzdWx0LmluZGV4KGksIDAsIDAsIDApLFxuICAgICAgICAgIHJlc3VsdC5pbmRleChpKzEsIDAsIDAsIDApKSlcbiAgICAgIH1cbiAgICB9IGNhdGNoKGVycikge1xuICAgICAgY2IoZXJyKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNiKG51bGwsIHJlc3VsdC50cmFuc3Bvc2UoMCwyLDEpKVxuICB9IGVsc2Uge1xuICAgIHZhciBuc2hhcGUgPSBbcmVhZGVyLmhlaWdodCwgcmVhZGVyLndpZHRoLCA0XVxuICAgIHZhciBuZGF0YSA9IG5ldyBVaW50OEFycmF5KG5zaGFwZVswXSAqIG5zaGFwZVsxXSAqIG5zaGFwZVsyXSlcbiAgICB2YXIgcmVzdWx0ID0gbmRhcnJheShuZGF0YSwgbnNoYXBlKVxuICAgIHRyeSB7XG4gICAgICByZWFkZXIuZGVjb2RlQW5kQmxpdEZyYW1lUkdCQSgwLCBuZGF0YSlcbiAgICB9IGNhdGNoKGVycikge1xuICAgICAgY2IoZXJyKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNiKG51bGwsIHJlc3VsdC50cmFuc3Bvc2UoMSwwKSlcbiAgfVxufVxuXG5mdW5jdGlvbiBodHRwR2lmKHVybCwgY2IpIHtcbiAgdmFyIHhociAgICAgICAgICA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpXG4gIHhoci5vcGVuKCdHRVQnLCB1cmwsIHRydWUpXG4gIHhoci5yZXNwb25zZVR5cGUgPSAnYXJyYXlidWZmZXInXG4gIGlmKHhoci5vdmVycmlkZU1pbWVUeXBlKXtcbiAgICB4aHIub3ZlcnJpZGVNaW1lVHlwZSgnYXBwbGljYXRpb24vYmluYXJ5JylcbiAgfVxuICB4aHIub25lcnJvciA9IGZ1bmN0aW9uKGVycikge1xuICAgIGNiKGVycilcbiAgfVxuICB4aHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgaWYoeGhyLnJlYWR5U3RhdGUgIT09IDQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgZGF0YSA9IG5ldyBVaW50OEFycmF5KHhoci5yZXNwb25zZSlcbiAgICBoYW5kbGVHaWYoZGF0YSwgY2IpXG4gICAgcmV0dXJuXG4gIH1cbiAgeGhyLnNlbmQoKVxufVxuXG5mdW5jdGlvbiBjb3B5QnVmZmVyKGJ1ZmZlcikge1xuICBpZihidWZmZXJbMF0gPT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBuID0gYnVmZmVyLmxlbmd0aFxuICAgIHZhciByZXN1bHQgPSBuZXcgVWludDhBcnJheShuKVxuICAgIGZvcih2YXIgaT0wOyBpPG47ICsraSkge1xuICAgICAgcmVzdWx0W2ldID0gYnVmZmVyLmdldChpKVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlcilcbiAgfVxufVxuXG5mdW5jdGlvbiBkYXRhR2lmKHVybCwgY2IpIHtcbiAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIGJ1ZmZlciA9IHBhcnNlRGF0YVVSSSh1cmwpXG4gICAgICBpZihidWZmZXIpIHtcbiAgICAgICAgaGFuZGxlR2lmKGNvcHlCdWZmZXIoYnVmZmVyKSwgY2IpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYihuZXcgRXJyb3IoJ0Vycm9yIHBhcnNpbmcgZGF0YSBVUkknKSlcbiAgICAgIH1cbiAgICB9IGNhdGNoKGVycikge1xuICAgICAgY2IoZXJyKVxuICAgIH1cbiAgfSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRQaXhlbHModXJsLCB0eXBlLCBjYikge1xuICBpZighY2IpIHtcbiAgICBjYiA9IHR5cGVcbiAgICB0eXBlID0gJydcbiAgfVxuICB2YXIgZXh0ID0gcGF0aC5leHRuYW1lKHVybClcbiAgc3dpdGNoKHR5cGUgfHwgZXh0LnRvVXBwZXJDYXNlKCkpIHtcbiAgICBjYXNlICcuR0lGJzpcbiAgICAgIGh0dHBHaWYodXJsLCBjYilcbiAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICBpZihCdWZmZXIuaXNCdWZmZXIodXJsKSkge1xuICAgICAgICB1cmwgPSAnZGF0YTonICsgdHlwZSArICc7YmFzZTY0LCcgKyB1cmwudG9TdHJpbmcoJ2Jhc2U2NCcpXG4gICAgICB9XG4gICAgICBpZih1cmwuaW5kZXhPZignZGF0YTppbWFnZS9naWY7JykgPT09IDApIHtcbiAgICAgICAgZGF0YUdpZih1cmwsIGNiKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVmYXVsdEltYWdlKHVybCwgY2IpXG4gICAgICB9XG4gIH1cbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGFkam9pbnQ7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgYWRqdWdhdGUgb2YgYSBtYXQ0XG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiBhZGpvaW50KG91dCwgYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgICAgICBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxuICAgICAgICBhMjAgPSBhWzhdLCBhMjEgPSBhWzldLCBhMjIgPSBhWzEwXSwgYTIzID0gYVsxMV0sXG4gICAgICAgIGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF0sIGEzMyA9IGFbMTVdO1xuXG4gICAgb3V0WzBdICA9ICAoYTExICogKGEyMiAqIGEzMyAtIGEyMyAqIGEzMikgLSBhMjEgKiAoYTEyICogYTMzIC0gYTEzICogYTMyKSArIGEzMSAqIChhMTIgKiBhMjMgLSBhMTMgKiBhMjIpKTtcbiAgICBvdXRbMV0gID0gLShhMDEgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMSAqIChhMDIgKiBhMzMgLSBhMDMgKiBhMzIpICsgYTMxICogKGEwMiAqIGEyMyAtIGEwMyAqIGEyMikpO1xuICAgIG91dFsyXSAgPSAgKGEwMSAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpIC0gYTExICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzEgKiAoYTAyICogYTEzIC0gYTAzICogYTEyKSk7XG4gICAgb3V0WzNdICA9IC0oYTAxICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikgLSBhMTEgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSArIGEyMSAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgICBvdXRbNF0gID0gLShhMTAgKiAoYTIyICogYTMzIC0gYTIzICogYTMyKSAtIGEyMCAqIChhMTIgKiBhMzMgLSBhMTMgKiBhMzIpICsgYTMwICogKGExMiAqIGEyMyAtIGExMyAqIGEyMikpO1xuICAgIG91dFs1XSAgPSAgKGEwMCAqIChhMjIgKiBhMzMgLSBhMjMgKiBhMzIpIC0gYTIwICogKGEwMiAqIGEzMyAtIGEwMyAqIGEzMikgKyBhMzAgKiAoYTAyICogYTIzIC0gYTAzICogYTIyKSk7XG4gICAgb3V0WzZdICA9IC0oYTAwICogKGExMiAqIGEzMyAtIGExMyAqIGEzMikgLSBhMTAgKiAoYTAyICogYTMzIC0gYTAzICogYTMyKSArIGEzMCAqIChhMDIgKiBhMTMgLSBhMDMgKiBhMTIpKTtcbiAgICBvdXRbN10gID0gIChhMDAgKiAoYTEyICogYTIzIC0gYTEzICogYTIyKSAtIGExMCAqIChhMDIgKiBhMjMgLSBhMDMgKiBhMjIpICsgYTIwICogKGEwMiAqIGExMyAtIGEwMyAqIGExMikpO1xuICAgIG91dFs4XSAgPSAgKGExMCAqIChhMjEgKiBhMzMgLSBhMjMgKiBhMzEpIC0gYTIwICogKGExMSAqIGEzMyAtIGExMyAqIGEzMSkgKyBhMzAgKiAoYTExICogYTIzIC0gYTEzICogYTIxKSk7XG4gICAgb3V0WzldICA9IC0oYTAwICogKGEyMSAqIGEzMyAtIGEyMyAqIGEzMSkgLSBhMjAgKiAoYTAxICogYTMzIC0gYTAzICogYTMxKSArIGEzMCAqIChhMDEgKiBhMjMgLSBhMDMgKiBhMjEpKTtcbiAgICBvdXRbMTBdID0gIChhMDAgKiAoYTExICogYTMzIC0gYTEzICogYTMxKSAtIGExMCAqIChhMDEgKiBhMzMgLSBhMDMgKiBhMzEpICsgYTMwICogKGEwMSAqIGExMyAtIGEwMyAqIGExMSkpO1xuICAgIG91dFsxMV0gPSAtKGEwMCAqIChhMTEgKiBhMjMgLSBhMTMgKiBhMjEpIC0gYTEwICogKGEwMSAqIGEyMyAtIGEwMyAqIGEyMSkgKyBhMjAgKiAoYTAxICogYTEzIC0gYTAzICogYTExKSk7XG4gICAgb3V0WzEyXSA9IC0oYTEwICogKGEyMSAqIGEzMiAtIGEyMiAqIGEzMSkgLSBhMjAgKiAoYTExICogYTMyIC0gYTEyICogYTMxKSArIGEzMCAqIChhMTEgKiBhMjIgLSBhMTIgKiBhMjEpKTtcbiAgICBvdXRbMTNdID0gIChhMDAgKiAoYTIxICogYTMyIC0gYTIyICogYTMxKSAtIGEyMCAqIChhMDEgKiBhMzIgLSBhMDIgKiBhMzEpICsgYTMwICogKGEwMSAqIGEyMiAtIGEwMiAqIGEyMSkpO1xuICAgIG91dFsxNF0gPSAtKGEwMCAqIChhMTEgKiBhMzIgLSBhMTIgKiBhMzEpIC0gYTEwICogKGEwMSAqIGEzMiAtIGEwMiAqIGEzMSkgKyBhMzAgKiAoYTAxICogYTEyIC0gYTAyICogYTExKSk7XG4gICAgb3V0WzE1XSA9ICAoYTAwICogKGExMSAqIGEyMiAtIGExMiAqIGEyMSkgLSBhMTAgKiAoYTAxICogYTIyIC0gYTAyICogYTIxKSArIGEyMCAqIChhMDEgKiBhMTIgLSBhMDIgKiBhMTEpKTtcbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGNsb25lO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgbWF0NCBpbml0aWFsaXplZCB3aXRoIHZhbHVlcyBmcm9tIGFuIGV4aXN0aW5nIG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gYSBtYXRyaXggdG8gY2xvbmVcbiAqIEByZXR1cm5zIHttYXQ0fSBhIG5ldyA0eDQgbWF0cml4XG4gKi9cbmZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XG4gICAgb3V0WzBdID0gYVswXTtcbiAgICBvdXRbMV0gPSBhWzFdO1xuICAgIG91dFsyXSA9IGFbMl07XG4gICAgb3V0WzNdID0gYVszXTtcbiAgICBvdXRbNF0gPSBhWzRdO1xuICAgIG91dFs1XSA9IGFbNV07XG4gICAgb3V0WzZdID0gYVs2XTtcbiAgICBvdXRbN10gPSBhWzddO1xuICAgIG91dFs4XSA9IGFbOF07XG4gICAgb3V0WzldID0gYVs5XTtcbiAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgb3V0WzExXSA9IGFbMTFdO1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGNvcHk7XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIG1hdDQgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdO1xuICAgIG91dFsxXSA9IGFbMV07XG4gICAgb3V0WzJdID0gYVsyXTtcbiAgICBvdXRbM10gPSBhWzNdO1xuICAgIG91dFs0XSA9IGFbNF07XG4gICAgb3V0WzVdID0gYVs1XTtcbiAgICBvdXRbNl0gPSBhWzZdO1xuICAgIG91dFs3XSA9IGFbN107XG4gICAgb3V0WzhdID0gYVs4XTtcbiAgICBvdXRbOV0gPSBhWzldO1xuICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICBvdXRbMTFdID0gYVsxMV07XG4gICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgIG91dFsxM10gPSBhWzEzXTtcbiAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gY3JlYXRlO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaWRlbnRpdHkgbWF0NFxuICpcbiAqIEByZXR1cm5zIHttYXQ0fSBhIG5ldyA0eDQgbWF0cml4XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgxNik7XG4gICAgb3V0WzBdID0gMTtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IDE7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gMTtcbiAgICBvdXRbMTFdID0gMDtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGRldGVybWluYW50O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRldGVybWluYW50IG9mIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgc291cmNlIG1hdHJpeFxuICogQHJldHVybnMge051bWJlcn0gZGV0ZXJtaW5hbnQgb2YgYVxuICovXG5mdW5jdGlvbiBkZXRlcm1pbmFudChhKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV0sXG5cbiAgICAgICAgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwLFxuICAgICAgICBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTAsXG4gICAgICAgIGIwMiA9IGEwMCAqIGExMyAtIGEwMyAqIGExMCxcbiAgICAgICAgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExLFxuICAgICAgICBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTEsXG4gICAgICAgIGIwNSA9IGEwMiAqIGExMyAtIGEwMyAqIGExMixcbiAgICAgICAgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwLFxuICAgICAgICBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzAsXG4gICAgICAgIGIwOCA9IGEyMCAqIGEzMyAtIGEyMyAqIGEzMCxcbiAgICAgICAgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxLFxuICAgICAgICBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzEsXG4gICAgICAgIGIxMSA9IGEyMiAqIGEzMyAtIGEyMyAqIGEzMjtcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcbiAgICByZXR1cm4gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGZyb21RdWF0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSBhIHF1YXRlcm5pb24gcm90YXRpb24uXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtxdWF0NH0gcSBSb3RhdGlvbiBxdWF0ZXJuaW9uXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIGZyb21RdWF0KG91dCwgcSkge1xuICAgIHZhciB4ID0gcVswXSwgeSA9IHFbMV0sIHogPSBxWzJdLCB3ID0gcVszXSxcbiAgICAgICAgeDIgPSB4ICsgeCxcbiAgICAgICAgeTIgPSB5ICsgeSxcbiAgICAgICAgejIgPSB6ICsgeixcblxuICAgICAgICB4eCA9IHggKiB4MixcbiAgICAgICAgeXggPSB5ICogeDIsXG4gICAgICAgIHl5ID0geSAqIHkyLFxuICAgICAgICB6eCA9IHogKiB4MixcbiAgICAgICAgenkgPSB6ICogeTIsXG4gICAgICAgIHp6ID0geiAqIHoyLFxuICAgICAgICB3eCA9IHcgKiB4MixcbiAgICAgICAgd3kgPSB3ICogeTIsXG4gICAgICAgIHd6ID0gdyAqIHoyO1xuXG4gICAgb3V0WzBdID0gMSAtIHl5IC0geno7XG4gICAgb3V0WzFdID0geXggKyB3ejtcbiAgICBvdXRbMl0gPSB6eCAtIHd5O1xuICAgIG91dFszXSA9IDA7XG5cbiAgICBvdXRbNF0gPSB5eCAtIHd6O1xuICAgIG91dFs1XSA9IDEgLSB4eCAtIHp6O1xuICAgIG91dFs2XSA9IHp5ICsgd3g7XG4gICAgb3V0WzddID0gMDtcblxuICAgIG91dFs4XSA9IHp4ICsgd3k7XG4gICAgb3V0WzldID0genkgLSB3eDtcbiAgICBvdXRbMTBdID0gMSAtIHh4IC0geXk7XG4gICAgb3V0WzExXSA9IDA7XG5cbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gMDtcbiAgICBvdXRbMTVdID0gMTtcblxuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnJvbVJvdGF0aW9uXG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgZ2l2ZW4gYW5nbGUgYXJvdW5kIGEgZ2l2ZW4gYXhpc1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdClcbiAqICAgICBtYXQ0LnJvdGF0ZShkZXN0LCBkZXN0LCByYWQsIGF4aXMpXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCByZWNlaXZpbmcgb3BlcmF0aW9uIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEBwYXJhbSB7dmVjM30gYXhpcyB0aGUgYXhpcyB0byByb3RhdGUgYXJvdW5kXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIGZyb21Sb3RhdGlvbihvdXQsIHJhZCwgYXhpcykge1xuICB2YXIgcywgYywgdFxuICB2YXIgeCA9IGF4aXNbMF1cbiAgdmFyIHkgPSBheGlzWzFdXG4gIHZhciB6ID0gYXhpc1syXVxuICB2YXIgbGVuID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkgKyB6ICogeilcblxuICBpZiAoTWF0aC5hYnMobGVuKSA8IDAuMDAwMDAxKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIGxlbiA9IDEgLyBsZW5cbiAgeCAqPSBsZW5cbiAgeSAqPSBsZW5cbiAgeiAqPSBsZW5cblxuICBzID0gTWF0aC5zaW4ocmFkKVxuICBjID0gTWF0aC5jb3MocmFkKVxuICB0ID0gMSAtIGNcblxuICAvLyBQZXJmb3JtIHJvdGF0aW9uLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICBvdXRbMF0gPSB4ICogeCAqIHQgKyBjXG4gIG91dFsxXSA9IHkgKiB4ICogdCArIHogKiBzXG4gIG91dFsyXSA9IHogKiB4ICogdCAtIHkgKiBzXG4gIG91dFszXSA9IDBcbiAgb3V0WzRdID0geCAqIHkgKiB0IC0geiAqIHNcbiAgb3V0WzVdID0geSAqIHkgKiB0ICsgY1xuICBvdXRbNl0gPSB6ICogeSAqIHQgKyB4ICogc1xuICBvdXRbN10gPSAwXG4gIG91dFs4XSA9IHggKiB6ICogdCArIHkgKiBzXG4gIG91dFs5XSA9IHkgKiB6ICogdCAtIHggKiBzXG4gIG91dFsxMF0gPSB6ICogeiAqIHQgKyBjXG4gIG91dFsxMV0gPSAwXG4gIG91dFsxMl0gPSAwXG4gIG91dFsxM10gPSAwXG4gIG91dFsxNF0gPSAwXG4gIG91dFsxNV0gPSAxXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnJvbVJvdGF0aW9uVHJhbnNsYXRpb247XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hdHJpeCBmcm9tIGEgcXVhdGVybmlvbiByb3RhdGlvbiBhbmQgdmVjdG9yIHRyYW5zbGF0aW9uXG4gKiBUaGlzIGlzIGVxdWl2YWxlbnQgdG8gKGJ1dCBtdWNoIGZhc3RlciB0aGFuKTpcbiAqXG4gKiAgICAgbWF0NC5pZGVudGl0eShkZXN0KTtcbiAqICAgICBtYXQ0LnRyYW5zbGF0ZShkZXN0LCB2ZWMpO1xuICogICAgIHZhciBxdWF0TWF0ID0gbWF0NC5jcmVhdGUoKTtcbiAqICAgICBxdWF0NC50b01hdDQocXVhdCwgcXVhdE1hdCk7XG4gKiAgICAgbWF0NC5tdWx0aXBseShkZXN0LCBxdWF0TWF0KTtcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3F1YXQ0fSBxIFJvdGF0aW9uIHF1YXRlcm5pb25cbiAqIEBwYXJhbSB7dmVjM30gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gZnJvbVJvdGF0aW9uVHJhbnNsYXRpb24ob3V0LCBxLCB2KSB7XG4gICAgLy8gUXVhdGVybmlvbiBtYXRoXG4gICAgdmFyIHggPSBxWzBdLCB5ID0gcVsxXSwgeiA9IHFbMl0sIHcgPSBxWzNdLFxuICAgICAgICB4MiA9IHggKyB4LFxuICAgICAgICB5MiA9IHkgKyB5LFxuICAgICAgICB6MiA9IHogKyB6LFxuXG4gICAgICAgIHh4ID0geCAqIHgyLFxuICAgICAgICB4eSA9IHggKiB5MixcbiAgICAgICAgeHogPSB4ICogejIsXG4gICAgICAgIHl5ID0geSAqIHkyLFxuICAgICAgICB5eiA9IHkgKiB6MixcbiAgICAgICAgenogPSB6ICogejIsXG4gICAgICAgIHd4ID0gdyAqIHgyLFxuICAgICAgICB3eSA9IHcgKiB5MixcbiAgICAgICAgd3ogPSB3ICogejI7XG5cbiAgICBvdXRbMF0gPSAxIC0gKHl5ICsgenopO1xuICAgIG91dFsxXSA9IHh5ICsgd3o7XG4gICAgb3V0WzJdID0geHogLSB3eTtcbiAgICBvdXRbM10gPSAwO1xuICAgIG91dFs0XSA9IHh5IC0gd3o7XG4gICAgb3V0WzVdID0gMSAtICh4eCArIHp6KTtcbiAgICBvdXRbNl0gPSB5eiArIHd4O1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0geHogKyB3eTtcbiAgICBvdXRbOV0gPSB5eiAtIHd4O1xuICAgIG91dFsxMF0gPSAxIC0gKHh4ICsgeXkpO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSB2WzBdO1xuICAgIG91dFsxM10gPSB2WzFdO1xuICAgIG91dFsxNF0gPSB2WzJdO1xuICAgIG91dFsxNV0gPSAxO1xuICAgIFxuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gZnJvbVNjYWxpbmdcblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3Igc2NhbGluZ1xuICogVGhpcyBpcyBlcXVpdmFsZW50IHRvIChidXQgbXVjaCBmYXN0ZXIgdGhhbik6XG4gKlxuICogICAgIG1hdDQuaWRlbnRpdHkoZGVzdClcbiAqICAgICBtYXQ0LnNjYWxlKGRlc3QsIGRlc3QsIHZlYylcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge3ZlYzN9IHYgU2NhbGluZyB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gZnJvbVNjYWxpbmcob3V0LCB2KSB7XG4gIG91dFswXSA9IHZbMF1cbiAgb3V0WzFdID0gMFxuICBvdXRbMl0gPSAwXG4gIG91dFszXSA9IDBcbiAgb3V0WzRdID0gMFxuICBvdXRbNV0gPSB2WzFdXG4gIG91dFs2XSA9IDBcbiAgb3V0WzddID0gMFxuICBvdXRbOF0gPSAwXG4gIG91dFs5XSA9IDBcbiAgb3V0WzEwXSA9IHZbMl1cbiAgb3V0WzExXSA9IDBcbiAgb3V0WzEyXSA9IDBcbiAgb3V0WzEzXSA9IDBcbiAgb3V0WzE0XSA9IDBcbiAgb3V0WzE1XSA9IDFcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBmcm9tVHJhbnNsYXRpb25cblxuLyoqXG4gKiBDcmVhdGVzIGEgbWF0cml4IGZyb20gYSB2ZWN0b3IgdHJhbnNsYXRpb25cbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpXG4gKiAgICAgbWF0NC50cmFuc2xhdGUoZGVzdCwgZGVzdCwgdmVjKVxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgcmVjZWl2aW5nIG9wZXJhdGlvbiByZXN1bHRcbiAqIEBwYXJhbSB7dmVjM30gdiBUcmFuc2xhdGlvbiB2ZWN0b3JcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gZnJvbVRyYW5zbGF0aW9uKG91dCwgdikge1xuICBvdXRbMF0gPSAxXG4gIG91dFsxXSA9IDBcbiAgb3V0WzJdID0gMFxuICBvdXRbM10gPSAwXG4gIG91dFs0XSA9IDBcbiAgb3V0WzVdID0gMVxuICBvdXRbNl0gPSAwXG4gIG91dFs3XSA9IDBcbiAgb3V0WzhdID0gMFxuICBvdXRbOV0gPSAwXG4gIG91dFsxMF0gPSAxXG4gIG91dFsxMV0gPSAwXG4gIG91dFsxMl0gPSB2WzBdXG4gIG91dFsxM10gPSB2WzFdXG4gIG91dFsxNF0gPSB2WzJdXG4gIG91dFsxNV0gPSAxXG4gIHJldHVybiBvdXRcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnJvbVhSb3RhdGlvblxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBYIGF4aXNcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpXG4gKiAgICAgbWF0NC5yb3RhdGVYKGRlc3QsIGRlc3QsIHJhZClcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiBmcm9tWFJvdGF0aW9uKG91dCwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKVxuXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFswXSA9IDFcbiAgICBvdXRbMV0gPSAwXG4gICAgb3V0WzJdID0gMFxuICAgIG91dFszXSA9IDBcbiAgICBvdXRbNF0gPSAwXG4gICAgb3V0WzVdID0gY1xuICAgIG91dFs2XSA9IHNcbiAgICBvdXRbN10gPSAwXG4gICAgb3V0WzhdID0gMFxuICAgIG91dFs5XSA9IC1zXG4gICAgb3V0WzEwXSA9IGNcbiAgICBvdXRbMTFdID0gMFxuICAgIG91dFsxMl0gPSAwXG4gICAgb3V0WzEzXSA9IDBcbiAgICBvdXRbMTRdID0gMFxuICAgIG91dFsxNV0gPSAxXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gZnJvbVlSb3RhdGlvblxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBZIGF4aXNcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpXG4gKiAgICAgbWF0NC5yb3RhdGVZKGRlc3QsIGRlc3QsIHJhZClcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiBmcm9tWVJvdGF0aW9uKG91dCwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKVxuXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFswXSA9IGNcbiAgICBvdXRbMV0gPSAwXG4gICAgb3V0WzJdID0gLXNcbiAgICBvdXRbM10gPSAwXG4gICAgb3V0WzRdID0gMFxuICAgIG91dFs1XSA9IDFcbiAgICBvdXRbNl0gPSAwXG4gICAgb3V0WzddID0gMFxuICAgIG91dFs4XSA9IHNcbiAgICBvdXRbOV0gPSAwXG4gICAgb3V0WzEwXSA9IGNcbiAgICBvdXRbMTFdID0gMFxuICAgIG91dFsxMl0gPSAwXG4gICAgb3V0WzEzXSA9IDBcbiAgICBvdXRbMTRdID0gMFxuICAgIG91dFsxNV0gPSAxXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gZnJvbVpSb3RhdGlvblxuXG4vKipcbiAqIENyZWF0ZXMgYSBtYXRyaXggZnJvbSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBaIGF4aXNcbiAqIFRoaXMgaXMgZXF1aXZhbGVudCB0byAoYnV0IG11Y2ggZmFzdGVyIHRoYW4pOlxuICpcbiAqICAgICBtYXQ0LmlkZW50aXR5KGRlc3QpXG4gKiAgICAgbWF0NC5yb3RhdGVaKGRlc3QsIGRlc3QsIHJhZClcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IHJlY2VpdmluZyBvcGVyYXRpb24gcmVzdWx0XG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiBmcm9tWlJvdGF0aW9uKG91dCwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKVxuXG4gICAgLy8gUGVyZm9ybSBheGlzLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFswXSA9IGNcbiAgICBvdXRbMV0gPSBzXG4gICAgb3V0WzJdID0gMFxuICAgIG91dFszXSA9IDBcbiAgICBvdXRbNF0gPSAtc1xuICAgIG91dFs1XSA9IGNcbiAgICBvdXRbNl0gPSAwXG4gICAgb3V0WzddID0gMFxuICAgIG91dFs4XSA9IDBcbiAgICBvdXRbOV0gPSAwXG4gICAgb3V0WzEwXSA9IDFcbiAgICBvdXRbMTFdID0gMFxuICAgIG91dFsxMl0gPSAwXG4gICAgb3V0WzEzXSA9IDBcbiAgICBvdXRbMTRdID0gMFxuICAgIG91dFsxNV0gPSAxXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gZnJ1c3R1bTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBmcnVzdHVtIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiBib3VuZHNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge051bWJlcn0gbGVmdCBMZWZ0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gcmlnaHQgUmlnaHQgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7TnVtYmVyfSBib3R0b20gQm90dG9tIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge051bWJlcn0gdG9wIFRvcCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IG5lYXIgTmVhciBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtOdW1iZXJ9IGZhciBGYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gZnJ1c3R1bShvdXQsIGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKSB7XG4gICAgdmFyIHJsID0gMSAvIChyaWdodCAtIGxlZnQpLFxuICAgICAgICB0YiA9IDEgLyAodG9wIC0gYm90dG9tKSxcbiAgICAgICAgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICAgIG91dFswXSA9IChuZWFyICogMikgKiBybDtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IChuZWFyICogMikgKiB0YjtcbiAgICBvdXRbNl0gPSAwO1xuICAgIG91dFs3XSA9IDA7XG4gICAgb3V0WzhdID0gKHJpZ2h0ICsgbGVmdCkgKiBybDtcbiAgICBvdXRbOV0gPSAodG9wICsgYm90dG9tKSAqIHRiO1xuICAgIG91dFsxMF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgICBvdXRbMTFdID0gLTE7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IChmYXIgKiBuZWFyICogMikgKiBuZjtcbiAgICBvdXRbMTVdID0gMDtcbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IGlkZW50aXR5O1xuXG4vKipcbiAqIFNldCBhIG1hdDQgdG8gdGhlIGlkZW50aXR5IG1hdHJpeFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIGlkZW50aXR5KG91dCkge1xuICAgIG91dFswXSA9IDE7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSAxO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IDE7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IDA7XG4gICAgb3V0WzEzXSA9IDA7XG4gICAgb3V0WzE0XSA9IDA7XG4gICAgb3V0WzE1XSA9IDE7XG4gICAgcmV0dXJuIG91dDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIGNyZWF0ZTogcmVxdWlyZSgnLi9jcmVhdGUnKVxuICAsIGNsb25lOiByZXF1aXJlKCcuL2Nsb25lJylcbiAgLCBjb3B5OiByZXF1aXJlKCcuL2NvcHknKVxuICAsIGlkZW50aXR5OiByZXF1aXJlKCcuL2lkZW50aXR5JylcbiAgLCB0cmFuc3Bvc2U6IHJlcXVpcmUoJy4vdHJhbnNwb3NlJylcbiAgLCBpbnZlcnQ6IHJlcXVpcmUoJy4vaW52ZXJ0JylcbiAgLCBhZGpvaW50OiByZXF1aXJlKCcuL2Fkam9pbnQnKVxuICAsIGRldGVybWluYW50OiByZXF1aXJlKCcuL2RldGVybWluYW50JylcbiAgLCBtdWx0aXBseTogcmVxdWlyZSgnLi9tdWx0aXBseScpXG4gICwgdHJhbnNsYXRlOiByZXF1aXJlKCcuL3RyYW5zbGF0ZScpXG4gICwgc2NhbGU6IHJlcXVpcmUoJy4vc2NhbGUnKVxuICAsIHJvdGF0ZTogcmVxdWlyZSgnLi9yb3RhdGUnKVxuICAsIHJvdGF0ZVg6IHJlcXVpcmUoJy4vcm90YXRlWCcpXG4gICwgcm90YXRlWTogcmVxdWlyZSgnLi9yb3RhdGVZJylcbiAgLCByb3RhdGVaOiByZXF1aXJlKCcuL3JvdGF0ZVonKVxuICAsIGZyb21Sb3RhdGlvbjogcmVxdWlyZSgnLi9mcm9tUm90YXRpb24nKVxuICAsIGZyb21Sb3RhdGlvblRyYW5zbGF0aW9uOiByZXF1aXJlKCcuL2Zyb21Sb3RhdGlvblRyYW5zbGF0aW9uJylcbiAgLCBmcm9tU2NhbGluZzogcmVxdWlyZSgnLi9mcm9tU2NhbGluZycpXG4gICwgZnJvbVRyYW5zbGF0aW9uOiByZXF1aXJlKCcuL2Zyb21UcmFuc2xhdGlvbicpXG4gICwgZnJvbVhSb3RhdGlvbjogcmVxdWlyZSgnLi9mcm9tWFJvdGF0aW9uJylcbiAgLCBmcm9tWVJvdGF0aW9uOiByZXF1aXJlKCcuL2Zyb21ZUm90YXRpb24nKVxuICAsIGZyb21aUm90YXRpb246IHJlcXVpcmUoJy4vZnJvbVpSb3RhdGlvbicpXG4gICwgZnJvbVF1YXQ6IHJlcXVpcmUoJy4vZnJvbVF1YXQnKVxuICAsIGZydXN0dW06IHJlcXVpcmUoJy4vZnJ1c3R1bScpXG4gICwgcGVyc3BlY3RpdmU6IHJlcXVpcmUoJy4vcGVyc3BlY3RpdmUnKVxuICAsIHBlcnNwZWN0aXZlRnJvbUZpZWxkT2ZWaWV3OiByZXF1aXJlKCcuL3BlcnNwZWN0aXZlRnJvbUZpZWxkT2ZWaWV3JylcbiAgLCBvcnRobzogcmVxdWlyZSgnLi9vcnRobycpXG4gICwgbG9va0F0OiByZXF1aXJlKCcuL2xvb2tBdCcpXG4gICwgc3RyOiByZXF1aXJlKCcuL3N0cicpXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGludmVydDtcblxuLyoqXG4gKiBJbnZlcnRzIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIHNvdXJjZSBtYXRyaXhcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gaW52ZXJ0KG91dCwgYSkge1xuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgICAgICBhMTAgPSBhWzRdLCBhMTEgPSBhWzVdLCBhMTIgPSBhWzZdLCBhMTMgPSBhWzddLFxuICAgICAgICBhMjAgPSBhWzhdLCBhMjEgPSBhWzldLCBhMjIgPSBhWzEwXSwgYTIzID0gYVsxMV0sXG4gICAgICAgIGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF0sIGEzMyA9IGFbMTVdLFxuXG4gICAgICAgIGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMCxcbiAgICAgICAgYjAxID0gYTAwICogYTEyIC0gYTAyICogYTEwLFxuICAgICAgICBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTAsXG4gICAgICAgIGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMSxcbiAgICAgICAgYjA0ID0gYTAxICogYTEzIC0gYTAzICogYTExLFxuICAgICAgICBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTIsXG4gICAgICAgIGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMCxcbiAgICAgICAgYjA3ID0gYTIwICogYTMyIC0gYTIyICogYTMwLFxuICAgICAgICBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzAsXG4gICAgICAgIGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMSxcbiAgICAgICAgYjEwID0gYTIxICogYTMzIC0gYTIzICogYTMxLFxuICAgICAgICBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzIsXG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICAgICAgICBkZXQgPSBiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDY7XG5cbiAgICBpZiAoIWRldCkgeyBcbiAgICAgICAgcmV0dXJuIG51bGw7IFxuICAgIH1cbiAgICBkZXQgPSAxLjAgLyBkZXQ7XG5cbiAgICBvdXRbMF0gPSAoYTExICogYjExIC0gYTEyICogYjEwICsgYTEzICogYjA5KSAqIGRldDtcbiAgICBvdXRbMV0gPSAoYTAyICogYjEwIC0gYTAxICogYjExIC0gYTAzICogYjA5KSAqIGRldDtcbiAgICBvdXRbMl0gPSAoYTMxICogYjA1IC0gYTMyICogYjA0ICsgYTMzICogYjAzKSAqIGRldDtcbiAgICBvdXRbM10gPSAoYTIyICogYjA0IC0gYTIxICogYjA1IC0gYTIzICogYjAzKSAqIGRldDtcbiAgICBvdXRbNF0gPSAoYTEyICogYjA4IC0gYTEwICogYjExIC0gYTEzICogYjA3KSAqIGRldDtcbiAgICBvdXRbNV0gPSAoYTAwICogYjExIC0gYTAyICogYjA4ICsgYTAzICogYjA3KSAqIGRldDtcbiAgICBvdXRbNl0gPSAoYTMyICogYjAyIC0gYTMwICogYjA1IC0gYTMzICogYjAxKSAqIGRldDtcbiAgICBvdXRbN10gPSAoYTIwICogYjA1IC0gYTIyICogYjAyICsgYTIzICogYjAxKSAqIGRldDtcbiAgICBvdXRbOF0gPSAoYTEwICogYjEwIC0gYTExICogYjA4ICsgYTEzICogYjA2KSAqIGRldDtcbiAgICBvdXRbOV0gPSAoYTAxICogYjA4IC0gYTAwICogYjEwIC0gYTAzICogYjA2KSAqIGRldDtcbiAgICBvdXRbMTBdID0gKGEzMCAqIGIwNCAtIGEzMSAqIGIwMiArIGEzMyAqIGIwMCkgKiBkZXQ7XG4gICAgb3V0WzExXSA9IChhMjEgKiBiMDIgLSBhMjAgKiBiMDQgLSBhMjMgKiBiMDApICogZGV0O1xuICAgIG91dFsxMl0gPSAoYTExICogYjA3IC0gYTEwICogYjA5IC0gYTEyICogYjA2KSAqIGRldDtcbiAgICBvdXRbMTNdID0gKGEwMCAqIGIwOSAtIGEwMSAqIGIwNyArIGEwMiAqIGIwNikgKiBkZXQ7XG4gICAgb3V0WzE0XSA9IChhMzEgKiBiMDEgLSBhMzAgKiBiMDMgLSBhMzIgKiBiMDApICogZGV0O1xuICAgIG91dFsxNV0gPSAoYTIwICogYjAzIC0gYTIxICogYjAxICsgYTIyICogYjAwKSAqIGRldDtcblxuICAgIHJldHVybiBvdXQ7XG59OyIsInZhciBpZGVudGl0eSA9IHJlcXVpcmUoJy4vaWRlbnRpdHknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBsb29rQXQ7XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgbG9vay1hdCBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gZXllIHBvc2l0aW9uLCBmb2NhbCBwb2ludCwgYW5kIHVwIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCBtYXQ0IGZydXN0dW0gbWF0cml4IHdpbGwgYmUgd3JpdHRlbiBpbnRvXG4gKiBAcGFyYW0ge3ZlYzN9IGV5ZSBQb3NpdGlvbiBvZiB0aGUgdmlld2VyXG4gKiBAcGFyYW0ge3ZlYzN9IGNlbnRlciBQb2ludCB0aGUgdmlld2VyIGlzIGxvb2tpbmcgYXRcbiAqIEBwYXJhbSB7dmVjM30gdXAgdmVjMyBwb2ludGluZyB1cFxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiBsb29rQXQob3V0LCBleWUsIGNlbnRlciwgdXApIHtcbiAgICB2YXIgeDAsIHgxLCB4MiwgeTAsIHkxLCB5MiwgejAsIHoxLCB6MiwgbGVuLFxuICAgICAgICBleWV4ID0gZXllWzBdLFxuICAgICAgICBleWV5ID0gZXllWzFdLFxuICAgICAgICBleWV6ID0gZXllWzJdLFxuICAgICAgICB1cHggPSB1cFswXSxcbiAgICAgICAgdXB5ID0gdXBbMV0sXG4gICAgICAgIHVweiA9IHVwWzJdLFxuICAgICAgICBjZW50ZXJ4ID0gY2VudGVyWzBdLFxuICAgICAgICBjZW50ZXJ5ID0gY2VudGVyWzFdLFxuICAgICAgICBjZW50ZXJ6ID0gY2VudGVyWzJdO1xuXG4gICAgaWYgKE1hdGguYWJzKGV5ZXggLSBjZW50ZXJ4KSA8IDAuMDAwMDAxICYmXG4gICAgICAgIE1hdGguYWJzKGV5ZXkgLSBjZW50ZXJ5KSA8IDAuMDAwMDAxICYmXG4gICAgICAgIE1hdGguYWJzKGV5ZXogLSBjZW50ZXJ6KSA8IDAuMDAwMDAxKSB7XG4gICAgICAgIHJldHVybiBpZGVudGl0eShvdXQpO1xuICAgIH1cblxuICAgIHowID0gZXlleCAtIGNlbnRlcng7XG4gICAgejEgPSBleWV5IC0gY2VudGVyeTtcbiAgICB6MiA9IGV5ZXogLSBjZW50ZXJ6O1xuXG4gICAgbGVuID0gMSAvIE1hdGguc3FydCh6MCAqIHowICsgejEgKiB6MSArIHoyICogejIpO1xuICAgIHowICo9IGxlbjtcbiAgICB6MSAqPSBsZW47XG4gICAgejIgKj0gbGVuO1xuXG4gICAgeDAgPSB1cHkgKiB6MiAtIHVweiAqIHoxO1xuICAgIHgxID0gdXB6ICogejAgLSB1cHggKiB6MjtcbiAgICB4MiA9IHVweCAqIHoxIC0gdXB5ICogejA7XG4gICAgbGVuID0gTWF0aC5zcXJ0KHgwICogeDAgKyB4MSAqIHgxICsgeDIgKiB4Mik7XG4gICAgaWYgKCFsZW4pIHtcbiAgICAgICAgeDAgPSAwO1xuICAgICAgICB4MSA9IDA7XG4gICAgICAgIHgyID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsZW4gPSAxIC8gbGVuO1xuICAgICAgICB4MCAqPSBsZW47XG4gICAgICAgIHgxICo9IGxlbjtcbiAgICAgICAgeDIgKj0gbGVuO1xuICAgIH1cblxuICAgIHkwID0gejEgKiB4MiAtIHoyICogeDE7XG4gICAgeTEgPSB6MiAqIHgwIC0gejAgKiB4MjtcbiAgICB5MiA9IHowICogeDEgLSB6MSAqIHgwO1xuXG4gICAgbGVuID0gTWF0aC5zcXJ0KHkwICogeTAgKyB5MSAqIHkxICsgeTIgKiB5Mik7XG4gICAgaWYgKCFsZW4pIHtcbiAgICAgICAgeTAgPSAwO1xuICAgICAgICB5MSA9IDA7XG4gICAgICAgIHkyID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsZW4gPSAxIC8gbGVuO1xuICAgICAgICB5MCAqPSBsZW47XG4gICAgICAgIHkxICo9IGxlbjtcbiAgICAgICAgeTIgKj0gbGVuO1xuICAgIH1cblxuICAgIG91dFswXSA9IHgwO1xuICAgIG91dFsxXSA9IHkwO1xuICAgIG91dFsyXSA9IHowO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0geDE7XG4gICAgb3V0WzVdID0geTE7XG4gICAgb3V0WzZdID0gejE7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSB4MjtcbiAgICBvdXRbOV0gPSB5MjtcbiAgICBvdXRbMTBdID0gejI7XG4gICAgb3V0WzExXSA9IDA7XG4gICAgb3V0WzEyXSA9IC0oeDAgKiBleWV4ICsgeDEgKiBleWV5ICsgeDIgKiBleWV6KTtcbiAgICBvdXRbMTNdID0gLSh5MCAqIGV5ZXggKyB5MSAqIGV5ZXkgKyB5MiAqIGV5ZXopO1xuICAgIG91dFsxNF0gPSAtKHowICogZXlleCArIHoxICogZXlleSArIHoyICogZXlleik7XG4gICAgb3V0WzE1XSA9IDE7XG5cbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IG11bHRpcGx5O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIG1hdDQnc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7bWF0NH0gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sIGEwMyA9IGFbM10sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLCBhMjMgPSBhWzExXSxcbiAgICAgICAgYTMwID0gYVsxMl0sIGEzMSA9IGFbMTNdLCBhMzIgPSBhWzE0XSwgYTMzID0gYVsxNV07XG5cbiAgICAvLyBDYWNoZSBvbmx5IHRoZSBjdXJyZW50IGxpbmUgb2YgdGhlIHNlY29uZCBtYXRyaXhcbiAgICB2YXIgYjAgID0gYlswXSwgYjEgPSBiWzFdLCBiMiA9IGJbMl0sIGIzID0gYlszXTsgIFxuICAgIG91dFswXSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBvdXRbMV0gPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgb3V0WzJdID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIG91dFszXSA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcblxuICAgIGIwID0gYls0XTsgYjEgPSBiWzVdOyBiMiA9IGJbNl07IGIzID0gYls3XTtcbiAgICBvdXRbNF0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgb3V0WzVdID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICAgIG91dFs2XSA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBvdXRbN10gPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG5cbiAgICBiMCA9IGJbOF07IGIxID0gYls5XTsgYjIgPSBiWzEwXTsgYjMgPSBiWzExXTtcbiAgICBvdXRbOF0gPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgb3V0WzldID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICAgIG91dFsxMF0gPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gICAgb3V0WzExXSA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcblxuICAgIGIwID0gYlsxMl07IGIxID0gYlsxM107IGIyID0gYlsxNF07IGIzID0gYlsxNV07XG4gICAgb3V0WzEyXSA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBvdXRbMTNdID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICAgIG91dFsxNF0gPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gICAgb3V0WzE1XSA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IG9ydGhvO1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIG9ydGhvZ29uYWwgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gYm91bmRzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgbWF0NCBmcnVzdHVtIG1hdHJpeCB3aWxsIGJlIHdyaXR0ZW4gaW50b1xuICogQHBhcmFtIHtudW1iZXJ9IGxlZnQgTGVmdCBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IHJpZ2h0IFJpZ2h0IGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcGFyYW0ge251bWJlcn0gYm90dG9tIEJvdHRvbSBib3VuZCBvZiB0aGUgZnJ1c3R1bVxuICogQHBhcmFtIHtudW1iZXJ9IHRvcCBUb3AgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIG9ydGhvKG91dCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpIHtcbiAgICB2YXIgbHIgPSAxIC8gKGxlZnQgLSByaWdodCksXG4gICAgICAgIGJ0ID0gMSAvIChib3R0b20gLSB0b3ApLFxuICAgICAgICBuZiA9IDEgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzBdID0gLTIgKiBscjtcbiAgICBvdXRbMV0gPSAwO1xuICAgIG91dFsyXSA9IDA7XG4gICAgb3V0WzNdID0gMDtcbiAgICBvdXRbNF0gPSAwO1xuICAgIG91dFs1XSA9IC0yICogYnQ7XG4gICAgb3V0WzZdID0gMDtcbiAgICBvdXRbN10gPSAwO1xuICAgIG91dFs4XSA9IDA7XG4gICAgb3V0WzldID0gMDtcbiAgICBvdXRbMTBdID0gMiAqIG5mO1xuICAgIG91dFsxMV0gPSAwO1xuICAgIG91dFsxMl0gPSAobGVmdCArIHJpZ2h0KSAqIGxyO1xuICAgIG91dFsxM10gPSAodG9wICsgYm90dG9tKSAqIGJ0O1xuICAgIG91dFsxNF0gPSAoZmFyICsgbmVhcikgKiBuZjtcbiAgICBvdXRbMTVdID0gMTtcbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHBlcnNwZWN0aXZlO1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHBlcnNwZWN0aXZlIHByb2plY3Rpb24gbWF0cml4IHdpdGggdGhlIGdpdmVuIGJvdW5kc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7bnVtYmVyfSBmb3Z5IFZlcnRpY2FsIGZpZWxkIG9mIHZpZXcgaW4gcmFkaWFuc1xuICogQHBhcmFtIHtudW1iZXJ9IGFzcGVjdCBBc3BlY3QgcmF0aW8uIHR5cGljYWxseSB2aWV3cG9ydCB3aWR0aC9oZWlnaHRcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIHBlcnNwZWN0aXZlKG91dCwgZm92eSwgYXNwZWN0LCBuZWFyLCBmYXIpIHtcbiAgICB2YXIgZiA9IDEuMCAvIE1hdGgudGFuKGZvdnkgLyAyKSxcbiAgICAgICAgbmYgPSAxIC8gKG5lYXIgLSBmYXIpO1xuICAgIG91dFswXSA9IGYgLyBhc3BlY3Q7XG4gICAgb3V0WzFdID0gMDtcbiAgICBvdXRbMl0gPSAwO1xuICAgIG91dFszXSA9IDA7XG4gICAgb3V0WzRdID0gMDtcbiAgICBvdXRbNV0gPSBmO1xuICAgIG91dFs2XSA9IDA7XG4gICAgb3V0WzddID0gMDtcbiAgICBvdXRbOF0gPSAwO1xuICAgIG91dFs5XSA9IDA7XG4gICAgb3V0WzEwXSA9IChmYXIgKyBuZWFyKSAqIG5mO1xuICAgIG91dFsxMV0gPSAtMTtcbiAgICBvdXRbMTJdID0gMDtcbiAgICBvdXRbMTNdID0gMDtcbiAgICBvdXRbMTRdID0gKDIgKiBmYXIgKiBuZWFyKSAqIG5mO1xuICAgIG91dFsxNV0gPSAwO1xuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gcGVyc3BlY3RpdmVGcm9tRmllbGRPZlZpZXc7XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgcGVyc3BlY3RpdmUgcHJvamVjdGlvbiBtYXRyaXggd2l0aCB0aGUgZ2l2ZW4gZmllbGQgb2Ygdmlldy5cbiAqIFRoaXMgaXMgcHJpbWFyaWx5IHVzZWZ1bCBmb3IgZ2VuZXJhdGluZyBwcm9qZWN0aW9uIG1hdHJpY2VzIHRvIGJlIHVzZWRcbiAqIHdpdGggdGhlIHN0aWxsIGV4cGVyaWVtZW50YWwgV2ViVlIgQVBJLlxuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IG1hdDQgZnJ1c3R1bSBtYXRyaXggd2lsbCBiZSB3cml0dGVuIGludG9cbiAqIEBwYXJhbSB7bnVtYmVyfSBmb3YgT2JqZWN0IGNvbnRhaW5pbmcgdGhlIGZvbGxvd2luZyB2YWx1ZXM6IHVwRGVncmVlcywgZG93bkRlZ3JlZXMsIGxlZnREZWdyZWVzLCByaWdodERlZ3JlZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBuZWFyIE5lYXIgYm91bmQgb2YgdGhlIGZydXN0dW1cbiAqIEBwYXJhbSB7bnVtYmVyfSBmYXIgRmFyIGJvdW5kIG9mIHRoZSBmcnVzdHVtXG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIHBlcnNwZWN0aXZlRnJvbUZpZWxkT2ZWaWV3KG91dCwgZm92LCBuZWFyLCBmYXIpIHtcbiAgICB2YXIgdXBUYW4gPSBNYXRoLnRhbihmb3YudXBEZWdyZWVzICogTWF0aC5QSS8xODAuMCksXG4gICAgICAgIGRvd25UYW4gPSBNYXRoLnRhbihmb3YuZG93bkRlZ3JlZXMgKiBNYXRoLlBJLzE4MC4wKSxcbiAgICAgICAgbGVmdFRhbiA9IE1hdGgudGFuKGZvdi5sZWZ0RGVncmVlcyAqIE1hdGguUEkvMTgwLjApLFxuICAgICAgICByaWdodFRhbiA9IE1hdGgudGFuKGZvdi5yaWdodERlZ3JlZXMgKiBNYXRoLlBJLzE4MC4wKSxcbiAgICAgICAgeFNjYWxlID0gMi4wIC8gKGxlZnRUYW4gKyByaWdodFRhbiksXG4gICAgICAgIHlTY2FsZSA9IDIuMCAvICh1cFRhbiArIGRvd25UYW4pO1xuXG4gICAgb3V0WzBdID0geFNjYWxlO1xuICAgIG91dFsxXSA9IDAuMDtcbiAgICBvdXRbMl0gPSAwLjA7XG4gICAgb3V0WzNdID0gMC4wO1xuICAgIG91dFs0XSA9IDAuMDtcbiAgICBvdXRbNV0gPSB5U2NhbGU7XG4gICAgb3V0WzZdID0gMC4wO1xuICAgIG91dFs3XSA9IDAuMDtcbiAgICBvdXRbOF0gPSAtKChsZWZ0VGFuIC0gcmlnaHRUYW4pICogeFNjYWxlICogMC41KTtcbiAgICBvdXRbOV0gPSAoKHVwVGFuIC0gZG93blRhbikgKiB5U2NhbGUgKiAwLjUpO1xuICAgIG91dFsxMF0gPSBmYXIgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzExXSA9IC0xLjA7XG4gICAgb3V0WzEyXSA9IDAuMDtcbiAgICBvdXRbMTNdID0gMC4wO1xuICAgIG91dFsxNF0gPSAoZmFyICogbmVhcikgLyAobmVhciAtIGZhcik7XG4gICAgb3V0WzE1XSA9IDAuMDtcbiAgICByZXR1cm4gb3V0O1xufVxuXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJvdGF0ZTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0NCBieSB0aGUgZ2l2ZW4gYW5nbGVcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHBhcmFtIHt2ZWMzfSBheGlzIHRoZSBheGlzIHRvIHJvdGF0ZSBhcm91bmRcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gcm90YXRlKG91dCwgYSwgcmFkLCBheGlzKSB7XG4gICAgdmFyIHggPSBheGlzWzBdLCB5ID0gYXhpc1sxXSwgeiA9IGF4aXNbMl0sXG4gICAgICAgIGxlbiA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5ICsgeiAqIHopLFxuICAgICAgICBzLCBjLCB0LFxuICAgICAgICBhMDAsIGEwMSwgYTAyLCBhMDMsXG4gICAgICAgIGExMCwgYTExLCBhMTIsIGExMyxcbiAgICAgICAgYTIwLCBhMjEsIGEyMiwgYTIzLFxuICAgICAgICBiMDAsIGIwMSwgYjAyLFxuICAgICAgICBiMTAsIGIxMSwgYjEyLFxuICAgICAgICBiMjAsIGIyMSwgYjIyO1xuXG4gICAgaWYgKE1hdGguYWJzKGxlbikgPCAwLjAwMDAwMSkgeyByZXR1cm4gbnVsbDsgfVxuICAgIFxuICAgIGxlbiA9IDEgLyBsZW47XG4gICAgeCAqPSBsZW47XG4gICAgeSAqPSBsZW47XG4gICAgeiAqPSBsZW47XG5cbiAgICBzID0gTWF0aC5zaW4ocmFkKTtcbiAgICBjID0gTWF0aC5jb3MocmFkKTtcbiAgICB0ID0gMSAtIGM7XG5cbiAgICBhMDAgPSBhWzBdOyBhMDEgPSBhWzFdOyBhMDIgPSBhWzJdOyBhMDMgPSBhWzNdO1xuICAgIGExMCA9IGFbNF07IGExMSA9IGFbNV07IGExMiA9IGFbNl07IGExMyA9IGFbN107XG4gICAgYTIwID0gYVs4XTsgYTIxID0gYVs5XTsgYTIyID0gYVsxMF07IGEyMyA9IGFbMTFdO1xuXG4gICAgLy8gQ29uc3RydWN0IHRoZSBlbGVtZW50cyBvZiB0aGUgcm90YXRpb24gbWF0cml4XG4gICAgYjAwID0geCAqIHggKiB0ICsgYzsgYjAxID0geSAqIHggKiB0ICsgeiAqIHM7IGIwMiA9IHogKiB4ICogdCAtIHkgKiBzO1xuICAgIGIxMCA9IHggKiB5ICogdCAtIHogKiBzOyBiMTEgPSB5ICogeSAqIHQgKyBjOyBiMTIgPSB6ICogeSAqIHQgKyB4ICogcztcbiAgICBiMjAgPSB4ICogeiAqIHQgKyB5ICogczsgYjIxID0geSAqIHogKiB0IC0geCAqIHM7IGIyMiA9IHogKiB6ICogdCArIGM7XG5cbiAgICAvLyBQZXJmb3JtIHJvdGF0aW9uLXNwZWNpZmljIG1hdHJpeCBtdWx0aXBsaWNhdGlvblxuICAgIG91dFswXSA9IGEwMCAqIGIwMCArIGExMCAqIGIwMSArIGEyMCAqIGIwMjtcbiAgICBvdXRbMV0gPSBhMDEgKiBiMDAgKyBhMTEgKiBiMDEgKyBhMjEgKiBiMDI7XG4gICAgb3V0WzJdID0gYTAyICogYjAwICsgYTEyICogYjAxICsgYTIyICogYjAyO1xuICAgIG91dFszXSA9IGEwMyAqIGIwMCArIGExMyAqIGIwMSArIGEyMyAqIGIwMjtcbiAgICBvdXRbNF0gPSBhMDAgKiBiMTAgKyBhMTAgKiBiMTEgKyBhMjAgKiBiMTI7XG4gICAgb3V0WzVdID0gYTAxICogYjEwICsgYTExICogYjExICsgYTIxICogYjEyO1xuICAgIG91dFs2XSA9IGEwMiAqIGIxMCArIGExMiAqIGIxMSArIGEyMiAqIGIxMjtcbiAgICBvdXRbN10gPSBhMDMgKiBiMTAgKyBhMTMgKiBiMTEgKyBhMjMgKiBiMTI7XG4gICAgb3V0WzhdID0gYTAwICogYjIwICsgYTEwICogYjIxICsgYTIwICogYjIyO1xuICAgIG91dFs5XSA9IGEwMSAqIGIyMCArIGExMSAqIGIyMSArIGEyMSAqIGIyMjtcbiAgICBvdXRbMTBdID0gYTAyICogYjIwICsgYTEyICogYjIxICsgYTIyICogYjIyO1xuICAgIG91dFsxMV0gPSBhMDMgKiBiMjAgKyBhMTMgKiBiMjEgKyBhMjMgKiBiMjI7XG5cbiAgICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIGxhc3Qgcm93XG4gICAgICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn07IiwibW9kdWxlLmV4cG9ydHMgPSByb3RhdGVYO1xuXG4vKipcbiAqIFJvdGF0ZXMgYSBtYXRyaXggYnkgdGhlIGdpdmVuIGFuZ2xlIGFyb3VuZCB0aGUgWCBheGlzXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHJvdGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHJhZCB0aGUgYW5nbGUgdG8gcm90YXRlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gcm90YXRlWChvdXQsIGEsIHJhZCkge1xuICAgIHZhciBzID0gTWF0aC5zaW4ocmFkKSxcbiAgICAgICAgYyA9IE1hdGguY29zKHJhZCksXG4gICAgICAgIGExMCA9IGFbNF0sXG4gICAgICAgIGExMSA9IGFbNV0sXG4gICAgICAgIGExMiA9IGFbNl0sXG4gICAgICAgIGExMyA9IGFbN10sXG4gICAgICAgIGEyMCA9IGFbOF0sXG4gICAgICAgIGEyMSA9IGFbOV0sXG4gICAgICAgIGEyMiA9IGFbMTBdLFxuICAgICAgICBhMjMgPSBhWzExXTtcblxuICAgIGlmIChhICE9PSBvdXQpIHsgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgcm93c1xuICAgICAgICBvdXRbMF0gID0gYVswXTtcbiAgICAgICAgb3V0WzFdICA9IGFbMV07XG4gICAgICAgIG91dFsyXSAgPSBhWzJdO1xuICAgICAgICBvdXRbM10gID0gYVszXTtcbiAgICAgICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cblxuICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbNF0gPSBhMTAgKiBjICsgYTIwICogcztcbiAgICBvdXRbNV0gPSBhMTEgKiBjICsgYTIxICogcztcbiAgICBvdXRbNl0gPSBhMTIgKiBjICsgYTIyICogcztcbiAgICBvdXRbN10gPSBhMTMgKiBjICsgYTIzICogcztcbiAgICBvdXRbOF0gPSBhMjAgKiBjIC0gYTEwICogcztcbiAgICBvdXRbOV0gPSBhMjEgKiBjIC0gYTExICogcztcbiAgICBvdXRbMTBdID0gYTIyICogYyAtIGExMiAqIHM7XG4gICAgb3V0WzExXSA9IGEyMyAqIGMgLSBhMTMgKiBzO1xuICAgIHJldHVybiBvdXQ7XG59OyIsIm1vZHVsZS5leHBvcnRzID0gcm90YXRlWTtcblxuLyoqXG4gKiBSb3RhdGVzIGEgbWF0cml4IGJ5IHRoZSBnaXZlbiBhbmdsZSBhcm91bmQgdGhlIFkgYXhpc1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byByb3RhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSByYWQgdGhlIGFuZ2xlIHRvIHJvdGF0ZSB0aGUgbWF0cml4IGJ5XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIHJvdGF0ZVkob3V0LCBhLCByYWQpIHtcbiAgICB2YXIgcyA9IE1hdGguc2luKHJhZCksXG4gICAgICAgIGMgPSBNYXRoLmNvcyhyYWQpLFxuICAgICAgICBhMDAgPSBhWzBdLFxuICAgICAgICBhMDEgPSBhWzFdLFxuICAgICAgICBhMDIgPSBhWzJdLFxuICAgICAgICBhMDMgPSBhWzNdLFxuICAgICAgICBhMjAgPSBhWzhdLFxuICAgICAgICBhMjEgPSBhWzldLFxuICAgICAgICBhMjIgPSBhWzEwXSxcbiAgICAgICAgYTIzID0gYVsxMV07XG5cbiAgICBpZiAoYSAhPT0gb3V0KSB7IC8vIElmIHRoZSBzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIGRpZmZlciwgY29weSB0aGUgdW5jaGFuZ2VkIHJvd3NcbiAgICAgICAgb3V0WzRdICA9IGFbNF07XG4gICAgICAgIG91dFs1XSAgPSBhWzVdO1xuICAgICAgICBvdXRbNl0gID0gYVs2XTtcbiAgICAgICAgb3V0WzddICA9IGFbN107XG4gICAgICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICB9XG5cbiAgICAvLyBQZXJmb3JtIGF4aXMtc3BlY2lmaWMgbWF0cml4IG11bHRpcGxpY2F0aW9uXG4gICAgb3V0WzBdID0gYTAwICogYyAtIGEyMCAqIHM7XG4gICAgb3V0WzFdID0gYTAxICogYyAtIGEyMSAqIHM7XG4gICAgb3V0WzJdID0gYTAyICogYyAtIGEyMiAqIHM7XG4gICAgb3V0WzNdID0gYTAzICogYyAtIGEyMyAqIHM7XG4gICAgb3V0WzhdID0gYTAwICogcyArIGEyMCAqIGM7XG4gICAgb3V0WzldID0gYTAxICogcyArIGEyMSAqIGM7XG4gICAgb3V0WzEwXSA9IGEwMiAqIHMgKyBhMjIgKiBjO1xuICAgIG91dFsxMV0gPSBhMDMgKiBzICsgYTIzICogYztcbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJvdGF0ZVo7XG5cbi8qKlxuICogUm90YXRlcyBhIG1hdHJpeCBieSB0aGUgZ2l2ZW4gYW5nbGUgYXJvdW5kIHRoZSBaIGF4aXNcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBtYXRyaXggdG8gcm90YXRlXG4gKiBAcGFyYW0ge051bWJlcn0gcmFkIHRoZSBhbmdsZSB0byByb3RhdGUgdGhlIG1hdHJpeCBieVxuICogQHJldHVybnMge21hdDR9IG91dFxuICovXG5mdW5jdGlvbiByb3RhdGVaKG91dCwgYSwgcmFkKSB7XG4gICAgdmFyIHMgPSBNYXRoLnNpbihyYWQpLFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKSxcbiAgICAgICAgYTAwID0gYVswXSxcbiAgICAgICAgYTAxID0gYVsxXSxcbiAgICAgICAgYTAyID0gYVsyXSxcbiAgICAgICAgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSxcbiAgICAgICAgYTExID0gYVs1XSxcbiAgICAgICAgYTEyID0gYVs2XSxcbiAgICAgICAgYTEzID0gYVs3XTtcblxuICAgIGlmIChhICE9PSBvdXQpIHsgLy8gSWYgdGhlIHNvdXJjZSBhbmQgZGVzdGluYXRpb24gZGlmZmVyLCBjb3B5IHRoZSB1bmNoYW5nZWQgbGFzdCByb3dcbiAgICAgICAgb3V0WzhdICA9IGFbOF07XG4gICAgICAgIG91dFs5XSAgPSBhWzldO1xuICAgICAgICBvdXRbMTBdID0gYVsxMF07XG4gICAgICAgIG91dFsxMV0gPSBhWzExXTtcbiAgICAgICAgb3V0WzEyXSA9IGFbMTJdO1xuICAgICAgICBvdXRbMTNdID0gYVsxM107XG4gICAgICAgIG91dFsxNF0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cblxuICAgIC8vIFBlcmZvcm0gYXhpcy1zcGVjaWZpYyBtYXRyaXggbXVsdGlwbGljYXRpb25cbiAgICBvdXRbMF0gPSBhMDAgKiBjICsgYTEwICogcztcbiAgICBvdXRbMV0gPSBhMDEgKiBjICsgYTExICogcztcbiAgICBvdXRbMl0gPSBhMDIgKiBjICsgYTEyICogcztcbiAgICBvdXRbM10gPSBhMDMgKiBjICsgYTEzICogcztcbiAgICBvdXRbNF0gPSBhMTAgKiBjIC0gYTAwICogcztcbiAgICBvdXRbNV0gPSBhMTEgKiBjIC0gYTAxICogcztcbiAgICBvdXRbNl0gPSBhMTIgKiBjIC0gYTAyICogcztcbiAgICBvdXRbN10gPSBhMTMgKiBjIC0gYTAzICogcztcbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHNjYWxlO1xuXG4vKipcbiAqIFNjYWxlcyB0aGUgbWF0NCBieSB0aGUgZGltZW5zaW9ucyBpbiB0aGUgZ2l2ZW4gdmVjM1xuICpcbiAqIEBwYXJhbSB7bWF0NH0gb3V0IHRoZSByZWNlaXZpbmcgbWF0cml4XG4gKiBAcGFyYW0ge21hdDR9IGEgdGhlIG1hdHJpeCB0byBzY2FsZVxuICogQHBhcmFtIHt2ZWMzfSB2IHRoZSB2ZWMzIHRvIHNjYWxlIHRoZSBtYXRyaXggYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqKi9cbmZ1bmN0aW9uIHNjYWxlKG91dCwgYSwgdikge1xuICAgIHZhciB4ID0gdlswXSwgeSA9IHZbMV0sIHogPSB2WzJdO1xuXG4gICAgb3V0WzBdID0gYVswXSAqIHg7XG4gICAgb3V0WzFdID0gYVsxXSAqIHg7XG4gICAgb3V0WzJdID0gYVsyXSAqIHg7XG4gICAgb3V0WzNdID0gYVszXSAqIHg7XG4gICAgb3V0WzRdID0gYVs0XSAqIHk7XG4gICAgb3V0WzVdID0gYVs1XSAqIHk7XG4gICAgb3V0WzZdID0gYVs2XSAqIHk7XG4gICAgb3V0WzddID0gYVs3XSAqIHk7XG4gICAgb3V0WzhdID0gYVs4XSAqIHo7XG4gICAgb3V0WzldID0gYVs5XSAqIHo7XG4gICAgb3V0WzEwXSA9IGFbMTBdICogejtcbiAgICBvdXRbMTFdID0gYVsxMV0gKiB6O1xuICAgIG91dFsxMl0gPSBhWzEyXTtcbiAgICBvdXRbMTNdID0gYVsxM107XG4gICAgb3V0WzE0XSA9IGFbMTRdO1xuICAgIG91dFsxNV0gPSBhWzE1XTtcbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHN0cjtcblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIGEgbWF0NFxuICpcbiAqIEBwYXJhbSB7bWF0NH0gbWF0IG1hdHJpeCB0byByZXByZXNlbnQgYXMgYSBzdHJpbmdcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgbWF0cml4XG4gKi9cbmZ1bmN0aW9uIHN0cihhKSB7XG4gICAgcmV0dXJuICdtYXQ0KCcgKyBhWzBdICsgJywgJyArIGFbMV0gKyAnLCAnICsgYVsyXSArICcsICcgKyBhWzNdICsgJywgJyArXG4gICAgICAgICAgICAgICAgICAgIGFbNF0gKyAnLCAnICsgYVs1XSArICcsICcgKyBhWzZdICsgJywgJyArIGFbN10gKyAnLCAnICtcbiAgICAgICAgICAgICAgICAgICAgYVs4XSArICcsICcgKyBhWzldICsgJywgJyArIGFbMTBdICsgJywgJyArIGFbMTFdICsgJywgJyArIFxuICAgICAgICAgICAgICAgICAgICBhWzEyXSArICcsICcgKyBhWzEzXSArICcsICcgKyBhWzE0XSArICcsICcgKyBhWzE1XSArICcpJztcbn07IiwibW9kdWxlLmV4cG9ydHMgPSB0cmFuc2xhdGU7XG5cbi8qKlxuICogVHJhbnNsYXRlIGEgbWF0NCBieSB0aGUgZ2l2ZW4gdmVjdG9yXG4gKlxuICogQHBhcmFtIHttYXQ0fSBvdXQgdGhlIHJlY2VpdmluZyBtYXRyaXhcbiAqIEBwYXJhbSB7bWF0NH0gYSB0aGUgbWF0cml4IHRvIHRyYW5zbGF0ZVxuICogQHBhcmFtIHt2ZWMzfSB2IHZlY3RvciB0byB0cmFuc2xhdGUgYnlcbiAqIEByZXR1cm5zIHttYXQ0fSBvdXRcbiAqL1xuZnVuY3Rpb24gdHJhbnNsYXRlKG91dCwgYSwgdikge1xuICAgIHZhciB4ID0gdlswXSwgeSA9IHZbMV0sIHogPSB2WzJdLFxuICAgICAgICBhMDAsIGEwMSwgYTAyLCBhMDMsXG4gICAgICAgIGExMCwgYTExLCBhMTIsIGExMyxcbiAgICAgICAgYTIwLCBhMjEsIGEyMiwgYTIzO1xuXG4gICAgaWYgKGEgPT09IG91dCkge1xuICAgICAgICBvdXRbMTJdID0gYVswXSAqIHggKyBhWzRdICogeSArIGFbOF0gKiB6ICsgYVsxMl07XG4gICAgICAgIG91dFsxM10gPSBhWzFdICogeCArIGFbNV0gKiB5ICsgYVs5XSAqIHogKyBhWzEzXTtcbiAgICAgICAgb3V0WzE0XSA9IGFbMl0gKiB4ICsgYVs2XSAqIHkgKyBhWzEwXSAqIHogKyBhWzE0XTtcbiAgICAgICAgb3V0WzE1XSA9IGFbM10gKiB4ICsgYVs3XSAqIHkgKyBhWzExXSAqIHogKyBhWzE1XTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBhMDAgPSBhWzBdOyBhMDEgPSBhWzFdOyBhMDIgPSBhWzJdOyBhMDMgPSBhWzNdO1xuICAgICAgICBhMTAgPSBhWzRdOyBhMTEgPSBhWzVdOyBhMTIgPSBhWzZdOyBhMTMgPSBhWzddO1xuICAgICAgICBhMjAgPSBhWzhdOyBhMjEgPSBhWzldOyBhMjIgPSBhWzEwXTsgYTIzID0gYVsxMV07XG5cbiAgICAgICAgb3V0WzBdID0gYTAwOyBvdXRbMV0gPSBhMDE7IG91dFsyXSA9IGEwMjsgb3V0WzNdID0gYTAzO1xuICAgICAgICBvdXRbNF0gPSBhMTA7IG91dFs1XSA9IGExMTsgb3V0WzZdID0gYTEyOyBvdXRbN10gPSBhMTM7XG4gICAgICAgIG91dFs4XSA9IGEyMDsgb3V0WzldID0gYTIxOyBvdXRbMTBdID0gYTIyOyBvdXRbMTFdID0gYTIzO1xuXG4gICAgICAgIG91dFsxMl0gPSBhMDAgKiB4ICsgYTEwICogeSArIGEyMCAqIHogKyBhWzEyXTtcbiAgICAgICAgb3V0WzEzXSA9IGEwMSAqIHggKyBhMTEgKiB5ICsgYTIxICogeiArIGFbMTNdO1xuICAgICAgICBvdXRbMTRdID0gYTAyICogeCArIGExMiAqIHkgKyBhMjIgKiB6ICsgYVsxNF07XG4gICAgICAgIG91dFsxNV0gPSBhMDMgKiB4ICsgYTEzICogeSArIGEyMyAqIHogKyBhWzE1XTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0O1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHRyYW5zcG9zZTtcblxuLyoqXG4gKiBUcmFuc3Bvc2UgdGhlIHZhbHVlcyBvZiBhIG1hdDRcbiAqXG4gKiBAcGFyYW0ge21hdDR9IG91dCB0aGUgcmVjZWl2aW5nIG1hdHJpeFxuICogQHBhcmFtIHttYXQ0fSBhIHRoZSBzb3VyY2UgbWF0cml4XG4gKiBAcmV0dXJucyB7bWF0NH0gb3V0XG4gKi9cbmZ1bmN0aW9uIHRyYW5zcG9zZShvdXQsIGEpIHtcbiAgICAvLyBJZiB3ZSBhcmUgdHJhbnNwb3Npbmcgb3Vyc2VsdmVzIHdlIGNhbiBza2lwIGEgZmV3IHN0ZXBzIGJ1dCBoYXZlIHRvIGNhY2hlIHNvbWUgdmFsdWVzXG4gICAgaWYgKG91dCA9PT0gYSkge1xuICAgICAgICB2YXIgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgICAgIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgICAgICAgICBhMjMgPSBhWzExXTtcblxuICAgICAgICBvdXRbMV0gPSBhWzRdO1xuICAgICAgICBvdXRbMl0gPSBhWzhdO1xuICAgICAgICBvdXRbM10gPSBhWzEyXTtcbiAgICAgICAgb3V0WzRdID0gYTAxO1xuICAgICAgICBvdXRbNl0gPSBhWzldO1xuICAgICAgICBvdXRbN10gPSBhWzEzXTtcbiAgICAgICAgb3V0WzhdID0gYTAyO1xuICAgICAgICBvdXRbOV0gPSBhMTI7XG4gICAgICAgIG91dFsxMV0gPSBhWzE0XTtcbiAgICAgICAgb3V0WzEyXSA9IGEwMztcbiAgICAgICAgb3V0WzEzXSA9IGExMztcbiAgICAgICAgb3V0WzE0XSA9IGEyMztcbiAgICB9IGVsc2Uge1xuICAgICAgICBvdXRbMF0gPSBhWzBdO1xuICAgICAgICBvdXRbMV0gPSBhWzRdO1xuICAgICAgICBvdXRbMl0gPSBhWzhdO1xuICAgICAgICBvdXRbM10gPSBhWzEyXTtcbiAgICAgICAgb3V0WzRdID0gYVsxXTtcbiAgICAgICAgb3V0WzVdID0gYVs1XTtcbiAgICAgICAgb3V0WzZdID0gYVs5XTtcbiAgICAgICAgb3V0WzddID0gYVsxM107XG4gICAgICAgIG91dFs4XSA9IGFbMl07XG4gICAgICAgIG91dFs5XSA9IGFbNl07XG4gICAgICAgIG91dFsxMF0gPSBhWzEwXTtcbiAgICAgICAgb3V0WzExXSA9IGFbMTRdO1xuICAgICAgICBvdXRbMTJdID0gYVszXTtcbiAgICAgICAgb3V0WzEzXSA9IGFbN107XG4gICAgICAgIG91dFsxNF0gPSBhWzExXTtcbiAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gb3V0O1xufTsiLCIndXNlIHN0cmljdCdcblxudmFyIG5kYXJyYXkgPSByZXF1aXJlKCduZGFycmF5JylcbnZhciBvcHMgICAgID0gcmVxdWlyZSgnbmRhcnJheS1vcHMnKVxudmFyIHBvb2wgICAgPSByZXF1aXJlKCd0eXBlZGFycmF5LXBvb2wnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVRleHR1cmUyRFxuXG52YXIgbGluZWFyVHlwZXMgPSBudWxsXG52YXIgZmlsdGVyVHlwZXMgPSBudWxsXG52YXIgd3JhcFR5cGVzICAgPSBudWxsXG5cbmZ1bmN0aW9uIGxhenlJbml0TGluZWFyVHlwZXMoZ2wpIHtcbiAgbGluZWFyVHlwZXMgPSBbXG4gICAgZ2wuTElORUFSLFxuICAgIGdsLk5FQVJFU1RfTUlQTUFQX0xJTkVBUixcbiAgICBnbC5MSU5FQVJfTUlQTUFQX05FQVJFU1QsXG4gICAgZ2wuTElORUFSX01JUE1BUF9ORUFSRVNUXG4gIF1cbiAgZmlsdGVyVHlwZXMgPSBbXG4gICAgZ2wuTkVBUkVTVCxcbiAgICBnbC5MSU5FQVIsXG4gICAgZ2wuTkVBUkVTVF9NSVBNQVBfTkVBUkVTVCxcbiAgICBnbC5ORUFSRVNUX01JUE1BUF9MSU5FQVIsXG4gICAgZ2wuTElORUFSX01JUE1BUF9ORUFSRVNULFxuICAgIGdsLkxJTkVBUl9NSVBNQVBfTElORUFSXG4gIF1cbiAgd3JhcFR5cGVzID0gW1xuICAgIGdsLlJFUEVBVCxcbiAgICBnbC5DTEFNUF9UT19FREdFLFxuICAgIGdsLk1JUlJPUkVEX1JFUEVBVFxuICBdXG59XG5cbmZ1bmN0aW9uIGFjY2VwdFRleHR1cmVET00gKG9iaikge1xuICByZXR1cm4gKFxuICAgICgndW5kZWZpbmVkJyAhPSB0eXBlb2YgSFRNTENhbnZhc0VsZW1lbnQgJiYgb2JqIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQpIHx8XG4gICAgKCd1bmRlZmluZWQnICE9IHR5cGVvZiBIVE1MSW1hZ2VFbGVtZW50ICYmIG9iaiBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpIHx8XG4gICAgKCd1bmRlZmluZWQnICE9IHR5cGVvZiBIVE1MVmlkZW9FbGVtZW50ICYmIG9iaiBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQpIHx8XG4gICAgKCd1bmRlZmluZWQnICE9IHR5cGVvZiBJbWFnZURhdGEgJiYgb2JqIGluc3RhbmNlb2YgSW1hZ2VEYXRhKSlcbn1cblxudmFyIGNvbnZlcnRGbG9hdFRvVWludDggPSBmdW5jdGlvbihvdXQsIGlucCkge1xuICBvcHMubXVscyhvdXQsIGlucCwgMjU1LjApXG59XG5cbmZ1bmN0aW9uIHJlc2hhcGVUZXh0dXJlKHRleCwgdywgaCkge1xuICB2YXIgZ2wgPSB0ZXguZ2xcbiAgdmFyIG1heFNpemUgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1RFWFRVUkVfU0laRSlcbiAgaWYodyA8IDAgfHwgdyA+IG1heFNpemUgfHwgaCA8IDAgfHwgaCA+IG1heFNpemUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXRleHR1cmUyZDogSW52YWxpZCB0ZXh0dXJlIHNpemUnKVxuICB9XG4gIHRleC5fc2hhcGUgPSBbdywgaF1cbiAgdGV4LmJpbmQoKVxuICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIHRleC5mb3JtYXQsIHcsIGgsIDAsIHRleC5mb3JtYXQsIHRleC50eXBlLCBudWxsKVxuICB0ZXguX21pcExldmVscyA9IFswXVxuICByZXR1cm4gdGV4XG59XG5cbmZ1bmN0aW9uIFRleHR1cmUyRChnbCwgaGFuZGxlLCB3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIHR5cGUpIHtcbiAgdGhpcy5nbCA9IGdsXG4gIHRoaXMuaGFuZGxlID0gaGFuZGxlXG4gIHRoaXMuZm9ybWF0ID0gZm9ybWF0XG4gIHRoaXMudHlwZSA9IHR5cGVcbiAgdGhpcy5fc2hhcGUgPSBbd2lkdGgsIGhlaWdodF1cbiAgdGhpcy5fbWlwTGV2ZWxzID0gWzBdXG4gIHRoaXMuX21hZ0ZpbHRlciA9IGdsLk5FQVJFU1RcbiAgdGhpcy5fbWluRmlsdGVyID0gZ2wuTkVBUkVTVFxuICB0aGlzLl93cmFwUyA9IGdsLkNMQU1QX1RPX0VER0VcbiAgdGhpcy5fd3JhcFQgPSBnbC5DTEFNUF9UT19FREdFXG4gIHRoaXMuX2FuaXNvU2FtcGxlcyA9IDFcblxuICB2YXIgcGFyZW50ID0gdGhpc1xuICB2YXIgd3JhcFZlY3RvciA9IFt0aGlzLl93cmFwUywgdGhpcy5fd3JhcFRdXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHdyYXBWZWN0b3IsIFtcbiAgICB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcGFyZW50Ll93cmFwU1xuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICByZXR1cm4gcGFyZW50LndyYXBTID0gdlxuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudC5fd3JhcFRcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudC53cmFwVCA9IHZcbiAgICAgIH1cbiAgICB9XG4gIF0pXG4gIHRoaXMuX3dyYXBWZWN0b3IgPSB3cmFwVmVjdG9yXG5cbiAgdmFyIHNoYXBlVmVjdG9yID0gW3RoaXMuX3NoYXBlWzBdLCB0aGlzLl9zaGFwZVsxXV1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoc2hhcGVWZWN0b3IsIFtcbiAgICB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcGFyZW50Ll9zaGFwZVswXVxuICAgICAgfSxcbiAgICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgICByZXR1cm4gcGFyZW50LndpZHRoID0gdlxuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudC5fc2hhcGVbMV1cbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudC5oZWlnaHQgPSB2XG4gICAgICB9XG4gICAgfVxuICBdKVxuICB0aGlzLl9zaGFwZVZlY3RvciA9IHNoYXBlVmVjdG9yXG59XG5cbnZhciBwcm90byA9IFRleHR1cmUyRC5wcm90b3R5cGVcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMocHJvdG8sIHtcbiAgbWluRmlsdGVyOiB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9taW5GaWx0ZXJcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24odikge1xuICAgICAgdGhpcy5iaW5kKClcbiAgICAgIHZhciBnbCA9IHRoaXMuZ2xcbiAgICAgIGlmKHRoaXMudHlwZSA9PT0gZ2wuRkxPQVQgJiYgbGluZWFyVHlwZXMuaW5kZXhPZih2KSA+PSAwKSB7XG4gICAgICAgIGlmKCFnbC5nZXRFeHRlbnNpb24oJ09FU190ZXh0dXJlX2Zsb2F0X2xpbmVhcicpKSB7XG4gICAgICAgICAgdiA9IGdsLk5FQVJFU1RcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYoZmlsdGVyVHlwZXMuaW5kZXhPZih2KSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnbC10ZXh0dXJlMmQ6IFVua25vd24gZmlsdGVyIG1vZGUgJyArIHYpXG4gICAgICB9XG4gICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgdilcbiAgICAgIHJldHVybiB0aGlzLl9taW5GaWx0ZXIgPSB2XG4gICAgfVxuICB9LFxuICBtYWdGaWx0ZXI6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX21hZ0ZpbHRlclxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICB0aGlzLmJpbmQoKVxuICAgICAgdmFyIGdsID0gdGhpcy5nbFxuICAgICAgaWYodGhpcy50eXBlID09PSBnbC5GTE9BVCAmJiBsaW5lYXJUeXBlcy5pbmRleE9mKHYpID49IDApIHtcbiAgICAgICAgaWYoIWdsLmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXRfbGluZWFyJykpIHtcbiAgICAgICAgICB2ID0gZ2wuTkVBUkVTVFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZihmaWx0ZXJUeXBlcy5pbmRleE9mKHYpIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXRleHR1cmUyZDogVW5rbm93biBmaWx0ZXIgbW9kZSAnICsgdilcbiAgICAgIH1cbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCB2KVxuICAgICAgcmV0dXJuIHRoaXMuX21hZ0ZpbHRlciA9IHZcbiAgICB9XG4gIH0sXG4gIG1pcFNhbXBsZXM6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FuaXNvU2FtcGxlc1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbihpKSB7XG4gICAgICB2YXIgcHNhbXBsZXMgPSB0aGlzLl9hbmlzb1NhbXBsZXNcbiAgICAgIHRoaXMuX2FuaXNvU2FtcGxlcyA9IE1hdGgubWF4KGksIDEpfDBcbiAgICAgIGlmKHBzYW1wbGVzICE9PSB0aGlzLl9hbmlzb1NhbXBsZXMpIHtcbiAgICAgICAgdmFyIGV4dCA9IHRoaXMuZ2wuZ2V0RXh0ZW5zaW9uKCdFWFRfdGV4dHVyZV9maWx0ZXJfYW5pc290cm9waWMnKVxuICAgICAgICBpZihleHQpIHtcbiAgICAgICAgICB0aGlzLmdsLnRleFBhcmFtZXRlcmYodGhpcy5nbC5URVhUVVJFXzJELCBleHQuVEVYVFVSRV9NQVhfQU5JU09UUk9QWV9FWFQsIHRoaXMuX2FuaXNvU2FtcGxlcylcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX2FuaXNvU2FtcGxlc1xuICAgIH1cbiAgfSxcbiAgd3JhcFM6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3dyYXBTXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIHRoaXMuYmluZCgpXG4gICAgICBpZih3cmFwVHlwZXMuaW5kZXhPZih2KSA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnbC10ZXh0dXJlMmQ6IFVua25vd24gd3JhcCBtb2RlICcgKyB2KVxuICAgICAgfVxuICAgICAgdGhpcy5nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuZ2wuVEVYVFVSRV8yRCwgdGhpcy5nbC5URVhUVVJFX1dSQVBfUywgdilcbiAgICAgIHJldHVybiB0aGlzLl93cmFwUyA9IHZcbiAgICB9XG4gIH0sXG4gIHdyYXBUOiB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl93cmFwVFxuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2KSB7XG4gICAgICB0aGlzLmJpbmQoKVxuICAgICAgaWYod3JhcFR5cGVzLmluZGV4T2YodikgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZ2wtdGV4dHVyZTJkOiBVbmtub3duIHdyYXAgbW9kZSAnICsgdilcbiAgICAgIH1cbiAgICAgIHRoaXMuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRoaXMuZ2wuVEVYVFVSRV9XUkFQX1QsIHYpXG4gICAgICByZXR1cm4gdGhpcy5fd3JhcFQgPSB2XG4gICAgfVxuICB9LFxuICB3cmFwOiB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl93cmFwVmVjdG9yXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHYpIHtcbiAgICAgIGlmKCFBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICAgIHYgPSBbdix2XVxuICAgICAgfVxuICAgICAgaWYodi5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdnbC10ZXh0dXJlMmQ6IE11c3Qgc3BlY2lmeSB3cmFwIG1vZGUgZm9yIHJvd3MgYW5kIGNvbHVtbnMnKVxuICAgICAgfVxuICAgICAgZm9yKHZhciBpPTA7IGk8MjsgKytpKSB7XG4gICAgICAgIGlmKHdyYXBUeXBlcy5pbmRleE9mKHZbaV0pIDwgMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZ2wtdGV4dHVyZTJkOiBVbmtub3duIHdyYXAgbW9kZSAnICsgdilcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fd3JhcFMgPSB2WzBdXG4gICAgICB0aGlzLl93cmFwVCA9IHZbMV1cblxuICAgICAgdmFyIGdsID0gdGhpcy5nbFxuICAgICAgdGhpcy5iaW5kKClcbiAgICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIHRoaXMuX3dyYXBTKVxuICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgdGhpcy5fd3JhcFQpXG5cbiAgICAgIHJldHVybiB2XG4gICAgfVxuICB9LFxuICBzaGFwZToge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2hhcGVWZWN0b3JcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24oeCkge1xuICAgICAgaWYoIUFycmF5LmlzQXJyYXkoeCkpIHtcbiAgICAgICAgeCA9IFt4fDAseHwwXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYoeC5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXRleHR1cmUyZDogSW52YWxpZCB0ZXh0dXJlIHNoYXBlJylcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzaGFwZVRleHR1cmUodGhpcywgeFswXXwwLCB4WzFdfDApXG4gICAgICByZXR1cm4gW3hbMF18MCwgeFsxXXwwXVxuICAgIH1cbiAgfSxcbiAgd2lkdGg6IHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NoYXBlWzBdXG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uKHcpIHtcbiAgICAgIHcgPSB3fDBcbiAgICAgIHJlc2hhcGVUZXh0dXJlKHRoaXMsIHcsIHRoaXMuX3NoYXBlWzFdKVxuICAgICAgcmV0dXJuIHdcbiAgICB9XG4gIH0sXG4gIGhlaWdodDoge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2hhcGVbMV1cbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24oaCkge1xuICAgICAgaCA9IGh8MFxuICAgICAgcmVzaGFwZVRleHR1cmUodGhpcywgdGhpcy5fc2hhcGVbMF0sIGgpXG4gICAgICByZXR1cm4gaFxuICAgIH1cbiAgfVxufSlcblxucHJvdG8uYmluZCA9IGZ1bmN0aW9uKHVuaXQpIHtcbiAgdmFyIGdsID0gdGhpcy5nbFxuICBpZih1bml0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBnbC5hY3RpdmVUZXh0dXJlKGdsLlRFWFRVUkUwICsgKHVuaXR8MCkpXG4gIH1cbiAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGhpcy5oYW5kbGUpXG4gIGlmKHVuaXQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAodW5pdHwwKVxuICB9XG4gIHJldHVybiBnbC5nZXRQYXJhbWV0ZXIoZ2wuQUNUSVZFX1RFWFRVUkUpIC0gZ2wuVEVYVFVSRTBcbn1cblxucHJvdG8uZGlzcG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLmdsLmRlbGV0ZVRleHR1cmUodGhpcy5oYW5kbGUpXG59XG5cbnByb3RvLmdlbmVyYXRlTWlwbWFwID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuYmluZCgpXG4gIHRoaXMuZ2wuZ2VuZXJhdGVNaXBtYXAodGhpcy5nbC5URVhUVVJFXzJEKVxuXG4gIC8vVXBkYXRlIG1pcCBsZXZlbHNcbiAgdmFyIGwgPSBNYXRoLm1pbih0aGlzLl9zaGFwZVswXSwgdGhpcy5fc2hhcGVbMV0pXG4gIGZvcih2YXIgaT0wOyBsPjA7ICsraSwgbD4+Pj0xKSB7XG4gICAgaWYodGhpcy5fbWlwTGV2ZWxzLmluZGV4T2YoaSkgPCAwKSB7XG4gICAgICB0aGlzLl9taXBMZXZlbHMucHVzaChpKVxuICAgIH1cbiAgfVxufVxuXG5wcm90by5zZXRQaXhlbHMgPSBmdW5jdGlvbihkYXRhLCB4X29mZiwgeV9vZmYsIG1pcF9sZXZlbCkge1xuICB2YXIgZ2wgPSB0aGlzLmdsXG4gIHRoaXMuYmluZCgpXG4gIGlmKEFycmF5LmlzQXJyYXkoeF9vZmYpKSB7XG4gICAgbWlwX2xldmVsID0geV9vZmZcbiAgICB5X29mZiA9IHhfb2ZmWzFdfDBcbiAgICB4X29mZiA9IHhfb2ZmWzBdfDBcbiAgfSBlbHNlIHtcbiAgICB4X29mZiA9IHhfb2ZmIHx8IDBcbiAgICB5X29mZiA9IHlfb2ZmIHx8IDBcbiAgfVxuICBtaXBfbGV2ZWwgPSBtaXBfbGV2ZWwgfHwgMFxuICB2YXIgZGlyZWN0RGF0YSA9IGFjY2VwdFRleHR1cmVET00oZGF0YSkgPyBkYXRhIDogZGF0YS5yYXdcbiAgaWYoZGlyZWN0RGF0YSkge1xuICAgIHZhciBuZWVkc01pcCA9IHRoaXMuX21pcExldmVscy5pbmRleE9mKG1pcF9sZXZlbCkgPCAwXG4gICAgaWYobmVlZHNNaXApIHtcbiAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgMCwgdGhpcy5mb3JtYXQsIHRoaXMuZm9ybWF0LCB0aGlzLnR5cGUsIGRpcmVjdERhdGEpXG4gICAgICB0aGlzLl9taXBMZXZlbHMucHVzaChtaXBfbGV2ZWwpXG4gICAgfSBlbHNlIHtcbiAgICAgIGdsLnRleFN1YkltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgbWlwX2xldmVsLCB4X29mZiwgeV9vZmYsIHRoaXMuZm9ybWF0LCB0aGlzLnR5cGUsIGRpcmVjdERhdGEpXG4gICAgfVxuICB9IGVsc2UgaWYoZGF0YS5zaGFwZSAmJiBkYXRhLnN0cmlkZSAmJiBkYXRhLmRhdGEpIHtcbiAgICBpZihkYXRhLnNoYXBlLmxlbmd0aCA8IDIgfHxcbiAgICAgICB4X29mZiArIGRhdGEuc2hhcGVbMV0gPiB0aGlzLl9zaGFwZVsxXT4+Pm1pcF9sZXZlbCB8fFxuICAgICAgIHlfb2ZmICsgZGF0YS5zaGFwZVswXSA+IHRoaXMuX3NoYXBlWzBdPj4+bWlwX2xldmVsIHx8XG4gICAgICAgeF9vZmYgPCAwIHx8XG4gICAgICAgeV9vZmYgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXRleHR1cmUyZDogVGV4dHVyZSBkaW1lbnNpb25zIGFyZSBvdXQgb2YgYm91bmRzJylcbiAgICB9XG4gICAgdGV4U3ViSW1hZ2VBcnJheShnbCwgeF9vZmYsIHlfb2ZmLCBtaXBfbGV2ZWwsIHRoaXMuZm9ybWF0LCB0aGlzLnR5cGUsIHRoaXMuX21pcExldmVscywgZGF0YSlcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXRleHR1cmUyZDogVW5zdXBwb3J0ZWQgZGF0YSB0eXBlJylcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGlzUGFja2VkKHNoYXBlLCBzdHJpZGUpIHtcbiAgaWYoc2hhcGUubGVuZ3RoID09PSAzKSB7XG4gICAgcmV0dXJuICAoc3RyaWRlWzJdID09PSAxKSAmJlxuICAgICAgICAgICAgKHN0cmlkZVsxXSA9PT0gc2hhcGVbMF0qc2hhcGVbMl0pICYmXG4gICAgICAgICAgICAoc3RyaWRlWzBdID09PSBzaGFwZVsyXSlcbiAgfVxuICByZXR1cm4gIChzdHJpZGVbMF0gPT09IDEpICYmXG4gICAgICAgICAgKHN0cmlkZVsxXSA9PT0gc2hhcGVbMF0pXG59XG5cbmZ1bmN0aW9uIHRleFN1YkltYWdlQXJyYXkoZ2wsIHhfb2ZmLCB5X29mZiwgbWlwX2xldmVsLCBjZm9ybWF0LCBjdHlwZSwgbWlwTGV2ZWxzLCBhcnJheSkge1xuICB2YXIgZHR5cGUgPSBhcnJheS5kdHlwZVxuICB2YXIgc2hhcGUgPSBhcnJheS5zaGFwZS5zbGljZSgpXG4gIGlmKHNoYXBlLmxlbmd0aCA8IDIgfHwgc2hhcGUubGVuZ3RoID4gMykge1xuICAgIHRocm93IG5ldyBFcnJvcignZ2wtdGV4dHVyZTJkOiBJbnZhbGlkIG5kYXJyYXksIG11c3QgYmUgMmQgb3IgM2QnKVxuICB9XG4gIHZhciB0eXBlID0gMCwgZm9ybWF0ID0gMFxuICB2YXIgcGFja2VkID0gaXNQYWNrZWQoc2hhcGUsIGFycmF5LnN0cmlkZS5zbGljZSgpKVxuICBpZihkdHlwZSA9PT0gJ2Zsb2F0MzInKSB7XG4gICAgdHlwZSA9IGdsLkZMT0FUXG4gIH0gZWxzZSBpZihkdHlwZSA9PT0gJ2Zsb2F0NjQnKSB7XG4gICAgdHlwZSA9IGdsLkZMT0FUXG4gICAgcGFja2VkID0gZmFsc2VcbiAgICBkdHlwZSA9ICdmbG9hdDMyJ1xuICB9IGVsc2UgaWYoZHR5cGUgPT09ICd1aW50OCcpIHtcbiAgICB0eXBlID0gZ2wuVU5TSUdORURfQllURVxuICB9IGVsc2Uge1xuICAgIHR5cGUgPSBnbC5VTlNJR05FRF9CWVRFXG4gICAgcGFja2VkID0gZmFsc2VcbiAgICBkdHlwZSA9ICd1aW50OCdcbiAgfVxuICB2YXIgY2hhbm5lbHMgPSAxXG4gIGlmKHNoYXBlLmxlbmd0aCA9PT0gMikge1xuICAgIGZvcm1hdCA9IGdsLkxVTUlOQU5DRVxuICAgIHNoYXBlID0gW3NoYXBlWzBdLCBzaGFwZVsxXSwgMV1cbiAgICBhcnJheSA9IG5kYXJyYXkoYXJyYXkuZGF0YSwgc2hhcGUsIFthcnJheS5zdHJpZGVbMF0sIGFycmF5LnN0cmlkZVsxXSwgMV0sIGFycmF5Lm9mZnNldClcbiAgfSBlbHNlIGlmKHNoYXBlLmxlbmd0aCA9PT0gMykge1xuICAgIGlmKHNoYXBlWzJdID09PSAxKSB7XG4gICAgICBmb3JtYXQgPSBnbC5BTFBIQVxuICAgIH0gZWxzZSBpZihzaGFwZVsyXSA9PT0gMikge1xuICAgICAgZm9ybWF0ID0gZ2wuTFVNSU5BTkNFX0FMUEhBXG4gICAgfSBlbHNlIGlmKHNoYXBlWzJdID09PSAzKSB7XG4gICAgICBmb3JtYXQgPSBnbC5SR0JcbiAgICB9IGVsc2UgaWYoc2hhcGVbMl0gPT09IDQpIHtcbiAgICAgIGZvcm1hdCA9IGdsLlJHQkFcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdnbC10ZXh0dXJlMmQ6IEludmFsaWQgc2hhcGUgZm9yIHBpeGVsIGNvb3JkcycpXG4gICAgfVxuICAgIGNoYW5uZWxzID0gc2hhcGVbMl1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXRleHR1cmUyZDogSW52YWxpZCBzaGFwZSBmb3IgdGV4dHVyZScpXG4gIH1cbiAgLy9Gb3IgMS1jaGFubmVsIHRleHR1cmVzIGFsbG93IGNvbnZlcnNpb24gYmV0d2VlbiBmb3JtYXRzXG4gIGlmKChmb3JtYXQgID09PSBnbC5MVU1JTkFOQ0UgfHwgZm9ybWF0ICA9PT0gZ2wuQUxQSEEpICYmXG4gICAgIChjZm9ybWF0ID09PSBnbC5MVU1JTkFOQ0UgfHwgY2Zvcm1hdCA9PT0gZ2wuQUxQSEEpKSB7XG4gICAgZm9ybWF0ID0gY2Zvcm1hdFxuICB9XG4gIGlmKGZvcm1hdCAhPT0gY2Zvcm1hdCkge1xuICAgIHRocm93IG5ldyBFcnJvcignZ2wtdGV4dHVyZTJkOiBJbmNvbXBhdGlibGUgdGV4dHVyZSBmb3JtYXQgZm9yIHNldFBpeGVscycpXG4gIH1cbiAgdmFyIHNpemUgPSBhcnJheS5zaXplXG4gIHZhciBuZWVkc01pcCA9IG1pcExldmVscy5pbmRleE9mKG1pcF9sZXZlbCkgPCAwXG4gIGlmKG5lZWRzTWlwKSB7XG4gICAgbWlwTGV2ZWxzLnB1c2gobWlwX2xldmVsKVxuICB9XG4gIGlmKHR5cGUgPT09IGN0eXBlICYmIHBhY2tlZCkge1xuICAgIC8vQXJyYXkgZGF0YSB0eXBlcyBhcmUgY29tcGF0aWJsZSwgY2FuIGRpcmVjdGx5IGNvcHkgaW50byB0ZXh0dXJlXG4gICAgaWYoYXJyYXkub2Zmc2V0ID09PSAwICYmIGFycmF5LmRhdGEubGVuZ3RoID09PSBzaXplKSB7XG4gICAgICBpZihuZWVkc01pcCkge1xuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIG1pcF9sZXZlbCwgY2Zvcm1hdCwgc2hhcGVbMF0sIHNoYXBlWzFdLCAwLCBjZm9ybWF0LCBjdHlwZSwgYXJyYXkuZGF0YSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdsLnRleFN1YkltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgbWlwX2xldmVsLCB4X29mZiwgeV9vZmYsIHNoYXBlWzBdLCBzaGFwZVsxXSwgY2Zvcm1hdCwgY3R5cGUsIGFycmF5LmRhdGEpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmKG5lZWRzTWlwKSB7XG4gICAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgbWlwX2xldmVsLCBjZm9ybWF0LCBzaGFwZVswXSwgc2hhcGVbMV0sIDAsIGNmb3JtYXQsIGN0eXBlLCBhcnJheS5kYXRhLnN1YmFycmF5KGFycmF5Lm9mZnNldCwgYXJyYXkub2Zmc2V0K3NpemUpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2wudGV4U3ViSW1hZ2UyRChnbC5URVhUVVJFXzJELCBtaXBfbGV2ZWwsIHhfb2ZmLCB5X29mZiwgc2hhcGVbMF0sIHNoYXBlWzFdLCBjZm9ybWF0LCBjdHlwZSwgYXJyYXkuZGF0YS5zdWJhcnJheShhcnJheS5vZmZzZXQsIGFycmF5Lm9mZnNldCtzaXplKSlcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy9OZWVkIHRvIGRvIHR5cGUgY29udmVyc2lvbiB0byBwYWNrIGRhdGEgaW50byBidWZmZXJcbiAgICB2YXIgcGFja19idWZmZXJcbiAgICBpZihjdHlwZSA9PT0gZ2wuRkxPQVQpIHtcbiAgICAgIHBhY2tfYnVmZmVyID0gcG9vbC5tYWxsb2NGbG9hdDMyKHNpemUpXG4gICAgfSBlbHNlIHtcbiAgICAgIHBhY2tfYnVmZmVyID0gcG9vbC5tYWxsb2NVaW50OChzaXplKVxuICAgIH1cbiAgICB2YXIgcGFja192aWV3ID0gbmRhcnJheShwYWNrX2J1ZmZlciwgc2hhcGUsIFtzaGFwZVsyXSwgc2hhcGVbMl0qc2hhcGVbMF0sIDFdKVxuICAgIGlmKHR5cGUgPT09IGdsLkZMT0FUICYmIGN0eXBlID09PSBnbC5VTlNJR05FRF9CWVRFKSB7XG4gICAgICBjb252ZXJ0RmxvYXRUb1VpbnQ4KHBhY2tfdmlldywgYXJyYXkpXG4gICAgfSBlbHNlIHtcbiAgICAgIG9wcy5hc3NpZ24ocGFja192aWV3LCBhcnJheSlcbiAgICB9XG4gICAgaWYobmVlZHNNaXApIHtcbiAgICAgIGdsLnRleEltYWdlMkQoZ2wuVEVYVFVSRV8yRCwgbWlwX2xldmVsLCBjZm9ybWF0LCBzaGFwZVswXSwgc2hhcGVbMV0sIDAsIGNmb3JtYXQsIGN0eXBlLCBwYWNrX2J1ZmZlci5zdWJhcnJheSgwLCBzaXplKSlcbiAgICB9IGVsc2Uge1xuICAgICAgZ2wudGV4U3ViSW1hZ2UyRChnbC5URVhUVVJFXzJELCBtaXBfbGV2ZWwsIHhfb2ZmLCB5X29mZiwgc2hhcGVbMF0sIHNoYXBlWzFdLCBjZm9ybWF0LCBjdHlwZSwgcGFja19idWZmZXIuc3ViYXJyYXkoMCwgc2l6ZSkpXG4gICAgfVxuICAgIGlmKGN0eXBlID09PSBnbC5GTE9BVCkge1xuICAgICAgcG9vbC5mcmVlRmxvYXQzMihwYWNrX2J1ZmZlcilcbiAgICB9IGVsc2Uge1xuICAgICAgcG9vbC5mcmVlVWludDgocGFja19idWZmZXIpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRUZXh0dXJlKGdsKSB7XG4gIHZhciB0ZXggPSBnbC5jcmVhdGVUZXh0dXJlKClcbiAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4KVxuICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZ2wuTkVBUkVTVClcbiAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX01BR19GSUxURVIsIGdsLk5FQVJFU1QpXG4gIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1MsIGdsLkNMQU1QX1RPX0VER0UpXG4gIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9XUkFQX1QsIGdsLkNMQU1QX1RPX0VER0UpXG4gIHJldHVybiB0ZXhcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGV4dHVyZVNoYXBlKGdsLCB3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIHR5cGUpIHtcbiAgdmFyIG1heFRleHR1cmVTaXplID0gZ2wuZ2V0UGFyYW1ldGVyKGdsLk1BWF9URVhUVVJFX1NJWkUpXG4gIGlmKHdpZHRoIDwgMCB8fCB3aWR0aCA+IG1heFRleHR1cmVTaXplIHx8IGhlaWdodCA8IDAgfHwgaGVpZ2h0ICA+IG1heFRleHR1cmVTaXplKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdnbC10ZXh0dXJlMmQ6IEludmFsaWQgdGV4dHVyZSBzaGFwZScpXG4gIH1cbiAgaWYodHlwZSA9PT0gZ2wuRkxPQVQgJiYgIWdsLmdldEV4dGVuc2lvbignT0VTX3RleHR1cmVfZmxvYXQnKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignZ2wtdGV4dHVyZTJkOiBGbG9hdGluZyBwb2ludCB0ZXh0dXJlcyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgcGxhdGZvcm0nKVxuICB9XG4gIHZhciB0ZXggPSBpbml0VGV4dHVyZShnbClcbiAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBmb3JtYXQsIHdpZHRoLCBoZWlnaHQsIDAsIGZvcm1hdCwgdHlwZSwgbnVsbClcbiAgcmV0dXJuIG5ldyBUZXh0dXJlMkQoZ2wsIHRleCwgd2lkdGgsIGhlaWdodCwgZm9ybWF0LCB0eXBlKVxufVxuXG5mdW5jdGlvbiBjcmVhdGVUZXh0dXJlRE9NKGdsLCBkaXJlY3REYXRhLCB3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIHR5cGUpIHtcbiAgdmFyIHRleCA9IGluaXRUZXh0dXJlKGdsKVxuICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGZvcm1hdCwgZm9ybWF0LCB0eXBlLCBkaXJlY3REYXRhKVxuICByZXR1cm4gbmV3IFRleHR1cmUyRChnbCwgdGV4LCB3aWR0aCwgaGVpZ2h0LCBmb3JtYXQsIHR5cGUpXG59XG5cbi8vQ3JlYXRlcyBhIHRleHR1cmUgZnJvbSBhbiBuZGFycmF5XG5mdW5jdGlvbiBjcmVhdGVUZXh0dXJlQXJyYXkoZ2wsIGFycmF5KSB7XG4gIHZhciBkdHlwZSA9IGFycmF5LmR0eXBlXG4gIHZhciBzaGFwZSA9IGFycmF5LnNoYXBlLnNsaWNlKClcbiAgdmFyIG1heFNpemUgPSBnbC5nZXRQYXJhbWV0ZXIoZ2wuTUFYX1RFWFRVUkVfU0laRSlcbiAgaWYoc2hhcGVbMF0gPCAwIHx8IHNoYXBlWzBdID4gbWF4U2l6ZSB8fCBzaGFwZVsxXSA8IDAgfHwgc2hhcGVbMV0gPiBtYXhTaXplKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdnbC10ZXh0dXJlMmQ6IEludmFsaWQgdGV4dHVyZSBzaXplJylcbiAgfVxuICB2YXIgcGFja2VkID0gaXNQYWNrZWQoc2hhcGUsIGFycmF5LnN0cmlkZS5zbGljZSgpKVxuICB2YXIgdHlwZSA9IDBcbiAgaWYoZHR5cGUgPT09ICdmbG9hdDMyJykge1xuICAgIHR5cGUgPSBnbC5GTE9BVFxuICB9IGVsc2UgaWYoZHR5cGUgPT09ICdmbG9hdDY0Jykge1xuICAgIHR5cGUgPSBnbC5GTE9BVFxuICAgIHBhY2tlZCA9IGZhbHNlXG4gICAgZHR5cGUgPSAnZmxvYXQzMidcbiAgfSBlbHNlIGlmKGR0eXBlID09PSAndWludDgnKSB7XG4gICAgdHlwZSA9IGdsLlVOU0lHTkVEX0JZVEVcbiAgfSBlbHNlIHtcbiAgICB0eXBlID0gZ2wuVU5TSUdORURfQllURVxuICAgIHBhY2tlZCA9IGZhbHNlXG4gICAgZHR5cGUgPSAndWludDgnXG4gIH1cbiAgdmFyIGZvcm1hdCA9IDBcbiAgaWYoc2hhcGUubGVuZ3RoID09PSAyKSB7XG4gICAgZm9ybWF0ID0gZ2wuTFVNSU5BTkNFXG4gICAgc2hhcGUgPSBbc2hhcGVbMF0sIHNoYXBlWzFdLCAxXVxuICAgIGFycmF5ID0gbmRhcnJheShhcnJheS5kYXRhLCBzaGFwZSwgW2FycmF5LnN0cmlkZVswXSwgYXJyYXkuc3RyaWRlWzFdLCAxXSwgYXJyYXkub2Zmc2V0KVxuICB9IGVsc2UgaWYoc2hhcGUubGVuZ3RoID09PSAzKSB7XG4gICAgaWYoc2hhcGVbMl0gPT09IDEpIHtcbiAgICAgIGZvcm1hdCA9IGdsLkFMUEhBXG4gICAgfSBlbHNlIGlmKHNoYXBlWzJdID09PSAyKSB7XG4gICAgICBmb3JtYXQgPSBnbC5MVU1JTkFOQ0VfQUxQSEFcbiAgICB9IGVsc2UgaWYoc2hhcGVbMl0gPT09IDMpIHtcbiAgICAgIGZvcm1hdCA9IGdsLlJHQlxuICAgIH0gZWxzZSBpZihzaGFwZVsyXSA9PT0gNCkge1xuICAgICAgZm9ybWF0ID0gZ2wuUkdCQVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXRleHR1cmUyZDogSW52YWxpZCBzaGFwZSBmb3IgcGl4ZWwgY29vcmRzJylcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdnbC10ZXh0dXJlMmQ6IEludmFsaWQgc2hhcGUgZm9yIHRleHR1cmUnKVxuICB9XG4gIGlmKHR5cGUgPT09IGdsLkZMT0FUICYmICFnbC5nZXRFeHRlbnNpb24oJ09FU190ZXh0dXJlX2Zsb2F0JykpIHtcbiAgICB0eXBlID0gZ2wuVU5TSUdORURfQllURVxuICAgIHBhY2tlZCA9IGZhbHNlXG4gIH1cbiAgdmFyIGJ1ZmZlciwgYnVmX3N0b3JlXG4gIHZhciBzaXplID0gYXJyYXkuc2l6ZVxuICBpZighcGFja2VkKSB7XG4gICAgdmFyIHN0cmlkZSA9IFtzaGFwZVsyXSwgc2hhcGVbMl0qc2hhcGVbMF0sIDFdXG4gICAgYnVmX3N0b3JlID0gcG9vbC5tYWxsb2Moc2l6ZSwgZHR5cGUpXG4gICAgdmFyIGJ1Zl9hcnJheSA9IG5kYXJyYXkoYnVmX3N0b3JlLCBzaGFwZSwgc3RyaWRlLCAwKVxuICAgIGlmKChkdHlwZSA9PT0gJ2Zsb2F0MzInIHx8IGR0eXBlID09PSAnZmxvYXQ2NCcpICYmIHR5cGUgPT09IGdsLlVOU0lHTkVEX0JZVEUpIHtcbiAgICAgIGNvbnZlcnRGbG9hdFRvVWludDgoYnVmX2FycmF5LCBhcnJheSlcbiAgICB9IGVsc2Uge1xuICAgICAgb3BzLmFzc2lnbihidWZfYXJyYXksIGFycmF5KVxuICAgIH1cbiAgICBidWZmZXIgPSBidWZfc3RvcmUuc3ViYXJyYXkoMCwgc2l6ZSlcbiAgfSBlbHNlIGlmIChhcnJheS5vZmZzZXQgPT09IDAgJiYgYXJyYXkuZGF0YS5sZW5ndGggPT09IHNpemUpIHtcbiAgICBidWZmZXIgPSBhcnJheS5kYXRhXG4gIH0gZWxzZSB7XG4gICAgYnVmZmVyID0gYXJyYXkuZGF0YS5zdWJhcnJheShhcnJheS5vZmZzZXQsIGFycmF5Lm9mZnNldCArIHNpemUpXG4gIH1cbiAgdmFyIHRleCA9IGluaXRUZXh0dXJlKGdsKVxuICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGZvcm1hdCwgc2hhcGVbMF0sIHNoYXBlWzFdLCAwLCBmb3JtYXQsIHR5cGUsIGJ1ZmZlcilcbiAgaWYoIXBhY2tlZCkge1xuICAgIHBvb2wuZnJlZShidWZfc3RvcmUpXG4gIH1cbiAgcmV0dXJuIG5ldyBUZXh0dXJlMkQoZ2wsIHRleCwgc2hhcGVbMF0sIHNoYXBlWzFdLCBmb3JtYXQsIHR5cGUpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHR1cmUyRChnbCkge1xuICBpZihhcmd1bWVudHMubGVuZ3RoIDw9IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2dsLXRleHR1cmUyZDogTWlzc2luZyBhcmd1bWVudHMgZm9yIHRleHR1cmUyZCBjb25zdHJ1Y3RvcicpXG4gIH1cbiAgaWYoIWxpbmVhclR5cGVzKSB7XG4gICAgbGF6eUluaXRMaW5lYXJUeXBlcyhnbClcbiAgfVxuICBpZih0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBjcmVhdGVUZXh0dXJlU2hhcGUoZ2wsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdLCBhcmd1bWVudHNbM118fGdsLlJHQkEsIGFyZ3VtZW50c1s0XXx8Z2wuVU5TSUdORURfQllURSlcbiAgfVxuICBpZihBcnJheS5pc0FycmF5KGFyZ3VtZW50c1sxXSkpIHtcbiAgICByZXR1cm4gY3JlYXRlVGV4dHVyZVNoYXBlKGdsLCBhcmd1bWVudHNbMV1bMF18MCwgYXJndW1lbnRzWzFdWzFdfDAsIGFyZ3VtZW50c1syXXx8Z2wuUkdCQSwgYXJndW1lbnRzWzNdfHxnbC5VTlNJR05FRF9CWVRFKVxuICB9XG4gIGlmKHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIG9iaiA9IGFyZ3VtZW50c1sxXVxuICAgIHZhciBkaXJlY3REYXRhID0gYWNjZXB0VGV4dHVyZURPTShvYmopID8gb2JqIDogb2JqLnJhd1xuICAgIGlmIChkaXJlY3REYXRhKSB7XG4gICAgICByZXR1cm4gY3JlYXRlVGV4dHVyZURPTShnbCwgZGlyZWN0RGF0YSwgb2JqLndpZHRofDAsIG9iai5oZWlnaHR8MCwgYXJndW1lbnRzWzJdfHxnbC5SR0JBLCBhcmd1bWVudHNbM118fGdsLlVOU0lHTkVEX0JZVEUpXG4gICAgfSBlbHNlIGlmKG9iai5zaGFwZSAmJiBvYmouZGF0YSAmJiBvYmouc3RyaWRlKSB7XG4gICAgICByZXR1cm4gY3JlYXRlVGV4dHVyZUFycmF5KGdsLCBvYmopXG4gICAgfVxuICB9XG4gIHRocm93IG5ldyBFcnJvcignZ2wtdGV4dHVyZTJkOiBJbnZhbGlkIGFyZ3VtZW50cyBmb3IgdGV4dHVyZTJkIGNvbnN0cnVjdG9yJylcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gYWRkO1xuXG4vKipcbiAqIEFkZHMgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gYWRkKG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gKyBiWzBdXG4gICAgb3V0WzFdID0gYVsxXSArIGJbMV1cbiAgICBvdXRbMl0gPSBhWzJdICsgYlsyXVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGFuZ2xlXG5cbnZhciBmcm9tVmFsdWVzID0gcmVxdWlyZSgnLi9mcm9tVmFsdWVzJylcbnZhciBub3JtYWxpemUgPSByZXF1aXJlKCcuL25vcm1hbGl6ZScpXG52YXIgZG90ID0gcmVxdWlyZSgnLi9kb3QnKVxuXG4vKipcbiAqIEdldCB0aGUgYW5nbGUgYmV0d2VlbiB0d28gM0QgdmVjdG9yc1xuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYW5nbGUgaW4gcmFkaWFuc1xuICovXG5mdW5jdGlvbiBhbmdsZShhLCBiKSB7XG4gICAgdmFyIHRlbXBBID0gZnJvbVZhbHVlcyhhWzBdLCBhWzFdLCBhWzJdKVxuICAgIHZhciB0ZW1wQiA9IGZyb21WYWx1ZXMoYlswXSwgYlsxXSwgYlsyXSlcbiBcbiAgICBub3JtYWxpemUodGVtcEEsIHRlbXBBKVxuICAgIG5vcm1hbGl6ZSh0ZW1wQiwgdGVtcEIpXG4gXG4gICAgdmFyIGNvc2luZSA9IGRvdCh0ZW1wQSwgdGVtcEIpXG5cbiAgICBpZihjb3NpbmUgPiAxLjApe1xuICAgICAgICByZXR1cm4gMFxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBNYXRoLmFjb3MoY29zaW5lKVxuICAgIH0gICAgIFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBjZWlsXG5cbi8qKlxuICogTWF0aC5jZWlsIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNlaWxcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gY2VpbChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5jZWlsKGFbMF0pXG4gIG91dFsxXSA9IE1hdGguY2VpbChhWzFdKVxuICBvdXRbMl0gPSBNYXRoLmNlaWwoYVsyXSlcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBjbG9uZTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IHZlYzMgaW5pdGlhbGl6ZWQgd2l0aCB2YWx1ZXMgZnJvbSBhbiBleGlzdGluZyB2ZWN0b3JcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGNsb25lXG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXG4gKi9cbmZ1bmN0aW9uIGNsb25lKGEpIHtcbiAgICB2YXIgb3V0ID0gbmV3IEZsb2F0MzJBcnJheSgzKVxuICAgIG91dFswXSA9IGFbMF1cbiAgICBvdXRbMV0gPSBhWzFdXG4gICAgb3V0WzJdID0gYVsyXVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IGNvcHk7XG5cbi8qKlxuICogQ29weSB0aGUgdmFsdWVzIGZyb20gb25lIHZlYzMgdG8gYW5vdGhlclxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHNvdXJjZSB2ZWN0b3JcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gY29weShvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSBhWzBdXG4gICAgb3V0WzFdID0gYVsxXVxuICAgIG91dFsyXSA9IGFbMl1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBjcmVhdGU7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldywgZW1wdHkgdmVjM1xuICpcbiAqIEByZXR1cm5zIHt2ZWMzfSBhIG5ldyAzRCB2ZWN0b3JcbiAqL1xuZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgIHZhciBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDMpXG4gICAgb3V0WzBdID0gMFxuICAgIG91dFsxXSA9IDBcbiAgICBvdXRbMl0gPSAwXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gY3Jvc3M7XG5cbi8qKlxuICogQ29tcHV0ZXMgdGhlIGNyb3NzIHByb2R1Y3Qgb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gY3Jvc3Mob3V0LCBhLCBiKSB7XG4gICAgdmFyIGF4ID0gYVswXSwgYXkgPSBhWzFdLCBheiA9IGFbMl0sXG4gICAgICAgIGJ4ID0gYlswXSwgYnkgPSBiWzFdLCBieiA9IGJbMl1cblxuICAgIG91dFswXSA9IGF5ICogYnogLSBheiAqIGJ5XG4gICAgb3V0WzFdID0gYXogKiBieCAtIGF4ICogYnpcbiAgICBvdXRbMl0gPSBheCAqIGJ5IC0gYXkgKiBieFxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZGlzdGFuY2UnKVxuIiwibW9kdWxlLmV4cG9ydHMgPSBkaXN0YW5jZTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBldWNsaWRpYW4gZGlzdGFuY2UgYmV0d2VlbiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xuZnVuY3Rpb24gZGlzdGFuY2UoYSwgYikge1xuICAgIHZhciB4ID0gYlswXSAtIGFbMF0sXG4gICAgICAgIHkgPSBiWzFdIC0gYVsxXSxcbiAgICAgICAgeiA9IGJbMl0gLSBhWzJdXG4gICAgcmV0dXJuIE1hdGguc3FydCh4KnggKyB5KnkgKyB6KnopXG59IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2RpdmlkZScpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGRpdmlkZTtcblxuLyoqXG4gKiBEaXZpZGVzIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIGRpdmlkZShvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBhWzBdIC8gYlswXVxuICAgIG91dFsxXSA9IGFbMV0gLyBiWzFdXG4gICAgb3V0WzJdID0gYVsyXSAvIGJbMl1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBkb3Q7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZG90IHByb2R1Y3Qgb2YgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gZG90IHByb2R1Y3Qgb2YgYSBhbmQgYlxuICovXG5mdW5jdGlvbiBkb3QoYSwgYikge1xuICAgIHJldHVybiBhWzBdICogYlswXSArIGFbMV0gKiBiWzFdICsgYVsyXSAqIGJbMl1cbn0iLCJtb2R1bGUuZXhwb3J0cyA9IDAuMDAwMDAxXG4iLCJtb2R1bGUuZXhwb3J0cyA9IGVxdWFsc1xuXG52YXIgRVBTSUxPTiA9IHJlcXVpcmUoJy4vZXBzaWxvbicpXG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBoYXZlIGFwcHJveGltYXRlbHkgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24uXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgdmFyIGEwID0gYVswXVxuICB2YXIgYTEgPSBhWzFdXG4gIHZhciBhMiA9IGFbMl1cbiAgdmFyIGIwID0gYlswXVxuICB2YXIgYjEgPSBiWzFdXG4gIHZhciBiMiA9IGJbMl1cbiAgcmV0dXJuIChNYXRoLmFicyhhMCAtIGIwKSA8PSBFUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMCksIE1hdGguYWJzKGIwKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMSAtIGIxKSA8PSBFUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMSksIE1hdGguYWJzKGIxKSkgJiZcbiAgICAgICAgICBNYXRoLmFicyhhMiAtIGIyKSA8PSBFUFNJTE9OICogTWF0aC5tYXgoMS4wLCBNYXRoLmFicyhhMiksIE1hdGguYWJzKGIyKSkpXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGV4YWN0RXF1YWxzXG5cbi8qKlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgdmVjdG9ycyBleGFjdGx5IGhhdmUgdGhlIHNhbWUgZWxlbWVudHMgaW4gdGhlIHNhbWUgcG9zaXRpb24gKHdoZW4gY29tcGFyZWQgd2l0aCA9PT0pXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIFRoZSBmaXJzdCB2ZWN0b3IuXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIHNlY29uZCB2ZWN0b3IuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmVjdG9ycyBhcmUgZXF1YWwsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gZXhhY3RFcXVhbHMoYSwgYikge1xuICByZXR1cm4gYVswXSA9PT0gYlswXSAmJiBhWzFdID09PSBiWzFdICYmIGFbMl0gPT09IGJbMl1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZmxvb3JcblxuLyoqXG4gKiBNYXRoLmZsb29yIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIGZsb29yXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIGZsb29yKG91dCwgYSkge1xuICBvdXRbMF0gPSBNYXRoLmZsb29yKGFbMF0pXG4gIG91dFsxXSA9IE1hdGguZmxvb3IoYVsxXSlcbiAgb3V0WzJdID0gTWF0aC5mbG9vcihhWzJdKVxuICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZvckVhY2g7XG5cbnZhciB2ZWMgPSByZXF1aXJlKCcuL2NyZWF0ZScpKClcblxuLyoqXG4gKiBQZXJmb3JtIHNvbWUgb3BlcmF0aW9uIG92ZXIgYW4gYXJyYXkgb2YgdmVjM3MuXG4gKlxuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgYXJyYXkgb2YgdmVjdG9ycyB0byBpdGVyYXRlIG92ZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdHJpZGUgTnVtYmVyIG9mIGVsZW1lbnRzIGJldHdlZW4gdGhlIHN0YXJ0IG9mIGVhY2ggdmVjMy4gSWYgMCBhc3N1bWVzIHRpZ2h0bHkgcGFja2VkXG4gKiBAcGFyYW0ge051bWJlcn0gb2Zmc2V0IE51bWJlciBvZiBlbGVtZW50cyB0byBza2lwIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGFycmF5XG4gKiBAcGFyYW0ge051bWJlcn0gY291bnQgTnVtYmVyIG9mIHZlYzNzIHRvIGl0ZXJhdGUgb3Zlci4gSWYgMCBpdGVyYXRlcyBvdmVyIGVudGlyZSBhcnJheVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gRnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCB2ZWN0b3IgaW4gdGhlIGFycmF5XG4gKiBAcGFyYW0ge09iamVjdH0gW2FyZ10gYWRkaXRpb25hbCBhcmd1bWVudCB0byBwYXNzIHRvIGZuXG4gKiBAcmV0dXJucyB7QXJyYXl9IGFcbiAqIEBmdW5jdGlvblxuICovXG5mdW5jdGlvbiBmb3JFYWNoKGEsIHN0cmlkZSwgb2Zmc2V0LCBjb3VudCwgZm4sIGFyZykge1xuICAgICAgICB2YXIgaSwgbFxuICAgICAgICBpZighc3RyaWRlKSB7XG4gICAgICAgICAgICBzdHJpZGUgPSAzXG4gICAgICAgIH1cblxuICAgICAgICBpZighb2Zmc2V0KSB7XG4gICAgICAgICAgICBvZmZzZXQgPSAwXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmKGNvdW50KSB7XG4gICAgICAgICAgICBsID0gTWF0aC5taW4oKGNvdW50ICogc3RyaWRlKSArIG9mZnNldCwgYS5sZW5ndGgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsID0gYS5sZW5ndGhcbiAgICAgICAgfVxuXG4gICAgICAgIGZvcihpID0gb2Zmc2V0OyBpIDwgbDsgaSArPSBzdHJpZGUpIHtcbiAgICAgICAgICAgIHZlY1swXSA9IGFbaV0gXG4gICAgICAgICAgICB2ZWNbMV0gPSBhW2krMV0gXG4gICAgICAgICAgICB2ZWNbMl0gPSBhW2krMl1cbiAgICAgICAgICAgIGZuKHZlYywgdmVjLCBhcmcpXG4gICAgICAgICAgICBhW2ldID0gdmVjWzBdIFxuICAgICAgICAgICAgYVtpKzFdID0gdmVjWzFdIFxuICAgICAgICAgICAgYVtpKzJdID0gdmVjWzJdXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiBhXG59IiwibW9kdWxlLmV4cG9ydHMgPSBmcm9tVmFsdWVzO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdmVjMyBpbml0aWFsaXplZCB3aXRoIHRoZSBnaXZlbiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBYIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHkgWSBjb21wb25lbnRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFogY29tcG9uZW50XG4gKiBAcmV0dXJucyB7dmVjM30gYSBuZXcgM0QgdmVjdG9yXG4gKi9cbmZ1bmN0aW9uIGZyb21WYWx1ZXMoeCwgeSwgeikge1xuICAgIHZhciBvdXQgPSBuZXcgRmxvYXQzMkFycmF5KDMpXG4gICAgb3V0WzBdID0geFxuICAgIG91dFsxXSA9IHlcbiAgICBvdXRbMl0gPSB6XG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBFUFNJTE9OOiByZXF1aXJlKCcuL2Vwc2lsb24nKVxuICAsIGNyZWF0ZTogcmVxdWlyZSgnLi9jcmVhdGUnKVxuICAsIGNsb25lOiByZXF1aXJlKCcuL2Nsb25lJylcbiAgLCBhbmdsZTogcmVxdWlyZSgnLi9hbmdsZScpXG4gICwgZnJvbVZhbHVlczogcmVxdWlyZSgnLi9mcm9tVmFsdWVzJylcbiAgLCBjb3B5OiByZXF1aXJlKCcuL2NvcHknKVxuICAsIHNldDogcmVxdWlyZSgnLi9zZXQnKVxuICAsIGVxdWFsczogcmVxdWlyZSgnLi9lcXVhbHMnKVxuICAsIGV4YWN0RXF1YWxzOiByZXF1aXJlKCcuL2V4YWN0RXF1YWxzJylcbiAgLCBhZGQ6IHJlcXVpcmUoJy4vYWRkJylcbiAgLCBzdWJ0cmFjdDogcmVxdWlyZSgnLi9zdWJ0cmFjdCcpXG4gICwgc3ViOiByZXF1aXJlKCcuL3N1YicpXG4gICwgbXVsdGlwbHk6IHJlcXVpcmUoJy4vbXVsdGlwbHknKVxuICAsIG11bDogcmVxdWlyZSgnLi9tdWwnKVxuICAsIGRpdmlkZTogcmVxdWlyZSgnLi9kaXZpZGUnKVxuICAsIGRpdjogcmVxdWlyZSgnLi9kaXYnKVxuICAsIG1pbjogcmVxdWlyZSgnLi9taW4nKVxuICAsIG1heDogcmVxdWlyZSgnLi9tYXgnKVxuICAsIGZsb29yOiByZXF1aXJlKCcuL2Zsb29yJylcbiAgLCBjZWlsOiByZXF1aXJlKCcuL2NlaWwnKVxuICAsIHJvdW5kOiByZXF1aXJlKCcuL3JvdW5kJylcbiAgLCBzY2FsZTogcmVxdWlyZSgnLi9zY2FsZScpXG4gICwgc2NhbGVBbmRBZGQ6IHJlcXVpcmUoJy4vc2NhbGVBbmRBZGQnKVxuICAsIGRpc3RhbmNlOiByZXF1aXJlKCcuL2Rpc3RhbmNlJylcbiAgLCBkaXN0OiByZXF1aXJlKCcuL2Rpc3QnKVxuICAsIHNxdWFyZWREaXN0YW5jZTogcmVxdWlyZSgnLi9zcXVhcmVkRGlzdGFuY2UnKVxuICAsIHNxckRpc3Q6IHJlcXVpcmUoJy4vc3FyRGlzdCcpXG4gICwgbGVuZ3RoOiByZXF1aXJlKCcuL2xlbmd0aCcpXG4gICwgbGVuOiByZXF1aXJlKCcuL2xlbicpXG4gICwgc3F1YXJlZExlbmd0aDogcmVxdWlyZSgnLi9zcXVhcmVkTGVuZ3RoJylcbiAgLCBzcXJMZW46IHJlcXVpcmUoJy4vc3FyTGVuJylcbiAgLCBuZWdhdGU6IHJlcXVpcmUoJy4vbmVnYXRlJylcbiAgLCBpbnZlcnNlOiByZXF1aXJlKCcuL2ludmVyc2UnKVxuICAsIG5vcm1hbGl6ZTogcmVxdWlyZSgnLi9ub3JtYWxpemUnKVxuICAsIGRvdDogcmVxdWlyZSgnLi9kb3QnKVxuICAsIGNyb3NzOiByZXF1aXJlKCcuL2Nyb3NzJylcbiAgLCBsZXJwOiByZXF1aXJlKCcuL2xlcnAnKVxuICAsIHJhbmRvbTogcmVxdWlyZSgnLi9yYW5kb20nKVxuICAsIHRyYW5zZm9ybU1hdDQ6IHJlcXVpcmUoJy4vdHJhbnNmb3JtTWF0NCcpXG4gICwgdHJhbnNmb3JtTWF0MzogcmVxdWlyZSgnLi90cmFuc2Zvcm1NYXQzJylcbiAgLCB0cmFuc2Zvcm1RdWF0OiByZXF1aXJlKCcuL3RyYW5zZm9ybVF1YXQnKVxuICAsIHJvdGF0ZVg6IHJlcXVpcmUoJy4vcm90YXRlWCcpXG4gICwgcm90YXRlWTogcmVxdWlyZSgnLi9yb3RhdGVZJylcbiAgLCByb3RhdGVaOiByZXF1aXJlKCcuL3JvdGF0ZVonKVxuICAsIGZvckVhY2g6IHJlcXVpcmUoJy4vZm9yRWFjaCcpXG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGludmVyc2U7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW52ZXJzZSBvZiB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBpbnZlcnRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gaW52ZXJzZShvdXQsIGEpIHtcbiAgb3V0WzBdID0gMS4wIC8gYVswXVxuICBvdXRbMV0gPSAxLjAgLyBhWzFdXG4gIG91dFsyXSA9IDEuMCAvIGFbMl1cbiAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9sZW5ndGgnKVxuIiwibW9kdWxlLmV4cG9ydHMgPSBsZW5ndGg7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gY2FsY3VsYXRlIGxlbmd0aCBvZlxuICogQHJldHVybnMge051bWJlcn0gbGVuZ3RoIG9mIGFcbiAqL1xuZnVuY3Rpb24gbGVuZ3RoKGEpIHtcbiAgICB2YXIgeCA9IGFbMF0sXG4gICAgICAgIHkgPSBhWzFdLFxuICAgICAgICB6ID0gYVsyXVxuICAgIHJldHVybiBNYXRoLnNxcnQoeCp4ICsgeSp5ICsgeip6KVxufSIsIm1vZHVsZS5leHBvcnRzID0gbGVycDtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIGxpbmVhciBpbnRlcnBvbGF0aW9uIGJldHdlZW4gdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0IGludGVycG9sYXRpb24gYW1vdW50IGJldHdlZW4gdGhlIHR3byBpbnB1dHNcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gbGVycChvdXQsIGEsIGIsIHQpIHtcbiAgICB2YXIgYXggPSBhWzBdLFxuICAgICAgICBheSA9IGFbMV0sXG4gICAgICAgIGF6ID0gYVsyXVxuICAgIG91dFswXSA9IGF4ICsgdCAqIChiWzBdIC0gYXgpXG4gICAgb3V0WzFdID0gYXkgKyB0ICogKGJbMV0gLSBheSlcbiAgICBvdXRbMl0gPSBheiArIHQgKiAoYlsyXSAtIGF6KVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IG1heDtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBtYXhpbXVtIG9mIHR3byB2ZWMzJ3NcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIG1heChvdXQsIGEsIGIpIHtcbiAgICBvdXRbMF0gPSBNYXRoLm1heChhWzBdLCBiWzBdKVxuICAgIG91dFsxXSA9IE1hdGgubWF4KGFbMV0sIGJbMV0pXG4gICAgb3V0WzJdID0gTWF0aC5tYXgoYVsyXSwgYlsyXSlcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBtaW47XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbWluaW11bSBvZiB0d28gdmVjMydzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBtaW4ob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gTWF0aC5taW4oYVswXSwgYlswXSlcbiAgICBvdXRbMV0gPSBNYXRoLm1pbihhWzFdLCBiWzFdKVxuICAgIG91dFsyXSA9IE1hdGgubWluKGFbMl0sIGJbMl0pXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9tdWx0aXBseScpXG4iLCJtb2R1bGUuZXhwb3J0cyA9IG11bHRpcGx5O1xuXG4vKipcbiAqIE11bHRpcGxpZXMgdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIGZpcnN0IG9wZXJhbmRcbiAqIEBwYXJhbSB7dmVjM30gYiB0aGUgc2Vjb25kIG9wZXJhbmRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gbXVsdGlwbHkob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGJbMF1cbiAgICBvdXRbMV0gPSBhWzFdICogYlsxXVxuICAgIG91dFsyXSA9IGFbMl0gKiBiWzJdXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gbmVnYXRlO1xuXG4vKipcbiAqIE5lZ2F0ZXMgdGhlIGNvbXBvbmVudHMgb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB2ZWN0b3IgdG8gbmVnYXRlXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIG5lZ2F0ZShvdXQsIGEpIHtcbiAgICBvdXRbMF0gPSAtYVswXVxuICAgIG91dFsxXSA9IC1hWzFdXG4gICAgb3V0WzJdID0gLWFbMl1cbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBub3JtYWxpemU7XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdmVjM1xuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdmVjdG9yIHRvIG5vcm1hbGl6ZVxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiBub3JtYWxpemUob3V0LCBhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl1cbiAgICB2YXIgbGVuID0geCp4ICsgeSp5ICsgeip6XG4gICAgaWYgKGxlbiA+IDApIHtcbiAgICAgICAgLy9UT0RPOiBldmFsdWF0ZSB1c2Ugb2YgZ2xtX2ludnNxcnQgaGVyZT9cbiAgICAgICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pXG4gICAgICAgIG91dFswXSA9IGFbMF0gKiBsZW5cbiAgICAgICAgb3V0WzFdID0gYVsxXSAqIGxlblxuICAgICAgICBvdXRbMl0gPSBhWzJdICogbGVuXG4gICAgfVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHJhbmRvbTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gdmVjdG9yIHdpdGggdGhlIGdpdmVuIHNjYWxlXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSBbc2NhbGVdIExlbmd0aCBvZiB0aGUgcmVzdWx0aW5nIHZlY3Rvci4gSWYgb21taXR0ZWQsIGEgdW5pdCB2ZWN0b3Igd2lsbCBiZSByZXR1cm5lZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiByYW5kb20ob3V0LCBzY2FsZSkge1xuICAgIHNjYWxlID0gc2NhbGUgfHwgMS4wXG5cbiAgICB2YXIgciA9IE1hdGgucmFuZG9tKCkgKiAyLjAgKiBNYXRoLlBJXG4gICAgdmFyIHogPSAoTWF0aC5yYW5kb20oKSAqIDIuMCkgLSAxLjBcbiAgICB2YXIgelNjYWxlID0gTWF0aC5zcXJ0KDEuMC16KnopICogc2NhbGVcblxuICAgIG91dFswXSA9IE1hdGguY29zKHIpICogelNjYWxlXG4gICAgb3V0WzFdID0gTWF0aC5zaW4ocikgKiB6U2NhbGVcbiAgICBvdXRbMl0gPSB6ICogc2NhbGVcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSByb3RhdGVYO1xuXG4vKipcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHgtYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiByb3RhdGVYKG91dCwgYSwgYiwgYyl7XG4gICAgdmFyIGJ5ID0gYlsxXVxuICAgIHZhciBieiA9IGJbMl1cblxuICAgIC8vIFRyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG4gICAgdmFyIHB5ID0gYVsxXSAtIGJ5XG4gICAgdmFyIHB6ID0gYVsyXSAtIGJ6XG5cbiAgICB2YXIgc2MgPSBNYXRoLnNpbihjKVxuICAgIHZhciBjYyA9IE1hdGguY29zKGMpXG5cbiAgICAvLyBwZXJmb3JtIHJvdGF0aW9uIGFuZCB0cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuICAgIG91dFswXSA9IGFbMF1cbiAgICBvdXRbMV0gPSBieSArIHB5ICogY2MgLSBweiAqIHNjXG4gICAgb3V0WzJdID0gYnogKyBweSAqIHNjICsgcHogKiBjY1xuXG4gICAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSByb3RhdGVZO1xuXG4vKipcbiAqIFJvdGF0ZSBhIDNEIHZlY3RvciBhcm91bmQgdGhlIHktYXhpc1xuICogQHBhcmFtIHt2ZWMzfSBvdXQgVGhlIHJlY2VpdmluZyB2ZWMzXG4gKiBAcGFyYW0ge3ZlYzN9IGEgVGhlIHZlYzMgcG9pbnQgdG8gcm90YXRlXG4gKiBAcGFyYW0ge3ZlYzN9IGIgVGhlIG9yaWdpbiBvZiB0aGUgcm90YXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSBjIFRoZSBhbmdsZSBvZiByb3RhdGlvblxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiByb3RhdGVZKG91dCwgYSwgYiwgYyl7XG4gICAgdmFyIGJ4ID0gYlswXVxuICAgIHZhciBieiA9IGJbMl1cblxuICAgIC8vIHRyYW5zbGF0ZSBwb2ludCB0byB0aGUgb3JpZ2luXG4gICAgdmFyIHB4ID0gYVswXSAtIGJ4XG4gICAgdmFyIHB6ID0gYVsyXSAtIGJ6XG4gICAgXG4gICAgdmFyIHNjID0gTWF0aC5zaW4oYylcbiAgICB2YXIgY2MgPSBNYXRoLmNvcyhjKVxuICBcbiAgICAvLyBwZXJmb3JtIHJvdGF0aW9uIGFuZCB0cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuICAgIG91dFswXSA9IGJ4ICsgcHogKiBzYyArIHB4ICogY2NcbiAgICBvdXRbMV0gPSBhWzFdXG4gICAgb3V0WzJdID0gYnogKyBweiAqIGNjIC0gcHggKiBzY1xuICBcbiAgICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJvdGF0ZVo7XG5cbi8qKlxuICogUm90YXRlIGEgM0QgdmVjdG9yIGFyb3VuZCB0aGUgei1heGlzXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCBUaGUgcmVjZWl2aW5nIHZlYzNcbiAqIEBwYXJhbSB7dmVjM30gYSBUaGUgdmVjMyBwb2ludCB0byByb3RhdGVcbiAqIEBwYXJhbSB7dmVjM30gYiBUaGUgb3JpZ2luIG9mIHRoZSByb3RhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IGMgVGhlIGFuZ2xlIG9mIHJvdGF0aW9uXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIHJvdGF0ZVoob3V0LCBhLCBiLCBjKXtcbiAgICB2YXIgYnggPSBiWzBdXG4gICAgdmFyIGJ5ID0gYlsxXVxuXG4gICAgLy9UcmFuc2xhdGUgcG9pbnQgdG8gdGhlIG9yaWdpblxuICAgIHZhciBweCA9IGFbMF0gLSBieFxuICAgIHZhciBweSA9IGFbMV0gLSBieVxuICBcbiAgICB2YXIgc2MgPSBNYXRoLnNpbihjKVxuICAgIHZhciBjYyA9IE1hdGguY29zKGMpXG5cbiAgICAvLyBwZXJmb3JtIHJvdGF0aW9uIGFuZCB0cmFuc2xhdGUgdG8gY29ycmVjdCBwb3NpdGlvblxuICAgIG91dFswXSA9IGJ4ICsgcHggKiBjYyAtIHB5ICogc2NcbiAgICBvdXRbMV0gPSBieSArIHB4ICogc2MgKyBweSAqIGNjXG4gICAgb3V0WzJdID0gYVsyXVxuICBcbiAgICByZXR1cm4gb3V0XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJvdW5kXG5cbi8qKlxuICogTWF0aC5yb3VuZCB0aGUgY29tcG9uZW50cyBvZiBhIHZlYzNcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byByb3VuZFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiByb3VuZChvdXQsIGEpIHtcbiAgb3V0WzBdID0gTWF0aC5yb3VuZChhWzBdKVxuICBvdXRbMV0gPSBNYXRoLnJvdW5kKGFbMV0pXG4gIG91dFsyXSA9IE1hdGgucm91bmQoYVsyXSlcbiAgcmV0dXJuIG91dFxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBzY2FsZTtcblxuLyoqXG4gKiBTY2FsZXMgYSB2ZWMzIGJ5IGEgc2NhbGFyIG51bWJlclxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXJ9IGIgYW1vdW50IHRvIHNjYWxlIHRoZSB2ZWN0b3IgYnlcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gc2NhbGUob3V0LCBhLCBiKSB7XG4gICAgb3V0WzBdID0gYVswXSAqIGJcbiAgICBvdXRbMV0gPSBhWzFdICogYlxuICAgIG91dFsyXSA9IGFbMl0gKiBiXG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gc2NhbGVBbmRBZGQ7XG5cbi8qKlxuICogQWRkcyB0d28gdmVjMydzIGFmdGVyIHNjYWxpbmcgdGhlIHNlY29uZCBvcGVyYW5kIGJ5IGEgc2NhbGFyIHZhbHVlXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlIHRoZSBhbW91bnQgdG8gc2NhbGUgYiBieSBiZWZvcmUgYWRkaW5nXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIHNjYWxlQW5kQWRkKG91dCwgYSwgYiwgc2NhbGUpIHtcbiAgICBvdXRbMF0gPSBhWzBdICsgKGJbMF0gKiBzY2FsZSlcbiAgICBvdXRbMV0gPSBhWzFdICsgKGJbMV0gKiBzY2FsZSlcbiAgICBvdXRbMl0gPSBhWzJdICsgKGJbMl0gKiBzY2FsZSlcbiAgICByZXR1cm4gb3V0XG59IiwibW9kdWxlLmV4cG9ydHMgPSBzZXQ7XG5cbi8qKlxuICogU2V0IHRoZSBjb21wb25lbnRzIG9mIGEgdmVjMyB0byB0aGUgZ2l2ZW4gdmFsdWVzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFggY29tcG9uZW50XG4gKiBAcGFyYW0ge051bWJlcn0geSBZIGNvbXBvbmVudFxuICogQHBhcmFtIHtOdW1iZXJ9IHogWiBjb21wb25lbnRcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gc2V0KG91dCwgeCwgeSwgeikge1xuICAgIG91dFswXSA9IHhcbiAgICBvdXRbMV0gPSB5XG4gICAgb3V0WzJdID0gelxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vc3F1YXJlZERpc3RhbmNlJylcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zcXVhcmVkTGVuZ3RoJylcbiIsIm1vZHVsZS5leHBvcnRzID0gc3F1YXJlZERpc3RhbmNlO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHNxdWFyZWQgZXVjbGlkaWFuIGRpc3RhbmNlIGJldHdlZW4gdHdvIHZlYzMnc1xuICpcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgZmlyc3Qgb3BlcmFuZFxuICogQHBhcmFtIHt2ZWMzfSBiIHRoZSBzZWNvbmQgb3BlcmFuZFxuICogQHJldHVybnMge051bWJlcn0gc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGEgYW5kIGJcbiAqL1xuZnVuY3Rpb24gc3F1YXJlZERpc3RhbmNlKGEsIGIpIHtcbiAgICB2YXIgeCA9IGJbMF0gLSBhWzBdLFxuICAgICAgICB5ID0gYlsxXSAtIGFbMV0sXG4gICAgICAgIHogPSBiWzJdIC0gYVsyXVxuICAgIHJldHVybiB4KnggKyB5KnkgKyB6Knpcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHNxdWFyZWRMZW5ndGg7XG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgc3F1YXJlZCBsZW5ndGggb2YgYSB2ZWMzXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBhIHZlY3RvciB0byBjYWxjdWxhdGUgc3F1YXJlZCBsZW5ndGggb2ZcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHNxdWFyZWQgbGVuZ3RoIG9mIGFcbiAqL1xuZnVuY3Rpb24gc3F1YXJlZExlbmd0aChhKSB7XG4gICAgdmFyIHggPSBhWzBdLFxuICAgICAgICB5ID0gYVsxXSxcbiAgICAgICAgeiA9IGFbMl1cbiAgICByZXR1cm4geCp4ICsgeSp5ICsgeip6XG59IiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3N1YnRyYWN0JylcbiIsIm1vZHVsZS5leHBvcnRzID0gc3VidHJhY3Q7XG5cbi8qKlxuICogU3VidHJhY3RzIHZlY3RvciBiIGZyb20gdmVjdG9yIGFcbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSBmaXJzdCBvcGVyYW5kXG4gKiBAcGFyYW0ge3ZlYzN9IGIgdGhlIHNlY29uZCBvcGVyYW5kXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIHN1YnRyYWN0KG91dCwgYSwgYikge1xuICAgIG91dFswXSA9IGFbMF0gLSBiWzBdXG4gICAgb3V0WzFdID0gYVsxXSAtIGJbMV1cbiAgICBvdXRbMl0gPSBhWzJdIC0gYlsyXVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHRyYW5zZm9ybU1hdDM7XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0My5cbiAqXG4gKiBAcGFyYW0ge3ZlYzN9IG91dCB0aGUgcmVjZWl2aW5nIHZlY3RvclxuICogQHBhcmFtIHt2ZWMzfSBhIHRoZSB2ZWN0b3IgdG8gdHJhbnNmb3JtXG4gKiBAcGFyYW0ge21hdDR9IG0gdGhlIDN4MyBtYXRyaXggdG8gdHJhbnNmb3JtIHdpdGhcbiAqIEByZXR1cm5zIHt2ZWMzfSBvdXRcbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtTWF0MyhvdXQsIGEsIG0pIHtcbiAgICB2YXIgeCA9IGFbMF0sIHkgPSBhWzFdLCB6ID0gYVsyXVxuICAgIG91dFswXSA9IHggKiBtWzBdICsgeSAqIG1bM10gKyB6ICogbVs2XVxuICAgIG91dFsxXSA9IHggKiBtWzFdICsgeSAqIG1bNF0gKyB6ICogbVs3XVxuICAgIG91dFsyXSA9IHggKiBtWzJdICsgeSAqIG1bNV0gKyB6ICogbVs4XVxuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHRyYW5zZm9ybU1hdDQ7XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgbWF0NC5cbiAqIDR0aCB2ZWN0b3IgY29tcG9uZW50IGlzIGltcGxpY2l0bHkgJzEnXG4gKlxuICogQHBhcmFtIHt2ZWMzfSBvdXQgdGhlIHJlY2VpdmluZyB2ZWN0b3JcbiAqIEBwYXJhbSB7dmVjM30gYSB0aGUgdmVjdG9yIHRvIHRyYW5zZm9ybVxuICogQHBhcmFtIHttYXQ0fSBtIG1hdHJpeCB0byB0cmFuc2Zvcm0gd2l0aFxuICogQHJldHVybnMge3ZlYzN9IG91dFxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1NYXQ0KG91dCwgYSwgbSkge1xuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdLFxuICAgICAgICB3ID0gbVszXSAqIHggKyBtWzddICogeSArIG1bMTFdICogeiArIG1bMTVdXG4gICAgdyA9IHcgfHwgMS4wXG4gICAgb3V0WzBdID0gKG1bMF0gKiB4ICsgbVs0XSAqIHkgKyBtWzhdICogeiArIG1bMTJdKSAvIHdcbiAgICBvdXRbMV0gPSAobVsxXSAqIHggKyBtWzVdICogeSArIG1bOV0gKiB6ICsgbVsxM10pIC8gd1xuICAgIG91dFsyXSA9IChtWzJdICogeCArIG1bNl0gKiB5ICsgbVsxMF0gKiB6ICsgbVsxNF0pIC8gd1xuICAgIHJldHVybiBvdXRcbn0iLCJtb2R1bGUuZXhwb3J0cyA9IHRyYW5zZm9ybVF1YXQ7XG5cbi8qKlxuICogVHJhbnNmb3JtcyB0aGUgdmVjMyB3aXRoIGEgcXVhdFxuICpcbiAqIEBwYXJhbSB7dmVjM30gb3V0IHRoZSByZWNlaXZpbmcgdmVjdG9yXG4gKiBAcGFyYW0ge3ZlYzN9IGEgdGhlIHZlY3RvciB0byB0cmFuc2Zvcm1cbiAqIEBwYXJhbSB7cXVhdH0gcSBxdWF0ZXJuaW9uIHRvIHRyYW5zZm9ybSB3aXRoXG4gKiBAcmV0dXJucyB7dmVjM30gb3V0XG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybVF1YXQob3V0LCBhLCBxKSB7XG4gICAgLy8gYmVuY2htYXJrczogaHR0cDovL2pzcGVyZi5jb20vcXVhdGVybmlvbi10cmFuc2Zvcm0tdmVjMy1pbXBsZW1lbnRhdGlvbnNcblxuICAgIHZhciB4ID0gYVswXSwgeSA9IGFbMV0sIHogPSBhWzJdLFxuICAgICAgICBxeCA9IHFbMF0sIHF5ID0gcVsxXSwgcXogPSBxWzJdLCBxdyA9IHFbM10sXG5cbiAgICAgICAgLy8gY2FsY3VsYXRlIHF1YXQgKiB2ZWNcbiAgICAgICAgaXggPSBxdyAqIHggKyBxeSAqIHogLSBxeiAqIHksXG4gICAgICAgIGl5ID0gcXcgKiB5ICsgcXogKiB4IC0gcXggKiB6LFxuICAgICAgICBpeiA9IHF3ICogeiArIHF4ICogeSAtIHF5ICogeCxcbiAgICAgICAgaXcgPSAtcXggKiB4IC0gcXkgKiB5IC0gcXogKiB6XG5cbiAgICAvLyBjYWxjdWxhdGUgcmVzdWx0ICogaW52ZXJzZSBxdWF0XG4gICAgb3V0WzBdID0gaXggKiBxdyArIGl3ICogLXF4ICsgaXkgKiAtcXogLSBpeiAqIC1xeVxuICAgIG91dFsxXSA9IGl5ICogcXcgKyBpdyAqIC1xeSArIGl6ICogLXF4IC0gaXggKiAtcXpcbiAgICBvdXRbMl0gPSBpeiAqIHF3ICsgaXcgKiAtcXogKyBpeCAqIC1xeSAtIGl5ICogLXF4XG4gICAgcmV0dXJuIG91dFxufSIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc3RyaW5ncykge1xyXG4gIGlmICh0eXBlb2Ygc3RyaW5ncyA9PT0gJ3N0cmluZycpIHN0cmluZ3MgPSBbc3RyaW5nc11cclxuICB2YXIgZXhwcnMgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKVxyXG4gIHZhciBwYXJ0cyA9IFtdXHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJpbmdzLmxlbmd0aC0xOyBpKyspIHtcclxuICAgIHBhcnRzLnB1c2goc3RyaW5nc1tpXSwgZXhwcnNbaV0gfHwgJycpXHJcbiAgfVxyXG4gIHBhcnRzLnB1c2goc3RyaW5nc1tpXSlcclxuICByZXR1cm4gcGFydHMuam9pbignJylcclxufVxyXG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCJpZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgICB2YWx1ZTogY3RvcixcbiAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGlmIChzdXBlckN0b3IpIHtcbiAgICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxuICAgICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXG4gICAgfVxuICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIlxuXG5mdW5jdGlvbiBpb3RhKG4pIHtcbiAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShuKVxuICBmb3IodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICByZXN1bHRbaV0gPSBpXG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlvdGEiLCIvKiFcbiAqIERldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBCdWZmZXJcbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cbi8vIFRoZSBfaXNCdWZmZXIgY2hlY2sgaXMgZm9yIFNhZmFyaSA1LTcgc3VwcG9ydCwgYmVjYXVzZSBpdCdzIG1pc3Npbmdcbi8vIE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHlcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgKGlzQnVmZmVyKG9iaikgfHwgaXNTbG93QnVmZmVyKG9iaikgfHwgISFvYmouX2lzQnVmZmVyKVxufVxuXG5mdW5jdGlvbiBpc0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiAhIW9iai5jb25zdHJ1Y3RvciAmJiB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopXG59XG5cbi8vIEZvciBOb2RlIHYwLjEwIHN1cHBvcnQuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHkuXG5mdW5jdGlvbiBpc1Nsb3dCdWZmZXIgKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iai5yZWFkRmxvYXRMRSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLnNsaWNlID09PSAnZnVuY3Rpb24nICYmIGlzQnVmZmVyKG9iai5zbGljZSgwLCAwKSlcbn1cbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCJcblxudmFyIGNvbXBpbGUgPSByZXF1aXJlKFwiY3dpc2UtY29tcGlsZXJcIilcblxudmFyIEVtcHR5UHJvYyA9IHtcbiAgYm9keTogXCJcIixcbiAgYXJnczogW10sXG4gIHRoaXNWYXJzOiBbXSxcbiAgbG9jYWxWYXJzOiBbXVxufVxuXG5mdW5jdGlvbiBmaXh1cCh4KSB7XG4gIGlmKCF4KSB7XG4gICAgcmV0dXJuIEVtcHR5UHJvY1xuICB9XG4gIGZvcih2YXIgaT0wOyBpPHguYXJncy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBhID0geC5hcmdzW2ldXG4gICAgaWYoaSA9PT0gMCkge1xuICAgICAgeC5hcmdzW2ldID0ge25hbWU6IGEsIGx2YWx1ZTp0cnVlLCBydmFsdWU6ICEheC5ydmFsdWUsIGNvdW50OnguY291bnR8fDEgfVxuICAgIH0gZWxzZSB7XG4gICAgICB4LmFyZ3NbaV0gPSB7bmFtZTogYSwgbHZhbHVlOmZhbHNlLCBydmFsdWU6dHJ1ZSwgY291bnQ6IDF9XG4gICAgfVxuICB9XG4gIGlmKCF4LnRoaXNWYXJzKSB7XG4gICAgeC50aGlzVmFycyA9IFtdXG4gIH1cbiAgaWYoIXgubG9jYWxWYXJzKSB7XG4gICAgeC5sb2NhbFZhcnMgPSBbXVxuICB9XG4gIHJldHVybiB4XG59XG5cbmZ1bmN0aW9uIHBjb21waWxlKHVzZXJfYXJncykge1xuICByZXR1cm4gY29tcGlsZSh7XG4gICAgYXJnczogICAgIHVzZXJfYXJncy5hcmdzLFxuICAgIHByZTogICAgICBmaXh1cCh1c2VyX2FyZ3MucHJlKSxcbiAgICBib2R5OiAgICAgZml4dXAodXNlcl9hcmdzLmJvZHkpLFxuICAgIHBvc3Q6ICAgICBmaXh1cCh1c2VyX2FyZ3MucHJvYyksXG4gICAgZnVuY05hbWU6IHVzZXJfYXJncy5mdW5jTmFtZVxuICB9KVxufVxuXG5mdW5jdGlvbiBtYWtlT3AodXNlcl9hcmdzKSB7XG4gIHZhciBhcmdzID0gW11cbiAgZm9yKHZhciBpPTA7IGk8dXNlcl9hcmdzLmFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICBhcmdzLnB1c2goXCJhXCIraSlcbiAgfVxuICB2YXIgd3JhcHBlciA9IG5ldyBGdW5jdGlvbihcIlBcIiwgW1xuICAgIFwicmV0dXJuIGZ1bmN0aW9uIFwiLCB1c2VyX2FyZ3MuZnVuY05hbWUsIFwiX25kYXJyYXlvcHMoXCIsIGFyZ3Muam9pbihcIixcIiksIFwiKSB7UChcIiwgYXJncy5qb2luKFwiLFwiKSwgXCIpO3JldHVybiBhMH1cIlxuICBdLmpvaW4oXCJcIikpXG4gIHJldHVybiB3cmFwcGVyKHBjb21waWxlKHVzZXJfYXJncykpXG59XG5cbnZhciBhc3NpZ25fb3BzID0ge1xuICBhZGQ6ICBcIitcIixcbiAgc3ViOiAgXCItXCIsXG4gIG11bDogIFwiKlwiLFxuICBkaXY6ICBcIi9cIixcbiAgbW9kOiAgXCIlXCIsXG4gIGJhbmQ6IFwiJlwiLFxuICBib3I6ICBcInxcIixcbiAgYnhvcjogXCJeXCIsXG4gIGxzaGlmdDogXCI8PFwiLFxuICByc2hpZnQ6IFwiPj5cIixcbiAgcnJzaGlmdDogXCI+Pj5cIlxufVxuOyhmdW5jdGlvbigpe1xuICBmb3IodmFyIGlkIGluIGFzc2lnbl9vcHMpIHtcbiAgICB2YXIgb3AgPSBhc3NpZ25fb3BzW2lkXVxuICAgIGV4cG9ydHNbaWRdID0gbWFrZU9wKHtcbiAgICAgIGFyZ3M6IFtcImFycmF5XCIsXCJhcnJheVwiLFwiYXJyYXlcIl0sXG4gICAgICBib2R5OiB7YXJnczpbXCJhXCIsXCJiXCIsXCJjXCJdLFxuICAgICAgICAgICAgIGJvZHk6IFwiYT1iXCIrb3ArXCJjXCJ9LFxuICAgICAgZnVuY05hbWU6IGlkXG4gICAgfSlcbiAgICBleHBvcnRzW2lkK1wiZXFcIl0gPSBtYWtlT3Aoe1xuICAgICAgYXJnczogW1wiYXJyYXlcIixcImFycmF5XCJdLFxuICAgICAgYm9keToge2FyZ3M6W1wiYVwiLFwiYlwiXSxcbiAgICAgICAgICAgICBib2R5OlwiYVwiK29wK1wiPWJcIn0sXG4gICAgICBydmFsdWU6IHRydWUsXG4gICAgICBmdW5jTmFtZTogaWQrXCJlcVwiXG4gICAgfSlcbiAgICBleHBvcnRzW2lkK1wic1wiXSA9IG1ha2VPcCh7XG4gICAgICBhcmdzOiBbXCJhcnJheVwiLCBcImFycmF5XCIsIFwic2NhbGFyXCJdLFxuICAgICAgYm9keToge2FyZ3M6W1wiYVwiLFwiYlwiLFwic1wiXSxcbiAgICAgICAgICAgICBib2R5OlwiYT1iXCIrb3ArXCJzXCJ9LFxuICAgICAgZnVuY05hbWU6IGlkK1wic1wiXG4gICAgfSlcbiAgICBleHBvcnRzW2lkK1wic2VxXCJdID0gbWFrZU9wKHtcbiAgICAgIGFyZ3M6IFtcImFycmF5XCIsXCJzY2FsYXJcIl0sXG4gICAgICBib2R5OiB7YXJnczpbXCJhXCIsXCJzXCJdLFxuICAgICAgICAgICAgIGJvZHk6XCJhXCIrb3ArXCI9c1wifSxcbiAgICAgIHJ2YWx1ZTogdHJ1ZSxcbiAgICAgIGZ1bmNOYW1lOiBpZCtcInNlcVwiXG4gICAgfSlcbiAgfVxufSkoKTtcblxudmFyIHVuYXJ5X29wcyA9IHtcbiAgbm90OiBcIiFcIixcbiAgYm5vdDogXCJ+XCIsXG4gIG5lZzogXCItXCIsXG4gIHJlY2lwOiBcIjEuMC9cIlxufVxuOyhmdW5jdGlvbigpe1xuICBmb3IodmFyIGlkIGluIHVuYXJ5X29wcykge1xuICAgIHZhciBvcCA9IHVuYXJ5X29wc1tpZF1cbiAgICBleHBvcnRzW2lkXSA9IG1ha2VPcCh7XG4gICAgICBhcmdzOiBbXCJhcnJheVwiLCBcImFycmF5XCJdLFxuICAgICAgYm9keToge2FyZ3M6W1wiYVwiLFwiYlwiXSxcbiAgICAgICAgICAgICBib2R5OlwiYT1cIitvcCtcImJcIn0sXG4gICAgICBmdW5jTmFtZTogaWRcbiAgICB9KVxuICAgIGV4cG9ydHNbaWQrXCJlcVwiXSA9IG1ha2VPcCh7XG4gICAgICBhcmdzOiBbXCJhcnJheVwiXSxcbiAgICAgIGJvZHk6IHthcmdzOltcImFcIl0sXG4gICAgICAgICAgICAgYm9keTpcImE9XCIrb3ArXCJhXCJ9LFxuICAgICAgcnZhbHVlOiB0cnVlLFxuICAgICAgY291bnQ6IDIsXG4gICAgICBmdW5jTmFtZTogaWQrXCJlcVwiXG4gICAgfSlcbiAgfVxufSkoKTtcblxudmFyIGJpbmFyeV9vcHMgPSB7XG4gIGFuZDogXCImJlwiLFxuICBvcjogXCJ8fFwiLFxuICBlcTogXCI9PT1cIixcbiAgbmVxOiBcIiE9PVwiLFxuICBsdDogXCI8XCIsXG4gIGd0OiBcIj5cIixcbiAgbGVxOiBcIjw9XCIsXG4gIGdlcTogXCI+PVwiXG59XG47KGZ1bmN0aW9uKCkge1xuICBmb3IodmFyIGlkIGluIGJpbmFyeV9vcHMpIHtcbiAgICB2YXIgb3AgPSBiaW5hcnlfb3BzW2lkXVxuICAgIGV4cG9ydHNbaWRdID0gbWFrZU9wKHtcbiAgICAgIGFyZ3M6IFtcImFycmF5XCIsXCJhcnJheVwiLFwiYXJyYXlcIl0sXG4gICAgICBib2R5OiB7YXJnczpbXCJhXCIsIFwiYlwiLCBcImNcIl0sXG4gICAgICAgICAgICAgYm9keTpcImE9YlwiK29wK1wiY1wifSxcbiAgICAgIGZ1bmNOYW1lOiBpZFxuICAgIH0pXG4gICAgZXhwb3J0c1tpZCtcInNcIl0gPSBtYWtlT3Aoe1xuICAgICAgYXJnczogW1wiYXJyYXlcIixcImFycmF5XCIsXCJzY2FsYXJcIl0sXG4gICAgICBib2R5OiB7YXJnczpbXCJhXCIsIFwiYlwiLCBcInNcIl0sXG4gICAgICAgICAgICAgYm9keTpcImE9YlwiK29wK1wic1wifSxcbiAgICAgIGZ1bmNOYW1lOiBpZCtcInNcIlxuICAgIH0pXG4gICAgZXhwb3J0c1tpZCtcImVxXCJdID0gbWFrZU9wKHtcbiAgICAgIGFyZ3M6IFtcImFycmF5XCIsIFwiYXJyYXlcIl0sXG4gICAgICBib2R5OiB7YXJnczpbXCJhXCIsIFwiYlwiXSxcbiAgICAgICAgICAgICBib2R5OlwiYT1hXCIrb3ArXCJiXCJ9LFxuICAgICAgcnZhbHVlOnRydWUsXG4gICAgICBjb3VudDoyLFxuICAgICAgZnVuY05hbWU6IGlkK1wiZXFcIlxuICAgIH0pXG4gICAgZXhwb3J0c1tpZCtcInNlcVwiXSA9IG1ha2VPcCh7XG4gICAgICBhcmdzOiBbXCJhcnJheVwiLCBcInNjYWxhclwiXSxcbiAgICAgIGJvZHk6IHthcmdzOltcImFcIixcInNcIl0sXG4gICAgICAgICAgICAgYm9keTpcImE9YVwiK29wK1wic1wifSxcbiAgICAgIHJ2YWx1ZTp0cnVlLFxuICAgICAgY291bnQ6MixcbiAgICAgIGZ1bmNOYW1lOiBpZCtcInNlcVwiXG4gICAgfSlcbiAgfVxufSkoKTtcblxudmFyIG1hdGhfdW5hcnkgPSBbXG4gIFwiYWJzXCIsXG4gIFwiYWNvc1wiLFxuICBcImFzaW5cIixcbiAgXCJhdGFuXCIsXG4gIFwiY2VpbFwiLFxuICBcImNvc1wiLFxuICBcImV4cFwiLFxuICBcImZsb29yXCIsXG4gIFwibG9nXCIsXG4gIFwicm91bmRcIixcbiAgXCJzaW5cIixcbiAgXCJzcXJ0XCIsXG4gIFwidGFuXCJcbl1cbjsoZnVuY3Rpb24oKSB7XG4gIGZvcih2YXIgaT0wOyBpPG1hdGhfdW5hcnkubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgZiA9IG1hdGhfdW5hcnlbaV1cbiAgICBleHBvcnRzW2ZdID0gbWFrZU9wKHtcbiAgICAgICAgICAgICAgICAgICAgYXJnczogW1wiYXJyYXlcIiwgXCJhcnJheVwiXSxcbiAgICAgICAgICAgICAgICAgICAgcHJlOiB7YXJnczpbXSwgYm9keTpcInRoaXNfZj1NYXRoLlwiK2YsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IHthcmdzOltcImFcIixcImJcIl0sIGJvZHk6XCJhPXRoaXNfZihiKVwiLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgICBmdW5jTmFtZTogZlxuICAgICAgICAgICAgICAgICAgfSlcbiAgICBleHBvcnRzW2YrXCJlcVwiXSA9IG1ha2VPcCh7XG4gICAgICAgICAgICAgICAgICAgICAgYXJnczogW1wiYXJyYXlcIl0sXG4gICAgICAgICAgICAgICAgICAgICAgcHJlOiB7YXJnczpbXSwgYm9keTpcInRoaXNfZj1NYXRoLlwiK2YsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICAgICAgYm9keToge2FyZ3M6IFtcImFcIl0sIGJvZHk6XCJhPXRoaXNfZihhKVwiLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgICAgIHJ2YWx1ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICBjb3VudDogMixcbiAgICAgICAgICAgICAgICAgICAgICBmdW5jTmFtZTogZitcImVxXCJcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgfVxufSkoKTtcblxudmFyIG1hdGhfY29tbSA9IFtcbiAgXCJtYXhcIixcbiAgXCJtaW5cIixcbiAgXCJhdGFuMlwiLFxuICBcInBvd1wiXG5dXG47KGZ1bmN0aW9uKCl7XG4gIGZvcih2YXIgaT0wOyBpPG1hdGhfY29tbS5sZW5ndGg7ICsraSkge1xuICAgIHZhciBmPSBtYXRoX2NvbW1baV1cbiAgICBleHBvcnRzW2ZdID0gbWFrZU9wKHtcbiAgICAgICAgICAgICAgICAgIGFyZ3M6W1wiYXJyYXlcIiwgXCJhcnJheVwiLCBcImFycmF5XCJdLFxuICAgICAgICAgICAgICAgICAgcHJlOiB7YXJnczpbXSwgYm9keTpcInRoaXNfZj1NYXRoLlwiK2YsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICBib2R5OiB7YXJnczpbXCJhXCIsXCJiXCIsXCJjXCJdLCBib2R5OlwiYT10aGlzX2YoYixjKVwiLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgZnVuY05hbWU6IGZcbiAgICAgICAgICAgICAgICB9KVxuICAgIGV4cG9ydHNbZitcInNcIl0gPSBtYWtlT3Aoe1xuICAgICAgICAgICAgICAgICAgYXJnczpbXCJhcnJheVwiLCBcImFycmF5XCIsIFwic2NhbGFyXCJdLFxuICAgICAgICAgICAgICAgICAgcHJlOiB7YXJnczpbXSwgYm9keTpcInRoaXNfZj1NYXRoLlwiK2YsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICBib2R5OiB7YXJnczpbXCJhXCIsXCJiXCIsXCJjXCJdLCBib2R5OlwiYT10aGlzX2YoYixjKVwiLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgZnVuY05hbWU6IGYrXCJzXCJcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgZXhwb3J0c1tmK1wiZXFcIl0gPSBtYWtlT3AoeyBhcmdzOltcImFycmF5XCIsIFwiYXJyYXlcIl0sXG4gICAgICAgICAgICAgICAgICBwcmU6IHthcmdzOltdLCBib2R5OlwidGhpc19mPU1hdGguXCIrZiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgIGJvZHk6IHthcmdzOltcImFcIixcImJcIl0sIGJvZHk6XCJhPXRoaXNfZihhLGIpXCIsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICBydmFsdWU6IHRydWUsXG4gICAgICAgICAgICAgICAgICBjb3VudDogMixcbiAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBmK1wiZXFcIlxuICAgICAgICAgICAgICAgICAgfSlcbiAgICBleHBvcnRzW2YrXCJzZXFcIl0gPSBtYWtlT3AoeyBhcmdzOltcImFycmF5XCIsIFwic2NhbGFyXCJdLFxuICAgICAgICAgICAgICAgICAgcHJlOiB7YXJnczpbXSwgYm9keTpcInRoaXNfZj1NYXRoLlwiK2YsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICBib2R5OiB7YXJnczpbXCJhXCIsXCJiXCJdLCBib2R5OlwiYT10aGlzX2YoYSxiKVwiLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgcnZhbHVlOnRydWUsXG4gICAgICAgICAgICAgICAgICBjb3VudDoyLFxuICAgICAgICAgICAgICAgICAgZnVuY05hbWU6IGYrXCJzZXFcIlxuICAgICAgICAgICAgICAgICAgfSlcbiAgfVxufSkoKTtcblxudmFyIG1hdGhfbm9uY29tbSA9IFtcbiAgXCJhdGFuMlwiLFxuICBcInBvd1wiXG5dXG47KGZ1bmN0aW9uKCl7XG4gIGZvcih2YXIgaT0wOyBpPG1hdGhfbm9uY29tbS5sZW5ndGg7ICsraSkge1xuICAgIHZhciBmPSBtYXRoX25vbmNvbW1baV1cbiAgICBleHBvcnRzW2YrXCJvcFwiXSA9IG1ha2VPcCh7XG4gICAgICAgICAgICAgICAgICBhcmdzOltcImFycmF5XCIsIFwiYXJyYXlcIiwgXCJhcnJheVwiXSxcbiAgICAgICAgICAgICAgICAgIHByZToge2FyZ3M6W10sIGJvZHk6XCJ0aGlzX2Y9TWF0aC5cIitmLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgYm9keToge2FyZ3M6W1wiYVwiLFwiYlwiLFwiY1wiXSwgYm9keTpcImE9dGhpc19mKGMsYilcIiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBmK1wib3BcIlxuICAgICAgICAgICAgICAgIH0pXG4gICAgZXhwb3J0c1tmK1wib3BzXCJdID0gbWFrZU9wKHtcbiAgICAgICAgICAgICAgICAgIGFyZ3M6W1wiYXJyYXlcIiwgXCJhcnJheVwiLCBcInNjYWxhclwiXSxcbiAgICAgICAgICAgICAgICAgIHByZToge2FyZ3M6W10sIGJvZHk6XCJ0aGlzX2Y9TWF0aC5cIitmLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgYm9keToge2FyZ3M6W1wiYVwiLFwiYlwiLFwiY1wiXSwgYm9keTpcImE9dGhpc19mKGMsYilcIiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgIGZ1bmNOYW1lOiBmK1wib3BzXCJcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgZXhwb3J0c1tmK1wib3BlcVwiXSA9IG1ha2VPcCh7IGFyZ3M6W1wiYXJyYXlcIiwgXCJhcnJheVwiXSxcbiAgICAgICAgICAgICAgICAgIHByZToge2FyZ3M6W10sIGJvZHk6XCJ0aGlzX2Y9TWF0aC5cIitmLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgYm9keToge2FyZ3M6W1wiYVwiLFwiYlwiXSwgYm9keTpcImE9dGhpc19mKGIsYSlcIiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgICAgICAgICAgICAgICAgIHJ2YWx1ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIGNvdW50OiAyLFxuICAgICAgICAgICAgICAgICAgZnVuY05hbWU6IGYrXCJvcGVxXCJcbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgZXhwb3J0c1tmK1wib3BzZXFcIl0gPSBtYWtlT3AoeyBhcmdzOltcImFycmF5XCIsIFwic2NhbGFyXCJdLFxuICAgICAgICAgICAgICAgICAgcHJlOiB7YXJnczpbXSwgYm9keTpcInRoaXNfZj1NYXRoLlwiK2YsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gICAgICAgICAgICAgICAgICBib2R5OiB7YXJnczpbXCJhXCIsXCJiXCJdLCBib2R5OlwiYT10aGlzX2YoYixhKVwiLCB0aGlzVmFyczpbXCJ0aGlzX2ZcIl19LFxuICAgICAgICAgICAgICAgICAgcnZhbHVlOnRydWUsXG4gICAgICAgICAgICAgICAgICBjb3VudDoyLFxuICAgICAgICAgICAgICAgICAgZnVuY05hbWU6IGYrXCJvcHNlcVwiXG4gICAgICAgICAgICAgICAgICB9KVxuICB9XG59KSgpO1xuXG5leHBvcnRzLmFueSA9IGNvbXBpbGUoe1xuICBhcmdzOltcImFycmF5XCJdLFxuICBwcmU6IEVtcHR5UHJvYyxcbiAgYm9keToge2FyZ3M6W3tuYW1lOlwiYVwiLCBsdmFsdWU6ZmFsc2UsIHJ2YWx1ZTp0cnVlLCBjb3VudDoxfV0sIGJvZHk6IFwiaWYoYSl7cmV0dXJuIHRydWV9XCIsIGxvY2FsVmFyczogW10sIHRoaXNWYXJzOiBbXX0sXG4gIHBvc3Q6IHthcmdzOltdLCBsb2NhbFZhcnM6W10sIHRoaXNWYXJzOltdLCBib2R5OlwicmV0dXJuIGZhbHNlXCJ9LFxuICBmdW5jTmFtZTogXCJhbnlcIlxufSlcblxuZXhwb3J0cy5hbGwgPSBjb21waWxlKHtcbiAgYXJnczpbXCJhcnJheVwiXSxcbiAgcHJlOiBFbXB0eVByb2MsXG4gIGJvZHk6IHthcmdzOlt7bmFtZTpcInhcIiwgbHZhbHVlOmZhbHNlLCBydmFsdWU6dHJ1ZSwgY291bnQ6MX1dLCBib2R5OiBcImlmKCF4KXtyZXR1cm4gZmFsc2V9XCIsIGxvY2FsVmFyczogW10sIHRoaXNWYXJzOiBbXX0sXG4gIHBvc3Q6IHthcmdzOltdLCBsb2NhbFZhcnM6W10sIHRoaXNWYXJzOltdLCBib2R5OlwicmV0dXJuIHRydWVcIn0sXG4gIGZ1bmNOYW1lOiBcImFsbFwiXG59KVxuXG5leHBvcnRzLnN1bSA9IGNvbXBpbGUoe1xuICBhcmdzOltcImFycmF5XCJdLFxuICBwcmU6IHthcmdzOltdLCBsb2NhbFZhcnM6W10sIHRoaXNWYXJzOltcInRoaXNfc1wiXSwgYm9keTpcInRoaXNfcz0wXCJ9LFxuICBib2R5OiB7YXJnczpbe25hbWU6XCJhXCIsIGx2YWx1ZTpmYWxzZSwgcnZhbHVlOnRydWUsIGNvdW50OjF9XSwgYm9keTogXCJ0aGlzX3MrPWFcIiwgbG9jYWxWYXJzOiBbXSwgdGhpc1ZhcnM6IFtcInRoaXNfc1wiXX0sXG4gIHBvc3Q6IHthcmdzOltdLCBsb2NhbFZhcnM6W10sIHRoaXNWYXJzOltcInRoaXNfc1wiXSwgYm9keTpcInJldHVybiB0aGlzX3NcIn0sXG4gIGZ1bmNOYW1lOiBcInN1bVwiXG59KVxuXG5leHBvcnRzLnByb2QgPSBjb21waWxlKHtcbiAgYXJnczpbXCJhcnJheVwiXSxcbiAgcHJlOiB7YXJnczpbXSwgbG9jYWxWYXJzOltdLCB0aGlzVmFyczpbXCJ0aGlzX3NcIl0sIGJvZHk6XCJ0aGlzX3M9MVwifSxcbiAgYm9keToge2FyZ3M6W3tuYW1lOlwiYVwiLCBsdmFsdWU6ZmFsc2UsIHJ2YWx1ZTp0cnVlLCBjb3VudDoxfV0sIGJvZHk6IFwidGhpc19zKj1hXCIsIGxvY2FsVmFyczogW10sIHRoaXNWYXJzOiBbXCJ0aGlzX3NcIl19LFxuICBwb3N0OiB7YXJnczpbXSwgbG9jYWxWYXJzOltdLCB0aGlzVmFyczpbXCJ0aGlzX3NcIl0sIGJvZHk6XCJyZXR1cm4gdGhpc19zXCJ9LFxuICBmdW5jTmFtZTogXCJwcm9kXCJcbn0pXG5cbmV4cG9ydHMubm9ybTJzcXVhcmVkID0gY29tcGlsZSh7XG4gIGFyZ3M6W1wiYXJyYXlcIl0sXG4gIHByZToge2FyZ3M6W10sIGxvY2FsVmFyczpbXSwgdGhpc1ZhcnM6W1widGhpc19zXCJdLCBib2R5OlwidGhpc19zPTBcIn0sXG4gIGJvZHk6IHthcmdzOlt7bmFtZTpcImFcIiwgbHZhbHVlOmZhbHNlLCBydmFsdWU6dHJ1ZSwgY291bnQ6Mn1dLCBib2R5OiBcInRoaXNfcys9YSphXCIsIGxvY2FsVmFyczogW10sIHRoaXNWYXJzOiBbXCJ0aGlzX3NcIl19LFxuICBwb3N0OiB7YXJnczpbXSwgbG9jYWxWYXJzOltdLCB0aGlzVmFyczpbXCJ0aGlzX3NcIl0sIGJvZHk6XCJyZXR1cm4gdGhpc19zXCJ9LFxuICBmdW5jTmFtZTogXCJub3JtMnNxdWFyZWRcIlxufSlcbiAgXG5leHBvcnRzLm5vcm0yID0gY29tcGlsZSh7XG4gIGFyZ3M6W1wiYXJyYXlcIl0sXG4gIHByZToge2FyZ3M6W10sIGxvY2FsVmFyczpbXSwgdGhpc1ZhcnM6W1widGhpc19zXCJdLCBib2R5OlwidGhpc19zPTBcIn0sXG4gIGJvZHk6IHthcmdzOlt7bmFtZTpcImFcIiwgbHZhbHVlOmZhbHNlLCBydmFsdWU6dHJ1ZSwgY291bnQ6Mn1dLCBib2R5OiBcInRoaXNfcys9YSphXCIsIGxvY2FsVmFyczogW10sIHRoaXNWYXJzOiBbXCJ0aGlzX3NcIl19LFxuICBwb3N0OiB7YXJnczpbXSwgbG9jYWxWYXJzOltdLCB0aGlzVmFyczpbXCJ0aGlzX3NcIl0sIGJvZHk6XCJyZXR1cm4gTWF0aC5zcXJ0KHRoaXNfcylcIn0sXG4gIGZ1bmNOYW1lOiBcIm5vcm0yXCJcbn0pXG4gIFxuXG5leHBvcnRzLm5vcm1pbmYgPSBjb21waWxlKHtcbiAgYXJnczpbXCJhcnJheVwiXSxcbiAgcHJlOiB7YXJnczpbXSwgbG9jYWxWYXJzOltdLCB0aGlzVmFyczpbXCJ0aGlzX3NcIl0sIGJvZHk6XCJ0aGlzX3M9MFwifSxcbiAgYm9keToge2FyZ3M6W3tuYW1lOlwiYVwiLCBsdmFsdWU6ZmFsc2UsIHJ2YWx1ZTp0cnVlLCBjb3VudDo0fV0sIGJvZHk6XCJpZigtYT50aGlzX3Mpe3RoaXNfcz0tYX1lbHNlIGlmKGE+dGhpc19zKXt0aGlzX3M9YX1cIiwgbG9jYWxWYXJzOiBbXSwgdGhpc1ZhcnM6IFtcInRoaXNfc1wiXX0sXG4gIHBvc3Q6IHthcmdzOltdLCBsb2NhbFZhcnM6W10sIHRoaXNWYXJzOltcInRoaXNfc1wiXSwgYm9keTpcInJldHVybiB0aGlzX3NcIn0sXG4gIGZ1bmNOYW1lOiBcIm5vcm1pbmZcIlxufSlcblxuZXhwb3J0cy5ub3JtMSA9IGNvbXBpbGUoe1xuICBhcmdzOltcImFycmF5XCJdLFxuICBwcmU6IHthcmdzOltdLCBsb2NhbFZhcnM6W10sIHRoaXNWYXJzOltcInRoaXNfc1wiXSwgYm9keTpcInRoaXNfcz0wXCJ9LFxuICBib2R5OiB7YXJnczpbe25hbWU6XCJhXCIsIGx2YWx1ZTpmYWxzZSwgcnZhbHVlOnRydWUsIGNvdW50OjN9XSwgYm9keTogXCJ0aGlzX3MrPWE8MD8tYTphXCIsIGxvY2FsVmFyczogW10sIHRoaXNWYXJzOiBbXCJ0aGlzX3NcIl19LFxuICBwb3N0OiB7YXJnczpbXSwgbG9jYWxWYXJzOltdLCB0aGlzVmFyczpbXCJ0aGlzX3NcIl0sIGJvZHk6XCJyZXR1cm4gdGhpc19zXCJ9LFxuICBmdW5jTmFtZTogXCJub3JtMVwiXG59KVxuXG5leHBvcnRzLnN1cCA9IGNvbXBpbGUoe1xuICBhcmdzOiBbIFwiYXJyYXlcIiBdLFxuICBwcmU6XG4gICB7IGJvZHk6IFwidGhpc19oPS1JbmZpbml0eVwiLFxuICAgICBhcmdzOiBbXSxcbiAgICAgdGhpc1ZhcnM6IFsgXCJ0aGlzX2hcIiBdLFxuICAgICBsb2NhbFZhcnM6IFtdIH0sXG4gIGJvZHk6XG4gICB7IGJvZHk6IFwiaWYoX2lubGluZV8xX2FyZzBfPnRoaXNfaCl0aGlzX2g9X2lubGluZV8xX2FyZzBfXCIsXG4gICAgIGFyZ3M6IFt7XCJuYW1lXCI6XCJfaW5saW5lXzFfYXJnMF9cIixcImx2YWx1ZVwiOmZhbHNlLFwicnZhbHVlXCI6dHJ1ZSxcImNvdW50XCI6Mn0gXSxcbiAgICAgdGhpc1ZhcnM6IFsgXCJ0aGlzX2hcIiBdLFxuICAgICBsb2NhbFZhcnM6IFtdIH0sXG4gIHBvc3Q6XG4gICB7IGJvZHk6IFwicmV0dXJuIHRoaXNfaFwiLFxuICAgICBhcmdzOiBbXSxcbiAgICAgdGhpc1ZhcnM6IFsgXCJ0aGlzX2hcIiBdLFxuICAgICBsb2NhbFZhcnM6IFtdIH1cbiB9KVxuXG5leHBvcnRzLmluZiA9IGNvbXBpbGUoe1xuICBhcmdzOiBbIFwiYXJyYXlcIiBdLFxuICBwcmU6XG4gICB7IGJvZHk6IFwidGhpc19oPUluZmluaXR5XCIsXG4gICAgIGFyZ3M6IFtdLFxuICAgICB0aGlzVmFyczogWyBcInRoaXNfaFwiIF0sXG4gICAgIGxvY2FsVmFyczogW10gfSxcbiAgYm9keTpcbiAgIHsgYm9keTogXCJpZihfaW5saW5lXzFfYXJnMF88dGhpc19oKXRoaXNfaD1faW5saW5lXzFfYXJnMF9cIixcbiAgICAgYXJnczogW3tcIm5hbWVcIjpcIl9pbmxpbmVfMV9hcmcwX1wiLFwibHZhbHVlXCI6ZmFsc2UsXCJydmFsdWVcIjp0cnVlLFwiY291bnRcIjoyfSBdLFxuICAgICB0aGlzVmFyczogWyBcInRoaXNfaFwiIF0sXG4gICAgIGxvY2FsVmFyczogW10gfSxcbiAgcG9zdDpcbiAgIHsgYm9keTogXCJyZXR1cm4gdGhpc19oXCIsXG4gICAgIGFyZ3M6IFtdLFxuICAgICB0aGlzVmFyczogWyBcInRoaXNfaFwiIF0sXG4gICAgIGxvY2FsVmFyczogW10gfVxuIH0pXG5cbmV4cG9ydHMuYXJnbWluID0gY29tcGlsZSh7XG4gIGFyZ3M6W1wiaW5kZXhcIixcImFycmF5XCIsXCJzaGFwZVwiXSxcbiAgcHJlOntcbiAgICBib2R5Olwie3RoaXNfdj1JbmZpbml0eTt0aGlzX2k9X2lubGluZV8wX2FyZzJfLnNsaWNlKDApfVwiLFxuICAgIGFyZ3M6W1xuICAgICAge25hbWU6XCJfaW5saW5lXzBfYXJnMF9cIixsdmFsdWU6ZmFsc2UscnZhbHVlOmZhbHNlLGNvdW50OjB9LFxuICAgICAge25hbWU6XCJfaW5saW5lXzBfYXJnMV9cIixsdmFsdWU6ZmFsc2UscnZhbHVlOmZhbHNlLGNvdW50OjB9LFxuICAgICAge25hbWU6XCJfaW5saW5lXzBfYXJnMl9cIixsdmFsdWU6ZmFsc2UscnZhbHVlOnRydWUsY291bnQ6MX1cbiAgICAgIF0sXG4gICAgdGhpc1ZhcnM6W1widGhpc19pXCIsXCJ0aGlzX3ZcIl0sXG4gICAgbG9jYWxWYXJzOltdfSxcbiAgYm9keTp7XG4gICAgYm9keTpcIntpZihfaW5saW5lXzFfYXJnMV88dGhpc192KXt0aGlzX3Y9X2lubGluZV8xX2FyZzFfO2Zvcih2YXIgX2lubGluZV8xX2s9MDtfaW5saW5lXzFfazxfaW5saW5lXzFfYXJnMF8ubGVuZ3RoOysrX2lubGluZV8xX2spe3RoaXNfaVtfaW5saW5lXzFfa109X2lubGluZV8xX2FyZzBfW19pbmxpbmVfMV9rXX19fVwiLFxuICAgIGFyZ3M6W1xuICAgICAge25hbWU6XCJfaW5saW5lXzFfYXJnMF9cIixsdmFsdWU6ZmFsc2UscnZhbHVlOnRydWUsY291bnQ6Mn0sXG4gICAgICB7bmFtZTpcIl9pbmxpbmVfMV9hcmcxX1wiLGx2YWx1ZTpmYWxzZSxydmFsdWU6dHJ1ZSxjb3VudDoyfV0sXG4gICAgdGhpc1ZhcnM6W1widGhpc19pXCIsXCJ0aGlzX3ZcIl0sXG4gICAgbG9jYWxWYXJzOltcIl9pbmxpbmVfMV9rXCJdfSxcbiAgcG9zdDp7XG4gICAgYm9keTpcIntyZXR1cm4gdGhpc19pfVwiLFxuICAgIGFyZ3M6W10sXG4gICAgdGhpc1ZhcnM6W1widGhpc19pXCJdLFxuICAgIGxvY2FsVmFyczpbXX1cbn0pXG5cbmV4cG9ydHMuYXJnbWF4ID0gY29tcGlsZSh7XG4gIGFyZ3M6W1wiaW5kZXhcIixcImFycmF5XCIsXCJzaGFwZVwiXSxcbiAgcHJlOntcbiAgICBib2R5Olwie3RoaXNfdj0tSW5maW5pdHk7dGhpc19pPV9pbmxpbmVfMF9hcmcyXy5zbGljZSgwKX1cIixcbiAgICBhcmdzOltcbiAgICAgIHtuYW1lOlwiX2lubGluZV8wX2FyZzBfXCIsbHZhbHVlOmZhbHNlLHJ2YWx1ZTpmYWxzZSxjb3VudDowfSxcbiAgICAgIHtuYW1lOlwiX2lubGluZV8wX2FyZzFfXCIsbHZhbHVlOmZhbHNlLHJ2YWx1ZTpmYWxzZSxjb3VudDowfSxcbiAgICAgIHtuYW1lOlwiX2lubGluZV8wX2FyZzJfXCIsbHZhbHVlOmZhbHNlLHJ2YWx1ZTp0cnVlLGNvdW50OjF9XG4gICAgICBdLFxuICAgIHRoaXNWYXJzOltcInRoaXNfaVwiLFwidGhpc192XCJdLFxuICAgIGxvY2FsVmFyczpbXX0sXG4gIGJvZHk6e1xuICAgIGJvZHk6XCJ7aWYoX2lubGluZV8xX2FyZzFfPnRoaXNfdil7dGhpc192PV9pbmxpbmVfMV9hcmcxXztmb3IodmFyIF9pbmxpbmVfMV9rPTA7X2lubGluZV8xX2s8X2lubGluZV8xX2FyZzBfLmxlbmd0aDsrK19pbmxpbmVfMV9rKXt0aGlzX2lbX2lubGluZV8xX2tdPV9pbmxpbmVfMV9hcmcwX1tfaW5saW5lXzFfa119fX1cIixcbiAgICBhcmdzOltcbiAgICAgIHtuYW1lOlwiX2lubGluZV8xX2FyZzBfXCIsbHZhbHVlOmZhbHNlLHJ2YWx1ZTp0cnVlLGNvdW50OjJ9LFxuICAgICAge25hbWU6XCJfaW5saW5lXzFfYXJnMV9cIixsdmFsdWU6ZmFsc2UscnZhbHVlOnRydWUsY291bnQ6Mn1dLFxuICAgIHRoaXNWYXJzOltcInRoaXNfaVwiLFwidGhpc192XCJdLFxuICAgIGxvY2FsVmFyczpbXCJfaW5saW5lXzFfa1wiXX0sXG4gIHBvc3Q6e1xuICAgIGJvZHk6XCJ7cmV0dXJuIHRoaXNfaX1cIixcbiAgICBhcmdzOltdLFxuICAgIHRoaXNWYXJzOltcInRoaXNfaVwiXSxcbiAgICBsb2NhbFZhcnM6W119XG59KSAgXG5cbmV4cG9ydHMucmFuZG9tID0gbWFrZU9wKHtcbiAgYXJnczogW1wiYXJyYXlcIl0sXG4gIHByZToge2FyZ3M6W10sIGJvZHk6XCJ0aGlzX2Y9TWF0aC5yYW5kb21cIiwgdGhpc1ZhcnM6W1widGhpc19mXCJdfSxcbiAgYm9keToge2FyZ3M6IFtcImFcIl0sIGJvZHk6XCJhPXRoaXNfZigpXCIsIHRoaXNWYXJzOltcInRoaXNfZlwiXX0sXG4gIGZ1bmNOYW1lOiBcInJhbmRvbVwiXG59KVxuXG5leHBvcnRzLmFzc2lnbiA9IG1ha2VPcCh7XG4gIGFyZ3M6W1wiYXJyYXlcIiwgXCJhcnJheVwiXSxcbiAgYm9keToge2FyZ3M6W1wiYVwiLCBcImJcIl0sIGJvZHk6XCJhPWJcIn0sXG4gIGZ1bmNOYW1lOiBcImFzc2lnblwiIH0pXG5cbmV4cG9ydHMuYXNzaWducyA9IG1ha2VPcCh7XG4gIGFyZ3M6W1wiYXJyYXlcIiwgXCJzY2FsYXJcIl0sXG4gIGJvZHk6IHthcmdzOltcImFcIiwgXCJiXCJdLCBib2R5OlwiYT1iXCJ9LFxuICBmdW5jTmFtZTogXCJhc3NpZ25zXCIgfSlcblxuXG5leHBvcnRzLmVxdWFscyA9IGNvbXBpbGUoe1xuICBhcmdzOltcImFycmF5XCIsIFwiYXJyYXlcIl0sXG4gIHByZTogRW1wdHlQcm9jLFxuICBib2R5OiB7YXJnczpbe25hbWU6XCJ4XCIsIGx2YWx1ZTpmYWxzZSwgcnZhbHVlOnRydWUsIGNvdW50OjF9LFxuICAgICAgICAgICAgICAge25hbWU6XCJ5XCIsIGx2YWx1ZTpmYWxzZSwgcnZhbHVlOnRydWUsIGNvdW50OjF9XSwgXG4gICAgICAgIGJvZHk6IFwiaWYoeCE9PXkpe3JldHVybiBmYWxzZX1cIiwgXG4gICAgICAgIGxvY2FsVmFyczogW10sIFxuICAgICAgICB0aGlzVmFyczogW119LFxuICBwb3N0OiB7YXJnczpbXSwgbG9jYWxWYXJzOltdLCB0aGlzVmFyczpbXSwgYm9keTpcInJldHVybiB0cnVlXCJ9LFxuICBmdW5jTmFtZTogXCJlcXVhbHNcIlxufSlcblxuXG4iLCJcInVzZSBzdHJpY3RcIlxuXG52YXIgbmRhcnJheSA9IHJlcXVpcmUoXCJuZGFycmF5XCIpXG52YXIgZG9fY29udmVydCA9IHJlcXVpcmUoXCIuL2RvQ29udmVydC5qc1wiKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvbnZlcnQoYXJyLCByZXN1bHQpIHtcbiAgdmFyIHNoYXBlID0gW10sIGMgPSBhcnIsIHN6ID0gMVxuICB3aGlsZShBcnJheS5pc0FycmF5KGMpKSB7XG4gICAgc2hhcGUucHVzaChjLmxlbmd0aClcbiAgICBzeiAqPSBjLmxlbmd0aFxuICAgIGMgPSBjWzBdXG4gIH1cbiAgaWYoc2hhcGUubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG5kYXJyYXkoKVxuICB9XG4gIGlmKCFyZXN1bHQpIHtcbiAgICByZXN1bHQgPSBuZGFycmF5KG5ldyBGbG9hdDY0QXJyYXkoc3opLCBzaGFwZSlcbiAgfVxuICBkb19jb252ZXJ0KHJlc3VsdCwgYXJyKVxuICByZXR1cm4gcmVzdWx0XG59XG4iLCJtb2R1bGUuZXhwb3J0cz1yZXF1aXJlKCdjd2lzZS1jb21waWxlcicpKHtcImFyZ3NcIjpbXCJhcnJheVwiLFwic2NhbGFyXCIsXCJpbmRleFwiXSxcInByZVwiOntcImJvZHlcIjpcInt9XCIsXCJhcmdzXCI6W10sXCJ0aGlzVmFyc1wiOltdLFwibG9jYWxWYXJzXCI6W119LFwiYm9keVwiOntcImJvZHlcIjpcIntcXG52YXIgX2lubGluZV8xX3Y9X2lubGluZV8xX2FyZzFfLF9pbmxpbmVfMV9pXFxuZm9yKF9pbmxpbmVfMV9pPTA7X2lubGluZV8xX2k8X2lubGluZV8xX2FyZzJfLmxlbmd0aC0xOysrX2lubGluZV8xX2kpIHtcXG5faW5saW5lXzFfdj1faW5saW5lXzFfdltfaW5saW5lXzFfYXJnMl9bX2lubGluZV8xX2ldXVxcbn1cXG5faW5saW5lXzFfYXJnMF89X2lubGluZV8xX3ZbX2lubGluZV8xX2FyZzJfW19pbmxpbmVfMV9hcmcyXy5sZW5ndGgtMV1dXFxufVwiLFwiYXJnc1wiOlt7XCJuYW1lXCI6XCJfaW5saW5lXzFfYXJnMF9cIixcImx2YWx1ZVwiOnRydWUsXCJydmFsdWVcIjpmYWxzZSxcImNvdW50XCI6MX0se1wibmFtZVwiOlwiX2lubGluZV8xX2FyZzFfXCIsXCJsdmFsdWVcIjpmYWxzZSxcInJ2YWx1ZVwiOnRydWUsXCJjb3VudFwiOjF9LHtcIm5hbWVcIjpcIl9pbmxpbmVfMV9hcmcyX1wiLFwibHZhbHVlXCI6ZmFsc2UsXCJydmFsdWVcIjp0cnVlLFwiY291bnRcIjo0fV0sXCJ0aGlzVmFyc1wiOltdLFwibG9jYWxWYXJzXCI6W1wiX2lubGluZV8xX2lcIixcIl9pbmxpbmVfMV92XCJdfSxcInBvc3RcIjp7XCJib2R5XCI6XCJ7fVwiLFwiYXJnc1wiOltdLFwidGhpc1ZhcnNcIjpbXSxcImxvY2FsVmFyc1wiOltdfSxcImZ1bmNOYW1lXCI6XCJjb252ZXJ0XCIsXCJibG9ja1NpemVcIjo2NH0pXG4iLCJ2YXIgaW90YSA9IHJlcXVpcmUoXCJpb3RhLWFycmF5XCIpXG52YXIgaXNCdWZmZXIgPSByZXF1aXJlKFwiaXMtYnVmZmVyXCIpXG5cbnZhciBoYXNUeXBlZEFycmF5cyAgPSAoKHR5cGVvZiBGbG9hdDY0QXJyYXkpICE9PSBcInVuZGVmaW5lZFwiKVxuXG5mdW5jdGlvbiBjb21wYXJlMXN0KGEsIGIpIHtcbiAgcmV0dXJuIGFbMF0gLSBiWzBdXG59XG5cbmZ1bmN0aW9uIG9yZGVyKCkge1xuICB2YXIgc3RyaWRlID0gdGhpcy5zdHJpZGVcbiAgdmFyIHRlcm1zID0gbmV3IEFycmF5KHN0cmlkZS5sZW5ndGgpXG4gIHZhciBpXG4gIGZvcihpPTA7IGk8dGVybXMubGVuZ3RoOyArK2kpIHtcbiAgICB0ZXJtc1tpXSA9IFtNYXRoLmFicyhzdHJpZGVbaV0pLCBpXVxuICB9XG4gIHRlcm1zLnNvcnQoY29tcGFyZTFzdClcbiAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheSh0ZXJtcy5sZW5ndGgpXG4gIGZvcihpPTA7IGk8cmVzdWx0Lmxlbmd0aDsgKytpKSB7XG4gICAgcmVzdWx0W2ldID0gdGVybXNbaV1bMV1cbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVDb25zdHJ1Y3RvcihkdHlwZSwgZGltZW5zaW9uKSB7XG4gIHZhciBjbGFzc05hbWUgPSBbXCJWaWV3XCIsIGRpbWVuc2lvbiwgXCJkXCIsIGR0eXBlXS5qb2luKFwiXCIpXG4gIGlmKGRpbWVuc2lvbiA8IDApIHtcbiAgICBjbGFzc05hbWUgPSBcIlZpZXdfTmlsXCIgKyBkdHlwZVxuICB9XG4gIHZhciB1c2VHZXR0ZXJzID0gKGR0eXBlID09PSBcImdlbmVyaWNcIilcblxuICBpZihkaW1lbnNpb24gPT09IC0xKSB7XG4gICAgLy9TcGVjaWFsIGNhc2UgZm9yIHRyaXZpYWwgYXJyYXlzXG4gICAgdmFyIGNvZGUgPVxuICAgICAgXCJmdW5jdGlvbiBcIitjbGFzc05hbWUrXCIoYSl7dGhpcy5kYXRhPWE7fTtcXFxudmFyIHByb3RvPVwiK2NsYXNzTmFtZStcIi5wcm90b3R5cGU7XFxcbnByb3RvLmR0eXBlPSdcIitkdHlwZStcIic7XFxcbnByb3RvLmluZGV4PWZ1bmN0aW9uKCl7cmV0dXJuIC0xfTtcXFxucHJvdG8uc2l6ZT0wO1xcXG5wcm90by5kaW1lbnNpb249LTE7XFxcbnByb3RvLnNoYXBlPXByb3RvLnN0cmlkZT1wcm90by5vcmRlcj1bXTtcXFxucHJvdG8ubG89cHJvdG8uaGk9cHJvdG8udHJhbnNwb3NlPXByb3RvLnN0ZXA9XFxcbmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIodGhpcy5kYXRhKTt9O1xcXG5wcm90by5nZXQ9cHJvdG8uc2V0PWZ1bmN0aW9uKCl7fTtcXFxucHJvdG8ucGljaz1mdW5jdGlvbigpe3JldHVybiBudWxsfTtcXFxucmV0dXJuIGZ1bmN0aW9uIGNvbnN0cnVjdF9cIitjbGFzc05hbWUrXCIoYSl7cmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIoYSk7fVwiXG4gICAgdmFyIHByb2NlZHVyZSA9IG5ldyBGdW5jdGlvbihjb2RlKVxuICAgIHJldHVybiBwcm9jZWR1cmUoKVxuICB9IGVsc2UgaWYoZGltZW5zaW9uID09PSAwKSB7XG4gICAgLy9TcGVjaWFsIGNhc2UgZm9yIDBkIGFycmF5c1xuICAgIHZhciBjb2RlID1cbiAgICAgIFwiZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiKGEsZCkge1xcXG50aGlzLmRhdGEgPSBhO1xcXG50aGlzLm9mZnNldCA9IGRcXFxufTtcXFxudmFyIHByb3RvPVwiK2NsYXNzTmFtZStcIi5wcm90b3R5cGU7XFxcbnByb3RvLmR0eXBlPSdcIitkdHlwZStcIic7XFxcbnByb3RvLmluZGV4PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub2Zmc2V0fTtcXFxucHJvdG8uZGltZW5zaW9uPTA7XFxcbnByb3RvLnNpemU9MTtcXFxucHJvdG8uc2hhcGU9XFxcbnByb3RvLnN0cmlkZT1cXFxucHJvdG8ub3JkZXI9W107XFxcbnByb3RvLmxvPVxcXG5wcm90by5oaT1cXFxucHJvdG8udHJhbnNwb3NlPVxcXG5wcm90by5zdGVwPWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9jb3B5KCkge1xcXG5yZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEsdGhpcy5vZmZzZXQpXFxcbn07XFxcbnByb3RvLnBpY2s9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3BpY2soKXtcXFxucmV0dXJuIFRyaXZpYWxBcnJheSh0aGlzLmRhdGEpO1xcXG59O1xcXG5wcm90by52YWx1ZU9mPXByb3RvLmdldD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfZ2V0KCl7XFxcbnJldHVybiBcIisodXNlR2V0dGVycyA/IFwidGhpcy5kYXRhLmdldCh0aGlzLm9mZnNldClcIiA6IFwidGhpcy5kYXRhW3RoaXMub2Zmc2V0XVwiKStcblwifTtcXFxucHJvdG8uc2V0PWZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIl9zZXQodil7XFxcbnJldHVybiBcIisodXNlR2V0dGVycyA/IFwidGhpcy5kYXRhLnNldCh0aGlzLm9mZnNldCx2KVwiIDogXCJ0aGlzLmRhdGFbdGhpcy5vZmZzZXRdPXZcIikrXCJcXFxufTtcXFxucmV0dXJuIGZ1bmN0aW9uIGNvbnN0cnVjdF9cIitjbGFzc05hbWUrXCIoYSxiLGMsZCl7cmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIoYSxkKX1cIlxuICAgIHZhciBwcm9jZWR1cmUgPSBuZXcgRnVuY3Rpb24oXCJUcml2aWFsQXJyYXlcIiwgY29kZSlcbiAgICByZXR1cm4gcHJvY2VkdXJlKENBQ0hFRF9DT05TVFJVQ1RPUlNbZHR5cGVdWzBdKVxuICB9XG5cbiAgdmFyIGNvZGUgPSBbXCIndXNlIHN0cmljdCdcIl1cblxuICAvL0NyZWF0ZSBjb25zdHJ1Y3RvciBmb3Igdmlld1xuICB2YXIgaW5kaWNlcyA9IGlvdGEoZGltZW5zaW9uKVxuICB2YXIgYXJncyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIFwiaVwiK2kgfSlcbiAgdmFyIGluZGV4X3N0ciA9IFwidGhpcy5vZmZzZXQrXCIgKyBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICAgIHJldHVybiBcInRoaXMuc3RyaWRlW1wiICsgaSArIFwiXSppXCIgKyBpXG4gICAgICB9KS5qb2luKFwiK1wiKVxuICB2YXIgc2hhcGVBcmcgPSBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJiXCIraVxuICAgIH0pLmpvaW4oXCIsXCIpXG4gIHZhciBzdHJpZGVBcmcgPSBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJjXCIraVxuICAgIH0pLmpvaW4oXCIsXCIpXG4gIGNvZGUucHVzaChcbiAgICBcImZ1bmN0aW9uIFwiK2NsYXNzTmFtZStcIihhLFwiICsgc2hhcGVBcmcgKyBcIixcIiArIHN0cmlkZUFyZyArIFwiLGQpe3RoaXMuZGF0YT1hXCIsXG4gICAgICBcInRoaXMuc2hhcGU9W1wiICsgc2hhcGVBcmcgKyBcIl1cIixcbiAgICAgIFwidGhpcy5zdHJpZGU9W1wiICsgc3RyaWRlQXJnICsgXCJdXCIsXG4gICAgICBcInRoaXMub2Zmc2V0PWR8MH1cIixcbiAgICBcInZhciBwcm90bz1cIitjbGFzc05hbWUrXCIucHJvdG90eXBlXCIsXG4gICAgXCJwcm90by5kdHlwZT0nXCIrZHR5cGUrXCInXCIsXG4gICAgXCJwcm90by5kaW1lbnNpb249XCIrZGltZW5zaW9uKVxuXG4gIC8vdmlldy5zaXplOlxuICBjb2RlLnB1c2goXCJPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sJ3NpemUnLHtnZXQ6ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3NpemUoKXtcXFxucmV0dXJuIFwiK2luZGljZXMubWFwKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIFwidGhpcy5zaGFwZVtcIitpK1wiXVwiIH0pLmpvaW4oXCIqXCIpLFxuXCJ9fSlcIilcblxuICAvL3ZpZXcub3JkZXI6XG4gIGlmKGRpbWVuc2lvbiA9PT0gMSkge1xuICAgIGNvZGUucHVzaChcInByb3RvLm9yZGVyPVswXVwiKVxuICB9IGVsc2Uge1xuICAgIGNvZGUucHVzaChcIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywnb3JkZXInLHtnZXQ6XCIpXG4gICAgaWYoZGltZW5zaW9uIDwgNCkge1xuICAgICAgY29kZS5wdXNoKFwiZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX29yZGVyKCl7XCIpXG4gICAgICBpZihkaW1lbnNpb24gPT09IDIpIHtcbiAgICAgICAgY29kZS5wdXNoKFwicmV0dXJuIChNYXRoLmFicyh0aGlzLnN0cmlkZVswXSk+TWF0aC5hYnModGhpcy5zdHJpZGVbMV0pKT9bMSwwXTpbMCwxXX19KVwiKVxuICAgICAgfSBlbHNlIGlmKGRpbWVuc2lvbiA9PT0gMykge1xuICAgICAgICBjb2RlLnB1c2goXG5cInZhciBzMD1NYXRoLmFicyh0aGlzLnN0cmlkZVswXSksczE9TWF0aC5hYnModGhpcy5zdHJpZGVbMV0pLHMyPU1hdGguYWJzKHRoaXMuc3RyaWRlWzJdKTtcXFxuaWYoczA+czEpe1xcXG5pZihzMT5zMil7XFxcbnJldHVybiBbMiwxLDBdO1xcXG59ZWxzZSBpZihzMD5zMil7XFxcbnJldHVybiBbMSwyLDBdO1xcXG59ZWxzZXtcXFxucmV0dXJuIFsxLDAsMl07XFxcbn1cXFxufWVsc2UgaWYoczA+czIpe1xcXG5yZXR1cm4gWzIsMCwxXTtcXFxufWVsc2UgaWYoczI+czEpe1xcXG5yZXR1cm4gWzAsMSwyXTtcXFxufWVsc2V7XFxcbnJldHVybiBbMCwyLDFdO1xcXG59fX0pXCIpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGUucHVzaChcIk9SREVSfSlcIilcbiAgICB9XG4gIH1cblxuICAvL3ZpZXcuc2V0KGkwLCAuLi4sIHYpOlxuICBjb2RlLnB1c2goXG5cInByb3RvLnNldD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfc2V0KFwiK2FyZ3Muam9pbihcIixcIikrXCIsdil7XCIpXG4gIGlmKHVzZUdldHRlcnMpIHtcbiAgICBjb2RlLnB1c2goXCJyZXR1cm4gdGhpcy5kYXRhLnNldChcIitpbmRleF9zdHIrXCIsdil9XCIpXG4gIH0gZWxzZSB7XG4gICAgY29kZS5wdXNoKFwicmV0dXJuIHRoaXMuZGF0YVtcIitpbmRleF9zdHIrXCJdPXZ9XCIpXG4gIH1cblxuICAvL3ZpZXcuZ2V0KGkwLCAuLi4pOlxuICBjb2RlLnB1c2goXCJwcm90by5nZXQ9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX2dldChcIithcmdzLmpvaW4oXCIsXCIpK1wiKXtcIilcbiAgaWYodXNlR2V0dGVycykge1xuICAgIGNvZGUucHVzaChcInJldHVybiB0aGlzLmRhdGEuZ2V0KFwiK2luZGV4X3N0citcIil9XCIpXG4gIH0gZWxzZSB7XG4gICAgY29kZS5wdXNoKFwicmV0dXJuIHRoaXMuZGF0YVtcIitpbmRleF9zdHIrXCJdfVwiKVxuICB9XG5cbiAgLy92aWV3LmluZGV4OlxuICBjb2RlLnB1c2goXG4gICAgXCJwcm90by5pbmRleD1mdW5jdGlvbiBcIitjbGFzc05hbWUrXCJfaW5kZXgoXCIsIGFyZ3Muam9pbigpLCBcIil7cmV0dXJuIFwiK2luZGV4X3N0citcIn1cIilcblxuICAvL3ZpZXcuaGkoKTpcbiAgY29kZS5wdXNoKFwicHJvdG8uaGk9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX2hpKFwiK2FyZ3Muam9pbihcIixcIikrXCIpe3JldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKHRoaXMuZGF0YSxcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gW1wiKHR5cGVvZiBpXCIsaSxcIiE9PSdudW1iZXInfHxpXCIsaSxcIjwwKT90aGlzLnNoYXBlW1wiLCBpLCBcIl06aVwiLCBpLFwifDBcIl0uam9pbihcIlwiKVxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcInRoaXMuc3RyaWRlW1wiK2kgKyBcIl1cIlxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLHRoaXMub2Zmc2V0KX1cIilcblxuICAvL3ZpZXcubG8oKTpcbiAgdmFyIGFfdmFycyA9IGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHsgcmV0dXJuIFwiYVwiK2krXCI9dGhpcy5zaGFwZVtcIitpK1wiXVwiIH0pXG4gIHZhciBjX3ZhcnMgPSBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7IHJldHVybiBcImNcIitpK1wiPXRoaXMuc3RyaWRlW1wiK2krXCJdXCIgfSlcbiAgY29kZS5wdXNoKFwicHJvdG8ubG89ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX2xvKFwiK2FyZ3Muam9pbihcIixcIikrXCIpe3ZhciBiPXRoaXMub2Zmc2V0LGQ9MCxcIithX3ZhcnMuam9pbihcIixcIikrXCIsXCIrY192YXJzLmpvaW4oXCIsXCIpKVxuICBmb3IodmFyIGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIGNvZGUucHVzaChcblwiaWYodHlwZW9mIGlcIitpK1wiPT09J251bWJlcicmJmlcIitpK1wiPj0wKXtcXFxuZD1pXCIraStcInwwO1xcXG5iKz1jXCIraStcIipkO1xcXG5hXCIraStcIi09ZH1cIilcbiAgfVxuICBjb2RlLnB1c2goXCJyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwiYVwiK2lcbiAgICB9KS5qb2luKFwiLFwiKStcIixcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJjXCIraVxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLGIpfVwiKVxuXG4gIC8vdmlldy5zdGVwKCk6XG4gIGNvZGUucHVzaChcInByb3RvLnN0ZXA9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3N0ZXAoXCIrYXJncy5qb2luKFwiLFwiKStcIil7dmFyIFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImFcIitpK1wiPXRoaXMuc2hhcGVbXCIraStcIl1cIlxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImJcIitpK1wiPXRoaXMuc3RyaWRlW1wiK2krXCJdXCJcbiAgICB9KS5qb2luKFwiLFwiKStcIixjPXRoaXMub2Zmc2V0LGQ9MCxjZWlsPU1hdGguY2VpbFwiKVxuICBmb3IodmFyIGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIGNvZGUucHVzaChcblwiaWYodHlwZW9mIGlcIitpK1wiPT09J251bWJlcicpe1xcXG5kPWlcIitpK1wifDA7XFxcbmlmKGQ8MCl7XFxcbmMrPWJcIitpK1wiKihhXCIraStcIi0xKTtcXFxuYVwiK2krXCI9Y2VpbCgtYVwiK2krXCIvZClcXFxufWVsc2V7XFxcbmFcIitpK1wiPWNlaWwoYVwiK2krXCIvZClcXFxufVxcXG5iXCIraStcIio9ZFxcXG59XCIpXG4gIH1cbiAgY29kZS5wdXNoKFwicmV0dXJuIG5ldyBcIitjbGFzc05hbWUrXCIodGhpcy5kYXRhLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcImFcIiArIGlcbiAgICB9KS5qb2luKFwiLFwiKStcIixcIitcbiAgICBpbmRpY2VzLm1hcChmdW5jdGlvbihpKSB7XG4gICAgICByZXR1cm4gXCJiXCIgKyBpXG4gICAgfSkuam9pbihcIixcIikrXCIsYyl9XCIpXG5cbiAgLy92aWV3LnRyYW5zcG9zZSgpOlxuICB2YXIgdFNoYXBlID0gbmV3IEFycmF5KGRpbWVuc2lvbilcbiAgdmFyIHRTdHJpZGUgPSBuZXcgQXJyYXkoZGltZW5zaW9uKVxuICBmb3IodmFyIGk9MDsgaTxkaW1lbnNpb247ICsraSkge1xuICAgIHRTaGFwZVtpXSA9IFwiYVtpXCIraStcIl1cIlxuICAgIHRTdHJpZGVbaV0gPSBcImJbaVwiK2krXCJdXCJcbiAgfVxuICBjb2RlLnB1c2goXCJwcm90by50cmFuc3Bvc2U9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3RyYW5zcG9zZShcIithcmdzK1wiKXtcIitcbiAgICBhcmdzLm1hcChmdW5jdGlvbihuLGlkeCkgeyByZXR1cm4gbiArIFwiPShcIiArIG4gKyBcIj09PXVuZGVmaW5lZD9cIiArIGlkeCArIFwiOlwiICsgbiArIFwifDApXCJ9KS5qb2luKFwiO1wiKSxcbiAgICBcInZhciBhPXRoaXMuc2hhcGUsYj10aGlzLnN0cmlkZTtyZXR1cm4gbmV3IFwiK2NsYXNzTmFtZStcIih0aGlzLmRhdGEsXCIrdFNoYXBlLmpvaW4oXCIsXCIpK1wiLFwiK3RTdHJpZGUuam9pbihcIixcIikrXCIsdGhpcy5vZmZzZXQpfVwiKVxuXG4gIC8vdmlldy5waWNrKCk6XG4gIGNvZGUucHVzaChcInByb3RvLnBpY2s9ZnVuY3Rpb24gXCIrY2xhc3NOYW1lK1wiX3BpY2soXCIrYXJncytcIil7dmFyIGE9W10sYj1bXSxjPXRoaXMub2Zmc2V0XCIpXG4gIGZvcih2YXIgaT0wOyBpPGRpbWVuc2lvbjsgKytpKSB7XG4gICAgY29kZS5wdXNoKFwiaWYodHlwZW9mIGlcIitpK1wiPT09J251bWJlcicmJmlcIitpK1wiPj0wKXtjPShjK3RoaXMuc3RyaWRlW1wiK2krXCJdKmlcIitpK1wiKXwwfWVsc2V7YS5wdXNoKHRoaXMuc2hhcGVbXCIraStcIl0pO2IucHVzaCh0aGlzLnN0cmlkZVtcIitpK1wiXSl9XCIpXG4gIH1cbiAgY29kZS5wdXNoKFwidmFyIGN0b3I9Q1RPUl9MSVNUW2EubGVuZ3RoKzFdO3JldHVybiBjdG9yKHRoaXMuZGF0YSxhLGIsYyl9XCIpXG5cbiAgLy9BZGQgcmV0dXJuIHN0YXRlbWVudFxuICBjb2RlLnB1c2goXCJyZXR1cm4gZnVuY3Rpb24gY29uc3RydWN0X1wiK2NsYXNzTmFtZStcIihkYXRhLHNoYXBlLHN0cmlkZSxvZmZzZXQpe3JldHVybiBuZXcgXCIrY2xhc3NOYW1lK1wiKGRhdGEsXCIrXG4gICAgaW5kaWNlcy5tYXAoZnVuY3Rpb24oaSkge1xuICAgICAgcmV0dXJuIFwic2hhcGVbXCIraStcIl1cIlxuICAgIH0pLmpvaW4oXCIsXCIpK1wiLFwiK1xuICAgIGluZGljZXMubWFwKGZ1bmN0aW9uKGkpIHtcbiAgICAgIHJldHVybiBcInN0cmlkZVtcIitpK1wiXVwiXG4gICAgfSkuam9pbihcIixcIikrXCIsb2Zmc2V0KX1cIilcblxuICAvL0NvbXBpbGUgcHJvY2VkdXJlXG4gIHZhciBwcm9jZWR1cmUgPSBuZXcgRnVuY3Rpb24oXCJDVE9SX0xJU1RcIiwgXCJPUkRFUlwiLCBjb2RlLmpvaW4oXCJcXG5cIikpXG4gIHJldHVybiBwcm9jZWR1cmUoQ0FDSEVEX0NPTlNUUlVDVE9SU1tkdHlwZV0sIG9yZGVyKVxufVxuXG5mdW5jdGlvbiBhcnJheURUeXBlKGRhdGEpIHtcbiAgaWYoaXNCdWZmZXIoZGF0YSkpIHtcbiAgICByZXR1cm4gXCJidWZmZXJcIlxuICB9XG4gIGlmKGhhc1R5cGVkQXJyYXlzKSB7XG4gICAgc3dpdGNoKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkYXRhKSkge1xuICAgICAgY2FzZSBcIltvYmplY3QgRmxvYXQ2NEFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJmbG9hdDY0XCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IEZsb2F0MzJBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwiZmxvYXQzMlwiXG4gICAgICBjYXNlIFwiW29iamVjdCBJbnQ4QXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcImludDhcIlxuICAgICAgY2FzZSBcIltvYmplY3QgSW50MTZBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwiaW50MTZcIlxuICAgICAgY2FzZSBcIltvYmplY3QgSW50MzJBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwiaW50MzJcIlxuICAgICAgY2FzZSBcIltvYmplY3QgVWludDhBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwidWludDhcIlxuICAgICAgY2FzZSBcIltvYmplY3QgVWludDE2QXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcInVpbnQxNlwiXG4gICAgICBjYXNlIFwiW29iamVjdCBVaW50MzJBcnJheV1cIjpcbiAgICAgICAgcmV0dXJuIFwidWludDMyXCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJ1aW50OF9jbGFtcGVkXCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IEJpZ0ludDY0QXJyYXldXCI6XG4gICAgICAgIHJldHVybiBcImJpZ2ludDY0XCJcbiAgICAgIGNhc2UgXCJbb2JqZWN0IEJpZ1VpbnQ2NEFycmF5XVwiOlxuICAgICAgICByZXR1cm4gXCJiaWd1aW50NjRcIlxuICAgIH1cbiAgfVxuICBpZihBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgcmV0dXJuIFwiYXJyYXlcIlxuICB9XG4gIHJldHVybiBcImdlbmVyaWNcIlxufVxuXG52YXIgQ0FDSEVEX0NPTlNUUlVDVE9SUyA9IHtcbiAgXCJmbG9hdDMyXCI6W10sXG4gIFwiZmxvYXQ2NFwiOltdLFxuICBcImludDhcIjpbXSxcbiAgXCJpbnQxNlwiOltdLFxuICBcImludDMyXCI6W10sXG4gIFwidWludDhcIjpbXSxcbiAgXCJ1aW50MTZcIjpbXSxcbiAgXCJ1aW50MzJcIjpbXSxcbiAgXCJhcnJheVwiOltdLFxuICBcInVpbnQ4X2NsYW1wZWRcIjpbXSxcbiAgXCJiaWdpbnQ2NFwiOiBbXSxcbiAgXCJiaWd1aW50NjRcIjogW10sXG4gIFwiYnVmZmVyXCI6W10sXG4gIFwiZ2VuZXJpY1wiOltdXG59XG5cbjsoZnVuY3Rpb24oKSB7XG4gIGZvcih2YXIgaWQgaW4gQ0FDSEVEX0NPTlNUUlVDVE9SUykge1xuICAgIENBQ0hFRF9DT05TVFJVQ1RPUlNbaWRdLnB1c2goY29tcGlsZUNvbnN0cnVjdG9yKGlkLCAtMSkpXG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB3cmFwcGVkTkRBcnJheUN0b3IoZGF0YSwgc2hhcGUsIHN0cmlkZSwgb2Zmc2V0KSB7XG4gIGlmKGRhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhciBjdG9yID0gQ0FDSEVEX0NPTlNUUlVDVE9SUy5hcnJheVswXVxuICAgIHJldHVybiBjdG9yKFtdKVxuICB9IGVsc2UgaWYodHlwZW9mIGRhdGEgPT09IFwibnVtYmVyXCIpIHtcbiAgICBkYXRhID0gW2RhdGFdXG4gIH1cbiAgaWYoc2hhcGUgPT09IHVuZGVmaW5lZCkge1xuICAgIHNoYXBlID0gWyBkYXRhLmxlbmd0aCBdXG4gIH1cbiAgdmFyIGQgPSBzaGFwZS5sZW5ndGhcbiAgaWYoc3RyaWRlID09PSB1bmRlZmluZWQpIHtcbiAgICBzdHJpZGUgPSBuZXcgQXJyYXkoZClcbiAgICBmb3IodmFyIGk9ZC0xLCBzej0xOyBpPj0wOyAtLWkpIHtcbiAgICAgIHN0cmlkZVtpXSA9IHN6XG4gICAgICBzeiAqPSBzaGFwZVtpXVxuICAgIH1cbiAgfVxuICBpZihvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIG9mZnNldCA9IDBcbiAgICBmb3IodmFyIGk9MDsgaTxkOyArK2kpIHtcbiAgICAgIGlmKHN0cmlkZVtpXSA8IDApIHtcbiAgICAgICAgb2Zmc2V0IC09IChzaGFwZVtpXS0xKSpzdHJpZGVbaV1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIGR0eXBlID0gYXJyYXlEVHlwZShkYXRhKVxuICB2YXIgY3Rvcl9saXN0ID0gQ0FDSEVEX0NPTlNUUlVDVE9SU1tkdHlwZV1cbiAgd2hpbGUoY3Rvcl9saXN0Lmxlbmd0aCA8PSBkKzEpIHtcbiAgICBjdG9yX2xpc3QucHVzaChjb21waWxlQ29uc3RydWN0b3IoZHR5cGUsIGN0b3JfbGlzdC5sZW5ndGgtMSkpXG4gIH1cbiAgdmFyIGN0b3IgPSBjdG9yX2xpc3RbZCsxXVxuICByZXR1cm4gY3RvcihkYXRhLCBzaGFwZSwgc3RyaWRlLCBvZmZzZXQpXG59XG5cbm1vZHVsZS5leHBvcnRzID0gd3JhcHBlZE5EQXJyYXlDdG9yXG4iLCIvLyAoYykgRGVhbiBNY05hbWVlIDxkZWFuQGdtYWlsLmNvbT4sIDIwMTMuXG4vL1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2RlYW5tL29tZ2dpZlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbi8vIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvXG4vLyBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZVxuLy8gcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yXG4vLyBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuLy8gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4vLyBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbi8vIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbi8vIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HXG4vLyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTXG4vLyBJTiBUSEUgU09GVFdBUkUuXG4vL1xuLy8gb21nZ2lmIGlzIGEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiBhIEdJRiA4OWEgZW5jb2RlciBhbmQgZGVjb2Rlcixcbi8vIGluY2x1ZGluZyBhbmltYXRpb24gYW5kIGNvbXByZXNzaW9uLiAgSXQgZG9lcyBub3QgcmVseSBvbiBhbnkgc3BlY2lmaWNcbi8vIHVuZGVybHlpbmcgc3lzdGVtLCBzbyBzaG91bGQgcnVuIGluIHRoZSBicm93c2VyLCBOb2RlLCBvciBQbGFzay5cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIEdpZldyaXRlcihidWYsIHdpZHRoLCBoZWlnaHQsIGdvcHRzKSB7XG4gIHZhciBwID0gMDtcblxuICB2YXIgZ29wdHMgPSBnb3B0cyA9PT0gdW5kZWZpbmVkID8geyB9IDogZ29wdHM7XG4gIHZhciBsb29wX2NvdW50ID0gZ29wdHMubG9vcCA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGdvcHRzLmxvb3A7XG4gIHZhciBnbG9iYWxfcGFsZXR0ZSA9IGdvcHRzLnBhbGV0dGUgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBnb3B0cy5wYWxldHRlO1xuXG4gIGlmICh3aWR0aCA8PSAwIHx8IGhlaWdodCA8PSAwIHx8IHdpZHRoID4gNjU1MzUgfHwgaGVpZ2h0ID4gNjU1MzUpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiV2lkdGgvSGVpZ2h0IGludmFsaWQuXCIpO1xuXG4gIGZ1bmN0aW9uIGNoZWNrX3BhbGV0dGVfYW5kX251bV9jb2xvcnMocGFsZXR0ZSkge1xuICAgIHZhciBudW1fY29sb3JzID0gcGFsZXR0ZS5sZW5ndGg7XG4gICAgaWYgKG51bV9jb2xvcnMgPCAyIHx8IG51bV9jb2xvcnMgPiAyNTYgfHwgIG51bV9jb2xvcnMgJiAobnVtX2NvbG9ycy0xKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwiSW52YWxpZCBjb2RlL2NvbG9yIGxlbmd0aCwgbXVzdCBiZSBwb3dlciBvZiAyIGFuZCAyIC4uIDI1Ni5cIik7XG4gICAgfVxuICAgIHJldHVybiBudW1fY29sb3JzO1xuICB9XG5cbiAgLy8gLSBIZWFkZXIuXG4gIGJ1ZltwKytdID0gMHg0NzsgYnVmW3ArK10gPSAweDQ5OyBidWZbcCsrXSA9IDB4NDY7ICAvLyBHSUZcbiAgYnVmW3ArK10gPSAweDM4OyBidWZbcCsrXSA9IDB4Mzk7IGJ1ZltwKytdID0gMHg2MTsgIC8vIDg5YVxuXG4gIC8vIEhhbmRsaW5nIG9mIEdsb2JhbCBDb2xvciBUYWJsZSAocGFsZXR0ZSkgYW5kIGJhY2tncm91bmQgaW5kZXguXG4gIHZhciBncF9udW1fY29sb3JzX3BvdzIgPSAwO1xuICB2YXIgYmFja2dyb3VuZCA9IDA7XG4gIGlmIChnbG9iYWxfcGFsZXR0ZSAhPT0gbnVsbCkge1xuICAgIHZhciBncF9udW1fY29sb3JzID0gY2hlY2tfcGFsZXR0ZV9hbmRfbnVtX2NvbG9ycyhnbG9iYWxfcGFsZXR0ZSk7XG4gICAgd2hpbGUgKGdwX251bV9jb2xvcnMgPj49IDEpICsrZ3BfbnVtX2NvbG9yc19wb3cyO1xuICAgIGdwX251bV9jb2xvcnMgPSAxIDw8IGdwX251bV9jb2xvcnNfcG93MjtcbiAgICAtLWdwX251bV9jb2xvcnNfcG93MjtcbiAgICBpZiAoZ29wdHMuYmFja2dyb3VuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBiYWNrZ3JvdW5kID0gZ29wdHMuYmFja2dyb3VuZDtcbiAgICAgIGlmIChiYWNrZ3JvdW5kID49IGdwX251bV9jb2xvcnMpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJhY2tncm91bmQgaW5kZXggb3V0IG9mIHJhbmdlLlwiKTtcbiAgICAgIC8vIFRoZSBHSUYgc3BlYyBzdGF0ZXMgdGhhdCBhIGJhY2tncm91bmQgaW5kZXggb2YgMCBzaG91bGQgYmUgaWdub3JlZCwgc29cbiAgICAgIC8vIHRoaXMgaXMgcHJvYmFibHkgYSBtaXN0YWtlIGFuZCB5b3UgcmVhbGx5IHdhbnQgdG8gc2V0IGl0IHRvIGFub3RoZXJcbiAgICAgIC8vIHNsb3QgaW4gdGhlIHBhbGV0dGUuICBCdXQgYWN0dWFsbHkgaW4gdGhlIGVuZCBtb3N0IGJyb3dzZXJzLCBldGMgZW5kXG4gICAgICAvLyB1cCBpZ25vcmluZyB0aGlzIGFsbW9zdCBjb21wbGV0ZWx5IChpbmNsdWRpbmcgZm9yIGRpc3Bvc2UgYmFja2dyb3VuZCkuXG4gICAgICBpZiAoYmFja2dyb3VuZCA9PT0gMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmFja2dyb3VuZCBpbmRleCBleHBsaWNpdGx5IHBhc3NlZCBhcyAwLlwiKTtcbiAgICB9XG4gIH1cblxuICAvLyAtIExvZ2ljYWwgU2NyZWVuIERlc2NyaXB0b3IuXG4gIC8vIE5PVEUoZGVhbm0pOiB3L2ggYXBwYXJlbnRseSBpZ25vcmVkIGJ5IGltcGxlbWVudGF0aW9ucywgYnV0IHNldCBhbnl3YXkuXG4gIGJ1ZltwKytdID0gd2lkdGggJiAweGZmOyBidWZbcCsrXSA9IHdpZHRoID4+IDggJiAweGZmO1xuICBidWZbcCsrXSA9IGhlaWdodCAmIDB4ZmY7IGJ1ZltwKytdID0gaGVpZ2h0ID4+IDggJiAweGZmO1xuICAvLyBOT1RFOiBJbmRpY2F0ZXMgMC1icHAgb3JpZ2luYWwgY29sb3IgcmVzb2x1dGlvbiAodW51c2VkPykuXG4gIGJ1ZltwKytdID0gKGdsb2JhbF9wYWxldHRlICE9PSBudWxsID8gMHg4MCA6IDApIHwgIC8vIEdsb2JhbCBDb2xvciBUYWJsZSBGbGFnLlxuICAgICAgICAgICAgIGdwX251bV9jb2xvcnNfcG93MjsgIC8vIE5PVEU6IE5vIHNvcnQgZmxhZyAodW51c2VkPykuXG4gIGJ1ZltwKytdID0gYmFja2dyb3VuZDsgIC8vIEJhY2tncm91bmQgQ29sb3IgSW5kZXguXG4gIGJ1ZltwKytdID0gMDsgIC8vIFBpeGVsIGFzcGVjdCByYXRpbyAodW51c2VkPykuXG5cbiAgLy8gLSBHbG9iYWwgQ29sb3IgVGFibGVcbiAgaWYgKGdsb2JhbF9wYWxldHRlICE9PSBudWxsKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGlsID0gZ2xvYmFsX3BhbGV0dGUubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgICAgdmFyIHJnYiA9IGdsb2JhbF9wYWxldHRlW2ldO1xuICAgICAgYnVmW3ArK10gPSByZ2IgPj4gMTYgJiAweGZmO1xuICAgICAgYnVmW3ArK10gPSByZ2IgPj4gOCAmIDB4ZmY7XG4gICAgICBidWZbcCsrXSA9IHJnYiAmIDB4ZmY7XG4gICAgfVxuICB9XG5cbiAgaWYgKGxvb3BfY291bnQgIT09IG51bGwpIHsgIC8vIE5ldHNjYXBlIGJsb2NrIGZvciBsb29waW5nLlxuICAgIGlmIChsb29wX2NvdW50IDwgMCB8fCBsb29wX2NvdW50ID4gNjU1MzUpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMb29wIGNvdW50IGludmFsaWQuXCIpXG4gICAgLy8gRXh0ZW5zaW9uIGNvZGUsIGxhYmVsLCBhbmQgbGVuZ3RoLlxuICAgIGJ1ZltwKytdID0gMHgyMTsgYnVmW3ArK10gPSAweGZmOyBidWZbcCsrXSA9IDB4MGI7XG4gICAgLy8gTkVUU0NBUEUyLjBcbiAgICBidWZbcCsrXSA9IDB4NGU7IGJ1ZltwKytdID0gMHg0NTsgYnVmW3ArK10gPSAweDU0OyBidWZbcCsrXSA9IDB4NTM7XG4gICAgYnVmW3ArK10gPSAweDQzOyBidWZbcCsrXSA9IDB4NDE7IGJ1ZltwKytdID0gMHg1MDsgYnVmW3ArK10gPSAweDQ1O1xuICAgIGJ1ZltwKytdID0gMHgzMjsgYnVmW3ArK10gPSAweDJlOyBidWZbcCsrXSA9IDB4MzA7XG4gICAgLy8gU3ViLWJsb2NrXG4gICAgYnVmW3ArK10gPSAweDAzOyBidWZbcCsrXSA9IDB4MDE7XG4gICAgYnVmW3ArK10gPSBsb29wX2NvdW50ICYgMHhmZjsgYnVmW3ArK10gPSBsb29wX2NvdW50ID4+IDggJiAweGZmO1xuICAgIGJ1ZltwKytdID0gMHgwMDsgIC8vIFRlcm1pbmF0b3IuXG4gIH1cblxuXG4gIHZhciBlbmRlZCA9IGZhbHNlO1xuXG4gIHRoaXMuYWRkRnJhbWUgPSBmdW5jdGlvbih4LCB5LCB3LCBoLCBpbmRleGVkX3BpeGVscywgb3B0cykge1xuICAgIGlmIChlbmRlZCA9PT0gdHJ1ZSkgeyAtLXA7IGVuZGVkID0gZmFsc2U7IH0gIC8vIFVuLWVuZC5cblxuICAgIG9wdHMgPSBvcHRzID09PSB1bmRlZmluZWQgPyB7IH0gOiBvcHRzO1xuXG4gICAgLy8gVE9ETyhkZWFubSk6IEJvdW5kcyBjaGVjayB4LCB5LiAgRG8gdGhleSBuZWVkIHRvIGJlIHdpdGhpbiB0aGUgdmlydHVhbFxuICAgIC8vIGNhbnZhcyB3aWR0aC9oZWlnaHQsIEkgaW1hZ2luZT9cbiAgICBpZiAoeCA8IDAgfHwgeSA8IDAgfHwgeCA+IDY1NTM1IHx8IHkgPiA2NTUzNSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIngveSBpbnZhbGlkLlwiKVxuXG4gICAgaWYgKHcgPD0gMCB8fCBoIDw9IDAgfHwgdyA+IDY1NTM1IHx8IGggPiA2NTUzNSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIldpZHRoL0hlaWdodCBpbnZhbGlkLlwiKVxuXG4gICAgaWYgKGluZGV4ZWRfcGl4ZWxzLmxlbmd0aCA8IHcgKiBoKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm90IGVub3VnaCBwaXhlbHMgZm9yIHRoZSBmcmFtZSBzaXplLlwiKTtcblxuICAgIHZhciB1c2luZ19sb2NhbF9wYWxldHRlID0gdHJ1ZTtcbiAgICB2YXIgcGFsZXR0ZSA9IG9wdHMucGFsZXR0ZTtcbiAgICBpZiAocGFsZXR0ZSA9PT0gdW5kZWZpbmVkIHx8IHBhbGV0dGUgPT09IG51bGwpIHtcbiAgICAgIHVzaW5nX2xvY2FsX3BhbGV0dGUgPSBmYWxzZTtcbiAgICAgIHBhbGV0dGUgPSBnbG9iYWxfcGFsZXR0ZTtcbiAgICB9XG5cbiAgICBpZiAocGFsZXR0ZSA9PT0gdW5kZWZpbmVkIHx8IHBhbGV0dGUgPT09IG51bGwpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHN1cHBseSBlaXRoZXIgYSBsb2NhbCBvciBnbG9iYWwgcGFsZXR0ZS5cIik7XG5cbiAgICB2YXIgbnVtX2NvbG9ycyA9IGNoZWNrX3BhbGV0dGVfYW5kX251bV9jb2xvcnMocGFsZXR0ZSk7XG5cbiAgICAvLyBDb21wdXRlIHRoZSBtaW5fY29kZV9zaXplIChwb3dlciBvZiAyKSwgZGVzdHJveWluZyBudW1fY29sb3JzLlxuICAgIHZhciBtaW5fY29kZV9zaXplID0gMDtcbiAgICB3aGlsZSAobnVtX2NvbG9ycyA+Pj0gMSkgKyttaW5fY29kZV9zaXplO1xuICAgIG51bV9jb2xvcnMgPSAxIDw8IG1pbl9jb2RlX3NpemU7ICAvLyBOb3cgd2UgY2FuIGVhc2lseSBnZXQgaXQgYmFjay5cblxuICAgIHZhciBkZWxheSA9IG9wdHMuZGVsYXkgPT09IHVuZGVmaW5lZCA/IDAgOiBvcHRzLmRlbGF5O1xuXG4gICAgLy8gRnJvbSB0aGUgc3BlYzpcbiAgICAvLyAgICAgMCAtICAgTm8gZGlzcG9zYWwgc3BlY2lmaWVkLiBUaGUgZGVjb2RlciBpc1xuICAgIC8vICAgICAgICAgICBub3QgcmVxdWlyZWQgdG8gdGFrZSBhbnkgYWN0aW9uLlxuICAgIC8vICAgICAxIC0gICBEbyBub3QgZGlzcG9zZS4gVGhlIGdyYXBoaWMgaXMgdG8gYmUgbGVmdFxuICAgIC8vICAgICAgICAgICBpbiBwbGFjZS5cbiAgICAvLyAgICAgMiAtICAgUmVzdG9yZSB0byBiYWNrZ3JvdW5kIGNvbG9yLiBUaGUgYXJlYSB1c2VkIGJ5IHRoZVxuICAgIC8vICAgICAgICAgICBncmFwaGljIG11c3QgYmUgcmVzdG9yZWQgdG8gdGhlIGJhY2tncm91bmQgY29sb3IuXG4gICAgLy8gICAgIDMgLSAgIFJlc3RvcmUgdG8gcHJldmlvdXMuIFRoZSBkZWNvZGVyIGlzIHJlcXVpcmVkIHRvXG4gICAgLy8gICAgICAgICAgIHJlc3RvcmUgdGhlIGFyZWEgb3ZlcndyaXR0ZW4gYnkgdGhlIGdyYXBoaWMgd2l0aFxuICAgIC8vICAgICAgICAgICB3aGF0IHdhcyB0aGVyZSBwcmlvciB0byByZW5kZXJpbmcgdGhlIGdyYXBoaWMuXG4gICAgLy8gIDQtNyAtICAgIFRvIGJlIGRlZmluZWQuXG4gICAgLy8gTk9URShkZWFubSk6IERpc3Bvc2UgYmFja2dyb3VuZCBkb2Vzbid0IHJlYWxseSB3b3JrLCBhcHBhcmVudGx5IG1vc3RcbiAgICAvLyBicm93c2VycyBpZ25vcmUgdGhlIGJhY2tncm91bmQgcGFsZXR0ZSBpbmRleCBhbmQgY2xlYXIgdG8gdHJhbnNwYXJlbmN5LlxuICAgIHZhciBkaXNwb3NhbCA9IG9wdHMuZGlzcG9zYWwgPT09IHVuZGVmaW5lZCA/IDAgOiBvcHRzLmRpc3Bvc2FsO1xuICAgIGlmIChkaXNwb3NhbCA8IDAgfHwgZGlzcG9zYWwgPiAzKSAgLy8gNC03IGlzIHJlc2VydmVkLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGlzcG9zYWwgb3V0IG9mIHJhbmdlLlwiKTtcblxuICAgIHZhciB1c2VfdHJhbnNwYXJlbmN5ID0gZmFsc2U7XG4gICAgdmFyIHRyYW5zcGFyZW50X2luZGV4ID0gMDtcbiAgICBpZiAob3B0cy50cmFuc3BhcmVudCAhPT0gdW5kZWZpbmVkICYmIG9wdHMudHJhbnNwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgIHVzZV90cmFuc3BhcmVuY3kgPSB0cnVlO1xuICAgICAgdHJhbnNwYXJlbnRfaW5kZXggPSBvcHRzLnRyYW5zcGFyZW50O1xuICAgICAgaWYgKHRyYW5zcGFyZW50X2luZGV4IDwgMCB8fCB0cmFuc3BhcmVudF9pbmRleCA+PSBudW1fY29sb3JzKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc3BhcmVudCBjb2xvciBpbmRleC5cIik7XG4gICAgfVxuXG4gICAgaWYgKGRpc3Bvc2FsICE9PSAwIHx8IHVzZV90cmFuc3BhcmVuY3kgfHwgZGVsYXkgIT09IDApIHtcbiAgICAgIC8vIC0gR3JhcGhpY3MgQ29udHJvbCBFeHRlbnNpb25cbiAgICAgIGJ1ZltwKytdID0gMHgyMTsgYnVmW3ArK10gPSAweGY5OyAgLy8gRXh0ZW5zaW9uIC8gTGFiZWwuXG4gICAgICBidWZbcCsrXSA9IDQ7ICAvLyBCeXRlIHNpemUuXG5cbiAgICAgIGJ1ZltwKytdID0gZGlzcG9zYWwgPDwgMiB8ICh1c2VfdHJhbnNwYXJlbmN5ID09PSB0cnVlID8gMSA6IDApO1xuICAgICAgYnVmW3ArK10gPSBkZWxheSAmIDB4ZmY7IGJ1ZltwKytdID0gZGVsYXkgPj4gOCAmIDB4ZmY7XG4gICAgICBidWZbcCsrXSA9IHRyYW5zcGFyZW50X2luZGV4OyAgLy8gVHJhbnNwYXJlbnQgY29sb3IgaW5kZXguXG4gICAgICBidWZbcCsrXSA9IDA7ICAvLyBCbG9jayBUZXJtaW5hdG9yLlxuICAgIH1cblxuICAgIC8vIC0gSW1hZ2UgRGVzY3JpcHRvclxuICAgIGJ1ZltwKytdID0gMHgyYzsgIC8vIEltYWdlIFNlcGVyYXRvci5cbiAgICBidWZbcCsrXSA9IHggJiAweGZmOyBidWZbcCsrXSA9IHggPj4gOCAmIDB4ZmY7ICAvLyBMZWZ0LlxuICAgIGJ1ZltwKytdID0geSAmIDB4ZmY7IGJ1ZltwKytdID0geSA+PiA4ICYgMHhmZjsgIC8vIFRvcC5cbiAgICBidWZbcCsrXSA9IHcgJiAweGZmOyBidWZbcCsrXSA9IHcgPj4gOCAmIDB4ZmY7XG4gICAgYnVmW3ArK10gPSBoICYgMHhmZjsgYnVmW3ArK10gPSBoID4+IDggJiAweGZmO1xuICAgIC8vIE5PVEU6IE5vIHNvcnQgZmxhZyAodW51c2VkPykuXG4gICAgLy8gVE9ETyhkZWFubSk6IFN1cHBvcnQgaW50ZXJsYWNlLlxuICAgIGJ1ZltwKytdID0gdXNpbmdfbG9jYWxfcGFsZXR0ZSA9PT0gdHJ1ZSA/ICgweDgwIHwgKG1pbl9jb2RlX3NpemUtMSkpIDogMDtcblxuICAgIC8vIC0gTG9jYWwgQ29sb3IgVGFibGVcbiAgICBpZiAodXNpbmdfbG9jYWxfcGFsZXR0ZSA9PT0gdHJ1ZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGlsID0gcGFsZXR0ZS5sZW5ndGg7IGkgPCBpbDsgKytpKSB7XG4gICAgICAgIHZhciByZ2IgPSBwYWxldHRlW2ldO1xuICAgICAgICBidWZbcCsrXSA9IHJnYiA+PiAxNiAmIDB4ZmY7XG4gICAgICAgIGJ1ZltwKytdID0gcmdiID4+IDggJiAweGZmO1xuICAgICAgICBidWZbcCsrXSA9IHJnYiAmIDB4ZmY7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcCA9IEdpZldyaXRlck91dHB1dExaV0NvZGVTdHJlYW0oXG4gICAgICAgICAgICBidWYsIHAsIG1pbl9jb2RlX3NpemUgPCAyID8gMiA6IG1pbl9jb2RlX3NpemUsIGluZGV4ZWRfcGl4ZWxzKTtcblxuICAgIHJldHVybiBwO1xuICB9O1xuXG4gIHRoaXMuZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKGVuZGVkID09PSBmYWxzZSkge1xuICAgICAgYnVmW3ArK10gPSAweDNiOyAgLy8gVHJhaWxlci5cbiAgICAgIGVuZGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH07XG5cbiAgdGhpcy5nZXRPdXRwdXRCdWZmZXIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIGJ1ZjsgfTtcbiAgdGhpcy5zZXRPdXRwdXRCdWZmZXIgPSBmdW5jdGlvbih2KSB7IGJ1ZiA9IHY7IH07XG4gIHRoaXMuZ2V0T3V0cHV0QnVmZmVyUG9zaXRpb24gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHA7IH07XG4gIHRoaXMuc2V0T3V0cHV0QnVmZmVyUG9zaXRpb24gPSBmdW5jdGlvbih2KSB7IHAgPSB2OyB9O1xufVxuXG4vLyBNYWluIGNvbXByZXNzaW9uIHJvdXRpbmUsIHBhbGV0dGUgaW5kZXhlcyAtPiBMWlcgY29kZSBzdHJlYW0uXG4vLyB8aW5kZXhfc3RyZWFtfCBtdXN0IGhhdmUgYXQgbGVhc3Qgb25lIGVudHJ5LlxuZnVuY3Rpb24gR2lmV3JpdGVyT3V0cHV0TFpXQ29kZVN0cmVhbShidWYsIHAsIG1pbl9jb2RlX3NpemUsIGluZGV4X3N0cmVhbSkge1xuICBidWZbcCsrXSA9IG1pbl9jb2RlX3NpemU7XG4gIHZhciBjdXJfc3ViYmxvY2sgPSBwKys7ICAvLyBQb2ludGluZyBhdCB0aGUgbGVuZ3RoIGZpZWxkLlxuXG4gIHZhciBjbGVhcl9jb2RlID0gMSA8PCBtaW5fY29kZV9zaXplO1xuICB2YXIgY29kZV9tYXNrID0gY2xlYXJfY29kZSAtIDE7XG4gIHZhciBlb2lfY29kZSA9IGNsZWFyX2NvZGUgKyAxO1xuICB2YXIgbmV4dF9jb2RlID0gZW9pX2NvZGUgKyAxO1xuXG4gIHZhciBjdXJfY29kZV9zaXplID0gbWluX2NvZGVfc2l6ZSArIDE7ICAvLyBOdW1iZXIgb2YgYml0cyBwZXIgY29kZS5cbiAgdmFyIGN1cl9zaGlmdCA9IDA7XG4gIC8vIFdlIGhhdmUgYXQgbW9zdCAxMi1iaXQgY29kZXMsIHNvIHdlIHNob3VsZCBoYXZlIHRvIGhvbGQgYSBtYXggb2YgMTlcbiAgLy8gYml0cyBoZXJlIChhbmQgdGhlbiB3ZSB3b3VsZCB3cml0ZSBvdXQpLlxuICB2YXIgY3VyID0gMDtcblxuICBmdW5jdGlvbiBlbWl0X2J5dGVzX3RvX2J1ZmZlcihiaXRfYmxvY2tfc2l6ZSkge1xuICAgIHdoaWxlIChjdXJfc2hpZnQgPj0gYml0X2Jsb2NrX3NpemUpIHtcbiAgICAgIGJ1ZltwKytdID0gY3VyICYgMHhmZjtcbiAgICAgIGN1ciA+Pj0gODsgY3VyX3NoaWZ0IC09IDg7XG4gICAgICBpZiAocCA9PT0gY3VyX3N1YmJsb2NrICsgMjU2KSB7ICAvLyBGaW5pc2hlZCBhIHN1YmJsb2NrLlxuICAgICAgICBidWZbY3VyX3N1YmJsb2NrXSA9IDI1NTtcbiAgICAgICAgY3VyX3N1YmJsb2NrID0gcCsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVtaXRfY29kZShjKSB7XG4gICAgY3VyIHw9IGMgPDwgY3VyX3NoaWZ0O1xuICAgIGN1cl9zaGlmdCArPSBjdXJfY29kZV9zaXplO1xuICAgIGVtaXRfYnl0ZXNfdG9fYnVmZmVyKDgpO1xuICB9XG5cbiAgLy8gSSBhbSBub3QgYW4gZXhwZXJ0IG9uIHRoZSB0b3BpYywgYW5kIEkgZG9uJ3Qgd2FudCB0byB3cml0ZSBhIHRoZXNpcy5cbiAgLy8gSG93ZXZlciwgaXQgaXMgZ29vZCB0byBvdXRsaW5lIGhlcmUgdGhlIGJhc2ljIGFsZ29yaXRobSBhbmQgdGhlIGZldyBkYXRhXG4gIC8vIHN0cnVjdHVyZXMgYW5kIG9wdGltaXphdGlvbnMgaGVyZSB0aGF0IG1ha2UgdGhpcyBpbXBsZW1lbnRhdGlvbiBmYXN0LlxuICAvLyBUaGUgYmFzaWMgaWRlYSBiZWhpbmQgTFpXIGlzIHRvIGJ1aWxkIGEgdGFibGUgb2YgcHJldmlvdXNseSBzZWVuIHJ1bnNcbiAgLy8gYWRkcmVzc2VkIGJ5IGEgc2hvcnQgaWQgKGhlcmVpbiBjYWxsZWQgb3V0cHV0IGNvZGUpLiAgQWxsIGRhdGEgaXNcbiAgLy8gcmVmZXJlbmNlZCBieSBhIGNvZGUsIHdoaWNoIHJlcHJlc2VudHMgb25lIG9yIG1vcmUgdmFsdWVzIGZyb20gdGhlXG4gIC8vIG9yaWdpbmFsIGlucHV0IHN0cmVhbS4gIEFsbCBpbnB1dCBieXRlcyBjYW4gYmUgcmVmZXJlbmNlZCBhcyB0aGUgc2FtZVxuICAvLyB2YWx1ZSBhcyBhbiBvdXRwdXQgY29kZS4gIFNvIGlmIHlvdSBkaWRuJ3Qgd2FudCBhbnkgY29tcHJlc3Npb24sIHlvdVxuICAvLyBjb3VsZCBtb3JlIG9yIGxlc3MganVzdCBvdXRwdXQgdGhlIG9yaWdpbmFsIGJ5dGVzIGFzIGNvZGVzICh0aGVyZSBhcmVcbiAgLy8gc29tZSBkZXRhaWxzIHRvIHRoaXMsIGJ1dCBpdCBpcyB0aGUgaWRlYSkuICBJbiBvcmRlciB0byBhY2hpZXZlXG4gIC8vIGNvbXByZXNzaW9uLCB2YWx1ZXMgZ3JlYXRlciB0aGVuIHRoZSBpbnB1dCByYW5nZSAoY29kZXMgY2FuIGJlIHVwIHRvXG4gIC8vIDEyLWJpdCB3aGlsZSBpbnB1dCBvbmx5IDgtYml0KSByZXByZXNlbnQgYSBzZXF1ZW5jZSBvZiBwcmV2aW91c2x5IHNlZW5cbiAgLy8gaW5wdXRzLiAgVGhlIGRlY29tcHJlc3NvciBpcyBhYmxlIHRvIGJ1aWxkIHRoZSBzYW1lIG1hcHBpbmcgd2hpbGVcbiAgLy8gZGVjb2RpbmcsIHNvIHRoZXJlIGlzIGFsd2F5cyBhIHNoYXJlZCBjb21tb24ga25vd2xlZGdlIGJldHdlZW4gdGhlXG4gIC8vIGVuY29kaW5nIGFuZCBkZWNvZGVyLCB3aGljaCBpcyBhbHNvIGltcG9ydGFudCBmb3IgXCJ0aW1pbmdcIiBhc3BlY3RzIGxpa2VcbiAgLy8gaG93IHRvIGhhbmRsZSB2YXJpYWJsZSBiaXQgd2lkdGggY29kZSBlbmNvZGluZy5cbiAgLy9cbiAgLy8gT25lIG9idmlvdXMgYnV0IHZlcnkgaW1wb3J0YW50IGNvbnNlcXVlbmNlIG9mIHRoZSB0YWJsZSBzeXN0ZW0gaXMgdGhlcmVcbiAgLy8gaXMgYWx3YXlzIGEgdW5pcXVlIGlkIChhdCBtb3N0IDEyLWJpdHMpIHRvIG1hcCB0aGUgcnVucy4gICdBJyBtaWdodCBiZVxuICAvLyA0LCB0aGVuICdBQScgbWlnaHQgYmUgMTAsICdBQUEnIDExLCAnQUFBQScgMTIsIGV0Yy4gIFRoaXMgcmVsYXRpb25zaGlwXG4gIC8vIGNhbiBiZSB1c2VkIGZvciBhbiBlZmZlY2llbnQgbG9va3VwIHN0cmF0ZWd5IGZvciB0aGUgY29kZSBtYXBwaW5nLiAgV2VcbiAgLy8gbmVlZCB0byBrbm93IGlmIGEgcnVuIGhhcyBiZWVuIHNlZW4gYmVmb3JlLCBhbmQgYmUgYWJsZSB0byBtYXAgdGhhdCBydW5cbiAgLy8gdG8gdGhlIG91dHB1dCBjb2RlLiAgU2luY2Ugd2Ugc3RhcnQgd2l0aCBrbm93biB1bmlxdWUgaWRzIChpbnB1dCBieXRlcyksXG4gIC8vIGFuZCB0aGVuIGZyb20gdGhvc2UgYnVpbGQgbW9yZSB1bmlxdWUgaWRzICh0YWJsZSBlbnRyaWVzKSwgd2UgY2FuXG4gIC8vIGNvbnRpbnVlIHRoaXMgY2hhaW4gKGFsbW9zdCBsaWtlIGEgbGlua2VkIGxpc3QpIHRvIGFsd2F5cyBoYXZlIHNtYWxsXG4gIC8vIGludGVnZXIgdmFsdWVzIHRoYXQgcmVwcmVzZW50IHRoZSBjdXJyZW50IGJ5dGUgY2hhaW5zIGluIHRoZSBlbmNvZGVyLlxuICAvLyBUaGlzIG1lYW5zIGluc3RlYWQgb2YgdHJhY2tpbmcgdGhlIGlucHV0IGJ5dGVzIChBQUFBQkNEKSB0byBrbm93IG91clxuICAvLyBjdXJyZW50IHN0YXRlLCB3ZSBjYW4gdHJhY2sgdGhlIHRhYmxlIGVudHJ5IGZvciBBQUFBQkMgKGl0IGlzIGd1YXJhbnRlZWRcbiAgLy8gdG8gZXhpc3QgYnkgdGhlIG5hdHVyZSBvZiB0aGUgYWxnb3JpdGhtKSBhbmQgdGhlIG5leHQgY2hhcmFjdGVyIEQuXG4gIC8vIFRoZXJlZm9yIHRoZSB0dXBsZSBvZiAodGFibGVfZW50cnksIGJ5dGUpIGlzIGd1YXJhbnRlZWQgdG8gYWxzbyBiZVxuICAvLyB1bmlxdWUuICBUaGlzIGFsbG93cyB1cyB0byBjcmVhdGUgYSBzaW1wbGUgbG9va3VwIGtleSBmb3IgbWFwcGluZyBpbnB1dFxuICAvLyBzZXF1ZW5jZXMgdG8gY29kZXMgKHRhYmxlIGluZGljZXMpIHdpdGhvdXQgaGF2aW5nIHRvIHN0b3JlIG9yIHNlYXJjaFxuICAvLyBhbnkgb2YgdGhlIGNvZGUgc2VxdWVuY2VzLiAgU28gaWYgJ0FBQUEnIGhhcyBhIHRhYmxlIGVudHJ5IG9mIDEyLCB0aGVcbiAgLy8gdHVwbGUgb2YgKCdBQUFBJywgSykgZm9yIGFueSBpbnB1dCBieXRlIEsgd2lsbCBiZSB1bmlxdWUsIGFuZCBjYW4gYmUgb3VyXG4gIC8vIGtleS4gIFRoaXMgbGVhZHMgdG8gYSBpbnRlZ2VyIHZhbHVlIGF0IG1vc3QgMjAtYml0cywgd2hpY2ggY2FuIGFsd2F5c1xuICAvLyBmaXQgaW4gYW4gU01JIHZhbHVlIGFuZCBiZSB1c2VkIGFzIGEgZmFzdCBzcGFyc2UgYXJyYXkgLyBvYmplY3Qga2V5LlxuXG4gIC8vIE91dHB1dCBjb2RlIGZvciB0aGUgY3VycmVudCBjb250ZW50cyBvZiB0aGUgaW5kZXggYnVmZmVyLlxuICB2YXIgaWJfY29kZSA9IGluZGV4X3N0cmVhbVswXSAmIGNvZGVfbWFzazsgIC8vIExvYWQgZmlyc3QgaW5wdXQgaW5kZXguXG4gIHZhciBjb2RlX3RhYmxlID0geyB9OyAgLy8gS2V5J2Qgb24gb3VyIDIwLWJpdCBcInR1cGxlXCIuXG5cbiAgZW1pdF9jb2RlKGNsZWFyX2NvZGUpOyAgLy8gU3BlYyBzYXlzIGZpcnN0IGNvZGUgc2hvdWxkIGJlIGEgY2xlYXIgY29kZS5cblxuICAvLyBGaXJzdCBpbmRleCBhbHJlYWR5IGxvYWRlZCwgcHJvY2VzcyB0aGUgcmVzdCBvZiB0aGUgc3RyZWFtLlxuICBmb3IgKHZhciBpID0gMSwgaWwgPSBpbmRleF9zdHJlYW0ubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgIHZhciBrID0gaW5kZXhfc3RyZWFtW2ldICYgY29kZV9tYXNrO1xuICAgIHZhciBjdXJfa2V5ID0gaWJfY29kZSA8PCA4IHwgazsgIC8vIChwcmV2LCBrKSB1bmlxdWUgdHVwbGUuXG4gICAgdmFyIGN1cl9jb2RlID0gY29kZV90YWJsZVtjdXJfa2V5XTsgIC8vIGJ1ZmZlciArIGsuXG5cbiAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIHRvIGNyZWF0ZSBhIG5ldyBjb2RlIHRhYmxlIGVudHJ5LlxuICAgIGlmIChjdXJfY29kZSA9PT0gdW5kZWZpbmVkKSB7ICAvLyBXZSBkb24ndCBoYXZlIGJ1ZmZlciArIGsuXG4gICAgICAvLyBFbWl0IGluZGV4IGJ1ZmZlciAod2l0aG91dCBrKS5cbiAgICAgIC8vIFRoaXMgaXMgYW4gaW5saW5lIHZlcnNpb24gb2YgZW1pdF9jb2RlLCBiZWNhdXNlIHRoaXMgaXMgdGhlIGNvcmVcbiAgICAgIC8vIHdyaXRpbmcgcm91dGluZSBvZiB0aGUgY29tcHJlc3NvciAoYW5kIFY4IGNhbm5vdCBpbmxpbmUgZW1pdF9jb2RlXG4gICAgICAvLyBiZWNhdXNlIGl0IGlzIGEgY2xvc3VyZSBoZXJlIGluIGEgZGlmZmVyZW50IGNvbnRleHQpLiAgQWRkaXRpb25hbGx5XG4gICAgICAvLyB3ZSBjYW4gY2FsbCBlbWl0X2J5dGVfdG9fYnVmZmVyIGxlc3Mgb2Z0ZW4sIGJlY2F1c2Ugd2UgY2FuIGhhdmVcbiAgICAgIC8vIDMwLWJpdHMgKGZyb20gb3VyIDMxLWJpdCBzaWduZWQgU01JKSwgYW5kIHdlIGtub3cgb3VyIGNvZGVzIHdpbGwgb25seVxuICAgICAgLy8gYmUgMTItYml0cywgc28gY2FuIHNhZmVseSBoYXZlIDE4LWJpdHMgdGhlcmUgd2l0aG91dCBvdmVyZmxvdy5cbiAgICAgIC8vIGVtaXRfY29kZShpYl9jb2RlKTtcbiAgICAgIGN1ciB8PSBpYl9jb2RlIDw8IGN1cl9zaGlmdDtcbiAgICAgIGN1cl9zaGlmdCArPSBjdXJfY29kZV9zaXplO1xuICAgICAgd2hpbGUgKGN1cl9zaGlmdCA+PSA4KSB7XG4gICAgICAgIGJ1ZltwKytdID0gY3VyICYgMHhmZjtcbiAgICAgICAgY3VyID4+PSA4OyBjdXJfc2hpZnQgLT0gODtcbiAgICAgICAgaWYgKHAgPT09IGN1cl9zdWJibG9jayArIDI1NikgeyAgLy8gRmluaXNoZWQgYSBzdWJibG9jay5cbiAgICAgICAgICBidWZbY3VyX3N1YmJsb2NrXSA9IDI1NTtcbiAgICAgICAgICBjdXJfc3ViYmxvY2sgPSBwKys7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG5leHRfY29kZSA9PT0gNDA5NikgeyAgLy8gVGFibGUgZnVsbCwgbmVlZCBhIGNsZWFyLlxuICAgICAgICBlbWl0X2NvZGUoY2xlYXJfY29kZSk7XG4gICAgICAgIG5leHRfY29kZSA9IGVvaV9jb2RlICsgMTtcbiAgICAgICAgY3VyX2NvZGVfc2l6ZSA9IG1pbl9jb2RlX3NpemUgKyAxO1xuICAgICAgICBjb2RlX3RhYmxlID0geyB9O1xuICAgICAgfSBlbHNlIHsgIC8vIFRhYmxlIG5vdCBmdWxsLCBpbnNlcnQgYSBuZXcgZW50cnkuXG4gICAgICAgIC8vIEluY3JlYXNlIG91ciB2YXJpYWJsZSBiaXQgY29kZSBzaXplcyBpZiBuZWNlc3NhcnkuICBUaGlzIGlzIGEgYml0XG4gICAgICAgIC8vIHRyaWNreSBhcyBpdCBpcyBiYXNlZCBvbiBcInRpbWluZ1wiIGJldHdlZW4gdGhlIGVuY29kaW5nIGFuZFxuICAgICAgICAvLyBkZWNvZGVyLiAgRnJvbSB0aGUgZW5jb2RlcnMgcGVyc3BlY3RpdmUgdGhpcyBzaG91bGQgaGFwcGVuIGFmdGVyXG4gICAgICAgIC8vIHdlJ3ZlIGFscmVhZHkgZW1pdHRlZCB0aGUgaW5kZXggYnVmZmVyIGFuZCBhcmUgYWJvdXQgdG8gY3JlYXRlIHRoZVxuICAgICAgICAvLyBmaXJzdCB0YWJsZSBlbnRyeSB0aGF0IHdvdWxkIG92ZXJmbG93IG91ciBjdXJyZW50IGNvZGUgYml0IHNpemUuXG4gICAgICAgIGlmIChuZXh0X2NvZGUgPj0gKDEgPDwgY3VyX2NvZGVfc2l6ZSkpICsrY3VyX2NvZGVfc2l6ZTtcbiAgICAgICAgY29kZV90YWJsZVtjdXJfa2V5XSA9IG5leHRfY29kZSsrOyAgLy8gSW5zZXJ0IGludG8gY29kZSB0YWJsZS5cbiAgICAgIH1cblxuICAgICAgaWJfY29kZSA9IGs7ICAvLyBJbmRleCBidWZmZXIgdG8gc2luZ2xlIGlucHV0IGsuXG4gICAgfSBlbHNlIHtcbiAgICAgIGliX2NvZGUgPSBjdXJfY29kZTsgIC8vIEluZGV4IGJ1ZmZlciB0byBzZXF1ZW5jZSBpbiBjb2RlIHRhYmxlLlxuICAgIH1cbiAgfVxuXG4gIGVtaXRfY29kZShpYl9jb2RlKTsgIC8vIFRoZXJlIHdpbGwgc3RpbGwgYmUgc29tZXRoaW5nIGluIHRoZSBpbmRleCBidWZmZXIuXG4gIGVtaXRfY29kZShlb2lfY29kZSk7ICAvLyBFbmQgT2YgSW5mb3JtYXRpb24uXG5cbiAgLy8gRmx1c2ggLyBmaW5hbGl6ZSB0aGUgc3ViLWJsb2NrcyBzdHJlYW0gdG8gdGhlIGJ1ZmZlci5cbiAgZW1pdF9ieXRlc190b19idWZmZXIoMSk7XG5cbiAgLy8gRmluaXNoIHRoZSBzdWItYmxvY2tzLCB3cml0aW5nIG91dCBhbnkgdW5maW5pc2hlZCBsZW5ndGhzIGFuZFxuICAvLyB0ZXJtaW5hdGluZyB3aXRoIGEgc3ViLWJsb2NrIG9mIGxlbmd0aCAwLiAgSWYgd2UgaGF2ZSBhbHJlYWR5IHN0YXJ0ZWRcbiAgLy8gYnV0IG5vdCB5ZXQgdXNlZCBhIHN1Yi1ibG9jayBpdCBjYW4ganVzdCBiZWNvbWUgdGhlIHRlcm1pbmF0b3IuXG4gIGlmIChjdXJfc3ViYmxvY2sgKyAxID09PSBwKSB7ICAvLyBTdGFydGVkIGJ1dCB1bnVzZWQuXG4gICAgYnVmW2N1cl9zdWJibG9ja10gPSAwO1xuICB9IGVsc2UgeyAgLy8gU3RhcnRlZCBhbmQgdXNlZCwgd3JpdGUgbGVuZ3RoIGFuZCBhZGRpdGlvbmFsIHRlcm1pbmF0b3IgYmxvY2suXG4gICAgYnVmW2N1cl9zdWJibG9ja10gPSBwIC0gY3VyX3N1YmJsb2NrIC0gMTtcbiAgICBidWZbcCsrXSA9IDA7XG4gIH1cbiAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIEdpZlJlYWRlcihidWYpIHtcbiAgdmFyIHAgPSAwO1xuXG4gIC8vIC0gSGVhZGVyIChHSUY4N2Egb3IgR0lGODlhKS5cbiAgaWYgKGJ1ZltwKytdICE9PSAweDQ3IHx8ICAgICAgICAgICAgYnVmW3ArK10gIT09IDB4NDkgfHwgYnVmW3ArK10gIT09IDB4NDYgfHxcbiAgICAgIGJ1ZltwKytdICE9PSAweDM4IHx8IChidWZbcCsrXSsxICYgMHhmZCkgIT09IDB4MzggfHwgYnVmW3ArK10gIT09IDB4NjEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIEdJRiA4N2EvODlhIGhlYWRlci5cIik7XG4gIH1cblxuICAvLyAtIExvZ2ljYWwgU2NyZWVuIERlc2NyaXB0b3IuXG4gIHZhciB3aWR0aCA9IGJ1ZltwKytdIHwgYnVmW3ArK10gPDwgODtcbiAgdmFyIGhlaWdodCA9IGJ1ZltwKytdIHwgYnVmW3ArK10gPDwgODtcbiAgdmFyIHBmMCA9IGJ1ZltwKytdOyAgLy8gPFBhY2tlZCBGaWVsZHM+LlxuICB2YXIgZ2xvYmFsX3BhbGV0dGVfZmxhZyA9IHBmMCA+PiA3O1xuICB2YXIgbnVtX2dsb2JhbF9jb2xvcnNfcG93MiA9IHBmMCAmIDB4NztcbiAgdmFyIG51bV9nbG9iYWxfY29sb3JzID0gMSA8PCAobnVtX2dsb2JhbF9jb2xvcnNfcG93MiArIDEpO1xuICB2YXIgYmFja2dyb3VuZCA9IGJ1ZltwKytdO1xuICBidWZbcCsrXTsgIC8vIFBpeGVsIGFzcGVjdCByYXRpbyAodW51c2VkPykuXG5cbiAgdmFyIGdsb2JhbF9wYWxldHRlX29mZnNldCA9IG51bGw7XG4gIHZhciBnbG9iYWxfcGFsZXR0ZV9zaXplICAgPSBudWxsO1xuXG4gIGlmIChnbG9iYWxfcGFsZXR0ZV9mbGFnKSB7XG4gICAgZ2xvYmFsX3BhbGV0dGVfb2Zmc2V0ID0gcDtcbiAgICBnbG9iYWxfcGFsZXR0ZV9zaXplID0gbnVtX2dsb2JhbF9jb2xvcnM7XG4gICAgcCArPSBudW1fZ2xvYmFsX2NvbG9ycyAqIDM7ICAvLyBTZWVrIHBhc3QgcGFsZXR0ZS5cbiAgfVxuXG4gIHZhciBub19lb2YgPSB0cnVlO1xuXG4gIHZhciBmcmFtZXMgPSBbIF07XG5cbiAgdmFyIGRlbGF5ID0gMDtcbiAgdmFyIHRyYW5zcGFyZW50X2luZGV4ID0gbnVsbDtcbiAgdmFyIGRpc3Bvc2FsID0gMDsgIC8vIDAgLSBObyBkaXNwb3NhbCBzcGVjaWZpZWQuXG4gIHZhciBsb29wX2NvdW50ID0gbnVsbDtcblxuICB0aGlzLndpZHRoID0gd2lkdGg7XG4gIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gIHdoaWxlIChub19lb2YgJiYgcCA8IGJ1Zi5sZW5ndGgpIHtcbiAgICBzd2l0Y2ggKGJ1ZltwKytdKSB7XG4gICAgICBjYXNlIDB4MjE6ICAvLyBHcmFwaGljcyBDb250cm9sIEV4dGVuc2lvbiBCbG9ja1xuICAgICAgICBzd2l0Y2ggKGJ1ZltwKytdKSB7XG4gICAgICAgICAgY2FzZSAweGZmOiAgLy8gQXBwbGljYXRpb24gc3BlY2lmaWMgYmxvY2tcbiAgICAgICAgICAgIC8vIFRyeSBpZiBpdCdzIGEgTmV0c2NhcGUgYmxvY2sgKHdpdGggYW5pbWF0aW9uIGxvb3AgY291bnRlcikuXG4gICAgICAgICAgICBpZiAoYnVmW3AgICBdICE9PSAweDBiIHx8ICAvLyAyMSBGRiBhbHJlYWR5IHJlYWQsIGNoZWNrIGJsb2NrIHNpemUuXG4gICAgICAgICAgICAgICAgLy8gTkVUU0NBUEUyLjBcbiAgICAgICAgICAgICAgICBidWZbcCsxIF0gPT0gMHg0ZSAmJiBidWZbcCsyIF0gPT0gMHg0NSAmJiBidWZbcCszIF0gPT0gMHg1NCAmJlxuICAgICAgICAgICAgICAgIGJ1ZltwKzQgXSA9PSAweDUzICYmIGJ1ZltwKzUgXSA9PSAweDQzICYmIGJ1ZltwKzYgXSA9PSAweDQxICYmXG4gICAgICAgICAgICAgICAgYnVmW3ArNyBdID09IDB4NTAgJiYgYnVmW3ArOCBdID09IDB4NDUgJiYgYnVmW3ArOSBdID09IDB4MzIgJiZcbiAgICAgICAgICAgICAgICBidWZbcCsxMF0gPT0gMHgyZSAmJiBidWZbcCsxMV0gPT0gMHgzMCAmJlxuICAgICAgICAgICAgICAgIC8vIFN1Yi1ibG9ja1xuICAgICAgICAgICAgICAgIGJ1ZltwKzEyXSA9PSAweDAzICYmIGJ1ZltwKzEzXSA9PSAweDAxICYmIGJ1ZltwKzE2XSA9PSAwKSB7XG4gICAgICAgICAgICAgIHAgKz0gMTQ7XG4gICAgICAgICAgICAgIGxvb3BfY291bnQgPSBidWZbcCsrXSB8IGJ1ZltwKytdIDw8IDg7XG4gICAgICAgICAgICAgIHArKzsgIC8vIFNraXAgdGVybWluYXRvci5cbiAgICAgICAgICAgIH0gZWxzZSB7ICAvLyBXZSBkb24ndCBrbm93IHdoYXQgaXQgaXMsIGp1c3QgdHJ5IHRvIGdldCBwYXN0IGl0LlxuICAgICAgICAgICAgICBwICs9IDEyO1xuICAgICAgICAgICAgICB3aGlsZSAodHJ1ZSkgeyAgLy8gU2VlayB0aHJvdWdoIHN1YmJsb2Nrcy5cbiAgICAgICAgICAgICAgICB2YXIgYmxvY2tfc2l6ZSA9IGJ1ZltwKytdO1xuICAgICAgICAgICAgICAgIC8vIEJhZCBibG9jayBzaXplIChleDogdW5kZWZpbmVkIGZyb20gYW4gb3V0IG9mIGJvdW5kcyByZWFkKS5cbiAgICAgICAgICAgICAgICBpZiAoIShibG9ja19zaXplID49IDApKSB0aHJvdyBFcnJvcihcIkludmFsaWQgYmxvY2sgc2l6ZVwiKTtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2tfc2l6ZSA9PT0gMCkgYnJlYWs7ICAvLyAwIHNpemUgaXMgdGVybWluYXRvclxuICAgICAgICAgICAgICAgIHAgKz0gYmxvY2tfc2l6ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDB4Zjk6ICAvLyBHcmFwaGljcyBDb250cm9sIEV4dGVuc2lvblxuICAgICAgICAgICAgaWYgKGJ1ZltwKytdICE9PSAweDQgfHwgYnVmW3ArNF0gIT09IDApXG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZ3JhcGhpY3MgZXh0ZW5zaW9uIGJsb2NrLlwiKTtcbiAgICAgICAgICAgIHZhciBwZjEgPSBidWZbcCsrXTtcbiAgICAgICAgICAgIGRlbGF5ID0gYnVmW3ArK10gfCBidWZbcCsrXSA8PCA4O1xuICAgICAgICAgICAgdHJhbnNwYXJlbnRfaW5kZXggPSBidWZbcCsrXTtcbiAgICAgICAgICAgIGlmICgocGYxICYgMSkgPT09IDApIHRyYW5zcGFyZW50X2luZGV4ID0gbnVsbDtcbiAgICAgICAgICAgIGRpc3Bvc2FsID0gcGYxID4+IDIgJiAweDc7XG4gICAgICAgICAgICBwKys7ICAvLyBTa2lwIHRlcm1pbmF0b3IuXG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgMHhmZTogIC8vIENvbW1lbnQgRXh0ZW5zaW9uLlxuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHsgIC8vIFNlZWsgdGhyb3VnaCBzdWJibG9ja3MuXG4gICAgICAgICAgICAgIHZhciBibG9ja19zaXplID0gYnVmW3ArK107XG4gICAgICAgICAgICAgIC8vIEJhZCBibG9jayBzaXplIChleDogdW5kZWZpbmVkIGZyb20gYW4gb3V0IG9mIGJvdW5kcyByZWFkKS5cbiAgICAgICAgICAgICAgaWYgKCEoYmxvY2tfc2l6ZSA+PSAwKSkgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIGJsb2NrIHNpemVcIik7XG4gICAgICAgICAgICAgIGlmIChibG9ja19zaXplID09PSAwKSBicmVhazsgIC8vIDAgc2l6ZSBpcyB0ZXJtaW5hdG9yXG4gICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKGJ1Zi5zbGljZShwLCBwK2Jsb2NrX3NpemUpLnRvU3RyaW5nKCdhc2NpaScpKTtcbiAgICAgICAgICAgICAgcCArPSBibG9ja19zaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiVW5rbm93biBncmFwaGljIGNvbnRyb2wgbGFiZWw6IDB4XCIgKyBidWZbcC0xXS50b1N0cmluZygxNikpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDB4MmM6ICAvLyBJbWFnZSBEZXNjcmlwdG9yLlxuICAgICAgICB2YXIgeCA9IGJ1ZltwKytdIHwgYnVmW3ArK10gPDwgODtcbiAgICAgICAgdmFyIHkgPSBidWZbcCsrXSB8IGJ1ZltwKytdIDw8IDg7XG4gICAgICAgIHZhciB3ID0gYnVmW3ArK10gfCBidWZbcCsrXSA8PCA4O1xuICAgICAgICB2YXIgaCA9IGJ1ZltwKytdIHwgYnVmW3ArK10gPDwgODtcbiAgICAgICAgdmFyIHBmMiA9IGJ1ZltwKytdO1xuICAgICAgICB2YXIgbG9jYWxfcGFsZXR0ZV9mbGFnID0gcGYyID4+IDc7XG4gICAgICAgIHZhciBpbnRlcmxhY2VfZmxhZyA9IHBmMiA+PiA2ICYgMTtcbiAgICAgICAgdmFyIG51bV9sb2NhbF9jb2xvcnNfcG93MiA9IHBmMiAmIDB4NztcbiAgICAgICAgdmFyIG51bV9sb2NhbF9jb2xvcnMgPSAxIDw8IChudW1fbG9jYWxfY29sb3JzX3BvdzIgKyAxKTtcbiAgICAgICAgdmFyIHBhbGV0dGVfb2Zmc2V0ID0gZ2xvYmFsX3BhbGV0dGVfb2Zmc2V0O1xuICAgICAgICB2YXIgcGFsZXR0ZV9zaXplID0gZ2xvYmFsX3BhbGV0dGVfc2l6ZTtcbiAgICAgICAgdmFyIGhhc19sb2NhbF9wYWxldHRlID0gZmFsc2U7XG4gICAgICAgIGlmIChsb2NhbF9wYWxldHRlX2ZsYWcpIHtcbiAgICAgICAgICB2YXIgaGFzX2xvY2FsX3BhbGV0dGUgPSB0cnVlO1xuICAgICAgICAgIHBhbGV0dGVfb2Zmc2V0ID0gcDsgIC8vIE92ZXJyaWRlIHdpdGggbG9jYWwgcGFsZXR0ZS5cbiAgICAgICAgICBwYWxldHRlX3NpemUgPSBudW1fbG9jYWxfY29sb3JzO1xuICAgICAgICAgIHAgKz0gbnVtX2xvY2FsX2NvbG9ycyAqIDM7ICAvLyBTZWVrIHBhc3QgcGFsZXR0ZS5cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkYXRhX29mZnNldCA9IHA7XG5cbiAgICAgICAgcCsrOyAgLy8gY29kZXNpemVcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICB2YXIgYmxvY2tfc2l6ZSA9IGJ1ZltwKytdO1xuICAgICAgICAgIC8vIEJhZCBibG9jayBzaXplIChleDogdW5kZWZpbmVkIGZyb20gYW4gb3V0IG9mIGJvdW5kcyByZWFkKS5cbiAgICAgICAgICBpZiAoIShibG9ja19zaXplID49IDApKSB0aHJvdyBFcnJvcihcIkludmFsaWQgYmxvY2sgc2l6ZVwiKTtcbiAgICAgICAgICBpZiAoYmxvY2tfc2l6ZSA9PT0gMCkgYnJlYWs7ICAvLyAwIHNpemUgaXMgdGVybWluYXRvclxuICAgICAgICAgIHAgKz0gYmxvY2tfc2l6ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZyYW1lcy5wdXNoKHt4OiB4LCB5OiB5LCB3aWR0aDogdywgaGVpZ2h0OiBoLFxuICAgICAgICAgICAgICAgICAgICAgaGFzX2xvY2FsX3BhbGV0dGU6IGhhc19sb2NhbF9wYWxldHRlLFxuICAgICAgICAgICAgICAgICAgICAgcGFsZXR0ZV9vZmZzZXQ6IHBhbGV0dGVfb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgcGFsZXR0ZV9zaXplOiBwYWxldHRlX3NpemUsXG4gICAgICAgICAgICAgICAgICAgICBkYXRhX29mZnNldDogZGF0YV9vZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICBkYXRhX2xlbmd0aDogcCAtIGRhdGFfb2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgdHJhbnNwYXJlbnRfaW5kZXg6IHRyYW5zcGFyZW50X2luZGV4LFxuICAgICAgICAgICAgICAgICAgICAgaW50ZXJsYWNlZDogISFpbnRlcmxhY2VfZmxhZyxcbiAgICAgICAgICAgICAgICAgICAgIGRlbGF5OiBkZWxheSxcbiAgICAgICAgICAgICAgICAgICAgIGRpc3Bvc2FsOiBkaXNwb3NhbH0pO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAweDNiOiAgLy8gVHJhaWxlciBNYXJrZXIgKGVuZCBvZiBmaWxlKS5cbiAgICAgICAgbm9fZW9mID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGdpZiBibG9jazogMHhcIiArIGJ1ZltwLTFdLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMubnVtRnJhbWVzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGZyYW1lcy5sZW5ndGg7XG4gIH07XG5cbiAgdGhpcy5sb29wQ291bnQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbG9vcF9jb3VudDtcbiAgfTtcblxuICB0aGlzLmZyYW1lSW5mbyA9IGZ1bmN0aW9uKGZyYW1lX251bSkge1xuICAgIGlmIChmcmFtZV9udW0gPCAwIHx8IGZyYW1lX251bSA+PSBmcmFtZXMubGVuZ3RoKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRnJhbWUgaW5kZXggb3V0IG9mIHJhbmdlLlwiKTtcbiAgICByZXR1cm4gZnJhbWVzW2ZyYW1lX251bV07XG4gIH1cblxuICB0aGlzLmRlY29kZUFuZEJsaXRGcmFtZUJHUkEgPSBmdW5jdGlvbihmcmFtZV9udW0sIHBpeGVscykge1xuICAgIHZhciBmcmFtZSA9IHRoaXMuZnJhbWVJbmZvKGZyYW1lX251bSk7XG4gICAgdmFyIG51bV9waXhlbHMgPSBmcmFtZS53aWR0aCAqIGZyYW1lLmhlaWdodDtcbiAgICB2YXIgaW5kZXhfc3RyZWFtID0gbmV3IFVpbnQ4QXJyYXkobnVtX3BpeGVscyk7ICAvLyBBdCBtb3N0IDgtYml0IGluZGljZXMuXG4gICAgR2lmUmVhZGVyTFpXT3V0cHV0SW5kZXhTdHJlYW0oXG4gICAgICAgIGJ1ZiwgZnJhbWUuZGF0YV9vZmZzZXQsIGluZGV4X3N0cmVhbSwgbnVtX3BpeGVscyk7XG4gICAgdmFyIHBhbGV0dGVfb2Zmc2V0ID0gZnJhbWUucGFsZXR0ZV9vZmZzZXQ7XG5cbiAgICAvLyBOT1RFKGRlYW5tKTogSXQgc2VlbXMgdG8gYmUgbXVjaCBmYXN0ZXIgdG8gY29tcGFyZSBpbmRleCB0byAyNTYgdGhhblxuICAgIC8vIHRvID09PSBudWxsLiAgTm90IHN1cmUgd2h5LCBidXQgQ29tcGFyZVN0dWJfRVFfU1RSSUNUIHNob3dzIHVwIGhpZ2ggaW5cbiAgICAvLyB0aGUgcHJvZmlsZSwgbm90IHN1cmUgaWYgaXQncyByZWxhdGVkIHRvIHVzaW5nIGEgVWludDhBcnJheS5cbiAgICB2YXIgdHJhbnMgPSBmcmFtZS50cmFuc3BhcmVudF9pbmRleDtcbiAgICBpZiAodHJhbnMgPT09IG51bGwpIHRyYW5zID0gMjU2O1xuXG4gICAgLy8gV2UgYXJlIHBvc3NpYmx5IGp1c3QgYmxpdHRpbmcgdG8gYSBwb3J0aW9uIG9mIHRoZSBlbnRpcmUgZnJhbWUuXG4gICAgLy8gVGhhdCBpcyBhIHN1YnJlY3Qgd2l0aGluIHRoZSBmcmFtZXJlY3QsIHNvIHRoZSBhZGRpdGlvbmFsIHBpeGVsc1xuICAgIC8vIG11c3QgYmUgc2tpcHBlZCBvdmVyIGFmdGVyIHdlIGZpbmlzaGVkIGEgc2NhbmxpbmUuXG4gICAgdmFyIGZyYW1ld2lkdGggID0gZnJhbWUud2lkdGg7XG4gICAgdmFyIGZyYW1lc3RyaWRlID0gd2lkdGggLSBmcmFtZXdpZHRoO1xuICAgIHZhciB4bGVmdCAgICAgICA9IGZyYW1ld2lkdGg7ICAvLyBOdW1iZXIgb2Ygc3VicmVjdCBwaXhlbHMgbGVmdCBpbiBzY2FubGluZS5cblxuICAgIC8vIE91dHB1dCBpbmRpY2llcyBvZiB0aGUgdG9wIGxlZnQgYW5kIGJvdHRvbSByaWdodCBjb3JuZXJzIG9mIHRoZSBzdWJyZWN0LlxuICAgIHZhciBvcGJlZyA9ICgoZnJhbWUueSAqIHdpZHRoKSArIGZyYW1lLngpICogNDtcbiAgICB2YXIgb3BlbmQgPSAoKGZyYW1lLnkgKyBmcmFtZS5oZWlnaHQpICogd2lkdGggKyBmcmFtZS54KSAqIDQ7XG4gICAgdmFyIG9wICAgID0gb3BiZWc7XG5cbiAgICB2YXIgc2NhbnN0cmlkZSA9IGZyYW1lc3RyaWRlICogNDtcblxuICAgIC8vIFVzZSBzY2Fuc3RyaWRlIHRvIHNraXAgcGFzdCB0aGUgcm93cyB3aGVuIGludGVybGFjaW5nLiAgVGhpcyBpcyBza2lwcGluZ1xuICAgIC8vIDcgcm93cyBmb3IgdGhlIGZpcnN0IHR3byBwYXNzZXMsIHRoZW4gMyB0aGVuIDEuXG4gICAgaWYgKGZyYW1lLmludGVybGFjZWQgPT09IHRydWUpIHtcbiAgICAgIHNjYW5zdHJpZGUgKz0gd2lkdGggKiA0ICogNzsgIC8vIFBhc3MgMS5cbiAgICB9XG5cbiAgICB2YXIgaW50ZXJsYWNlc2tpcCA9IDg7ICAvLyBUcmFja2luZyB0aGUgcm93IGludGVydmFsIGluIHRoZSBjdXJyZW50IHBhc3MuXG5cbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBpbmRleF9zdHJlYW0ubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgICAgdmFyIGluZGV4ID0gaW5kZXhfc3RyZWFtW2ldO1xuXG4gICAgICBpZiAoeGxlZnQgPT09IDApIHsgIC8vIEJlZ2lubmluZyBvZiBuZXcgc2NhbiBsaW5lXG4gICAgICAgIG9wICs9IHNjYW5zdHJpZGU7XG4gICAgICAgIHhsZWZ0ID0gZnJhbWV3aWR0aDtcbiAgICAgICAgaWYgKG9wID49IG9wZW5kKSB7IC8vIENhdGNoIHRoZSB3cmFwIHRvIHN3aXRjaCBwYXNzZXMgd2hlbiBpbnRlcmxhY2luZy5cbiAgICAgICAgICBzY2Fuc3RyaWRlID0gZnJhbWVzdHJpZGUgKiA0ICsgd2lkdGggKiA0ICogKGludGVybGFjZXNraXAtMSk7XG4gICAgICAgICAgLy8gaW50ZXJsYWNlc2tpcCAvIDIgKiA0IGlzIGludGVybGFjZXNraXAgPDwgMS5cbiAgICAgICAgICBvcCA9IG9wYmVnICsgKGZyYW1ld2lkdGggKyBmcmFtZXN0cmlkZSkgKiAoaW50ZXJsYWNlc2tpcCA8PCAxKTtcbiAgICAgICAgICBpbnRlcmxhY2Vza2lwID4+PSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCA9PT0gdHJhbnMpIHtcbiAgICAgICAgb3AgKz0gNDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByID0gYnVmW3BhbGV0dGVfb2Zmc2V0ICsgaW5kZXggKiAzXTtcbiAgICAgICAgdmFyIGcgPSBidWZbcGFsZXR0ZV9vZmZzZXQgKyBpbmRleCAqIDMgKyAxXTtcbiAgICAgICAgdmFyIGIgPSBidWZbcGFsZXR0ZV9vZmZzZXQgKyBpbmRleCAqIDMgKyAyXTtcbiAgICAgICAgcGl4ZWxzW29wKytdID0gYjtcbiAgICAgICAgcGl4ZWxzW29wKytdID0gZztcbiAgICAgICAgcGl4ZWxzW29wKytdID0gcjtcbiAgICAgICAgcGl4ZWxzW29wKytdID0gMjU1O1xuICAgICAgfVxuICAgICAgLS14bGVmdDtcbiAgICB9XG4gIH07XG5cbiAgLy8gSSB3aWxsIGdvIHRvIGNvcHkgYW5kIHBhc3RlIGhlbGwgb25lIGRheS4uLlxuICB0aGlzLmRlY29kZUFuZEJsaXRGcmFtZVJHQkEgPSBmdW5jdGlvbihmcmFtZV9udW0sIHBpeGVscykge1xuICAgIHZhciBmcmFtZSA9IHRoaXMuZnJhbWVJbmZvKGZyYW1lX251bSk7XG4gICAgdmFyIG51bV9waXhlbHMgPSBmcmFtZS53aWR0aCAqIGZyYW1lLmhlaWdodDtcbiAgICB2YXIgaW5kZXhfc3RyZWFtID0gbmV3IFVpbnQ4QXJyYXkobnVtX3BpeGVscyk7ICAvLyBBdCBtb3N0IDgtYml0IGluZGljZXMuXG4gICAgR2lmUmVhZGVyTFpXT3V0cHV0SW5kZXhTdHJlYW0oXG4gICAgICAgIGJ1ZiwgZnJhbWUuZGF0YV9vZmZzZXQsIGluZGV4X3N0cmVhbSwgbnVtX3BpeGVscyk7XG4gICAgdmFyIHBhbGV0dGVfb2Zmc2V0ID0gZnJhbWUucGFsZXR0ZV9vZmZzZXQ7XG5cbiAgICAvLyBOT1RFKGRlYW5tKTogSXQgc2VlbXMgdG8gYmUgbXVjaCBmYXN0ZXIgdG8gY29tcGFyZSBpbmRleCB0byAyNTYgdGhhblxuICAgIC8vIHRvID09PSBudWxsLiAgTm90IHN1cmUgd2h5LCBidXQgQ29tcGFyZVN0dWJfRVFfU1RSSUNUIHNob3dzIHVwIGhpZ2ggaW5cbiAgICAvLyB0aGUgcHJvZmlsZSwgbm90IHN1cmUgaWYgaXQncyByZWxhdGVkIHRvIHVzaW5nIGEgVWludDhBcnJheS5cbiAgICB2YXIgdHJhbnMgPSBmcmFtZS50cmFuc3BhcmVudF9pbmRleDtcbiAgICBpZiAodHJhbnMgPT09IG51bGwpIHRyYW5zID0gMjU2O1xuXG4gICAgLy8gV2UgYXJlIHBvc3NpYmx5IGp1c3QgYmxpdHRpbmcgdG8gYSBwb3J0aW9uIG9mIHRoZSBlbnRpcmUgZnJhbWUuXG4gICAgLy8gVGhhdCBpcyBhIHN1YnJlY3Qgd2l0aGluIHRoZSBmcmFtZXJlY3QsIHNvIHRoZSBhZGRpdGlvbmFsIHBpeGVsc1xuICAgIC8vIG11c3QgYmUgc2tpcHBlZCBvdmVyIGFmdGVyIHdlIGZpbmlzaGVkIGEgc2NhbmxpbmUuXG4gICAgdmFyIGZyYW1ld2lkdGggID0gZnJhbWUud2lkdGg7XG4gICAgdmFyIGZyYW1lc3RyaWRlID0gd2lkdGggLSBmcmFtZXdpZHRoO1xuICAgIHZhciB4bGVmdCAgICAgICA9IGZyYW1ld2lkdGg7ICAvLyBOdW1iZXIgb2Ygc3VicmVjdCBwaXhlbHMgbGVmdCBpbiBzY2FubGluZS5cblxuICAgIC8vIE91dHB1dCBpbmRpY2llcyBvZiB0aGUgdG9wIGxlZnQgYW5kIGJvdHRvbSByaWdodCBjb3JuZXJzIG9mIHRoZSBzdWJyZWN0LlxuICAgIHZhciBvcGJlZyA9ICgoZnJhbWUueSAqIHdpZHRoKSArIGZyYW1lLngpICogNDtcbiAgICB2YXIgb3BlbmQgPSAoKGZyYW1lLnkgKyBmcmFtZS5oZWlnaHQpICogd2lkdGggKyBmcmFtZS54KSAqIDQ7XG4gICAgdmFyIG9wICAgID0gb3BiZWc7XG5cbiAgICB2YXIgc2NhbnN0cmlkZSA9IGZyYW1lc3RyaWRlICogNDtcblxuICAgIC8vIFVzZSBzY2Fuc3RyaWRlIHRvIHNraXAgcGFzdCB0aGUgcm93cyB3aGVuIGludGVybGFjaW5nLiAgVGhpcyBpcyBza2lwcGluZ1xuICAgIC8vIDcgcm93cyBmb3IgdGhlIGZpcnN0IHR3byBwYXNzZXMsIHRoZW4gMyB0aGVuIDEuXG4gICAgaWYgKGZyYW1lLmludGVybGFjZWQgPT09IHRydWUpIHtcbiAgICAgIHNjYW5zdHJpZGUgKz0gd2lkdGggKiA0ICogNzsgIC8vIFBhc3MgMS5cbiAgICB9XG5cbiAgICB2YXIgaW50ZXJsYWNlc2tpcCA9IDg7ICAvLyBUcmFja2luZyB0aGUgcm93IGludGVydmFsIGluIHRoZSBjdXJyZW50IHBhc3MuXG5cbiAgICBmb3IgKHZhciBpID0gMCwgaWwgPSBpbmRleF9zdHJlYW0ubGVuZ3RoOyBpIDwgaWw7ICsraSkge1xuICAgICAgdmFyIGluZGV4ID0gaW5kZXhfc3RyZWFtW2ldO1xuXG4gICAgICBpZiAoeGxlZnQgPT09IDApIHsgIC8vIEJlZ2lubmluZyBvZiBuZXcgc2NhbiBsaW5lXG4gICAgICAgIG9wICs9IHNjYW5zdHJpZGU7XG4gICAgICAgIHhsZWZ0ID0gZnJhbWV3aWR0aDtcbiAgICAgICAgaWYgKG9wID49IG9wZW5kKSB7IC8vIENhdGNoIHRoZSB3cmFwIHRvIHN3aXRjaCBwYXNzZXMgd2hlbiBpbnRlcmxhY2luZy5cbiAgICAgICAgICBzY2Fuc3RyaWRlID0gZnJhbWVzdHJpZGUgKiA0ICsgd2lkdGggKiA0ICogKGludGVybGFjZXNraXAtMSk7XG4gICAgICAgICAgLy8gaW50ZXJsYWNlc2tpcCAvIDIgKiA0IGlzIGludGVybGFjZXNraXAgPDwgMS5cbiAgICAgICAgICBvcCA9IG9wYmVnICsgKGZyYW1ld2lkdGggKyBmcmFtZXN0cmlkZSkgKiAoaW50ZXJsYWNlc2tpcCA8PCAxKTtcbiAgICAgICAgICBpbnRlcmxhY2Vza2lwID4+PSAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCA9PT0gdHJhbnMpIHtcbiAgICAgICAgb3AgKz0gNDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByID0gYnVmW3BhbGV0dGVfb2Zmc2V0ICsgaW5kZXggKiAzXTtcbiAgICAgICAgdmFyIGcgPSBidWZbcGFsZXR0ZV9vZmZzZXQgKyBpbmRleCAqIDMgKyAxXTtcbiAgICAgICAgdmFyIGIgPSBidWZbcGFsZXR0ZV9vZmZzZXQgKyBpbmRleCAqIDMgKyAyXTtcbiAgICAgICAgcGl4ZWxzW29wKytdID0gcjtcbiAgICAgICAgcGl4ZWxzW29wKytdID0gZztcbiAgICAgICAgcGl4ZWxzW29wKytdID0gYjtcbiAgICAgICAgcGl4ZWxzW29wKytdID0gMjU1O1xuICAgICAgfVxuICAgICAgLS14bGVmdDtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIEdpZlJlYWRlckxaV091dHB1dEluZGV4U3RyZWFtKGNvZGVfc3RyZWFtLCBwLCBvdXRwdXQsIG91dHB1dF9sZW5ndGgpIHtcbiAgdmFyIG1pbl9jb2RlX3NpemUgPSBjb2RlX3N0cmVhbVtwKytdO1xuXG4gIHZhciBjbGVhcl9jb2RlID0gMSA8PCBtaW5fY29kZV9zaXplO1xuICB2YXIgZW9pX2NvZGUgPSBjbGVhcl9jb2RlICsgMTtcbiAgdmFyIG5leHRfY29kZSA9IGVvaV9jb2RlICsgMTtcblxuICB2YXIgY3VyX2NvZGVfc2l6ZSA9IG1pbl9jb2RlX3NpemUgKyAxOyAgLy8gTnVtYmVyIG9mIGJpdHMgcGVyIGNvZGUuXG4gIC8vIE5PVEU6IFRoaXMgc2hhcmVzIHRoZSBzYW1lIG5hbWUgYXMgdGhlIGVuY29kZXIsIGJ1dCBoYXMgYSBkaWZmZXJlbnRcbiAgLy8gbWVhbmluZyBoZXJlLiAgSGVyZSB0aGlzIG1hc2tzIGVhY2ggY29kZSBjb21pbmcgZnJvbSB0aGUgY29kZSBzdHJlYW0uXG4gIHZhciBjb2RlX21hc2sgPSAoMSA8PCBjdXJfY29kZV9zaXplKSAtIDE7XG4gIHZhciBjdXJfc2hpZnQgPSAwO1xuICB2YXIgY3VyID0gMDtcblxuICB2YXIgb3AgPSAwOyAgLy8gT3V0cHV0IHBvaW50ZXIuXG5cbiAgdmFyIHN1YmJsb2NrX3NpemUgPSBjb2RlX3N0cmVhbVtwKytdO1xuXG4gIC8vIFRPRE8oZGVhbm0pOiBXb3VsZCB1c2luZyBhIFR5cGVkQXJyYXkgYmUgYW55IGZhc3Rlcj8gIEF0IGxlYXN0IGl0IHdvdWxkXG4gIC8vIHNvbHZlIHRoZSBmYXN0IG1vZGUgLyBiYWNraW5nIHN0b3JlIHVuY2VydGFpbnR5LlxuICAvLyB2YXIgY29kZV90YWJsZSA9IEFycmF5KDQwOTYpO1xuICB2YXIgY29kZV90YWJsZSA9IG5ldyBJbnQzMkFycmF5KDQwOTYpOyAgLy8gQ2FuIGJlIHNpZ25lZCwgd2Ugb25seSB1c2UgMjAgYml0cy5cblxuICB2YXIgcHJldl9jb2RlID0gbnVsbDsgIC8vIFRyYWNrIGNvZGUtMS5cblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIC8vIFJlYWQgdXAgdG8gdHdvIGJ5dGVzLCBtYWtpbmcgc3VyZSB3ZSBhbHdheXMgMTItYml0cyBmb3IgbWF4IHNpemVkIGNvZGUuXG4gICAgd2hpbGUgKGN1cl9zaGlmdCA8IDE2KSB7XG4gICAgICBpZiAoc3ViYmxvY2tfc2l6ZSA9PT0gMCkgYnJlYWs7ICAvLyBObyBtb3JlIGRhdGEgdG8gYmUgcmVhZC5cblxuICAgICAgY3VyIHw9IGNvZGVfc3RyZWFtW3ArK10gPDwgY3VyX3NoaWZ0O1xuICAgICAgY3VyX3NoaWZ0ICs9IDg7XG5cbiAgICAgIGlmIChzdWJibG9ja19zaXplID09PSAxKSB7ICAvLyBOZXZlciBsZXQgaXQgZ2V0IHRvIDAgdG8gaG9sZCBsb2dpYyBhYm92ZS5cbiAgICAgICAgc3ViYmxvY2tfc2l6ZSA9IGNvZGVfc3RyZWFtW3ArK107ICAvLyBOZXh0IHN1YmJsb2NrLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLS1zdWJibG9ja19zaXplO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE8oZGVhbm0pOiBXZSBzaG91bGQgbmV2ZXIgcmVhbGx5IGdldCBoZXJlLCB3ZSBzaG91bGQgaGF2ZSByZWNlaXZlZFxuICAgIC8vIGFuZCBFT0kuXG4gICAgaWYgKGN1cl9zaGlmdCA8IGN1cl9jb2RlX3NpemUpXG4gICAgICBicmVhaztcblxuICAgIHZhciBjb2RlID0gY3VyICYgY29kZV9tYXNrO1xuICAgIGN1ciA+Pj0gY3VyX2NvZGVfc2l6ZTtcbiAgICBjdXJfc2hpZnQgLT0gY3VyX2NvZGVfc2l6ZTtcblxuICAgIC8vIFRPRE8oZGVhbm0pOiBNYXliZSBzaG91bGQgY2hlY2sgdGhhdCB0aGUgZmlyc3QgY29kZSB3YXMgYSBjbGVhciBjb2RlLFxuICAgIC8vIGF0IGxlYXN0IHRoaXMgaXMgd2hhdCB5b3UncmUgc3VwcG9zZWQgdG8gZG8uICBCdXQgYWN0dWFsbHkgb3VyIGVuY29kZXJcbiAgICAvLyBub3cgZG9lc24ndCBlbWl0IGEgY2xlYXIgY29kZSBmaXJzdCBhbnl3YXkuXG4gICAgaWYgKGNvZGUgPT09IGNsZWFyX2NvZGUpIHtcbiAgICAgIC8vIFdlIGRvbid0IGFjdHVhbGx5IGhhdmUgdG8gY2xlYXIgdGhlIHRhYmxlLiAgVGhpcyBjb3VsZCBiZSBhIGdvb2QgaWRlYVxuICAgICAgLy8gZm9yIGdyZWF0ZXIgZXJyb3IgY2hlY2tpbmcsIGJ1dCB3ZSBkb24ndCByZWFsbHkgZG8gYW55IGFueXdheS4gIFdlXG4gICAgICAvLyB3aWxsIGp1c3QgdHJhY2sgaXQgd2l0aCBuZXh0X2NvZGUgYW5kIG92ZXJ3cml0ZSBvbGQgZW50cmllcy5cblxuICAgICAgbmV4dF9jb2RlID0gZW9pX2NvZGUgKyAxO1xuICAgICAgY3VyX2NvZGVfc2l6ZSA9IG1pbl9jb2RlX3NpemUgKyAxO1xuICAgICAgY29kZV9tYXNrID0gKDEgPDwgY3VyX2NvZGVfc2l6ZSkgLSAxO1xuXG4gICAgICAvLyBEb24ndCB1cGRhdGUgcHJldl9jb2RlID9cbiAgICAgIHByZXZfY29kZSA9IG51bGw7XG4gICAgICBjb250aW51ZTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IGVvaV9jb2RlKSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBXZSBoYXZlIGEgc2ltaWxhciBzaXR1YXRpb24gYXMgdGhlIGRlY29kZXIsIHdoZXJlIHdlIHdhbnQgdG8gc3RvcmVcbiAgICAvLyB2YXJpYWJsZSBsZW5ndGggZW50cmllcyAoY29kZSB0YWJsZSBlbnRyaWVzKSwgYnV0IHdlIHdhbnQgdG8gZG8gaW4gYVxuICAgIC8vIGZhc3RlciBtYW5uZXIgdGhhbiBhbiBhcnJheSBvZiBhcnJheXMuICBUaGUgY29kZSBiZWxvdyBzdG9yZXMgc29ydCBvZiBhXG4gICAgLy8gbGlua2VkIGxpc3Qgd2l0aGluIHRoZSBjb2RlIHRhYmxlLCBhbmQgdGhlbiBcImNoYXNlc1wiIHRocm91Z2ggaXQgdG9cbiAgICAvLyBjb25zdHJ1Y3QgdGhlIGRpY3Rpb25hcnkgZW50cmllcy4gIFdoZW4gYSBuZXcgZW50cnkgaXMgY3JlYXRlZCwganVzdCB0aGVcbiAgICAvLyBsYXN0IGJ5dGUgaXMgc3RvcmVkLCBhbmQgdGhlIHJlc3QgKHByZWZpeCkgb2YgdGhlIGVudHJ5IGlzIG9ubHlcbiAgICAvLyByZWZlcmVuY2VkIGJ5IGl0cyB0YWJsZSBlbnRyeS4gIFRoZW4gdGhlIGNvZGUgY2hhc2VzIHRocm91Z2ggdGhlXG4gICAgLy8gcHJlZml4ZXMgdW50aWwgaXQgcmVhY2hlcyBhIHNpbmdsZSBieXRlIGNvZGUuICBXZSBoYXZlIHRvIGNoYXNlIHR3aWNlLFxuICAgIC8vIGZpcnN0IHRvIGNvbXB1dGUgdGhlIGxlbmd0aCwgYW5kIHRoZW4gdG8gYWN0dWFsbHkgY29weSB0aGUgZGF0YSB0byB0aGVcbiAgICAvLyBvdXRwdXQgKGJhY2t3YXJkcywgc2luY2Ugd2Uga25vdyB0aGUgbGVuZ3RoKS4gIFRoZSBhbHRlcm5hdGl2ZSB3b3VsZCBiZVxuICAgIC8vIHN0b3Jpbmcgc29tZXRoaW5nIGluIGFuIGludGVybWVkaWF0ZSBzdGFjaywgYnV0IHRoYXQgZG9lc24ndCBtYWtlIGFueVxuICAgIC8vIG1vcmUgc2Vuc2UuICBJIGltcGxlbWVudGVkIGFuIGFwcHJvYWNoIHdoZXJlIGl0IGFsc28gc3RvcmVkIHRoZSBsZW5ndGhcbiAgICAvLyBpbiB0aGUgY29kZSB0YWJsZSwgYWx0aG91Z2ggaXQncyBhIGJpdCB0cmlja3kgYmVjYXVzZSB5b3UgcnVuIG91dCBvZlxuICAgIC8vIGJpdHMgKDEyICsgMTIgKyA4KSwgYnV0IEkgZGlkbid0IG1lYXN1cmUgbXVjaCBpbXByb3ZlbWVudHMgKHRoZSB0YWJsZVxuICAgIC8vIGVudHJpZXMgYXJlIGdlbmVyYWxseSBub3QgdGhlIGxvbmcpLiAgRXZlbiB3aGVuIEkgY3JlYXRlZCBiZW5jaG1hcmtzIGZvclxuICAgIC8vIHZlcnkgbG9uZyB0YWJsZSBlbnRyaWVzIHRoZSBjb21wbGV4aXR5IGRpZCBub3Qgc2VlbSB3b3J0aCBpdC5cbiAgICAvLyBUaGUgY29kZSB0YWJsZSBzdG9yZXMgdGhlIHByZWZpeCBlbnRyeSBpbiAxMiBiaXRzIGFuZCB0aGVuIHRoZSBzdWZmaXhcbiAgICAvLyBieXRlIGluIDggYml0cywgc28gZWFjaCBlbnRyeSBpcyAyMCBiaXRzLlxuXG4gICAgdmFyIGNoYXNlX2NvZGUgPSBjb2RlIDwgbmV4dF9jb2RlID8gY29kZSA6IHByZXZfY29kZTtcblxuICAgIC8vIENoYXNlIHdoYXQgd2Ugd2lsbCBvdXRwdXQsIGVpdGhlciB7Q09ERX0gb3Ige0NPREUtMX0uXG4gICAgdmFyIGNoYXNlX2xlbmd0aCA9IDA7XG4gICAgdmFyIGNoYXNlID0gY2hhc2VfY29kZTtcbiAgICB3aGlsZSAoY2hhc2UgPiBjbGVhcl9jb2RlKSB7XG4gICAgICBjaGFzZSA9IGNvZGVfdGFibGVbY2hhc2VdID4+IDg7XG4gICAgICArK2NoYXNlX2xlbmd0aDtcbiAgICB9XG5cbiAgICB2YXIgayA9IGNoYXNlO1xuXG4gICAgdmFyIG9wX2VuZCA9IG9wICsgY2hhc2VfbGVuZ3RoICsgKGNoYXNlX2NvZGUgIT09IGNvZGUgPyAxIDogMCk7XG4gICAgaWYgKG9wX2VuZCA+IG91dHB1dF9sZW5ndGgpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiV2FybmluZywgZ2lmIHN0cmVhbSBsb25nZXIgdGhhbiBleHBlY3RlZC5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQWxyZWFkeSBoYXZlIHRoZSBmaXJzdCBieXRlIGZyb20gdGhlIGNoYXNlLCBtaWdodCBhcyB3ZWxsIHdyaXRlIGl0IGZhc3QuXG4gICAgb3V0cHV0W29wKytdID0gaztcblxuICAgIG9wICs9IGNoYXNlX2xlbmd0aDtcbiAgICB2YXIgYiA9IG9wOyAgLy8gVHJhY2sgcG9pbnRlciwgd3JpdGluZyBiYWNrd2FyZHMuXG5cbiAgICBpZiAoY2hhc2VfY29kZSAhPT0gY29kZSkgIC8vIFRoZSBjYXNlIG9mIGVtaXR0aW5nIHtDT0RFLTF9ICsgay5cbiAgICAgIG91dHB1dFtvcCsrXSA9IGs7XG5cbiAgICBjaGFzZSA9IGNoYXNlX2NvZGU7XG4gICAgd2hpbGUgKGNoYXNlX2xlbmd0aC0tKSB7XG4gICAgICBjaGFzZSA9IGNvZGVfdGFibGVbY2hhc2VdO1xuICAgICAgb3V0cHV0Wy0tYl0gPSBjaGFzZSAmIDB4ZmY7ICAvLyBXcml0ZSBiYWNrd2FyZHMuXG4gICAgICBjaGFzZSA+Pj0gODsgIC8vIFB1bGwgZG93biB0byB0aGUgcHJlZml4IGNvZGUuXG4gICAgfVxuXG4gICAgaWYgKHByZXZfY29kZSAhPT0gbnVsbCAmJiBuZXh0X2NvZGUgPCA0MDk2KSB7XG4gICAgICBjb2RlX3RhYmxlW25leHRfY29kZSsrXSA9IHByZXZfY29kZSA8PCA4IHwgaztcbiAgICAgIC8vIFRPRE8oZGVhbm0pOiBGaWd1cmUgb3V0IHRoaXMgY2xlYXJpbmcgdnMgY29kZSBncm93dGggbG9naWMgYmV0dGVyLiAgSVxuICAgICAgLy8gaGF2ZSBhbiBmZWVsaW5nIHRoYXQgaXQgc2hvdWxkIGp1c3QgaGFwcGVuIHNvbWV3aGVyZSBlbHNlLCBmb3Igbm93IGl0XG4gICAgICAvLyBpcyBhd2t3YXJkIGJldHdlZW4gd2hlbiB3ZSBncm93IHBhc3QgdGhlIG1heCBhbmQgdGhlbiBoaXQgYSBjbGVhciBjb2RlLlxuICAgICAgLy8gRm9yIG5vdyBqdXN0IGNoZWNrIGlmIHdlIGhpdCB0aGUgbWF4IDEyLWJpdHMgKHRoZW4gYSBjbGVhciBjb2RlIHNob3VsZFxuICAgICAgLy8gZm9sbG93LCBhbHNvIG9mIGNvdXJzZSBlbmNvZGVkIGluIDEyLWJpdHMpLlxuICAgICAgaWYgKG5leHRfY29kZSA+PSBjb2RlX21hc2srMSAmJiBjdXJfY29kZV9zaXplIDwgMTIpIHtcbiAgICAgICAgKytjdXJfY29kZV9zaXplO1xuICAgICAgICBjb2RlX21hc2sgPSBjb2RlX21hc2sgPDwgMSB8IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcHJldl9jb2RlID0gY29kZTtcbiAgfVxuXG4gIGlmIChvcCAhPT0gb3V0cHV0X2xlbmd0aCkge1xuICAgIGNvbnNvbGUubG9nKFwiV2FybmluZywgZ2lmIHN0cmVhbSBzaG9ydGVyIHRoYW4gZXhwZWN0ZWQuXCIpO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuLy8gQ29tbW9uSlMuXG50cnkgeyBleHBvcnRzLkdpZldyaXRlciA9IEdpZldyaXRlcjsgZXhwb3J0cy5HaWZSZWFkZXIgPSBHaWZSZWFkZXIgfSBjYXRjaChlKSB7fVxuIiwiLy8gLmRpcm5hbWUsIC5iYXNlbmFtZSwgYW5kIC5leHRuYW1lIG1ldGhvZHMgYXJlIGV4dHJhY3RlZCBmcm9tIE5vZGUuanMgdjguMTEuMSxcbi8vIGJhY2twb3J0ZWQgYW5kIHRyYW5zcGxpdGVkIHdpdGggQmFiZWwsIHdpdGggYmFja3dhcmRzLWNvbXBhdCBmaXhlc1xuXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gcmVzb2x2ZXMgLiBhbmQgLi4gZWxlbWVudHMgaW4gYSBwYXRoIGFycmF5IHdpdGggZGlyZWN0b3J5IG5hbWVzIHRoZXJlXG4vLyBtdXN0IGJlIG5vIHNsYXNoZXMsIGVtcHR5IGVsZW1lbnRzLCBvciBkZXZpY2UgbmFtZXMgKGM6XFwpIGluIHRoZSBhcnJheVxuLy8gKHNvIGFsc28gbm8gbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlcyAtIGl0IGRvZXMgbm90IGRpc3Rpbmd1aXNoXG4vLyByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgcGF0aHMpXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheShwYXJ0cywgYWxsb3dBYm92ZVJvb3QpIHtcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGxhc3QgPSBwYXJ0c1tpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoYWxsb3dBYm92ZVJvb3QpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHBhcnRzLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG4vLyBwYXRoLnJlc29sdmUoW2Zyb20gLi4uXSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlc29sdmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc29sdmVkUGF0aCA9ICcnLFxuICAgICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAtMSAmJiAhcmVzb2x2ZWRBYnNvbHV0ZTsgaS0tKSB7XG4gICAgdmFyIHBhdGggPSAoaSA+PSAwKSA/IGFyZ3VtZW50c1tpXSA6IHByb2Nlc3MuY3dkKCk7XG5cbiAgICAvLyBTa2lwIGVtcHR5IGFuZCBpbnZhbGlkIGVudHJpZXNcbiAgICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5yZXNvbHZlIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH0gZWxzZSBpZiAoIXBhdGgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJlc29sdmVkUGF0aCA9IHBhdGggKyAnLycgKyByZXNvbHZlZFBhdGg7XG4gICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IHBhdGguY2hhckF0KDApID09PSAnLyc7XG4gIH1cblxuICAvLyBBdCB0aGlzIHBvaW50IHRoZSBwYXRoIHNob3VsZCBiZSByZXNvbHZlZCB0byBhIGZ1bGwgYWJzb2x1dGUgcGF0aCwgYnV0XG4gIC8vIGhhbmRsZSByZWxhdGl2ZSBwYXRocyB0byBiZSBzYWZlIChtaWdodCBoYXBwZW4gd2hlbiBwcm9jZXNzLmN3ZCgpIGZhaWxzKVxuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICByZXNvbHZlZFBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocmVzb2x2ZWRQYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIXJlc29sdmVkQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICByZXR1cm4gKChyZXNvbHZlZEFic29sdXRlID8gJy8nIDogJycpICsgcmVzb2x2ZWRQYXRoKSB8fCAnLic7XG59O1xuXG4vLyBwYXRoLm5vcm1hbGl6ZShwYXRoKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5ub3JtYWxpemUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciBpc0Fic29sdXRlID0gZXhwb3J0cy5pc0Fic29sdXRlKHBhdGgpLFxuICAgICAgdHJhaWxpbmdTbGFzaCA9IHN1YnN0cihwYXRoLCAtMSkgPT09ICcvJztcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihwYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIWlzQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICBpZiAoIXBhdGggJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBwYXRoID0gJy4nO1xuICB9XG4gIGlmIChwYXRoICYmIHRyYWlsaW5nU2xhc2gpIHtcbiAgICBwYXRoICs9ICcvJztcbiAgfVxuXG4gIHJldHVybiAoaXNBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHBhdGg7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmlzQWJzb2x1dGUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5qb2luID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYXRocyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gIHJldHVybiBleHBvcnRzLm5vcm1hbGl6ZShmaWx0ZXIocGF0aHMsIGZ1bmN0aW9uKHAsIGluZGV4KSB7XG4gICAgaWYgKHR5cGVvZiBwICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGguam9pbiBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH0pLmpvaW4oJy8nKSk7XG59O1xuXG5cbi8vIHBhdGgucmVsYXRpdmUoZnJvbSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlbGF0aXZlID0gZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgZnJvbSA9IGV4cG9ydHMucmVzb2x2ZShmcm9tKS5zdWJzdHIoMSk7XG4gIHRvID0gZXhwb3J0cy5yZXNvbHZlKHRvKS5zdWJzdHIoMSk7XG5cbiAgZnVuY3Rpb24gdHJpbShhcnIpIHtcbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIGZvciAoOyBzdGFydCA8IGFyci5sZW5ndGg7IHN0YXJ0KyspIHtcbiAgICAgIGlmIChhcnJbc3RhcnRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIGVuZCA9IGFyci5sZW5ndGggLSAxO1xuICAgIGZvciAoOyBlbmQgPj0gMDsgZW5kLS0pIHtcbiAgICAgIGlmIChhcnJbZW5kXSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA+IGVuZCkgcmV0dXJuIFtdO1xuICAgIHJldHVybiBhcnIuc2xpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0ICsgMSk7XG4gIH1cblxuICB2YXIgZnJvbVBhcnRzID0gdHJpbShmcm9tLnNwbGl0KCcvJykpO1xuICB2YXIgdG9QYXJ0cyA9IHRyaW0odG8uc3BsaXQoJy8nKSk7XG5cbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGZyb21QYXJ0cy5sZW5ndGgsIHRvUGFydHMubGVuZ3RoKTtcbiAgdmFyIHNhbWVQYXJ0c0xlbmd0aCA9IGxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChmcm9tUGFydHNbaV0gIT09IHRvUGFydHNbaV0pIHtcbiAgICAgIHNhbWVQYXJ0c0xlbmd0aCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgb3V0cHV0UGFydHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IHNhbWVQYXJ0c0xlbmd0aDsgaSA8IGZyb21QYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIG91dHB1dFBhcnRzLnB1c2goJy4uJyk7XG4gIH1cblxuICBvdXRwdXRQYXJ0cyA9IG91dHB1dFBhcnRzLmNvbmNhdCh0b1BhcnRzLnNsaWNlKHNhbWVQYXJ0c0xlbmd0aCkpO1xuXG4gIHJldHVybiBvdXRwdXRQYXJ0cy5qb2luKCcvJyk7XG59O1xuXG5leHBvcnRzLnNlcCA9ICcvJztcbmV4cG9ydHMuZGVsaW1pdGVyID0gJzonO1xuXG5leHBvcnRzLmRpcm5hbWUgPSBmdW5jdGlvbiAocGF0aCkge1xuICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSBwYXRoID0gcGF0aCArICcnO1xuICBpZiAocGF0aC5sZW5ndGggPT09IDApIHJldHVybiAnLic7XG4gIHZhciBjb2RlID0gcGF0aC5jaGFyQ29kZUF0KDApO1xuICB2YXIgaGFzUm9vdCA9IGNvZGUgPT09IDQ3IC8qLyovO1xuICB2YXIgZW5kID0gLTE7XG4gIHZhciBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICBmb3IgKHZhciBpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDE7IC0taSkge1xuICAgIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNvZGUgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgZW5kID0gaTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgIC8vIFdlIHNhdyB0aGUgZmlyc3Qgbm9uLXBhdGggc2VwYXJhdG9yXG4gICAgICBtYXRjaGVkU2xhc2ggPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoZW5kID09PSAtMSkgcmV0dXJuIGhhc1Jvb3QgPyAnLycgOiAnLic7XG4gIGlmIChoYXNSb290ICYmIGVuZCA9PT0gMSkge1xuICAgIC8vIHJldHVybiAnLy8nO1xuICAgIC8vIEJhY2t3YXJkcy1jb21wYXQgZml4OlxuICAgIHJldHVybiAnLyc7XG4gIH1cbiAgcmV0dXJuIHBhdGguc2xpY2UoMCwgZW5kKTtcbn07XG5cbmZ1bmN0aW9uIGJhc2VuYW1lKHBhdGgpIHtcbiAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykgcGF0aCA9IHBhdGggKyAnJztcblxuICB2YXIgc3RhcnQgPSAwO1xuICB2YXIgZW5kID0gLTE7XG4gIHZhciBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICB2YXIgaTtcblxuICBmb3IgKGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgaWYgKHBhdGguY2hhckNvZGVBdChpKSA9PT0gNDcgLyovKi8pIHtcbiAgICAgICAgLy8gSWYgd2UgcmVhY2hlZCBhIHBhdGggc2VwYXJhdG9yIHRoYXQgd2FzIG5vdCBwYXJ0IG9mIGEgc2V0IG9mIHBhdGhcbiAgICAgICAgLy8gc2VwYXJhdG9ycyBhdCB0aGUgZW5kIG9mIHRoZSBzdHJpbmcsIHN0b3Agbm93XG4gICAgICAgIGlmICghbWF0Y2hlZFNsYXNoKSB7XG4gICAgICAgICAgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyXG4gICAgICAvLyBwYXRoIGNvbXBvbmVudFxuICAgICAgbWF0Y2hlZFNsYXNoID0gZmFsc2U7XG4gICAgICBlbmQgPSBpICsgMTtcbiAgICB9XG4gIH1cblxuICBpZiAoZW5kID09PSAtMSkgcmV0dXJuICcnO1xuICByZXR1cm4gcGF0aC5zbGljZShzdGFydCwgZW5kKTtcbn1cblxuLy8gVXNlcyBhIG1peGVkIGFwcHJvYWNoIGZvciBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSwgYXMgZXh0IGJlaGF2aW9yIGNoYW5nZWRcbi8vIGluIG5ldyBOb2RlLmpzIHZlcnNpb25zLCBzbyBvbmx5IGJhc2VuYW1lKCkgYWJvdmUgaXMgYmFja3BvcnRlZCBoZXJlXG5leHBvcnRzLmJhc2VuYW1lID0gZnVuY3Rpb24gKHBhdGgsIGV4dCkge1xuICB2YXIgZiA9IGJhc2VuYW1lKHBhdGgpO1xuICBpZiAoZXh0ICYmIGYuc3Vic3RyKC0xICogZXh0Lmxlbmd0aCkgPT09IGV4dCkge1xuICAgIGYgPSBmLnN1YnN0cigwLCBmLmxlbmd0aCAtIGV4dC5sZW5ndGgpO1xuICB9XG4gIHJldHVybiBmO1xufTtcblxuZXhwb3J0cy5leHRuYW1lID0gZnVuY3Rpb24gKHBhdGgpIHtcbiAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykgcGF0aCA9IHBhdGggKyAnJztcbiAgdmFyIHN0YXJ0RG90ID0gLTE7XG4gIHZhciBzdGFydFBhcnQgPSAwO1xuICB2YXIgZW5kID0gLTE7XG4gIHZhciBtYXRjaGVkU2xhc2ggPSB0cnVlO1xuICAvLyBUcmFjayB0aGUgc3RhdGUgb2YgY2hhcmFjdGVycyAoaWYgYW55KSB3ZSBzZWUgYmVmb3JlIG91ciBmaXJzdCBkb3QgYW5kXG4gIC8vIGFmdGVyIGFueSBwYXRoIHNlcGFyYXRvciB3ZSBmaW5kXG4gIHZhciBwcmVEb3RTdGF0ZSA9IDA7XG4gIGZvciAodmFyIGkgPSBwYXRoLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgdmFyIGNvZGUgPSBwYXRoLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGNvZGUgPT09IDQ3IC8qLyovKSB7XG4gICAgICAgIC8vIElmIHdlIHJlYWNoZWQgYSBwYXRoIHNlcGFyYXRvciB0aGF0IHdhcyBub3QgcGFydCBvZiBhIHNldCBvZiBwYXRoXG4gICAgICAgIC8vIHNlcGFyYXRvcnMgYXQgdGhlIGVuZCBvZiB0aGUgc3RyaW5nLCBzdG9wIG5vd1xuICAgICAgICBpZiAoIW1hdGNoZWRTbGFzaCkge1xuICAgICAgICAgIHN0YXJ0UGFydCA9IGkgKyAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIGlmIChlbmQgPT09IC0xKSB7XG4gICAgICAvLyBXZSBzYXcgdGhlIGZpcnN0IG5vbi1wYXRoIHNlcGFyYXRvciwgbWFyayB0aGlzIGFzIHRoZSBlbmQgb2Ygb3VyXG4gICAgICAvLyBleHRlbnNpb25cbiAgICAgIG1hdGNoZWRTbGFzaCA9IGZhbHNlO1xuICAgICAgZW5kID0gaSArIDE7XG4gICAgfVxuICAgIGlmIChjb2RlID09PSA0NiAvKi4qLykge1xuICAgICAgICAvLyBJZiB0aGlzIGlzIG91ciBmaXJzdCBkb3QsIG1hcmsgaXQgYXMgdGhlIHN0YXJ0IG9mIG91ciBleHRlbnNpb25cbiAgICAgICAgaWYgKHN0YXJ0RG90ID09PSAtMSlcbiAgICAgICAgICBzdGFydERvdCA9IGk7XG4gICAgICAgIGVsc2UgaWYgKHByZURvdFN0YXRlICE9PSAxKVxuICAgICAgICAgIHByZURvdFN0YXRlID0gMTtcbiAgICB9IGVsc2UgaWYgKHN0YXJ0RG90ICE9PSAtMSkge1xuICAgICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBhbmQgbm9uLXBhdGggc2VwYXJhdG9yIGJlZm9yZSBvdXIgZG90LCBzbyB3ZSBzaG91bGRcbiAgICAgIC8vIGhhdmUgYSBnb29kIGNoYW5jZSBhdCBoYXZpbmcgYSBub24tZW1wdHkgZXh0ZW5zaW9uXG4gICAgICBwcmVEb3RTdGF0ZSA9IC0xO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdGFydERvdCA9PT0gLTEgfHwgZW5kID09PSAtMSB8fFxuICAgICAgLy8gV2Ugc2F3IGEgbm9uLWRvdCBjaGFyYWN0ZXIgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBkb3RcbiAgICAgIHByZURvdFN0YXRlID09PSAwIHx8XG4gICAgICAvLyBUaGUgKHJpZ2h0LW1vc3QpIHRyaW1tZWQgcGF0aCBjb21wb25lbnQgaXMgZXhhY3RseSAnLi4nXG4gICAgICBwcmVEb3RTdGF0ZSA9PT0gMSAmJiBzdGFydERvdCA9PT0gZW5kIC0gMSAmJiBzdGFydERvdCA9PT0gc3RhcnRQYXJ0ICsgMSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICByZXR1cm4gcGF0aC5zbGljZShzdGFydERvdCwgZW5kKTtcbn07XG5cbmZ1bmN0aW9uIGZpbHRlciAoeHMsIGYpIHtcbiAgICBpZiAoeHMuZmlsdGVyKSByZXR1cm4geHMuZmlsdGVyKGYpO1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChmKHhzW2ldLCBpLCB4cykpIHJlcy5wdXNoKHhzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy8gU3RyaW5nLnByb3RvdHlwZS5zdWJzdHIgLSBuZWdhdGl2ZSBpbmRleCBkb24ndCB3b3JrIGluIElFOFxudmFyIHN1YnN0ciA9ICdhYicuc3Vic3RyKC0xKSA9PT0gJ2InXG4gICAgPyBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7IHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pIH1cbiAgICA6IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHtcbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSBzdHIubGVuZ3RoICsgc3RhcnQ7XG4gICAgICAgIHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pO1xuICAgIH1cbjtcbiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJyB8fFxuICAgICFwcm9jZXNzLnZlcnNpb24gfHxcbiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjAuJykgPT09IDAgfHxcbiAgICBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuJykgPT09IDAgJiYgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLjguJykgIT09IDApIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSB7IG5leHRUaWNrOiBuZXh0VGljayB9O1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBwcm9jZXNzXG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrKGZuLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImNhbGxiYWNrXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cbiAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBhcmdzLCBpO1xuICBzd2l0Y2ggKGxlbikge1xuICBjYXNlIDA6XG4gIGNhc2UgMTpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmbik7XG4gIGNhc2UgMjpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tPbmUoKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEpO1xuICAgIH0pO1xuICBjYXNlIDM6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVHdvKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyKTtcbiAgICB9KTtcbiAgY2FzZSA0OlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1RocmVlKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgICB9KTtcbiAgZGVmYXVsdDpcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgYXJncy5sZW5ndGgpIHtcbiAgICAgIGFyZ3NbaSsrXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrKCkge1xuICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfSk7XG4gIH1cbn1cblxuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIGR1cGxleCBzdHJlYW0gaXMganVzdCBhIHN0cmVhbSB0aGF0IGlzIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLlxuLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHRoaXMgY2xhc3Ncbi8vIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFJlYWRhYmxlLCBhbmQgdGhlbiBwYXJhc2l0aWNhbGx5IGZyb21cbi8vIFdyaXRhYmxlLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGtleXMucHVzaChrZXkpO1xuICB9cmV0dXJuIGtleXM7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV9yZWFkYWJsZScpO1xudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3dyaXRhYmxlJyk7XG5cbnV0aWwuaW5oZXJpdHMoRHVwbGV4LCBSZWFkYWJsZSk7XG5cbntcbiAgLy8gYXZvaWQgc2NvcGUgY3JlZXAsIHRoZSBrZXlzIGFycmF5IGNhbiB0aGVuIGJlIGNvbGxlY3RlZFxuICB2YXIga2V5cyA9IG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKTtcbiAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgdmFyIG1ldGhvZCA9IGtleXNbdl07XG4gICAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xuICB9XG59XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcblxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICBXcml0YWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKSB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICB0aGlzLmFsbG93SGFsZk9wZW4gPSB0cnVlO1xuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKSB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcblxuICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcbiAgLy8gdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuYWxsb3dIYWxmT3BlbiB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKSByZXR1cm47XG5cbiAgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cbiAgcG5hLm5leHRUaWNrKG9uRW5kTlQsIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBvbkVuZE5UKHNlbGYpIHtcbiAgc2VsZi5lbmQoKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMucHVzaChudWxsKTtcbiAgdGhpcy5lbmQoKTtcblxuICBwbmEubmV4dFRpY2soY2IsIGVycik7XG59OyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIHBhc3N0aHJvdWdoIHN0cmVhbS5cbi8vIGJhc2ljYWxseSBqdXN0IHRoZSBtb3N0IG1pbmltYWwgc29ydCBvZiBUcmFuc2Zvcm0gc3RyZWFtLlxuLy8gRXZlcnkgd3JpdHRlbiBjaHVuayBnZXRzIG91dHB1dCBhcy1pcy5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhc3NUaHJvdWdoO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9fc3RyZWFtX3RyYW5zZm9ybScpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoUGFzc1Rocm91Z2gsIFRyYW5zZm9ybSk7XG5cbmZ1bmN0aW9uIFBhc3NUaHJvdWdoKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhc3NUaHJvdWdoKSkgcmV0dXJuIG5ldyBQYXNzVGhyb3VnaChvcHRpb25zKTtcblxuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cblxuUGFzc1Rocm91Z2gucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihudWxsLCBjaHVuayk7XG59OyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxudmFyIEVFbGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIChlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cblxuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IE9iamVjdC5jcmVhdGUocmVxdWlyZSgnY29yZS11dGlsLWlzJykpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBkZWJ1Z1V0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG52YXIgZGVidWcgPSB2b2lkIDA7XG5pZiAoZGVidWdVdGlsICYmIGRlYnVnVXRpbC5kZWJ1Z2xvZykge1xuICBkZWJ1ZyA9IGRlYnVnVXRpbC5kZWJ1Z2xvZygnc3RyZWFtJyk7XG59IGVsc2Uge1xuICBkZWJ1ZyA9IGZ1bmN0aW9uICgpIHt9O1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXJMaXN0ID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QnKTtcbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG52YXIgU3RyaW5nRGVjb2RlcjtcblxudXRpbC5pbmhlcml0cyhSZWFkYWJsZSwgU3RyZWFtKTtcblxudmFyIGtQcm94eUV2ZW50cyA9IFsnZXJyb3InLCAnY2xvc2UnLCAnZGVzdHJveScsICdwYXVzZScsICdyZXN1bWUnXTtcblxuZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbikge1xuICAvLyBTYWRseSB0aGlzIGlzIG5vdCBjYWNoZWFibGUgYXMgc29tZSBsaWJyYXJpZXMgYnVuZGxlIHRoZWlyIG93blxuICAvLyBldmVudCBlbWl0dGVyIGltcGxlbWVudGF0aW9uIHdpdGggdGhlbS5cbiAgaWYgKHR5cGVvZiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyKGV2ZW50LCBmbik7XG5cbiAgLy8gVGhpcyBpcyBhIGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIGFueVxuICAvLyB1c2VybGFuZCBvbmVzLiAgTkVWRVIgRE8gVEhJUy4gVGhpcyBpcyBoZXJlIG9ubHkgYmVjYXVzZSB0aGlzIGNvZGUgbmVlZHNcbiAgLy8gdG8gY29udGludWUgdG8gd29yayB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIE5vZGUuanMgdGhhdCBkbyBub3QgaW5jbHVkZVxuICAvLyB0aGUgcHJlcGVuZExpc3RlbmVyKCkgbWV0aG9kLiBUaGUgZ29hbCBpcyB0byBldmVudHVhbGx5IHJlbW92ZSB0aGlzIGhhY2suXG4gIGlmICghZW1pdHRlci5fZXZlbnRzIHx8ICFlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSBlbWl0dGVyLm9uKGV2ZW50LCBmbik7ZWxzZSBpZiAoaXNBcnJheShlbWl0dGVyLl9ldmVudHNbZXZlbnRdKSkgZW1pdHRlci5fZXZlbnRzW2V2ZW50XS51bnNoaWZ0KGZuKTtlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0gPSBbZm4sIGVtaXR0ZXIuX2V2ZW50c1tldmVudF1dO1xufVxuXG5mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLlxuICAvLyBUaGVzZSBvcHRpb25zIGNhbiBiZSBwcm92aWRlZCBzZXBhcmF0ZWx5IGFzIHJlYWRhYmxlWFhYIGFuZCB3cml0YWJsZVhYWC5cbiAgdmFyIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5XG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGU7XG5cbiAgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgcmVhZGFibGVId20gPSBvcHRpb25zLnJlYWRhYmxlSGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcblxuICBpZiAoaHdtIHx8IGh3bSA9PT0gMCkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtO2Vsc2UgaWYgKGlzRHVwbGV4ICYmIChyZWFkYWJsZUh3bSB8fCByZWFkYWJsZUh3bSA9PT0gMCkpIHRoaXMuaGlnaFdhdGVyTWFyayA9IHJlYWRhYmxlSHdtO2Vsc2UgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IE1hdGguZmxvb3IodGhpcy5oaWdoV2F0ZXJNYXJrKTtcblxuICAvLyBBIGxpbmtlZCBsaXN0IGlzIHVzZWQgdG8gc3RvcmUgZGF0YSBjaHVua3MgaW5zdGVhZCBvZiBhbiBhcnJheSBiZWNhdXNlIHRoZVxuICAvLyBsaW5rZWQgbGlzdCBjYW4gcmVtb3ZlIGVsZW1lbnRzIGZyb20gdGhlIGJlZ2lubmluZyBmYXN0ZXIgdGhhblxuICAvLyBhcnJheS5zaGlmdCgpXG4gIHRoaXMuYnVmZmVyID0gbmV3IEJ1ZmZlckxpc3QoKTtcbiAgdGhpcy5sZW5ndGggPSAwO1xuICB0aGlzLnBpcGVzID0gbnVsbDtcbiAgdGhpcy5waXBlc0NvdW50ID0gMDtcbiAgdGhpcy5mbG93aW5nID0gbnVsbDtcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgZXZlbnQgJ3JlYWRhYmxlJy8nZGF0YScgaXMgZW1pdHRlZFxuICAvLyBpbW1lZGlhdGVseSwgb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZVxuICAvLyBhbnkgYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3QgcmVhZCBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIHdoZW5ldmVyIHdlIHJldHVybiBudWxsLCB0aGVuIHdlIHNldCBhIGZsYWcgdG8gc2F5XG4gIC8vIHRoYXQgd2UncmUgYXdhaXRpbmcgYSAncmVhZGFibGUnIGV2ZW50IGVtaXNzaW9uLlxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG4gIHRoaXMucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcbiAgdGhpcy5hd2FpdERyYWluID0gMDtcblxuICAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXG4gIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcblxuICB0aGlzLmRlY29kZXIgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKSByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpO1xuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3lcbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fcmVhZCA9IG9wdGlvbnMucmVhZDtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cblJlYWRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuUmVhZGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5wdXNoKG51bGwpO1xuICBjYihlcnIpO1xufTtcblxuLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuXG4vLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCxcbi8vIHNpbWlsYXIgdG8gaG93IFdyaXRhYmxlLndyaXRlKCkgcmV0dXJucyB0cnVlIGlmIHlvdSBzaG91bGRcbi8vIHdyaXRlKCkgc29tZSBtb3JlLlxuUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBza2lwQ2h1bmtDaGVjaztcblxuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gICAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICAgIH1cbiAgICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIGVuY29kaW5nLCBmYWxzZSwgc2tpcENodW5rQ2hlY2spO1xufTtcblxuLy8gVW5zaGlmdCBzaG91bGQgKmFsd2F5cyogYmUgc29tZXRoaW5nIGRpcmVjdGx5IG91dCBvZiByZWFkKClcblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBudWxsLCB0cnVlLCBmYWxzZSk7XG59O1xuXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250LCBza2lwQ2h1bmtDaGVjaykge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBlcjtcbiAgICBpZiAoIXNraXBDaHVua0NoZWNrKSBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuICAgIGlmIChlcikge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiAhc3RhdGUub2JqZWN0TW9kZSAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY2h1bmspICE9PSBCdWZmZXIucHJvdG90eXBlKSB7XG4gICAgICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhZGRUb0Zyb250KSB7XG4gICAgICAgIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50JykpO2Vsc2UgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIHRydWUpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRlZCkge1xuICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3N0cmVhbS5wdXNoKCkgYWZ0ZXIgRU9GJykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhZW5jb2RpbmcpIHtcbiAgICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuICAgICAgICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rLmxlbmd0aCAhPT0gMCkgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtlbHNlIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmVlZE1vcmVEYXRhKHN0YXRlKTtcbn1cblxuZnVuY3Rpb24gYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGFkZFRvRnJvbnQpIHtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgaWYgKGFkZFRvRnJvbnQpIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtlbHNlIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcblxuICAgIGlmIChzdGF0ZS5uZWVkUmVhZGFibGUpIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICB9XG4gIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspIHtcbiAgdmFyIGVyO1xuICBpZiAoIV9pc1VpbnQ4QXJyYXkoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIHJldHVybiBlcjtcbn1cblxuLy8gaWYgaXQncyBwYXN0IHRoZSBoaWdoIHdhdGVyIG1hcmssIHdlIGNhbiBwdXNoIGluIHNvbWUgbW9yZS5cbi8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lXG4vLyBtb3JlIGJ5dGVzLiAgVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCxcbi8vIHN1Y2ggYXMgdGhlIHJlcGwuICBBbHNvLCBpZiB0aGUgcHVzaCgpIHRyaWdnZXJlZCBhXG4vLyByZWFkYWJsZSBldmVudCwgYW5kIHRoZSB1c2VyIGNhbGxlZCByZWFkKGxhcmdlTnVtYmVyKSBzdWNoIHRoYXRcbi8vIG5lZWRSZWFkYWJsZSB3YXMgc2V0LCB0aGVuIHdlIG91Z2h0IHRvIHB1c2ggbW9yZSwgc28gdGhhdCBhbm90aGVyXG4vLyAncmVhZGFibGUnIGV2ZW50IHdpbGwgYmUgdHJpZ2dlcmVkLlxuZnVuY3Rpb24gbmVlZE1vcmVEYXRhKHN0YXRlKSB7XG4gIHJldHVybiAhc3RhdGUuZW5kZWQgJiYgKHN0YXRlLm5lZWRSZWFkYWJsZSB8fCBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5pc1BhdXNlZCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9PT0gZmFsc2U7XG59O1xuXG4vLyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIoZW5jKTtcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IGVuYztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBEb24ndCByYWlzZSB0aGUgaHdtID4gOE1CXG52YXIgTUFYX0hXTSA9IDB4ODAwMDAwO1xuZnVuY3Rpb24gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobikge1xuICBpZiAobiA+PSBNQVhfSFdNKSB7XG4gICAgbiA9IE1BWF9IV007XG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMiB0byBwcmV2ZW50IGluY3JlYXNpbmcgaHdtIGV4Y2Vzc2l2ZWx5IGluXG4gICAgLy8gdGlueSBhbW91bnRzXG4gICAgbi0tO1xuICAgIG4gfD0gbiA+Pj4gMTtcbiAgICBuIHw9IG4gPj4+IDI7XG4gICAgbiB8PSBuID4+PiA0O1xuICAgIG4gfD0gbiA+Pj4gODtcbiAgICBuIHw9IG4gPj4+IDE2O1xuICAgIG4rKztcbiAgfVxuICByZXR1cm4gbjtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChuIDw9IDAgfHwgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSByZXR1cm4gMDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldHVybiAxO1xuICBpZiAobiAhPT0gbikge1xuICAgIC8vIE9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCkgcmV0dXJuIHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGEubGVuZ3RoO2Vsc2UgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfVxuICAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgY3VycmVudCBod20sIHRoZW4gcmFpc2UgdGhlIGh3bS5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobik7XG4gIGlmIChuIDw9IHN0YXRlLmxlbmd0aCkgcmV0dXJuIG47XG4gIC8vIERvbid0IGhhdmUgZW5vdWdoXG4gIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiBzdGF0ZS5sZW5ndGg7XG59XG5cbi8vIHlvdSBjYW4gb3ZlcnJpZGUgZWl0aGVyIHRoaXMgbWV0aG9kLCBvciB0aGUgYXN5bmMgX3JlYWQobikgYmVsb3cuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIGRlYnVnKCdyZWFkJywgbik7XG4gIG4gPSBwYXJzZUludChuLCAxMCk7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBuT3JpZyA9IG47XG5cbiAgaWYgKG4gIT09IDApIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIC8vIGlmIHdlJ3JlIGRvaW5nIHJlYWQoMCkgdG8gdHJpZ2dlciBhIHJlYWRhYmxlIGV2ZW50LCBidXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGEgYnVuY2ggb2YgZGF0YSBpbiB0aGUgYnVmZmVyLCB0aGVuIGp1c3QgdHJpZ2dlclxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUubmVlZFJlYWRhYmxlICYmIChzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBkZWJ1ZygncmVhZDogZW1pdFJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7ZWxzZSBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBuID0gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSk7XG5cbiAgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkge1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIGVuZFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cblxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG4gIHZhciBkb1JlYWQgPSBzdGF0ZS5uZWVkUmVhZGFibGU7XG4gIGRlYnVnKCduZWVkIHJlYWRhYmxlJywgZG9SZWFkKTtcblxuICAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZS5sZW5ndGggLSBuIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRvUmVhZCA9IHRydWU7XG4gICAgZGVidWcoJ2xlbmd0aCBsZXNzIHRoYW4gd2F0ZXJtYXJrJywgZG9SZWFkKTtcbiAgfVxuXG4gIC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XG4gIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpIHtcbiAgICBkb1JlYWQgPSBmYWxzZTtcbiAgICBkZWJ1ZygncmVhZGluZyBvciBlbmRlZCcsIGRvUmVhZCk7XG4gIH0gZWxzZSBpZiAoZG9SZWFkKSB7XG4gICAgZGVidWcoJ2RvIHJlYWQnKTtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgICAvLyBpZiB0aGUgbGVuZ3RoIGlzIGN1cnJlbnRseSB6ZXJvLCB0aGVuIHdlICpuZWVkKiBhIHJlYWRhYmxlIGV2ZW50LlxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgLy8gY2FsbCBpbnRlcm5hbCByZWFkIG1ldGhvZFxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XG4gICAgc3RhdGUuc3luYyA9IGZhbHNlO1xuICAgIC8vIElmIF9yZWFkIHB1c2hlZCBkYXRhIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgIHdpbGwgYmUgZmFsc2UsXG4gICAgLy8gYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZSBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuICAgIGlmICghc3RhdGUucmVhZGluZykgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcbiAgfVxuXG4gIHZhciByZXQ7XG4gIGlmIChuID4gMCkgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO2Vsc2UgcmV0ID0gbnVsbDtcblxuICBpZiAocmV0ID09PSBudWxsKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBuID0gMDtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5sZW5ndGggLT0gbjtcbiAgfVxuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAgIC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay5cbiAgICBpZiAobk9yaWcgIT09IG4gJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO1xuICB9XG5cbiAgaWYgKHJldCAhPT0gbnVsbCkgdGhpcy5lbWl0KCdkYXRhJywgcmV0KTtcblxuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5lbmRlZCkgcmV0dXJuO1xuICBpZiAoc3RhdGUuZGVjb2Rlcikge1xuICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG5cbiAgLy8gZW1pdCAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXG4gIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xufVxuXG4vLyBEb24ndCBlbWl0IHJlYWRhYmxlIHJpZ2h0IGF3YXkgaW4gc3luYyBtb2RlLCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXJcbi8vIGFub3RoZXIgcmVhZCgpIGNhbGwgPT4gc3RhY2sgb3ZlcmZsb3cuICBUaGlzIHdheSwgaXQgbWlnaHQgdHJpZ2dlclxuLy8gYSBuZXh0VGljayByZWN1cnNpb24gd2FybmluZywgYnV0IHRoYXQncyBub3Qgc28gYmFkLlxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5mbG93aW5nKTtcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSB0cnVlO1xuICAgIGlmIChzdGF0ZS5zeW5jKSBwbmEubmV4dFRpY2soZW1pdFJlYWRhYmxlXywgc3RyZWFtKTtlbHNlIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGVfKHN0cmVhbSkge1xuICBkZWJ1ZygnZW1pdCByZWFkYWJsZScpO1xuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbiAgZmxvdyhzdHJlYW0pO1xufVxuXG4vLyBhdCB0aGlzIHBvaW50LCB0aGUgdXNlciBoYXMgcHJlc3VtYWJseSBzZWVuIHRoZSAncmVhZGFibGUnIGV2ZW50LFxuLy8gYW5kIGNhbGxlZCByZWFkKCkgdG8gY29uc3VtZSBzb21lIGRhdGEuICB0aGF0IG1heSBoYXZlIHRyaWdnZXJlZFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcbi8vIGl0J3MgaW4gcHJvZ3Jlc3MuXG4vLyBIb3dldmVyLCBpZiB3ZSdyZSBub3QgZW5kZWQsIG9yIHJlYWRpbmcsIGFuZCB0aGUgbGVuZ3RoIDwgaHdtLFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhtYXliZVJlYWRNb3JlXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLmVuZGVkICYmIHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkZWJ1ZygnbWF5YmVSZWFkTW9yZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgICBpZiAobGVuID09PSBzdGF0ZS5sZW5ndGgpXG4gICAgICAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7ZWxzZSBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcbn1cblxuLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cbi8vIGZvciB2aXJ0dWFsIChub24tc3RyaW5nLCBub24tYnVmZmVyKSBzdHJlYW1zLCBcImxlbmd0aFwiIGlzIHNvbWV3aGF0XG4vLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdfcmVhZCgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpKTtcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKGRlc3QsIHBpcGVPcHRzKSB7XG4gIHZhciBzcmMgPSB0aGlzO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xuICAgIGNhc2UgMDpcbiAgICAgIHN0YXRlLnBpcGVzID0gZGVzdDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgc3RhdGUucGlwZXNDb3VudCArPSAxO1xuICBkZWJ1ZygncGlwZSBjb3VudD0lZCBvcHRzPSVqJywgc3RhdGUucGlwZXNDb3VudCwgcGlwZU9wdHMpO1xuXG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XG5cbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IHVucGlwZTtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHBuYS5uZXh0VGljayhlbmRGbik7ZWxzZSBzcmMub25jZSgnZW5kJywgZW5kRm4pO1xuXG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcbiAgZnVuY3Rpb24gb251bnBpcGUocmVhZGFibGUsIHVucGlwZUluZm8pIHtcbiAgICBkZWJ1Zygnb251bnBpcGUnKTtcbiAgICBpZiAocmVhZGFibGUgPT09IHNyYykge1xuICAgICAgaWYgKHVucGlwZUluZm8gJiYgdW5waXBlSW5mby5oYXNVbnBpcGVkID09PSBmYWxzZSkge1xuICAgICAgICB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPSB0cnVlO1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgZGVidWcoJ29uZW5kJyk7XG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG4gIC8vIHdoZW4gdGhlIGRlc3QgZHJhaW5zLCBpdCByZWR1Y2VzIHRoZSBhd2FpdERyYWluIGNvdW50ZXJcbiAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXG4gIC8vIGhhbmRsZXIgaW4gZmxvdygpLCBidXQgYWRkaW5nIGFuZCByZW1vdmluZyByZXBlYXRlZGx5IGlzXG4gIC8vIHRvbyBzbG93LlxuICB2YXIgb25kcmFpbiA9IHBpcGVPbkRyYWluKHNyYyk7XG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgdmFyIGNsZWFuZWRVcCA9IGZhbHNlO1xuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGRlYnVnKCdjbGVhbnVwJyk7XG4gICAgLy8gY2xlYW51cCBldmVudCBoYW5kbGVycyBvbmNlIHRoZSBwaXBlIGlzIGJyb2tlblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCB1bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG5cbiAgICBjbGVhbmVkVXAgPSB0cnVlO1xuXG4gICAgLy8gaWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiAmJiAoIWRlc3QuX3dyaXRhYmxlU3RhdGUgfHwgZGVzdC5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pKSBvbmRyYWluKCk7XG4gIH1cblxuICAvLyBJZiB0aGUgdXNlciBwdXNoZXMgbW9yZSBkYXRhIHdoaWxlIHdlJ3JlIHdyaXRpbmcgdG8gZGVzdCB0aGVuIHdlJ2xsIGVuZCB1cFxuICAvLyBpbiBvbmRhdGEgYWdhaW4uIEhvd2V2ZXIsIHdlIG9ubHkgd2FudCB0byBpbmNyZWFzZSBhd2FpdERyYWluIG9uY2UgYmVjYXVzZVxuICAvLyBkZXN0IHdpbGwgb25seSBlbWl0IG9uZSAnZHJhaW4nIGV2ZW50IGZvciB0aGUgbXVsdGlwbGUgd3JpdGVzLlxuICAvLyA9PiBJbnRyb2R1Y2UgYSBndWFyZCBvbiBpbmNyZWFzaW5nIGF3YWl0RHJhaW4uXG4gIHZhciBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7XG4gIHNyYy5vbignZGF0YScsIG9uZGF0YSk7XG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGRlYnVnKCdvbmRhdGEnKTtcbiAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7XG4gICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGlmIChmYWxzZSA9PT0gcmV0ICYmICFpbmNyZWFzZWRBd2FpdERyYWluKSB7XG4gICAgICAvLyBJZiB0aGUgdXNlciB1bnBpcGVkIGR1cmluZyBgZGVzdC53cml0ZSgpYCwgaXQgaXMgcG9zc2libGVcbiAgICAgIC8vIHRvIGdldCBzdHVjayBpbiBhIHBlcm1hbmVudGx5IHBhdXNlZCBzdGF0ZSBpZiB0aGF0IHdyaXRlXG4gICAgICAvLyBhbHNvIHJldHVybmVkIGZhbHNlLlxuICAgICAgLy8gPT4gQ2hlY2sgd2hldGhlciBgZGVzdGAgaXMgc3RpbGwgYSBwaXBpbmcgZGVzdGluYXRpb24uXG4gICAgICBpZiAoKHN0YXRlLnBpcGVzQ291bnQgPT09IDEgJiYgc3RhdGUucGlwZXMgPT09IGRlc3QgfHwgc3RhdGUucGlwZXNDb3VudCA+IDEgJiYgaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCkgIT09IC0xKSAmJiAhY2xlYW5lZFVwKSB7XG4gICAgICAgIGRlYnVnKCdmYWxzZSB3cml0ZSByZXNwb25zZSwgcGF1c2UnLCBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbik7XG4gICAgICAgIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKys7XG4gICAgICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSB0cnVlO1xuICAgICAgfVxuICAgICAgc3JjLnBhdXNlKCk7XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGRlYnVnKCdvbmVycm9yJywgZXIpO1xuICAgIHVucGlwZSgpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgaWYgKEVFbGlzdGVuZXJDb3VudChkZXN0LCAnZXJyb3InKSA9PT0gMCkgZGVzdC5lbWl0KCdlcnJvcicsIGVyKTtcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgdXNlcmxhbmQgb25lcy5cbiAgcHJlcGVuZExpc3RlbmVyKGRlc3QsICdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnY2xvc2UnLCBvbmNsb3NlKTtcbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgZGVidWcoJ29uZmluaXNoJyk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblxuICBmdW5jdGlvbiB1bnBpcGUoKSB7XG4gICAgZGVidWcoJ3VucGlwZScpO1xuICAgIHNyYy51bnBpcGUoZGVzdCk7XG4gIH1cblxuICAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpO1xuXG4gIC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BpcGUgcmVzdW1lJyk7XG4gICAgc3JjLnJlc3VtZSgpO1xuICB9XG5cbiAgcmV0dXJuIGRlc3Q7XG59O1xuXG5mdW5jdGlvbiBwaXBlT25EcmFpbihzcmMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gICAgZGVidWcoJ3BpcGVPbkRyYWluJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4pIHN0YXRlLmF3YWl0RHJhaW4tLTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbiA9PT0gMCAmJiBFRWxpc3RlbmVyQ291bnQoc3JjLCAnZGF0YScpKSB7XG4gICAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICAgIGZsb3coc3JjKTtcbiAgICB9XG4gIH07XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnBpcGUgPSBmdW5jdGlvbiAoZGVzdCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgdW5waXBlSW5mbyA9IHsgaGFzVW5waXBlZDogZmFsc2UgfTtcblxuICAvLyBpZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKSByZXR1cm4gdGhpcztcblxuICAvLyBqdXN0IG9uZSBkZXN0aW5hdGlvbi4gIG1vc3QgY29tbW9uIGNhc2UuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7XG4gICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuXG4gICAgaWYgKGRlc3QgJiYgZGVzdCAhPT0gc3RhdGUucGlwZXMpIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKCFkZXN0KSBkZXN0ID0gc3RhdGUucGlwZXM7XG5cbiAgICAvLyBnb3QgYSBtYXRjaC5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KSBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gc2xvdyBjYXNlLiBtdWx0aXBsZSBwaXBlIGRlc3RpbmF0aW9ucy5cblxuICBpZiAoIWRlc3QpIHtcbiAgICAvLyByZW1vdmUgYWxsLlxuICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50O1xuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0c1tpXS5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgICB9cmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgb25lLlxuICB2YXIgaW5kZXggPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIHRoaXM7XG5cbiAgc3RhdGUucGlwZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgc3RhdGUucGlwZXNDb3VudCAtPSAxO1xuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkgc3RhdGUucGlwZXMgPSBzdGF0ZS5waXBlc1swXTtcblxuICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gc2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvclxuLy8gRW5zdXJlIHJlYWRhYmxlIGxpc3RlbmVycyBldmVudHVhbGx5IGdldCBzb21ldGhpbmdcblJlYWRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldiwgZm4pIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUub24uY2FsbCh0aGlzLCBldiwgZm4pO1xuXG4gIGlmIChldiA9PT0gJ2RhdGEnKSB7XG4gICAgLy8gU3RhcnQgZmxvd2luZyBvbiBuZXh0IHRpY2sgaWYgc3RyZWFtIGlzbid0IGV4cGxpY2l0bHkgcGF1c2VkXG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHRoaXMucmVzdW1lKCk7XG4gIH0gZWxzZSBpZiAoZXYgPT09ICdyZWFkYWJsZScpIHtcbiAgICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICAgIHBuYS5uZXh0VGljayhuUmVhZGluZ05leHRUaWNrLCB0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcblxuZnVuY3Rpb24gblJlYWRpbmdOZXh0VGljayhzZWxmKSB7XG4gIGRlYnVnKCdyZWFkYWJsZSBuZXh0dGljayByZWFkIDAnKTtcbiAgc2VsZi5yZWFkKDApO1xufVxuXG4vLyBwYXVzZSgpIGFuZCByZXN1bWUoKSBhcmUgcmVtbmFudHMgb2YgdGhlIGxlZ2FjeSByZWFkYWJsZSBzdHJlYW0gQVBJXG4vLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lJyk7XG4gICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgcmVzdW1lKHRoaXMsIHN0YXRlKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7XG4gICAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBwbmEubmV4dFRpY2socmVzdW1lXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdW1lXyhzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZykge1xuICAgIGRlYnVnKCdyZXN1bWUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH1cblxuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG4gIHN0cmVhbS5lbWl0KCdyZXN1bWUnKTtcbiAgZmxvdyhzdHJlYW0pO1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUucmVhZGluZykgc3RyZWFtLnJlYWQoMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XG4gIGlmIChmYWxzZSAhPT0gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3BhdXNlJyk7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdwYXVzZScpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZmxvdycsIHN0YXRlLmZsb3dpbmcpO1xuICB3aGlsZSAoc3RhdGUuZmxvd2luZyAmJiBzdHJlYW0ucmVhZCgpICE9PSBudWxsKSB7fVxufVxuXG4vLyB3cmFwIGFuIG9sZC1zdHlsZSBzdHJlYW0gYXMgdGhlIGFzeW5jIGRhdGEgc291cmNlLlxuLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLlxuLy8gSXQgaXMgYW4gdWdseSB1bmZvcnR1bmF0ZSBtZXNzIG9mIGhpc3RvcnkuXG5SZWFkYWJsZS5wcm90b3R5cGUud3JhcCA9IGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG5cbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZW5kJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIXN0YXRlLmVuZGVkKSB7XG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkgX3RoaXMucHVzaChjaHVuayk7XG4gICAgfVxuXG4gICAgX3RoaXMucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZGF0YScpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuXG4gICAgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlXG4gICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpKSByZXR1cm47ZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSkgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IF90aGlzLnB1c2goY2h1bmspO1xuICAgIGlmICghcmV0KSB7XG4gICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xuICAgIGlmICh0aGlzW2ldID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHN0cmVhbVtpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgfShpKTtcbiAgICB9XG4gIH1cblxuICAvLyBwcm94eSBjZXJ0YWluIGltcG9ydGFudCBldmVudHMuXG4gIGZvciAodmFyIG4gPSAwOyBuIDwga1Byb3h5RXZlbnRzLmxlbmd0aDsgbisrKSB7XG4gICAgc3RyZWFtLm9uKGtQcm94eUV2ZW50c1tuXSwgdGhpcy5lbWl0LmJpbmQodGhpcywga1Byb3h5RXZlbnRzW25dKSk7XG4gIH1cblxuICAvLyB3aGVuIHdlIHRyeSB0byBjb25zdW1lIHNvbWUgbW9yZSBieXRlcywgc2ltcGx5IHVucGF1c2UgdGhlXG4gIC8vIHVuZGVybHlpbmcgc3RyZWFtLlxuICB0aGlzLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBfcmVhZCcsIG4pO1xuICAgIGlmIChwYXVzZWQpIHtcbiAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgc3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuXG4vLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcblxuLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgLy8gbm90aGluZyBidWZmZXJlZFxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcblxuICB2YXIgcmV0O1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0ID0gc3RhdGUuYnVmZmVyLnNoaWZ0KCk7ZWxzZSBpZiAoIW4gfHwgbiA+PSBzdGF0ZS5sZW5ndGgpIHtcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGxpc3RcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgcmV0ID0gc3RhdGUuYnVmZmVyLmpvaW4oJycpO2Vsc2UgaWYgKHN0YXRlLmJ1ZmZlci5sZW5ndGggPT09IDEpIHJldCA9IHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGE7ZWxzZSByZXQgPSBzdGF0ZS5idWZmZXIuY29uY2F0KHN0YXRlLmxlbmd0aCk7XG4gICAgc3RhdGUuYnVmZmVyLmNsZWFyKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBwYXJ0IG9mIGxpc3RcbiAgICByZXQgPSBmcm9tTGlzdFBhcnRpYWwobiwgc3RhdGUuYnVmZmVyLCBzdGF0ZS5kZWNvZGVyKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbi8vIEV4dHJhY3RzIG9ubHkgZW5vdWdoIGJ1ZmZlcmVkIGRhdGEgdG8gc2F0aXNmeSB0aGUgYW1vdW50IHJlcXVlc3RlZC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3RQYXJ0aWFsKG4sIGxpc3QsIGhhc1N0cmluZ3MpIHtcbiAgdmFyIHJldDtcbiAgaWYgKG4gPCBsaXN0LmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBzbGljZSBpcyB0aGUgc2FtZSBmb3IgYnVmZmVycyBhbmQgc3RyaW5nc1xuICAgIHJldCA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKDAsIG4pO1xuICAgIGxpc3QuaGVhZC5kYXRhID0gbGlzdC5oZWFkLmRhdGEuc2xpY2Uobik7XG4gIH0gZWxzZSBpZiAobiA9PT0gbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gZmlyc3QgY2h1bmsgaXMgYSBwZXJmZWN0IG1hdGNoXG4gICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlc3VsdCBzcGFucyBtb3JlIHRoYW4gb25lIGJ1ZmZlclxuICAgIHJldCA9IGhhc1N0cmluZ3MgPyBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSA6IGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgY2hhcmFjdGVycyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGFcbi8vIGNodW5rcy5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkge1xuICB2YXIgcCA9IGxpc3QuaGVhZDtcbiAgdmFyIGMgPSAxO1xuICB2YXIgcmV0ID0gcC5kYXRhO1xuICBuIC09IHJldC5sZW5ndGg7XG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgdmFyIHN0ciA9IHAuZGF0YTtcbiAgICB2YXIgbmIgPSBuID4gc3RyLmxlbmd0aCA/IHN0ci5sZW5ndGggOiBuO1xuICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkgcmV0ICs9IHN0cjtlbHNlIHJldCArPSBzdHIuc2xpY2UoMCwgbik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IHN0ci5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgYnl0ZXMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhIGNodW5rcy5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gY29weUZyb21CdWZmZXIobiwgbGlzdCkge1xuICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4pO1xuICB2YXIgcCA9IGxpc3QuaGVhZDtcbiAgdmFyIGMgPSAxO1xuICBwLmRhdGEuY29weShyZXQpO1xuICBuIC09IHAuZGF0YS5sZW5ndGg7XG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgdmFyIGJ1ZiA9IHAuZGF0YTtcbiAgICB2YXIgbmIgPSBuID4gYnVmLmxlbmd0aCA/IGJ1Zi5sZW5ndGggOiBuO1xuICAgIGJ1Zi5jb3B5KHJldCwgcmV0Lmxlbmd0aCAtIG4sIDAsIG5iKTtcbiAgICBuIC09IG5iO1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICBpZiAobmIgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgKytjO1xuICAgICAgICBpZiAocC5uZXh0KSBsaXN0LmhlYWQgPSBwLm5leHQ7ZWxzZSBsaXN0LmhlYWQgPSBsaXN0LnRhaWwgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdC5oZWFkID0gcDtcbiAgICAgICAgcC5kYXRhID0gYnVmLnNsaWNlKG5iKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICArK2M7XG4gIH1cbiAgbGlzdC5sZW5ndGggLT0gYztcbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBJZiB3ZSBnZXQgaGVyZSBiZWZvcmUgY29uc3VtaW5nIGFsbCB0aGUgYnl0ZXMsIHRoZW4gdGhhdCBpcyBhXG4gIC8vIGJ1ZyBpbiBub2RlLiAgU2hvdWxkIG5ldmVyIGhhcHBlbi5cbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApIHRocm93IG5ldyBFcnJvcignXCJlbmRSZWFkYWJsZSgpXCIgY2FsbGVkIG9uIG5vbi1lbXB0eSBzdHJlYW0nKTtcblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKGVuZFJlYWRhYmxlTlQsIHN0YXRlLCBzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkge1xuICAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbmRleE9mKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuICByZXR1cm4gLTE7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgdHJhbnNmb3JtIHN0cmVhbSBpcyBhIHJlYWRhYmxlL3dyaXRhYmxlIHN0cmVhbSB3aGVyZSB5b3UgZG9cbi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgXCJmaWx0ZXJcIixcbi8vIGJ1dCB0aGF0J3Mgbm90IGEgZ3JlYXQgbmFtZSBmb3IgaXQsIHNpbmNlIHRoYXQgaW1wbGllcyBhIHRoaW5nIHdoZXJlXG4vLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkXG4vLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pXG4vL1xuLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYVxuLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsXG4vLyBhIHpsaWIgc3RyZWFtIG1pZ2h0IHRha2UgbXVsdGlwbGUgcGxhaW4tdGV4dCB3cml0ZXMoKSwgYW5kIHRoZW5cbi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS5cbi8vXG4vLyBIZXJlJ3MgaG93IHRoaXMgd29ya3M6XG4vL1xuLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXG4vLyBzdHJlYW0gY2xhc3Nlcy4gIFdoZW4geW91IHdyaXRlKGNodW5rKSwgdGhhdCBjYWxscyBfd3JpdGUoY2h1bmssY2IpXG4vLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzXG4vLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsXG4vLyB0aGVyZSdzIGVub3VnaCBwZW5kaW5nIHJlYWRhYmxlIGRhdGEgYnVmZmVyZWQgdXAuXG4vL1xuLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW5cbi8vIF9yZWFkKG4pIGlzIGNhbGxlZCwgaXQgdHJhbnNmb3JtcyB0aGUgcXVldWVkIHVwIGRhdGEsIGNhbGxpbmcgdGhlXG4vLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGVcbi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0XG4vLyBvdXRwdXR0ZWQgYml0IGNhbGxzIHRoZSByZWFkY2IsIGFuZCBzdWJzZXF1ZW50IGNodW5rcyBqdXN0IGdvIGludG9cbi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS5cbi8vXG4vLyBUaGlzIHdheSwgYmFjay1wcmVzc3VyZSBpcyBhY3R1YWxseSBkZXRlcm1pbmVkIGJ5IHRoZSByZWFkaW5nIHNpZGUsXG4vLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLFxuLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZ1xuLy8gaGVyZS4gIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgc3RyZWFtIHdoZXJlIGV2ZXJ5IGJ5dGUgb2YgaW5wdXQgaXNcbi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnlcbi8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW5cbi8vIDFrYiBvZiBkYXRhIGJlaW5nIG91dHB1dC4gIEluIHRoaXMgY2FzZSwgeW91IGNvdWxkIHdyaXRlIGEgdmVyeSBzbWFsbFxuLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJblxuLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsXG4vLyB0aGUgc3lzdGVtIHRvIHN0b3AgZG9pbmcgdGhlIHRyYW5zZm9ybS4gIEEgc2luZ2xlIDRNQiB3cml0ZSBjb3VsZFxuLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS5cbi8vXG4vLyBIb3dldmVyLCBldmVuIGluIHN1Y2ggYSBwYXRob2xvZ2ljYWwgY2FzZSwgb25seSBhIHNpbmdsZSB3cml0dGVuIGNodW5rXG4vLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsXG4vLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxudmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFRyYW5zZm9ybSwgRHVwbGV4KTtcblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuXG4gIHZhciBjYiA9IHRzLndyaXRlY2I7XG5cbiAgaWYgKCFjYikge1xuICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCd3cml0ZSBjYWxsYmFjayBjYWxsZWQgbXVsdGlwbGUgdGltZXMnKSk7XG4gIH1cblxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG5cbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgdGhpcy5wdXNoKGRhdGEpO1xuXG4gIGNiKGVyKTtcblxuICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBycy5yZWFkaW5nID0gZmFsc2U7XG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn1cblxuZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRyYW5zZm9ybSkpIHJldHVybiBuZXcgVHJhbnNmb3JtKG9wdGlvbnMpO1xuXG4gIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlID0ge1xuICAgIGFmdGVyVHJhbnNmb3JtOiBhZnRlclRyYW5zZm9ybS5iaW5kKHRoaXMpLFxuICAgIG5lZWRUcmFuc2Zvcm06IGZhbHNlLFxuICAgIHRyYW5zZm9ybWluZzogZmFsc2UsXG4gICAgd3JpdGVjYjogbnVsbCxcbiAgICB3cml0ZWNodW5rOiBudWxsLFxuICAgIHdyaXRlZW5jb2Rpbmc6IG51bGxcbiAgfTtcblxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2ggPSBvcHRpb25zLmZsdXNoO1xuICB9XG5cbiAgLy8gV2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICB0aGlzLm9uKCdwcmVmaW5pc2gnLCBwcmVmaW5pc2gpO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgaWYgKHR5cGVvZiB0aGlzLl9mbHVzaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuX2ZsdXNoKGZ1bmN0aW9uIChlciwgZGF0YSkge1xuICAgICAgZG9uZShfdGhpcywgZXIsIGRhdGEpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGRvbmUodGhpcywgbnVsbCwgbnVsbCk7XG4gIH1cbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xufTtcblxuLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuLy9cbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbi8vXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRocm93IG5ldyBFcnJvcignX3RyYW5zZm9ybSgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMud3JpdGVjYiA9IGNiO1xuICB0cy53cml0ZWNodW5rID0gY2h1bms7XG4gIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8IHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59O1xuXG4vLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoZSBhcmdzIGFyZSBoZXJlLlxuLy8gX3RyYW5zZm9ybSBkb2VzIGFsbCB0aGUgd29yay5cbi8vIFRoYXQgd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGUgcmVhZGFibGUgc2lkZSB3YW50cyBtb3JlIGRhdGEuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHRzLndyaXRlY2h1bmsgIT09IG51bGwgJiYgdHMud3JpdGVjYiAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cbiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcbiAgfVxufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gIER1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kuY2FsbCh0aGlzLCBlcnIsIGZ1bmN0aW9uIChlcnIyKSB7XG4gICAgY2IoZXJyMik7XG4gICAgX3RoaXMyLmVtaXQoJ2Nsb3NlJyk7XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyLCBkYXRhKSB7XG4gIGlmIChlcikgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcblxuICBpZiAoZGF0YSAhPSBudWxsKSAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICBzdHJlYW0ucHVzaChkYXRhKTtcblxuICAvLyBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHdyaXRlIGJ1ZmZlciwgdGhlbiB0aGF0IG1lYW5zXG4gIC8vIHRoYXQgbm90aGluZyBtb3JlIHdpbGwgZXZlciBiZSBwcm92aWRlZFxuICBpZiAoc3RyZWFtLl93cml0YWJsZVN0YXRlLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gd3MubGVuZ3RoICE9IDAnKTtcblxuICBpZiAoc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZS50cmFuc2Zvcm1pbmcpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHN0aWxsIHRyYW5zZm9ybWluZycpO1xuXG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuXG4vLyBJbXBsZW1lbnQgYW4gYXN5bmMgLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gV3JpdGFibGU7XG5cbi8qIDxyZXBsYWNlbWVudD4gKi9cbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbn1cblxuLy8gSXQgc2VlbXMgYSBsaW5rZWQgbGlzdCBidXQgaXQgaXMgbm90XG4vLyB0aGVyZSB3aWxsIGJlIG9ubHkgMiBvZiB0aGVzZSBmb3IgZWFjaCBzdHJlYW1cbmZ1bmN0aW9uIENvcmtlZFJlcXVlc3Qoc3RhdGUpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB0aGlzLm5leHQgPSBudWxsO1xuICB0aGlzLmVudHJ5ID0gbnVsbDtcbiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgb25Db3JrZWRGaW5pc2goX3RoaXMsIHN0YXRlKTtcbiAgfTtcbn1cbi8qIDwvcmVwbGFjZW1lbnQ+ICovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgYXN5bmNXcml0ZSA9ICFwcm9jZXNzLmJyb3dzZXIgJiYgWyd2MC4xMCcsICd2MC45LiddLmluZGV4T2YocHJvY2Vzcy52ZXJzaW9uLnNsaWNlKDAsIDUpKSA+IC0xID8gc2V0SW1tZWRpYXRlIDogcG5hLm5leHRUaWNrO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaW50ZXJuYWxVdGlsID0ge1xuICBkZXByZWNhdGU6IHJlcXVpcmUoJ3V0aWwtZGVwcmVjYXRlJylcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XG4gIHJldHVybiBCdWZmZXIuaXNCdWZmZXIob2JqKSB8fCBvYmogaW5zdGFuY2VvZiBPdXJVaW50OEFycmF5O1xufVxuXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcblxudXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gbm9wKCkge31cblxuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbS5cbiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguXG4gIHZhciBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgd3JpdGFibGVId20gPSBvcHRpb25zLndyaXRhYmxlSGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcblxuICBpZiAoaHdtIHx8IGh3bSA9PT0gMCkgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtO2Vsc2UgaWYgKGlzRHVwbGV4ICYmICh3cml0YWJsZUh3bSB8fCB3cml0YWJsZUh3bSA9PT0gMCkpIHRoaXMuaGlnaFdhdGVyTWFyayA9IHdyaXRhYmxlSHdtO2Vsc2UgdGhpcy5oaWdoV2F0ZXJNYXJrID0gZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IE1hdGguZmxvb3IodGhpcy5oaWdoV2F0ZXJNYXJrKTtcblxuICAvLyBpZiBfZmluYWwgaGFzIGJlZW4gY2FsbGVkXG4gIHRoaXMuZmluYWxDYWxsZWQgPSBmYWxzZTtcblxuICAvLyBkcmFpbiBldmVudCBmbGFnLlxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlO1xuICAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuICB0aGlzLmVuZGluZyA9IGZhbHNlO1xuICAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcblxuICAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7XG5cbiAgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbFxuICB0aGlzLmNvcmtlZCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbiAoZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9O1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuXG4gIC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG5cbiAgdGhpcy5idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB0aGlzLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuXG4gIC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxuICB0aGlzLnBlbmRpbmdjYiA9IDA7XG5cbiAgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcblxuICAvLyBjb3VudCBidWZmZXJlZCByZXF1ZXN0c1xuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcblxuICAvLyBhbGxvY2F0ZSB0aGUgZmlyc3QgQ29ya2VkUmVxdWVzdCwgdGhlcmUgaXMgYWx3YXlzXG4gIC8vIG9uZSBhbGxvY2F0ZWQgYW5kIGZyZWUgdG8gdXNlLCBhbmQgd2UgbWFpbnRhaW4gYXQgbW9zdCB0d29cbiAgdGhpcy5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdCh0aGlzKTtcbn1cblxuV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gZ2V0QnVmZmVyKCkge1xuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xuICB2YXIgb3V0ID0gW107XG4gIHdoaWxlIChjdXJyZW50KSB7XG4gICAgb3V0LnB1c2goY3VycmVudCk7XG4gICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUsICdidWZmZXInLCB7XG4gICAgICBnZXQ6IGludGVybmFsVXRpbC5kZXByZWNhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTtcbiAgICAgIH0sICdfd3JpdGFibGVTdGF0ZS5idWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIF93cml0YWJsZVN0YXRlLmdldEJ1ZmZlciAnICsgJ2luc3RlYWQuJywgJ0RFUDAwMDMnKVxuICAgIH0pO1xuICB9IGNhdGNoIChfKSB7fVxufSkoKTtcblxuLy8gVGVzdCBfd3JpdGFibGVTdGF0ZSBmb3IgaW5oZXJpdGFuY2UgdG8gYWNjb3VudCBmb3IgRHVwbGV4IHN0cmVhbXMsXG4vLyB3aG9zZSBwcm90b3R5cGUgY2hhaW4gb25seSBwb2ludHMgdG8gUmVhZGFibGUuXG52YXIgcmVhbEhhc0luc3RhbmNlO1xuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmhhc0luc3RhbmNlICYmIHR5cGVvZiBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICByZWFsSGFzSW5zdGFuY2UgPSBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLCBTeW1ib2wuaGFzSW5zdGFuY2UsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgaWYgKHJlYWxIYXNJbnN0YW5jZS5jYWxsKHRoaXMsIG9iamVjdCkpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKHRoaXMgIT09IFdyaXRhYmxlKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIHJldHVybiBvYmplY3QgJiYgb2JqZWN0Ll93cml0YWJsZVN0YXRlIGluc3RhbmNlb2YgV3JpdGFibGVTdGF0ZTtcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiB0aGlzO1xuICB9O1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0b28uXG4gIC8vIGByZWFsSGFzSW5zdGFuY2VgIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHVzaW5nIHBsYWluIGBpbnN0YW5jZW9mYFxuICAvLyB3b3VsZCByZXR1cm4gZmFsc2UsIGFzIG5vIGBfd3JpdGFibGVTdGF0ZWAgcHJvcGVydHkgaXMgYXR0YWNoZWQuXG5cbiAgLy8gVHJ5aW5nIHRvIHVzZSB0aGUgY3VzdG9tIGBpbnN0YW5jZW9mYCBmb3IgV3JpdGFibGUgaGVyZSB3aWxsIGFsc28gYnJlYWsgdGhlXG4gIC8vIE5vZGUuanMgTGF6eVRyYW5zZm9ybSBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaGFzIGEgbm9uLXRyaXZpYWwgZ2V0dGVyIGZvclxuICAvLyBgX3dyaXRhYmxlU3RhdGVgIHRoYXQgd291bGQgbGVhZCB0byBpbmZpbml0ZSByZWN1cnNpb24uXG4gIGlmICghcmVhbEhhc0luc3RhbmNlLmNhbGwoV3JpdGFibGUsIHRoaXMpICYmICEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHtcbiAgICByZXR1cm4gbmV3IFdyaXRhYmxlKG9wdGlvbnMpO1xuICB9XG5cbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeS5cbiAgdGhpcy53cml0YWJsZSA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGUgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRlID0gb3B0aW9ucy53cml0ZTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZXYgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRldiA9IG9wdGlvbnMud3JpdGV2O1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmluYWwgPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZpbmFsID0gb3B0aW9ucy5maW5hbDtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG4vLyBPdGhlcndpc2UgcGVvcGxlIGNhbiBwaXBlIFdyaXRhYmxlIHN0cmVhbXMsIHdoaWNoIGlzIGp1c3Qgd3JvbmcuXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQ2Fubm90IHBpcGUsIG5vdCByZWFkYWJsZScpKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBjYikge1xuICB2YXIgZXIgPSBuZXcgRXJyb3IoJ3dyaXRlIGFmdGVyIGVuZCcpO1xuICAvLyBUT0RPOiBkZWZlciBlcnJvciBldmVudHMgY29uc2lzdGVudGx5IGV2ZXJ5d2hlcmUsIG5vdCBqdXN0IHRoZSBjYlxuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIHBuYS5uZXh0VGljayhjYiwgZXIpO1xufVxuXG4vLyBDaGVja3MgdGhhdCBhIHVzZXItc3VwcGxpZWQgY2h1bmsgaXMgdmFsaWQsIGVzcGVjaWFsbHkgZm9yIHRoZSBwYXJ0aWN1bGFyXG4vLyBtb2RlIHRoZSBzdHJlYW0gaXMgaW4uIEN1cnJlbnRseSB0aGlzIG1lYW5zIHRoYXQgYG51bGxgIGlzIG5ldmVyIGFjY2VwdGVkXG4vLyBhbmQgdW5kZWZpbmVkL25vbi1zdHJpbmcgdmFsdWVzIGFyZSBvbmx5IGFsbG93ZWQgaW4gb2JqZWN0IG1vZGUuXG5mdW5jdGlvbiB2YWxpZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBjYikge1xuICB2YXIgdmFsaWQgPSB0cnVlO1xuICB2YXIgZXIgPSBmYWxzZTtcblxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ01heSBub3Qgd3JpdGUgbnVsbCB2YWx1ZXMgdG8gc3RyZWFtJyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgaWYgKGVyKSB7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIHBuYS5uZXh0VGljayhjYiwgZXIpO1xuICAgIHZhbGlkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHZhbGlkO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuICB2YXIgcmV0ID0gZmFsc2U7XG4gIHZhciBpc0J1ZiA9ICFzdGF0ZS5vYmplY3RNb2RlICYmIF9pc1VpbnQ4QXJyYXkoY2h1bmspO1xuXG4gIGlmIChpc0J1ZiAmJiAhQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkge1xuICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoaXNCdWYpIGVuY29kaW5nID0gJ2J1ZmZlcic7ZWxzZSBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcblxuICBpZiAodHlwZW9mIGNiICE9PSAnZnVuY3Rpb24nKSBjYiA9IG5vcDtcblxuICBpZiAoc3RhdGUuZW5kZWQpIHdyaXRlQWZ0ZXJFbmQodGhpcywgY2IpO2Vsc2UgaWYgKGlzQnVmIHx8IHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgc3RhdGUuY29ya2VkKys7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUudW5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQtLTtcblxuICAgIGlmICghc3RhdGUud3JpdGluZyAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIGNsZWFyQnVmZmVyKHRoaXMsIHN0YXRlKTtcbiAgfVxufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnNldERlZmF1bHRFbmNvZGluZyA9IGZ1bmN0aW9uIHNldERlZmF1bHRFbmNvZGluZyhlbmNvZGluZykge1xuICAvLyBub2RlOjpQYXJzZUVuY29kaW5nKCkgcmVxdWlyZXMgbG93ZXIgY2FzZS5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIGVuY29kaW5nID0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKTtcbiAgaWYgKCEoWydoZXgnLCAndXRmOCcsICd1dGYtOCcsICdhc2NpaScsICdiaW5hcnknLCAnYmFzZTY0JywgJ3VjczInLCAndWNzLTInLCAndXRmMTZsZScsICd1dGYtMTZsZScsICdyYXcnXS5pbmRleE9mKChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpKSA+IC0xKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZWZhdWx0RW5jb2RpbmcgPSBlbmNvZGluZztcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKSB7XG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICB9XG4gIHJldHVybiBjaHVuaztcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5cbi8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGlmICghaXNCdWYpIHtcbiAgICB2YXIgbmV3Q2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcbiAgICBpZiAoY2h1bmsgIT09IG5ld0NodW5rKSB7XG4gICAgICBpc0J1ZiA9IHRydWU7XG4gICAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICAgICAgY2h1bmsgPSBuZXdDaHVuaztcbiAgICB9XG4gIH1cbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG5cbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuICBpZiAoIXJldCkgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpIHtcbiAgICB2YXIgbGFzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IHtcbiAgICAgIGNodW5rOiBjaHVuayxcbiAgICAgIGVuY29kaW5nOiBlbmNvZGluZyxcbiAgICAgIGlzQnVmOiBpc0J1ZixcbiAgICAgIGNhbGxiYWNrOiBjYixcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuICAgIGlmIChsYXN0KSB7XG4gICAgICBsYXN0Lm5leHQgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCArPSAxO1xuICB9IGVsc2Uge1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgaWYgKHdyaXRldikgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO2Vsc2Ugc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgLS1zdGF0ZS5wZW5kaW5nY2I7XG5cbiAgaWYgKHN5bmMpIHtcbiAgICAvLyBkZWZlciB0aGUgY2FsbGJhY2sgaWYgd2UgYXJlIGJlaW5nIGNhbGxlZCBzeW5jaHJvbm91c2x5XG4gICAgLy8gdG8gYXZvaWQgcGlsaW5nIHVwIHRoaW5ncyBvbiB0aGUgc3RhY2tcbiAgICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbiAgICAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYW5kIGl0IHdpbGwgYWx3YXlzIGhhcHBlblxuICAgIC8vIGFmdGVyIGVycm9yXG4gICAgcG5hLm5leHRUaWNrKGZpbmlzaE1heWJlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIGNhbGxlciBleHBlY3QgdGhpcyB0byBoYXBwZW4gYmVmb3JlIGlmXG4gICAgLy8gaXQgaXMgYXN5bmNcbiAgICBjYihlcik7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBidXQgZmluaXNoIG11c3RcbiAgICAvLyBhbHdheXMgZm9sbG93IGVycm9yXG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG5cbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcblxuICBpZiAoZXIpIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO2Vsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSB7XG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgLyo8cmVwbGFjZW1lbnQ+Ki9cbiAgICAgIGFzeW5jV3JpdGUoYWZ0ZXJXcml0ZSwgc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgIC8qPC9yZXBsYWNlbWVudD4qL1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgc3RhdGUucGVuZGluZ2NiLS07XG4gIGNiKCk7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn1cblxuLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG4gIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdDtcblxuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgZW50cnkgJiYgZW50cnkubmV4dCkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgbCA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50O1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobCk7XG4gICAgdmFyIGhvbGRlciA9IHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZTtcbiAgICBob2xkZXIuZW50cnkgPSBlbnRyeTtcblxuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIGFsbEJ1ZmZlcnMgPSB0cnVlO1xuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgYnVmZmVyW2NvdW50XSA9IGVudHJ5O1xuICAgICAgaWYgKCFlbnRyeS5pc0J1ZikgYWxsQnVmZmVycyA9IGZhbHNlO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG4gICAgYnVmZmVyLmFsbEJ1ZmZlcnMgPSBhbGxCdWZmZXJzO1xuXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIGJ1ZmZlciwgJycsIGhvbGRlci5maW5pc2gpO1xuXG4gICAgLy8gZG9Xcml0ZSBpcyBhbG1vc3QgYWx3YXlzIGFzeW5jLCBkZWZlciB0aGVzZSB0byBzYXZlIGEgYml0IG9mIHRpbWVcbiAgICAvLyBhcyB0aGUgaG90IHBhdGggZW5kcyB3aXRoIGRvV3JpdGVcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgICBpZiAoaG9sZGVyLm5leHQpIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGhvbGRlci5uZXh0O1xuICAgICAgaG9sZGVyLm5leHQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdChzdGF0ZSk7XG4gICAgfVxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudC0tO1xuICAgICAgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XG4gICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cbiAgICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbnRyeSA9PT0gbnVsbCkgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIH1cblxuICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBlbnRyeTtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVycm9yKCdfd3JpdGUoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRldiA9IG51bGw7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCkgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xuXG4gIC8vIC5lbmQoKSBmdWxseSB1bmNvcmtzXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQgPSAxO1xuICAgIHRoaXMudW5jb3JrKCk7XG4gIH1cblxuICAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuXG4gIGlmICghc3RhdGUuZW5kaW5nICYmICFzdGF0ZS5maW5pc2hlZCkgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbn07XG5cbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLmVuZGluZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID09PSBudWxsICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUud3JpdGluZztcbn1cbmZ1bmN0aW9uIGNhbGxGaW5hbChzdHJlYW0sIHN0YXRlKSB7XG4gIHN0cmVhbS5fZmluYWwoZnVuY3Rpb24gKGVycikge1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgfVxuICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCAmJiAhc3RhdGUuZmluYWxDYWxsZWQpIHtcbiAgICBpZiAodHlwZW9mIHN0cmVhbS5fZmluYWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgICAgc3RhdGUuZmluYWxDYWxsZWQgPSB0cnVlO1xuICAgICAgcG5hLm5leHRUaWNrKGNhbGxGaW5hbCwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuICBpZiAobmVlZCkge1xuICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKSBwbmEubmV4dFRpY2soY2IpO2Vsc2Ugc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbkNvcmtlZEZpbmlzaChjb3JrUmVxLCBzdGF0ZSwgZXJyKSB7XG4gIHZhciBlbnRyeSA9IGNvcmtSZXEuZW50cnk7XG4gIGNvcmtSZXEuZW50cnkgPSBudWxsO1xuICB3aGlsZSAoZW50cnkpIHtcbiAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBjYihlcnIpO1xuICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgfVxuICBpZiAoc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlKSB7XG4gICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlLm5leHQgPSBjb3JrUmVxO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGNvcmtSZXE7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuV3JpdGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5Xcml0YWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLmVuZCgpO1xuICBjYihlcnIpO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuXG5mdW5jdGlvbiBjb3B5QnVmZmVyKHNyYywgdGFyZ2V0LCBvZmZzZXQpIHtcbiAgc3JjLmNvcHkodGFyZ2V0LCBvZmZzZXQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQnVmZmVyTGlzdCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnVmZmVyTGlzdCk7XG5cbiAgICB0aGlzLmhlYWQgPSBudWxsO1xuICAgIHRoaXMudGFpbCA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICB9XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2godikge1xuICAgIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogbnVsbCB9O1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IDApIHRoaXMudGFpbC5uZXh0ID0gZW50cnk7ZWxzZSB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICArK3RoaXMubGVuZ3RoO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiB1bnNoaWZ0KHYpIHtcbiAgICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IHRoaXMuaGVhZCB9O1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgdGhpcy50YWlsID0gZW50cnk7XG4gICAgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgKyt0aGlzLmxlbmd0aDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uIHNoaWZ0KCkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIHZhciByZXQgPSB0aGlzLmhlYWQuZGF0YTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDtcbiAgICAtLXRoaXMubGVuZ3RoO1xuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gam9pbihzKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgdmFyIHJldCA9ICcnICsgcC5kYXRhO1xuICAgIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgICByZXQgKz0gcyArIHAuZGF0YTtcbiAgICB9cmV0dXJuIHJldDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQobikge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHJldHVybiB0aGlzLmhlYWQuZGF0YTtcbiAgICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4gPj4+IDApO1xuICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAocCkge1xuICAgICAgY29weUJ1ZmZlcihwLmRhdGEsIHJldCwgaSk7XG4gICAgICBpICs9IHAuZGF0YS5sZW5ndGg7XG4gICAgICBwID0gcC5uZXh0O1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIHJldHVybiBCdWZmZXJMaXN0O1xufSgpO1xuXG5pZiAodXRpbCAmJiB1dGlsLmluc3BlY3QgJiYgdXRpbC5pbnNwZWN0LmN1c3RvbSkge1xuICBtb2R1bGUuZXhwb3J0cy5wcm90b3R5cGVbdXRpbC5pbnNwZWN0LmN1c3RvbV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iaiA9IHV0aWwuaW5zcGVjdCh7IGxlbmd0aDogdGhpcy5sZW5ndGggfSk7XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IubmFtZSArICcgJyArIG9iajtcbiAgfTtcbn0iLCIndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwbmEgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8vIHVuZG9jdW1lbnRlZCBjYigpIEFQSSwgbmVlZGVkIGZvciBjb3JlLCBub3QgZm9yIHB1YmxpYyBBUElcbmZ1bmN0aW9uIGRlc3Ryb3koZXJyLCBjYikge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciByZWFkYWJsZURlc3Ryb3llZCA9IHRoaXMuX3JlYWRhYmxlU3RhdGUgJiYgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIHZhciB3cml0YWJsZURlc3Ryb3llZCA9IHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG5cbiAgaWYgKHJlYWRhYmxlRGVzdHJveWVkIHx8IHdyaXRhYmxlRGVzdHJveWVkKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH0gZWxzZSBpZiAoZXJyICYmICghdGhpcy5fd3JpdGFibGVTdGF0ZSB8fCAhdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpKSB7XG4gICAgICBwbmEubmV4dFRpY2soZW1pdEVycm9yTlQsIHRoaXMsIGVycik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gd2Ugc2V0IGRlc3Ryb3llZCB0byB0cnVlIGJlZm9yZSBmaXJpbmcgZXJyb3IgY2FsbGJhY2tzIGluIG9yZGVyXG4gIC8vIHRvIG1ha2UgaXQgcmUtZW50cmFuY2Ugc2FmZSBpbiBjYXNlIGRlc3Ryb3koKSBpcyBjYWxsZWQgd2l0aGluIGNhbGxiYWNrc1xuXG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG5cbiAgLy8gaWYgdGhpcyBpcyBhIGR1cGxleCBzdHJlYW0gbWFyayB0aGUgd3JpdGFibGUgcGFydCBhcyBkZXN0cm95ZWQgYXMgd2VsbFxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIHRoaXMuX2Rlc3Ryb3koZXJyIHx8IG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoIWNiICYmIGVycikge1xuICAgICAgcG5hLm5leHRUaWNrKGVtaXRFcnJvck5ULCBfdGhpcywgZXJyKTtcbiAgICAgIGlmIChfdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgICBfdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2IpIHtcbiAgICAgIGNiKGVycik7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gdW5kZXN0cm95KCkge1xuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRFcnJvck5UKHNlbGYsIGVycikge1xuICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gIHVuZGVzdHJveTogdW5kZXN0cm95XG59OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuIiwiLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby1kZXByZWNhdGVkLWFwaSAqL1xudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpXG52YXIgQnVmZmVyID0gYnVmZmVyLkJ1ZmZlclxuXG4vLyBhbHRlcm5hdGl2ZSB0byB1c2luZyBPYmplY3Qua2V5cyBmb3Igb2xkIGJyb3dzZXJzXG5mdW5jdGlvbiBjb3B5UHJvcHMgKHNyYywgZHN0KSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICBkc3Rba2V5XSA9IHNyY1trZXldXG4gIH1cbn1cbmlmIChCdWZmZXIuZnJvbSAmJiBCdWZmZXIuYWxsb2MgJiYgQnVmZmVyLmFsbG9jVW5zYWZlICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBidWZmZXJcbn0gZWxzZSB7XG4gIC8vIENvcHkgcHJvcGVydGllcyBmcm9tIHJlcXVpcmUoJ2J1ZmZlcicpXG4gIGNvcHlQcm9wcyhidWZmZXIsIGV4cG9ydHMpXG4gIGV4cG9ydHMuQnVmZmVyID0gU2FmZUJ1ZmZlclxufVxuXG5mdW5jdGlvbiBTYWZlQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBDb3B5IHN0YXRpYyBtZXRob2RzIGZyb20gQnVmZmVyXG5jb3B5UHJvcHMoQnVmZmVyLCBTYWZlQnVmZmVyKVxuXG5TYWZlQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHZhciBidWYgPSBCdWZmZXIoc2l6ZSlcbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBidWYuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmZpbGwoZmlsbClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYnVmLmZpbGwoMClcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihzaXplKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gYnVmZmVyLlNsb3dCdWZmZXIoc2l6ZSlcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9yZWFkYWJsZScpLlBhc3NUaHJvdWdoXG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG5leHBvcnRzLlN0cmVhbSA9IGV4cG9ydHM7XG5leHBvcnRzLlJlYWRhYmxlID0gZXhwb3J0cztcbmV4cG9ydHMuV3JpdGFibGUgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG5leHBvcnRzLkR1cGxleCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG5leHBvcnRzLlRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzJyk7XG5leHBvcnRzLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcycpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3JlYWRhYmxlJykuVHJhbnNmb3JtXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVhbTtcblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuaW5oZXJpdHMoU3RyZWFtLCBFRSk7XG5TdHJlYW0uUmVhZGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanMnKTtcblN0cmVhbS5Xcml0YWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS5qcycpO1xuU3RyZWFtLkR1cGxleCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9kdXBsZXguanMnKTtcblN0cmVhbS5UcmFuc2Zvcm0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzJyk7XG5TdHJlYW0uUGFzc1Rocm91Z2ggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMnKTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC40LnhcblN0cmVhbS5TdHJlYW0gPSBTdHJlYW07XG5cblxuXG4vLyBvbGQtc3R5bGUgc3RyZWFtcy4gIE5vdGUgdGhhdCB0aGUgcGlwZSBtZXRob2QgKHRoZSBvbmx5IHJlbGV2YW50XG4vLyBwYXJ0IG9mIHRoaXMgY2xhc3MpIGlzIG92ZXJyaWRkZW4gaW4gdGhlIFJlYWRhYmxlIGNsYXNzLlxuXG5mdW5jdGlvbiBTdHJlYW0oKSB7XG4gIEVFLmNhbGwodGhpcyk7XG59XG5cblN0cmVhbS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIG9wdGlvbnMpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgaWYgKGRlc3Qud3JpdGFibGUpIHtcbiAgICAgIGlmIChmYWxzZSA9PT0gZGVzdC53cml0ZShjaHVuaykgJiYgc291cmNlLnBhdXNlKSB7XG4gICAgICAgIHNvdXJjZS5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZGF0YScsIG9uZGF0YSk7XG5cbiAgZnVuY3Rpb24gb25kcmFpbigpIHtcbiAgICBpZiAoc291cmNlLnJlYWRhYmxlICYmIHNvdXJjZS5yZXN1bWUpIHtcbiAgICAgIHNvdXJjZS5yZXN1bWUoKTtcbiAgICB9XG4gIH1cblxuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIC8vIElmIHRoZSAnZW5kJyBvcHRpb24gaXMgbm90IHN1cHBsaWVkLCBkZXN0LmVuZCgpIHdpbGwgYmUgY2FsbGVkIHdoZW5cbiAgLy8gc291cmNlIGdldHMgdGhlICdlbmQnIG9yICdjbG9zZScgZXZlbnRzLiAgT25seSBkZXN0LmVuZCgpIG9uY2UuXG4gIGlmICghZGVzdC5faXNTdGRpbyAmJiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5lbmQgIT09IGZhbHNlKSkge1xuICAgIHNvdXJjZS5vbignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5vbignY2xvc2UnLCBvbmNsb3NlKTtcbiAgfVxuXG4gIHZhciBkaWRPbkVuZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cblxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGlmICh0eXBlb2YgZGVzdC5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSBkZXN0LmRlc3Ryb3koKTtcbiAgfVxuXG4gIC8vIGRvbid0IGxlYXZlIGRhbmdsaW5nIHBpcGVzIHdoZW4gdGhlcmUgYXJlIGVycm9ycy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGNsZWFudXAoKTtcbiAgICBpZiAoRUUubGlzdGVuZXJDb3VudCh0aGlzLCAnZXJyb3InKSA9PT0gMCkge1xuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCBzdHJlYW0gZXJyb3IgaW4gcGlwZS5cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIGRlc3Qub24oJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gcmVtb3ZlIGFsbCB0aGUgZXZlbnQgbGlzdGVuZXJzIHRoYXQgd2VyZSBhZGRlZC5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcbiAgfVxuXG4gIHNvdXJjZS5vbignZW5kJywgY2xlYW51cCk7XG4gIHNvdXJjZS5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0Lm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3QuZW1pdCgncGlwZScsIHNvdXJjZSk7XG5cbiAgLy8gQWxsb3cgZm9yIHVuaXgtbGlrZSB1c2FnZTogQS5waXBlKEIpLnBpcGUoQylcbiAgcmV0dXJuIGRlc3Q7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBpc0VuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmcgfHwgZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIGVuY29kaW5nID0gJycgKyBlbmNvZGluZztcbiAgc3dpdGNoIChlbmNvZGluZyAmJiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpjYXNlICd1dGY4JzpjYXNlICd1dGYtOCc6Y2FzZSAnYXNjaWknOmNhc2UgJ2JpbmFyeSc6Y2FzZSAnYmFzZTY0JzpjYXNlICd1Y3MyJzpjYXNlICd1Y3MtMic6Y2FzZSAndXRmMTZsZSc6Y2FzZSAndXRmLTE2bGUnOmNhc2UgJ3Jhdyc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XG4gIGlmICghZW5jKSByZXR1cm4gJ3V0ZjgnO1xuICB2YXIgcmV0cmllZDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuYykge1xuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiAndXRmOCc7XG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gJ3V0ZjE2bGUnO1xuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiAnbGF0aW4xJztcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gZW5jO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHJldHJpZWQpIHJldHVybjsgLy8gdW5kZWZpbmVkXG4gICAgICAgIGVuYyA9ICgnJyArIGVuYykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0cmllZCA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG4vLyBEbyBub3QgY2FjaGUgYEJ1ZmZlci5pc0VuY29kaW5nYCB3aGVuIGNoZWNraW5nIGVuY29kaW5nIG5hbWVzIGFzIHNvbWVcbi8vIG1vZHVsZXMgbW9ua2V5LXBhdGNoIGl0IHRvIHN1cHBvcnQgYWRkaXRpb25hbCBlbmNvZGluZ3NcbmZ1bmN0aW9uIG5vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICB2YXIgbmVuYyA9IF9ub3JtYWxpemVFbmNvZGluZyhlbmMpO1xuICBpZiAodHlwZW9mIG5lbmMgIT09ICdzdHJpbmcnICYmIChCdWZmZXIuaXNFbmNvZGluZyA9PT0gaXNFbmNvZGluZyB8fCAhaXNFbmNvZGluZyhlbmMpKSkgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jKTtcbiAgcmV0dXJuIG5lbmMgfHwgZW5jO1xufVxuXG4vLyBTdHJpbmdEZWNvZGVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgZWZmaWNpZW50bHkgc3BsaXR0aW5nIGEgc2VyaWVzIG9mXG4vLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGVcbi8vIGNoYXJhY3RlcnMuXG5leHBvcnRzLlN0cmluZ0RlY29kZXIgPSBTdHJpbmdEZWNvZGVyO1xuZnVuY3Rpb24gU3RyaW5nRGVjb2RlcihlbmNvZGluZykge1xuICB0aGlzLmVuY29kaW5nID0gbm9ybWFsaXplRW5jb2RpbmcoZW5jb2RpbmcpO1xuICB2YXIgbmI7XG4gIHN3aXRjaCAodGhpcy5lbmNvZGluZykge1xuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgdGhpcy50ZXh0ID0gdXRmMTZUZXh0O1xuICAgICAgdGhpcy5lbmQgPSB1dGYxNkVuZDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgdGhpcy5maWxsTGFzdCA9IHV0ZjhGaWxsTGFzdDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICB0aGlzLnRleHQgPSBiYXNlNjRUZXh0O1xuICAgICAgdGhpcy5lbmQgPSBiYXNlNjRFbmQ7XG4gICAgICBuYiA9IDM7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy53cml0ZSA9IHNpbXBsZVdyaXRlO1xuICAgICAgdGhpcy5lbmQgPSBzaW1wbGVFbmQ7XG4gICAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIHRoaXMubGFzdFRvdGFsID0gMDtcbiAgdGhpcy5sYXN0Q2hhciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuYik7XG59XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICB2YXIgcjtcbiAgdmFyIGk7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XG4gICAgciA9IHRoaXMuZmlsbExhc3QoYnVmKTtcbiAgICBpZiAociA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJyc7XG4gICAgaSA9IHRoaXMubGFzdE5lZWQ7XG4gICAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgaSA9IDA7XG4gIH1cbiAgaWYgKGkgPCBidWYubGVuZ3RoKSByZXR1cm4gciA/IHIgKyB0aGlzLnRleHQoYnVmLCBpKSA6IHRoaXMudGV4dChidWYsIGkpO1xuICByZXR1cm4gciB8fCAnJztcbn07XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IHV0ZjhFbmQ7XG5cbi8vIFJldHVybnMgb25seSBjb21wbGV0ZSBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS50ZXh0ID0gdXRmOFRleHQ7XG5cbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgcGFydGlhbCBub24tVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmZpbGxMYXN0ID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCB0aGlzLmxhc3ROZWVkKTtcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XG4gIH1cbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCBidWYubGVuZ3RoKTtcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xufTtcblxuLy8gQ2hlY2tzIHRoZSB0eXBlIG9mIGEgVVRGLTggYnl0ZSwgd2hldGhlciBpdCdzIEFTQ0lJLCBhIGxlYWRpbmcgYnl0ZSwgb3IgYVxuLy8gY29udGludWF0aW9uIGJ5dGUuIElmIGFuIGludmFsaWQgYnl0ZSBpcyBkZXRlY3RlZCwgLTIgaXMgcmV0dXJuZWQuXG5mdW5jdGlvbiB1dGY4Q2hlY2tCeXRlKGJ5dGUpIHtcbiAgaWYgKGJ5dGUgPD0gMHg3RikgcmV0dXJuIDA7ZWxzZSBpZiAoYnl0ZSA+PiA1ID09PSAweDA2KSByZXR1cm4gMjtlbHNlIGlmIChieXRlID4+IDQgPT09IDB4MEUpIHJldHVybiAzO2Vsc2UgaWYgKGJ5dGUgPj4gMyA9PT0gMHgxRSkgcmV0dXJuIDQ7XG4gIHJldHVybiBieXRlID4+IDYgPT09IDB4MDIgPyAtMSA6IC0yO1xufVxuXG4vLyBDaGVja3MgYXQgbW9zdCAzIGJ5dGVzIGF0IHRoZSBlbmQgb2YgYSBCdWZmZXIgaW4gb3JkZXIgdG8gZGV0ZWN0IGFuXG4vLyBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyLiBUaGUgdG90YWwgbnVtYmVyIG9mIGJ5dGVzICgyLCAzLCBvciA0KVxuLy8gbmVlZGVkIHRvIGNvbXBsZXRlIHRoZSBVVEYtOCBjaGFyYWN0ZXIgKGlmIGFwcGxpY2FibGUpIGFyZSByZXR1cm5lZC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0luY29tcGxldGUoc2VsZiwgYnVmLCBpKSB7XG4gIHZhciBqID0gYnVmLmxlbmd0aCAtIDE7XG4gIGlmIChqIDwgaSkgcmV0dXJuIDA7XG4gIHZhciBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAxO1xuICAgIHJldHVybiBuYjtcbiAgfVxuICBpZiAoLS1qIDwgaSB8fCBuYiA9PT0gLTIpIHJldHVybiAwO1xuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAyO1xuICAgIHJldHVybiBuYjtcbiAgfVxuICBpZiAoLS1qIDwgaSB8fCBuYiA9PT0gLTIpIHJldHVybiAwO1xuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSB7XG4gICAgICBpZiAobmIgPT09IDIpIG5iID0gMDtlbHNlIHNlbGYubGFzdE5lZWQgPSBuYiAtIDM7XG4gICAgfVxuICAgIHJldHVybiBuYjtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy8gVmFsaWRhdGVzIGFzIG1hbnkgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIGFzXG4vLyBuZWVkZWQgb3IgYXJlIGF2YWlsYWJsZS4gSWYgd2Ugc2VlIGEgbm9uLWNvbnRpbnVhdGlvbiBieXRlIHdoZXJlIHdlIGV4cGVjdFxuLy8gb25lLCB3ZSBcInJlcGxhY2VcIiB0aGUgdmFsaWRhdGVkIGNvbnRpbnVhdGlvbiBieXRlcyB3ZSd2ZSBzZWVuIHNvIGZhciB3aXRoXG4vLyBhIHNpbmdsZSBVVEYtOCByZXBsYWNlbWVudCBjaGFyYWN0ZXIgKCdcXHVmZmZkJyksIHRvIG1hdGNoIHY4J3MgVVRGLTggZGVjb2Rpbmdcbi8vIGJlaGF2aW9yLiBUaGUgY29udGludWF0aW9uIGJ5dGUgY2hlY2sgaXMgaW5jbHVkZWQgdGhyZWUgdGltZXMgaW4gdGhlIGNhc2Vcbi8vIHdoZXJlIGFsbCBvZiB0aGUgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIGNoYXJhY3RlciBleGlzdCBpbiB0aGUgc2FtZSBidWZmZXIuXG4vLyBJdCBpcyBhbHNvIGRvbmUgdGhpcyB3YXkgYXMgYSBzbGlnaHQgcGVyZm9ybWFuY2UgaW5jcmVhc2UgaW5zdGVhZCBvZiB1c2luZyBhXG4vLyBsb29wLlxuZnVuY3Rpb24gdXRmOENoZWNrRXh0cmFCeXRlcyhzZWxmLCBidWYsIHApIHtcbiAgaWYgKChidWZbMF0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgIHNlbGYubGFzdE5lZWQgPSAwO1xuICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gIH1cbiAgaWYgKHNlbGYubGFzdE5lZWQgPiAxICYmIGJ1Zi5sZW5ndGggPiAxKSB7XG4gICAgaWYgKChidWZbMV0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgICAgc2VsZi5sYXN0TmVlZCA9IDE7XG4gICAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICAgIH1cbiAgICBpZiAoc2VsZi5sYXN0TmVlZCA+IDIgJiYgYnVmLmxlbmd0aCA+IDIpIHtcbiAgICAgIGlmICgoYnVmWzJdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgICAgc2VsZi5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlci5cbmZ1bmN0aW9uIHV0ZjhGaWxsTGFzdChidWYpIHtcbiAgdmFyIHAgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gIHZhciByID0gdXRmOENoZWNrRXh0cmFCeXRlcyh0aGlzLCBidWYsIHApO1xuICBpZiAociAhPT0gdW5kZWZpbmVkKSByZXR1cm4gcjtcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIHRoaXMubGFzdE5lZWQpO1xuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcbiAgfVxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCBidWYubGVuZ3RoKTtcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xufVxuXG4vLyBSZXR1cm5zIGFsbCBjb21wbGV0ZSBVVEYtOCBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyLiBJZiB0aGUgQnVmZmVyIGVuZGVkIG9uIGFcbi8vIHBhcnRpYWwgY2hhcmFjdGVyLCB0aGUgY2hhcmFjdGVyJ3MgYnl0ZXMgYXJlIGJ1ZmZlcmVkIHVudGlsIHRoZSByZXF1aXJlZFxuLy8gbnVtYmVyIG9mIGJ5dGVzIGFyZSBhdmFpbGFibGUuXG5mdW5jdGlvbiB1dGY4VGV4dChidWYsIGkpIHtcbiAgdmFyIHRvdGFsID0gdXRmOENoZWNrSW5jb21wbGV0ZSh0aGlzLCBidWYsIGkpO1xuICBpZiAoIXRoaXMubGFzdE5lZWQpIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpKTtcbiAgdGhpcy5sYXN0VG90YWwgPSB0b3RhbDtcbiAgdmFyIGVuZCA9IGJ1Zi5sZW5ndGggLSAodG90YWwgLSB0aGlzLmxhc3ROZWVkKTtcbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgMCwgZW5kKTtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGksIGVuZCk7XG59XG5cbi8vIEZvciBVVEYtOCwgYSByZXBsYWNlbWVudCBjaGFyYWN0ZXIgaXMgYWRkZWQgd2hlbiBlbmRpbmcgb24gYSBwYXJ0aWFsXG4vLyBjaGFyYWN0ZXIuXG5mdW5jdGlvbiB1dGY4RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArICdcXHVmZmZkJztcbiAgcmV0dXJuIHI7XG59XG5cbi8vIFVURi0xNkxFIHR5cGljYWxseSBuZWVkcyB0d28gYnl0ZXMgcGVyIGNoYXJhY3RlciwgYnV0IGV2ZW4gaWYgd2UgaGF2ZSBhbiBldmVuXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXZhaWxhYmxlLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHdlIGVuZCBvbiBhIGxlYWRpbmcvaGlnaFxuLy8gc3Vycm9nYXRlLiBJbiB0aGF0IGNhc2UsIHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIG5leHQgdHdvIGJ5dGVzIGluIG9yZGVyIHRvXG4vLyBkZWNvZGUgdGhlIGxhc3QgY2hhcmFjdGVyIHByb3Blcmx5LlxuZnVuY3Rpb24gdXRmMTZUZXh0KGJ1ZiwgaSkge1xuICBpZiAoKGJ1Zi5sZW5ndGggLSBpKSAlIDIgPT09IDApIHtcbiAgICB2YXIgciA9IGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGkpO1xuICAgIGlmIChyKSB7XG4gICAgICB2YXIgYyA9IHIuY2hhckNvZGVBdChyLmxlbmd0aCAtIDEpO1xuICAgICAgaWYgKGMgPj0gMHhEODAwICYmIGMgPD0gMHhEQkZGKSB7XG4gICAgICAgIHRoaXMubGFzdE5lZWQgPSAyO1xuICAgICAgICB0aGlzLmxhc3RUb3RhbCA9IDQ7XG4gICAgICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xuICAgICAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIHIuc2xpY2UoMCwgLTEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuICB0aGlzLmxhc3ROZWVkID0gMTtcbiAgdGhpcy5sYXN0VG90YWwgPSAyO1xuICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGksIGJ1Zi5sZW5ndGggLSAxKTtcbn1cblxuLy8gRm9yIFVURi0xNkxFIHdlIGRvIG5vdCBleHBsaWNpdGx5IGFwcGVuZCBzcGVjaWFsIHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgaWYgd2Vcbi8vIGVuZCBvbiBhIHBhcnRpYWwgY2hhcmFjdGVyLCB3ZSBzaW1wbHkgbGV0IHY4IGhhbmRsZSB0aGF0LlxuZnVuY3Rpb24gdXRmMTZFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcbiAgICB2YXIgZW5kID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xuICAgIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygndXRmMTZsZScsIDAsIGVuZCk7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRleHQoYnVmLCBpKSB7XG4gIHZhciBuID0gKGJ1Zi5sZW5ndGggLSBpKSAlIDM7XG4gIGlmIChuID09PSAwKSByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpKTtcbiAgdGhpcy5sYXN0TmVlZCA9IDMgLSBuO1xuICB0aGlzLmxhc3RUb3RhbCA9IDM7XG4gIGlmIChuID09PSAxKSB7XG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSwgYnVmLmxlbmd0aCAtIG4pO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygnYmFzZTY0JywgMCwgMyAtIHRoaXMubGFzdE5lZWQpO1xuICByZXR1cm4gcjtcbn1cblxuLy8gUGFzcyBieXRlcyBvbiB0aHJvdWdoIGZvciBzaW5nbGUtYnl0ZSBlbmNvZGluZ3MgKGUuZy4gYXNjaWksIGxhdGluMSwgaGV4KVxuZnVuY3Rpb24gc2ltcGxlV3JpdGUoYnVmKSB7XG4gIHJldHVybiBidWYudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG59XG5cbmZ1bmN0aW9uIHNpbXBsZUVuZChidWYpIHtcbiAgcmV0dXJuIGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG59IiwidmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpXG5cbi8vIHRocm91Z2hcbi8vXG4vLyBhIHN0cmVhbSB0aGF0IGRvZXMgbm90aGluZyBidXQgcmUtZW1pdCB0aGUgaW5wdXQuXG4vLyB1c2VmdWwgZm9yIGFnZ3JlZ2F0aW5nIGEgc2VyaWVzIG9mIGNoYW5naW5nIGJ1dCBub3QgZW5kaW5nIHN0cmVhbXMgaW50byBvbmUgc3RyZWFtKVxuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB0aHJvdWdoXG50aHJvdWdoLnRocm91Z2ggPSB0aHJvdWdoXG5cbi8vY3JlYXRlIGEgcmVhZGFibGUgd3JpdGFibGUgc3RyZWFtLlxuXG5mdW5jdGlvbiB0aHJvdWdoICh3cml0ZSwgZW5kLCBvcHRzKSB7XG4gIHdyaXRlID0gd3JpdGUgfHwgZnVuY3Rpb24gKGRhdGEpIHsgdGhpcy5xdWV1ZShkYXRhKSB9XG4gIGVuZCA9IGVuZCB8fCBmdW5jdGlvbiAoKSB7IHRoaXMucXVldWUobnVsbCkgfVxuXG4gIHZhciBlbmRlZCA9IGZhbHNlLCBkZXN0cm95ZWQgPSBmYWxzZSwgYnVmZmVyID0gW10sIF9lbmRlZCA9IGZhbHNlXG4gIHZhciBzdHJlYW0gPSBuZXcgU3RyZWFtKClcbiAgc3RyZWFtLnJlYWRhYmxlID0gc3RyZWFtLndyaXRhYmxlID0gdHJ1ZVxuICBzdHJlYW0ucGF1c2VkID0gZmFsc2VcblxuLy8gIHN0cmVhbS5hdXRvUGF1c2UgICA9ICEob3B0cyAmJiBvcHRzLmF1dG9QYXVzZSAgID09PSBmYWxzZSlcbiAgc3RyZWFtLmF1dG9EZXN0cm95ID0gIShvcHRzICYmIG9wdHMuYXV0b0Rlc3Ryb3kgPT09IGZhbHNlKVxuXG4gIHN0cmVhbS53cml0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgd3JpdGUuY2FsbCh0aGlzLCBkYXRhKVxuICAgIHJldHVybiAhc3RyZWFtLnBhdXNlZFxuICB9XG5cbiAgZnVuY3Rpb24gZHJhaW4oKSB7XG4gICAgd2hpbGUoYnVmZmVyLmxlbmd0aCAmJiAhc3RyZWFtLnBhdXNlZCkge1xuICAgICAgdmFyIGRhdGEgPSBidWZmZXIuc2hpZnQoKVxuICAgICAgaWYobnVsbCA9PT0gZGF0YSlcbiAgICAgICAgcmV0dXJuIHN0cmVhbS5lbWl0KCdlbmQnKVxuICAgICAgZWxzZVxuICAgICAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGRhdGEpXG4gICAgfVxuICB9XG5cbiAgc3RyZWFtLnF1ZXVlID0gc3RyZWFtLnB1c2ggPSBmdW5jdGlvbiAoZGF0YSkge1xuLy8gICAgY29uc29sZS5lcnJvcihlbmRlZClcbiAgICBpZihfZW5kZWQpIHJldHVybiBzdHJlYW1cbiAgICBpZihkYXRhID09PSBudWxsKSBfZW5kZWQgPSB0cnVlXG4gICAgYnVmZmVyLnB1c2goZGF0YSlcbiAgICBkcmFpbigpXG4gICAgcmV0dXJuIHN0cmVhbVxuICB9XG5cbiAgLy90aGlzIHdpbGwgYmUgcmVnaXN0ZXJlZCBhcyB0aGUgZmlyc3QgJ2VuZCcgbGlzdGVuZXJcbiAgLy9tdXN0IGNhbGwgZGVzdHJveSBuZXh0IHRpY2ssIHRvIG1ha2Ugc3VyZSB3ZSdyZSBhZnRlciBhbnlcbiAgLy9zdHJlYW0gcGlwZWQgZnJvbSBoZXJlLlxuICAvL3RoaXMgaXMgb25seSBhIHByb2JsZW0gaWYgZW5kIGlzIG5vdCBlbWl0dGVkIHN5bmNocm9ub3VzbHkuXG4gIC8vYSBuaWNlciB3YXkgdG8gZG8gdGhpcyBpcyB0byBtYWtlIHN1cmUgdGhpcyBpcyB0aGUgbGFzdCBsaXN0ZW5lciBmb3IgJ2VuZCdcblxuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZVxuICAgIGlmKCFzdHJlYW0ud3JpdGFibGUgJiYgc3RyZWFtLmF1dG9EZXN0cm95KVxuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN0cmVhbS5kZXN0cm95KClcbiAgICAgIH0pXG4gIH0pXG5cbiAgZnVuY3Rpb24gX2VuZCAoKSB7XG4gICAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2VcbiAgICBlbmQuY2FsbChzdHJlYW0pXG4gICAgaWYoIXN0cmVhbS5yZWFkYWJsZSAmJiBzdHJlYW0uYXV0b0Rlc3Ryb3kpXG4gICAgICBzdHJlYW0uZGVzdHJveSgpXG4gIH1cblxuICBzdHJlYW0uZW5kID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZihlbmRlZCkgcmV0dXJuXG4gICAgZW5kZWQgPSB0cnVlXG4gICAgaWYoYXJndW1lbnRzLmxlbmd0aCkgc3RyZWFtLndyaXRlKGRhdGEpXG4gICAgX2VuZCgpIC8vIHdpbGwgZW1pdCBvciBxdWV1ZVxuICAgIHJldHVybiBzdHJlYW1cbiAgfVxuXG4gIHN0cmVhbS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmKGRlc3Ryb3llZCkgcmV0dXJuXG4gICAgZGVzdHJveWVkID0gdHJ1ZVxuICAgIGVuZGVkID0gdHJ1ZVxuICAgIGJ1ZmZlci5sZW5ndGggPSAwXG4gICAgc3RyZWFtLndyaXRhYmxlID0gc3RyZWFtLnJlYWRhYmxlID0gZmFsc2VcbiAgICBzdHJlYW0uZW1pdCgnY2xvc2UnKVxuICAgIHJldHVybiBzdHJlYW1cbiAgfVxuXG4gIHN0cmVhbS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZihzdHJlYW0ucGF1c2VkKSByZXR1cm5cbiAgICBzdHJlYW0ucGF1c2VkID0gdHJ1ZVxuICAgIHJldHVybiBzdHJlYW1cbiAgfVxuXG4gIHN0cmVhbS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYoc3RyZWFtLnBhdXNlZCkge1xuICAgICAgc3RyZWFtLnBhdXNlZCA9IGZhbHNlXG4gICAgICBzdHJlYW0uZW1pdCgncmVzdW1lJylcbiAgICB9XG4gICAgZHJhaW4oKVxuICAgIC8vbWF5IGhhdmUgYmVjb21lIHBhdXNlZCBhZ2FpbixcbiAgICAvL2FzIGRyYWluIGVtaXRzICdkYXRhJy5cbiAgICBpZighc3RyZWFtLnBhdXNlZClcbiAgICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpXG4gICAgcmV0dXJuIHN0cmVhbVxuICB9XG4gIHJldHVybiBzdHJlYW1cbn1cblxuIiwidmFyIG5leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy9icm93c2VyLmpzJykubmV4dFRpY2s7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG52YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgaW1tZWRpYXRlSWRzID0ge307XG52YXIgbmV4dEltbWVkaWF0ZUlkID0gMDtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHdpbmRvdywgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFySW50ZXJ2YWwpO1xufTtcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cbmV4cG9ydHMuY2xlYXJJbnRlcnZhbCA9IGZ1bmN0aW9uKHRpbWVvdXQpIHsgdGltZW91dC5jbG9zZSgpOyB9O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHdpbmRvdywgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIFRoYXQncyBub3QgaG93IG5vZGUuanMgaW1wbGVtZW50cyBpdCBidXQgdGhlIGV4cG9zZWQgYXBpIGlzIHRoZSBzYW1lLlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSB0eXBlb2Ygc2V0SW1tZWRpYXRlID09PSBcImZ1bmN0aW9uXCIgPyBzZXRJbW1lZGlhdGUgOiBmdW5jdGlvbihmbikge1xuICB2YXIgaWQgPSBuZXh0SW1tZWRpYXRlSWQrKztcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGZhbHNlIDogc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXG4gIGltbWVkaWF0ZUlkc1tpZF0gPSB0cnVlO1xuXG4gIG5leHRUaWNrKGZ1bmN0aW9uIG9uTmV4dFRpY2soKSB7XG4gICAgaWYgKGltbWVkaWF0ZUlkc1tpZF0pIHtcbiAgICAgIC8vIGZuLmNhbGwoKSBpcyBmYXN0ZXIgc28gd2Ugb3B0aW1pemUgZm9yIHRoZSBjb21tb24gdXNlLWNhc2VcbiAgICAgIC8vIEBzZWUgaHR0cDovL2pzcGVyZi5jb20vY2FsbC1hcHBseS1zZWd1XG4gICAgICBpZiAoYXJncykge1xuICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZuLmNhbGwobnVsbCk7XG4gICAgICB9XG4gICAgICAvLyBQcmV2ZW50IGlkcyBmcm9tIGxlYWtpbmdcbiAgICAgIGV4cG9ydHMuY2xlYXJJbW1lZGlhdGUoaWQpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGlkO1xufTtcblxuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9IHR5cGVvZiBjbGVhckltbWVkaWF0ZSA9PT0gXCJmdW5jdGlvblwiID8gY2xlYXJJbW1lZGlhdGUgOiBmdW5jdGlvbihpZCkge1xuICBkZWxldGUgaW1tZWRpYXRlSWRzW2lkXTtcbn07IiwiJ3VzZSBzdHJpY3QnXG5cbnZhciBiaXRzID0gcmVxdWlyZSgnYml0LXR3aWRkbGUnKVxudmFyIGR1cCA9IHJlcXVpcmUoJ2R1cCcpXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyXG5cbi8vTGVnYWN5IHBvb2wgc3VwcG9ydFxuaWYoIWdsb2JhbC5fX1RZUEVEQVJSQVlfUE9PTCkge1xuICBnbG9iYWwuX19UWVBFREFSUkFZX1BPT0wgPSB7XG4gICAgICBVSU5UOCAgICAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIFVJTlQxNiAgICA6IGR1cChbMzIsIDBdKVxuICAgICwgVUlOVDMyICAgIDogZHVwKFszMiwgMF0pXG4gICAgLCBCSUdVSU5UNjQgOiBkdXAoWzMyLCAwXSlcbiAgICAsIElOVDggICAgICA6IGR1cChbMzIsIDBdKVxuICAgICwgSU5UMTYgICAgIDogZHVwKFszMiwgMF0pXG4gICAgLCBJTlQzMiAgICAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIEJJR0lOVDY0ICA6IGR1cChbMzIsIDBdKVxuICAgICwgRkxPQVQgICAgIDogZHVwKFszMiwgMF0pXG4gICAgLCBET1VCTEUgICAgOiBkdXAoWzMyLCAwXSlcbiAgICAsIERBVEEgICAgICA6IGR1cChbMzIsIDBdKVxuICAgICwgVUlOVDhDICAgIDogZHVwKFszMiwgMF0pXG4gICAgLCBCVUZGRVIgICAgOiBkdXAoWzMyLCAwXSlcbiAgfVxufVxuXG52YXIgaGFzVWludDhDID0gKHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSkgIT09ICd1bmRlZmluZWQnXG52YXIgaGFzQmlnVWludDY0ID0gKHR5cGVvZiBCaWdVaW50NjRBcnJheSkgIT09ICd1bmRlZmluZWQnXG52YXIgaGFzQmlnSW50NjQgPSAodHlwZW9mIEJpZ0ludDY0QXJyYXkpICE9PSAndW5kZWZpbmVkJ1xudmFyIFBPT0wgPSBnbG9iYWwuX19UWVBFREFSUkFZX1BPT0xcblxuLy9VcGdyYWRlIHBvb2xcbmlmKCFQT09MLlVJTlQ4Qykge1xuICBQT09MLlVJTlQ4QyA9IGR1cChbMzIsIDBdKVxufVxuaWYoIVBPT0wuQklHVUlOVDY0KSB7XG4gIFBPT0wuQklHVUlOVDY0ID0gZHVwKFszMiwgMF0pXG59XG5pZighUE9PTC5CSUdJTlQ2NCkge1xuICBQT09MLkJJR0lOVDY0ID0gZHVwKFszMiwgMF0pXG59XG5pZighUE9PTC5CVUZGRVIpIHtcbiAgUE9PTC5CVUZGRVIgPSBkdXAoWzMyLCAwXSlcbn1cblxuLy9OZXcgdGVjaG5pcXVlOiBPbmx5IGFsbG9jYXRlIGZyb20gQXJyYXlCdWZmZXJWaWV3IGFuZCBCdWZmZXJcbnZhciBEQVRBICAgID0gUE9PTC5EQVRBXG4gICwgQlVGRkVSICA9IFBPT0wuQlVGRkVSXG5cbmV4cG9ydHMuZnJlZSA9IGZ1bmN0aW9uIGZyZWUoYXJyYXkpIHtcbiAgaWYoQnVmZmVyLmlzQnVmZmVyKGFycmF5KSkge1xuICAgIEJVRkZFUltiaXRzLmxvZzIoYXJyYXkubGVuZ3RoKV0ucHVzaChhcnJheSlcbiAgfSBlbHNlIHtcbiAgICBpZihPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJyYXkpICE9PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nKSB7XG4gICAgICBhcnJheSA9IGFycmF5LmJ1ZmZlclxuICAgIH1cbiAgICBpZighYXJyYXkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YXIgbiA9IGFycmF5Lmxlbmd0aCB8fCBhcnJheS5ieXRlTGVuZ3RoXG4gICAgdmFyIGxvZ19uID0gYml0cy5sb2cyKG4pfDBcbiAgICBEQVRBW2xvZ19uXS5wdXNoKGFycmF5KVxuICB9XG59XG5cbmZ1bmN0aW9uIGZyZWVBcnJheUJ1ZmZlcihidWZmZXIpIHtcbiAgaWYoIWJ1ZmZlcikge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBuID0gYnVmZmVyLmxlbmd0aCB8fCBidWZmZXIuYnl0ZUxlbmd0aFxuICB2YXIgbG9nX24gPSBiaXRzLmxvZzIobilcbiAgREFUQVtsb2dfbl0ucHVzaChidWZmZXIpXG59XG5cbmZ1bmN0aW9uIGZyZWVUeXBlZEFycmF5KGFycmF5KSB7XG4gIGZyZWVBcnJheUJ1ZmZlcihhcnJheS5idWZmZXIpXG59XG5cbmV4cG9ydHMuZnJlZVVpbnQ4ID1cbmV4cG9ydHMuZnJlZVVpbnQxNiA9XG5leHBvcnRzLmZyZWVVaW50MzIgPVxuZXhwb3J0cy5mcmVlQmlnVWludDY0ID1cbmV4cG9ydHMuZnJlZUludDggPVxuZXhwb3J0cy5mcmVlSW50MTYgPVxuZXhwb3J0cy5mcmVlSW50MzIgPVxuZXhwb3J0cy5mcmVlQmlnSW50NjQgPVxuZXhwb3J0cy5mcmVlRmxvYXQzMiA9IFxuZXhwb3J0cy5mcmVlRmxvYXQgPVxuZXhwb3J0cy5mcmVlRmxvYXQ2NCA9IFxuZXhwb3J0cy5mcmVlRG91YmxlID0gXG5leHBvcnRzLmZyZWVVaW50OENsYW1wZWQgPSBcbmV4cG9ydHMuZnJlZURhdGFWaWV3ID0gZnJlZVR5cGVkQXJyYXlcblxuZXhwb3J0cy5mcmVlQXJyYXlCdWZmZXIgPSBmcmVlQXJyYXlCdWZmZXJcblxuZXhwb3J0cy5mcmVlQnVmZmVyID0gZnVuY3Rpb24gZnJlZUJ1ZmZlcihhcnJheSkge1xuICBCVUZGRVJbYml0cy5sb2cyKGFycmF5Lmxlbmd0aCldLnB1c2goYXJyYXkpXG59XG5cbmV4cG9ydHMubWFsbG9jID0gZnVuY3Rpb24gbWFsbG9jKG4sIGR0eXBlKSB7XG4gIGlmKGR0eXBlID09PSB1bmRlZmluZWQgfHwgZHR5cGUgPT09ICdhcnJheWJ1ZmZlcicpIHtcbiAgICByZXR1cm4gbWFsbG9jQXJyYXlCdWZmZXIobilcbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2goZHR5cGUpIHtcbiAgICAgIGNhc2UgJ3VpbnQ4JzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY1VpbnQ4KG4pXG4gICAgICBjYXNlICd1aW50MTYnOlxuICAgICAgICByZXR1cm4gbWFsbG9jVWludDE2KG4pXG4gICAgICBjYXNlICd1aW50MzInOlxuICAgICAgICByZXR1cm4gbWFsbG9jVWludDMyKG4pXG4gICAgICBjYXNlICdpbnQ4JzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY0ludDgobilcbiAgICAgIGNhc2UgJ2ludDE2JzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY0ludDE2KG4pXG4gICAgICBjYXNlICdpbnQzMic6XG4gICAgICAgIHJldHVybiBtYWxsb2NJbnQzMihuKVxuICAgICAgY2FzZSAnZmxvYXQnOlxuICAgICAgY2FzZSAnZmxvYXQzMic6XG4gICAgICAgIHJldHVybiBtYWxsb2NGbG9hdChuKVxuICAgICAgY2FzZSAnZG91YmxlJzpcbiAgICAgIGNhc2UgJ2Zsb2F0NjQnOlxuICAgICAgICByZXR1cm4gbWFsbG9jRG91YmxlKG4pXG4gICAgICBjYXNlICd1aW50OF9jbGFtcGVkJzpcbiAgICAgICAgcmV0dXJuIG1hbGxvY1VpbnQ4Q2xhbXBlZChuKVxuICAgICAgY2FzZSAnYmlnaW50NjQnOlxuICAgICAgICByZXR1cm4gbWFsbG9jQmlnSW50NjQobilcbiAgICAgIGNhc2UgJ2JpZ3VpbnQ2NCc6XG4gICAgICAgIHJldHVybiBtYWxsb2NCaWdVaW50NjQobilcbiAgICAgIGNhc2UgJ2J1ZmZlcic6XG4gICAgICAgIHJldHVybiBtYWxsb2NCdWZmZXIobilcbiAgICAgIGNhc2UgJ2RhdGEnOlxuICAgICAgY2FzZSAnZGF0YXZpZXcnOlxuICAgICAgICByZXR1cm4gbWFsbG9jRGF0YVZpZXcobilcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxuZnVuY3Rpb24gbWFsbG9jQXJyYXlCdWZmZXIobikge1xuICB2YXIgbiA9IGJpdHMubmV4dFBvdzIobilcbiAgdmFyIGxvZ19uID0gYml0cy5sb2cyKG4pXG4gIHZhciBkID0gREFUQVtsb2dfbl1cbiAgaWYoZC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIGQucG9wKClcbiAgfVxuICByZXR1cm4gbmV3IEFycmF5QnVmZmVyKG4pXG59XG5leHBvcnRzLm1hbGxvY0FycmF5QnVmZmVyID0gbWFsbG9jQXJyYXlCdWZmZXJcblxuZnVuY3Rpb24gbWFsbG9jVWludDgobikge1xuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobWFsbG9jQXJyYXlCdWZmZXIobiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY1VpbnQ4ID0gbWFsbG9jVWludDhcblxuZnVuY3Rpb24gbWFsbG9jVWludDE2KG4pIHtcbiAgcmV0dXJuIG5ldyBVaW50MTZBcnJheShtYWxsb2NBcnJheUJ1ZmZlcigyKm4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NVaW50MTYgPSBtYWxsb2NVaW50MTZcblxuZnVuY3Rpb24gbWFsbG9jVWludDMyKG4pIHtcbiAgcmV0dXJuIG5ldyBVaW50MzJBcnJheShtYWxsb2NBcnJheUJ1ZmZlcig0Km4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NVaW50MzIgPSBtYWxsb2NVaW50MzJcblxuZnVuY3Rpb24gbWFsbG9jSW50OChuKSB7XG4gIHJldHVybiBuZXcgSW50OEFycmF5KG1hbGxvY0FycmF5QnVmZmVyKG4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NJbnQ4ID0gbWFsbG9jSW50OFxuXG5mdW5jdGlvbiBtYWxsb2NJbnQxNihuKSB7XG4gIHJldHVybiBuZXcgSW50MTZBcnJheShtYWxsb2NBcnJheUJ1ZmZlcigyKm4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NJbnQxNiA9IG1hbGxvY0ludDE2XG5cbmZ1bmN0aW9uIG1hbGxvY0ludDMyKG4pIHtcbiAgcmV0dXJuIG5ldyBJbnQzMkFycmF5KG1hbGxvY0FycmF5QnVmZmVyKDQqbiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY0ludDMyID0gbWFsbG9jSW50MzJcblxuZnVuY3Rpb24gbWFsbG9jRmxvYXQobikge1xuICByZXR1cm4gbmV3IEZsb2F0MzJBcnJheShtYWxsb2NBcnJheUJ1ZmZlcig0Km4pLCAwLCBuKVxufVxuZXhwb3J0cy5tYWxsb2NGbG9hdDMyID0gZXhwb3J0cy5tYWxsb2NGbG9hdCA9IG1hbGxvY0Zsb2F0XG5cbmZ1bmN0aW9uIG1hbGxvY0RvdWJsZShuKSB7XG4gIHJldHVybiBuZXcgRmxvYXQ2NEFycmF5KG1hbGxvY0FycmF5QnVmZmVyKDgqbiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY0Zsb2F0NjQgPSBleHBvcnRzLm1hbGxvY0RvdWJsZSA9IG1hbGxvY0RvdWJsZVxuXG5mdW5jdGlvbiBtYWxsb2NVaW50OENsYW1wZWQobikge1xuICBpZihoYXNVaW50OEMpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KG1hbGxvY0FycmF5QnVmZmVyKG4pLCAwLCBuKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBtYWxsb2NVaW50OChuKVxuICB9XG59XG5leHBvcnRzLm1hbGxvY1VpbnQ4Q2xhbXBlZCA9IG1hbGxvY1VpbnQ4Q2xhbXBlZFxuXG5mdW5jdGlvbiBtYWxsb2NCaWdVaW50NjQobikge1xuICBpZihoYXNCaWdVaW50NjQpIHtcbiAgICByZXR1cm4gbmV3IEJpZ1VpbnQ2NEFycmF5KG1hbGxvY0FycmF5QnVmZmVyKDgqbiksIDAsIG4pXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmV4cG9ydHMubWFsbG9jQmlnVWludDY0ID0gbWFsbG9jQmlnVWludDY0XG5cbmZ1bmN0aW9uIG1hbGxvY0JpZ0ludDY0KG4pIHtcbiAgaWYgKGhhc0JpZ0ludDY0KSB7XG4gICAgcmV0dXJuIG5ldyBCaWdJbnQ2NEFycmF5KG1hbGxvY0FycmF5QnVmZmVyKDgqbiksIDAsIG4pXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmV4cG9ydHMubWFsbG9jQmlnSW50NjQgPSBtYWxsb2NCaWdJbnQ2NFxuXG5mdW5jdGlvbiBtYWxsb2NEYXRhVmlldyhuKSB7XG4gIHJldHVybiBuZXcgRGF0YVZpZXcobWFsbG9jQXJyYXlCdWZmZXIobiksIDAsIG4pXG59XG5leHBvcnRzLm1hbGxvY0RhdGFWaWV3ID0gbWFsbG9jRGF0YVZpZXdcblxuZnVuY3Rpb24gbWFsbG9jQnVmZmVyKG4pIHtcbiAgbiA9IGJpdHMubmV4dFBvdzIobilcbiAgdmFyIGxvZ19uID0gYml0cy5sb2cyKG4pXG4gIHZhciBjYWNoZSA9IEJVRkZFUltsb2dfbl1cbiAgaWYoY2FjaGUubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBjYWNoZS5wb3AoKVxuICB9XG4gIHJldHVybiBuZXcgQnVmZmVyKG4pXG59XG5leHBvcnRzLm1hbGxvY0J1ZmZlciA9IG1hbGxvY0J1ZmZlclxuXG5leHBvcnRzLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiBjbGVhckNhY2hlKCkge1xuICBmb3IodmFyIGk9MDsgaTwzMjsgKytpKSB7XG4gICAgUE9PTC5VSU5UOFtpXS5sZW5ndGggPSAwXG4gICAgUE9PTC5VSU5UMTZbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuVUlOVDMyW2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLklOVDhbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuSU5UMTZbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuSU5UMzJbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuRkxPQVRbaV0ubGVuZ3RoID0gMFxuICAgIFBPT0wuRE9VQkxFW2ldLmxlbmd0aCA9IDBcbiAgICBQT09MLkJJR1VJTlQ2NFtpXS5sZW5ndGggPSAwXG4gICAgUE9PTC5CSUdJTlQ2NFtpXS5sZW5ndGggPSAwXG4gICAgUE9PTC5VSU5UOENbaV0ubGVuZ3RoID0gMFxuICAgIERBVEFbaV0ubGVuZ3RoID0gMFxuICAgIEJVRkZFUltpXS5sZW5ndGggPSAwXG4gIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiXG5cbmZ1bmN0aW9uIHVuaXF1ZV9wcmVkKGxpc3QsIGNvbXBhcmUpIHtcbiAgdmFyIHB0ciA9IDFcbiAgICAsIGxlbiA9IGxpc3QubGVuZ3RoXG4gICAgLCBhPWxpc3RbMF0sIGI9bGlzdFswXVxuICBmb3IodmFyIGk9MTsgaTxsZW47ICsraSkge1xuICAgIGIgPSBhXG4gICAgYSA9IGxpc3RbaV1cbiAgICBpZihjb21wYXJlKGEsIGIpKSB7XG4gICAgICBpZihpID09PSBwdHIpIHtcbiAgICAgICAgcHRyKytcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIGxpc3RbcHRyKytdID0gYVxuICAgIH1cbiAgfVxuICBsaXN0Lmxlbmd0aCA9IHB0clxuICByZXR1cm4gbGlzdFxufVxuXG5mdW5jdGlvbiB1bmlxdWVfZXEobGlzdCkge1xuICB2YXIgcHRyID0gMVxuICAgICwgbGVuID0gbGlzdC5sZW5ndGhcbiAgICAsIGE9bGlzdFswXSwgYiA9IGxpc3RbMF1cbiAgZm9yKHZhciBpPTE7IGk8bGVuOyArK2ksIGI9YSkge1xuICAgIGIgPSBhXG4gICAgYSA9IGxpc3RbaV1cbiAgICBpZihhICE9PSBiKSB7XG4gICAgICBpZihpID09PSBwdHIpIHtcbiAgICAgICAgcHRyKytcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIGxpc3RbcHRyKytdID0gYVxuICAgIH1cbiAgfVxuICBsaXN0Lmxlbmd0aCA9IHB0clxuICByZXR1cm4gbGlzdFxufVxuXG5mdW5jdGlvbiB1bmlxdWUobGlzdCwgY29tcGFyZSwgc29ydGVkKSB7XG4gIGlmKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGxpc3RcbiAgfVxuICBpZihjb21wYXJlKSB7XG4gICAgaWYoIXNvcnRlZCkge1xuICAgICAgbGlzdC5zb3J0KGNvbXBhcmUpXG4gICAgfVxuICAgIHJldHVybiB1bmlxdWVfcHJlZChsaXN0LCBjb21wYXJlKVxuICB9XG4gIGlmKCFzb3J0ZWQpIHtcbiAgICBsaXN0LnNvcnQoKVxuICB9XG4gIHJldHVybiB1bmlxdWVfZXEobGlzdClcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB1bmlxdWVcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlcHJlY2F0ZTtcblxuLyoqXG4gKiBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICogUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLm5vRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRocm93RGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgdGhyb3cgYW4gRXJyb3Igd2hlbiBpbnZva2VkLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudHJhY2VEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCBpbnZva2UgYGNvbnNvbGUudHJhY2UoKWAgaW5zdGVhZCBvZiBgY29uc29sZS5lcnJvcigpYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIHRoZSBmdW5jdGlvbiB0byBkZXByZWNhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgLSB0aGUgc3RyaW5nIHRvIHByaW50IHRvIHRoZSBjb25zb2xlIHdoZW4gYGZuYCBpcyBpbnZva2VkXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgbmV3IFwiZGVwcmVjYXRlZFwiIHZlcnNpb24gb2YgYGZuYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZXByZWNhdGUgKGZuLCBtc2cpIHtcbiAgaWYgKGNvbmZpZygnbm9EZXByZWNhdGlvbicpKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAoY29uZmlnKCd0aHJvd0RlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKGNvbmZpZygndHJhY2VEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgYGxvY2FsU3RvcmFnZWAgZm9yIGJvb2xlYW4gdmFsdWVzIGZvciB0aGUgZ2l2ZW4gYG5hbWVgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbmZpZyAobmFtZSkge1xuICAvLyBhY2Nlc3NpbmcgZ2xvYmFsLmxvY2FsU3RvcmFnZSBjYW4gdHJpZ2dlciBhIERPTUV4Y2VwdGlvbiBpbiBzYW5kYm94ZWQgaWZyYW1lc1xuICB0cnkge1xuICAgIGlmICghZ2xvYmFsLmxvY2FsU3RvcmFnZSkgcmV0dXJuIGZhbHNlO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB2YWwgPSBnbG9iYWwubG9jYWxTdG9yYWdlW25hbWVdO1xuICBpZiAobnVsbCA9PSB2YWwpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIFN0cmluZyh2YWwpLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Db2RlQnVpbGRlciA9IGV4cG9ydHMuY2hhbm5lbFNhbXBsZXJOYW1lID0gdm9pZCAwO1xuY29uc3QgZXhwcl8xID0gcmVxdWlyZShcIi4vZXhwcnMvZXhwclwiKTtcbmNvbnN0IHdlYmdscHJvZ3JhbWxvb3BfMSA9IHJlcXVpcmUoXCIuL3dlYmdscHJvZ3JhbWxvb3BcIik7XG4vKiogQGlnbm9yZSAqL1xuY29uc3QgRlJBR19TRVQgPSBgICBnbF9GcmFnQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIGdsX0ZyYWdDb29yZC54eSAvIHVSZXNvbHV0aW9uKTtcXG5gO1xuLyoqIEBpZ25vcmUgKi9cbmNvbnN0IFNDRU5FX1NFVCA9IGB1bmlmb3JtIHNhbXBsZXIyRCB1U2NlbmVTYW1wbGVyO1xcbmA7XG4vKiogQGlnbm9yZSAqL1xuY29uc3QgVElNRV9TRVQgPSBgdW5pZm9ybSBtZWRpdW1wIGZsb2F0IHVUaW1lO1xcbmA7XG4vKiogQGlnbm9yZSAqL1xuY29uc3QgTU9VU0VfU0VUID0gYHVuaWZvcm0gbWVkaXVtcCB2ZWMyIHVNb3VzZTtcXG5gO1xuLyoqIEBpZ25vcmUgKi9cbmNvbnN0IEJPSUxFUlBMQVRFID0gYCNpZmRlZiBHTF9FU1xucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG4jZW5kaWZcblxudW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XG51bmlmb3JtIG1lZGl1bXAgdmVjMiB1UmVzb2x1dGlvbjtcXG5gO1xuLyoqXG4gKiByZXR1cm5zIHRoZSBzdHJpbmcgbmFtZSBvZiB0aGUgc2FtcGxlciB1bmlmb3JtIGZvciBjb2RlIGdlbmVyYXRpb24gcHVycG9zZXNcbiAqIEBwYXJhbSBudW0gY2hhbm5lbCBudW1iZXIgdG8gc2FtcGxlIGZyb21cbiAqL1xuZnVuY3Rpb24gY2hhbm5lbFNhbXBsZXJOYW1lKG51bSkge1xuICAgIC8vIHRleHR1cmUgMiBzYW1wbGVyIGhhcyBudW1iZXIgMCAoMCBhbmQgMSBhcmUgdXNlZCBmb3IgYmFjayBidWZmZXIgYW5kIHNjZW5lKVxuICAgIHJldHVybiBgdUJ1ZmZlclNhbXBsZXIke251bX1gO1xufVxuZXhwb3J0cy5jaGFubmVsU2FtcGxlck5hbWUgPSBjaGFubmVsU2FtcGxlck5hbWU7XG4vKipcbiAqIHJldHVybnMgdGhlIHN0cmluZyBvZiB0aGUgZGVjbGFyYXRpb24gb2YgdGhlIHNhbXBsZXIgZm9yIGNvZGUgZ2VuZXJhdGlvblxuICogcHVycG9zZXNcbiAqIEBwYXJhbSBudW0gY2hhbm5lbCBudW1iZXIgdG8gc2FtcGxlIGZyb21cbiAqL1xuZnVuY3Rpb24gY2hhbm5lbFNhbXBsZXJEZWNsYXJhdGlvbihudW0pIHtcbiAgICByZXR1cm4gYHVuaWZvcm0gc2FtcGxlcjJEICR7Y2hhbm5lbFNhbXBsZXJOYW1lKG51bSl9O2A7XG59XG4vKiogY2xhc3MgdGhhdCBtYW5hZ2VzIGdlbmVyYXRpb24gYW5kIGNvbXBpbGF0aW9uIG9mIEdMU0wgY29kZSAqL1xuY2xhc3MgQ29kZUJ1aWxkZXIge1xuICAgIGNvbnN0cnVjdG9yKGVmZmVjdExvb3ApIHtcbiAgICAgICAgdGhpcy5jYWxscyA9IFtdO1xuICAgICAgICB0aGlzLmV4dGVybmFsRnVuY3MgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMudW5pZm9ybURlY2xhcmF0aW9ucyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5jb3VudGVyID0gMDtcbiAgICAgICAgdGhpcy5iYXNlTG9vcCA9IGVmZmVjdExvb3A7XG4gICAgICAgIGNvbnN0IGJ1aWxkSW5mbyA9IHtcbiAgICAgICAgICAgIHVuaWZvcm1UeXBlczoge30sXG4gICAgICAgICAgICBleHRlcm5hbEZ1bmNzOiBuZXcgU2V0KCksXG4gICAgICAgICAgICBleHByczogW10sXG4gICAgICAgICAgICBuZWVkczoge1xuICAgICAgICAgICAgICAgIGNlbnRlclNhbXBsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgbmVpZ2hib3JTYW1wbGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNjZW5lQnVmZmVyOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0aW1lVW5pZm9ybTogZmFsc2UsXG4gICAgICAgICAgICAgICAgbW91c2VVbmlmb3JtOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBleHRyYUJ1ZmZlcnM6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWRkRWZmZWN0TG9vcChlZmZlY3RMb29wLCAxLCBidWlsZEluZm8pO1xuICAgICAgICAvLyBhZGQgYWxsIHRoZSB0eXBlcyB0byB1bmlmb3JtIGRlY2xhcmF0aW9ucyBmcm9tIHRoZSBgQnVpbGRJbmZvYCBpbnN0YW5jZVxuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gYnVpbGRJbmZvLnVuaWZvcm1UeXBlcykge1xuICAgICAgICAgICAgY29uc3QgdHlwZU5hbWUgPSBidWlsZEluZm8udW5pZm9ybVR5cGVzW25hbWVdO1xuICAgICAgICAgICAgdGhpcy51bmlmb3JtRGVjbGFyYXRpb25zLmFkZChgdW5pZm9ybSBtZWRpdW1wICR7dHlwZU5hbWV9ICR7bmFtZX07YCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWRkIGFsbCBleHRlcm5hbCBmdW5jdGlvbnMgZnJvbSB0aGUgYEJ1aWxkSW5mb2AgaW5zdGFuY2VcbiAgICAgICAgYnVpbGRJbmZvLmV4dGVybmFsRnVuY3MuZm9yRWFjaCgoZnVuYykgPT4gdGhpcy5leHRlcm5hbEZ1bmNzLmFkZChmdW5jKSk7XG4gICAgICAgIHRoaXMudG90YWxOZWVkcyA9IGJ1aWxkSW5mby5uZWVkcztcbiAgICAgICAgdGhpcy5leHBycyA9IGJ1aWxkSW5mby5leHBycztcbiAgICB9XG4gICAgYWRkRWZmZWN0TG9vcChlZmZlY3RMb29wLCBpbmRlbnRMZXZlbCwgYnVpbGRJbmZvLCB0b3BMZXZlbCA9IHRydWUpIHtcbiAgICAgICAgY29uc3QgbmVlZHNMb29wID0gIXRvcExldmVsICYmIGVmZmVjdExvb3AubG9vcEluZm8ubnVtID4gMTtcbiAgICAgICAgaWYgKG5lZWRzTG9vcCkge1xuICAgICAgICAgICAgY29uc3QgaU5hbWUgPSBcImlcIiArIHRoaXMuY291bnRlcjtcbiAgICAgICAgICAgIGluZGVudExldmVsKys7XG4gICAgICAgICAgICBjb25zdCBmb3JTdGFydCA9IFwiICBcIi5yZXBlYXQoaW5kZW50TGV2ZWwgLSAxKSArXG4gICAgICAgICAgICAgICAgYGZvciAoaW50ICR7aU5hbWV9ID0gMDsgJHtpTmFtZX0gPCAke2VmZmVjdExvb3AubG9vcEluZm8ubnVtfTsgJHtpTmFtZX0rKykge2A7XG4gICAgICAgICAgICB0aGlzLmNhbGxzLnB1c2goZm9yU3RhcnQpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZSBvZiBlZmZlY3RMb29wLmVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgZXhwcl8xLkV4cHIpIHtcbiAgICAgICAgICAgICAgICBlLnBhcnNlKGJ1aWxkSW5mbyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jYWxscy5wdXNoKFwiICBcIi5yZXBlYXQoaW5kZW50TGV2ZWwpICsgXCJnbF9GcmFnQ29sb3IgPSBcIiArIGUuc291cmNlQ29kZSArIFwiO1wiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvdW50ZXIrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkRWZmZWN0TG9vcChlLCBpbmRlbnRMZXZlbCwgYnVpbGRJbmZvLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5lZWRzTG9vcCkge1xuICAgICAgICAgICAgdGhpcy5jYWxscy5wdXNoKFwiICBcIi5yZXBlYXQoaW5kZW50TGV2ZWwgLSAxKSArIFwifVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogZ2VuZXJhdGUgdGhlIGNvZGUgYW5kIGNvbXBpbGUgdGhlIHByb2dyYW0gaW50byBhIGxvb3AgKi9cbiAgICBjb21waWxlUHJvZ3JhbShnbCwgdlNoYWRlciwgdW5pZm9ybUxvY3MsIHNoYWRlcnMgPSBbXSkge1xuICAgICAgICAvLyBzZXQgdXAgdGhlIGZyYWdtZW50IHNoYWRlclxuICAgICAgICBjb25zdCBmU2hhZGVyID0gZ2wuY3JlYXRlU2hhZGVyKGdsLkZSQUdNRU5UX1NIQURFUik7XG4gICAgICAgIGlmIChmU2hhZGVyID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwcm9ibGVtIGNyZWF0aW5nIGZyYWdtZW50IHNoYWRlclwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmdWxsQ29kZSA9IEJPSUxFUlBMQVRFICtcbiAgICAgICAgICAgICh0aGlzLnRvdGFsTmVlZHMuc2NlbmVCdWZmZXIgPyBTQ0VORV9TRVQgOiBcIlwiKSArXG4gICAgICAgICAgICAodGhpcy50b3RhbE5lZWRzLnRpbWVVbmlmb3JtID8gVElNRV9TRVQgOiBcIlwiKSArXG4gICAgICAgICAgICAodGhpcy50b3RhbE5lZWRzLm1vdXNlVW5pZm9ybSA/IE1PVVNFX1NFVCA6IFwiXCIpICtcbiAgICAgICAgICAgIEFycmF5LmZyb20odGhpcy50b3RhbE5lZWRzLmV4dHJhQnVmZmVycylcbiAgICAgICAgICAgICAgICAubWFwKChuKSA9PiBjaGFubmVsU2FtcGxlckRlY2xhcmF0aW9uKG4pKVxuICAgICAgICAgICAgICAgIC5qb2luKFwiXFxuXCIpICtcbiAgICAgICAgICAgIFwiXFxuXCIgK1xuICAgICAgICAgICAgWy4uLnRoaXMudW5pZm9ybURlY2xhcmF0aW9uc10uam9pbihcIlxcblwiKSArXG4gICAgICAgICAgICBcIlxcblwiICtcbiAgICAgICAgICAgIFsuLi50aGlzLmV4dGVybmFsRnVuY3NdLmpvaW4oXCJcXG5cIikgK1xuICAgICAgICAgICAgXCJcXG5cIiArXG4gICAgICAgICAgICBcInZvaWQgbWFpbigpIHtcXG5cIiArXG4gICAgICAgICAgICAodGhpcy50b3RhbE5lZWRzLmNlbnRlclNhbXBsZSA/IEZSQUdfU0VUIDogXCJcIikgK1xuICAgICAgICAgICAgdGhpcy5jYWxscy5qb2luKFwiXFxuXCIpICtcbiAgICAgICAgICAgIFwiXFxufVwiO1xuICAgICAgICBjb25zb2xlLmxvZyhmdWxsQ29kZSk7XG4gICAgICAgIGdsLnNoYWRlclNvdXJjZShmU2hhZGVyLCBmdWxsQ29kZSk7XG4gICAgICAgIGdsLmNvbXBpbGVTaGFkZXIoZlNoYWRlcik7XG4gICAgICAgIC8vIHNldCB1cCB0aGUgcHJvZ3JhbVxuICAgICAgICBjb25zdCBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuICAgICAgICBpZiAocHJvZ3JhbSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicHJvYmxlbSBjcmVhdGluZyBwcm9ncmFtXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8gYXJlIHdlIGF0dGFjaGluZyB0aGUgdmVydGV4IHNoYWRlciBtb3JlIHRpbWVzIHRoYW4gaXMgbmVjZXNzYXJ5P1xuICAgICAgICBnbC5hdHRhY2hTaGFkZXIocHJvZ3JhbSwgdlNoYWRlcik7XG4gICAgICAgIGdsLmF0dGFjaFNoYWRlcihwcm9ncmFtLCBmU2hhZGVyKTtcbiAgICAgICAgc2hhZGVycy5wdXNoKGZTaGFkZXIpO1xuICAgICAgICBjb25zdCBzaGFkZXJMb2cgPSAobmFtZSwgc2hhZGVyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvdXRwdXQgPSBnbC5nZXRTaGFkZXJJbmZvTG9nKHNoYWRlcik7XG4gICAgICAgICAgICBpZiAob3V0cHV0KVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGAke25hbWV9IHNoYWRlciBpbmZvIGxvZ1xcbiR7b3V0cHV0fWApO1xuICAgICAgICB9O1xuICAgICAgICBzaGFkZXJMb2coXCJ2ZXJ0ZXhcIiwgdlNoYWRlcik7XG4gICAgICAgIHNoYWRlckxvZyhcImZyYWdtZW50XCIsIGZTaGFkZXIpO1xuICAgICAgICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgICAgLy8gd2UgbmVlZCB0byB1c2UgdGhlIHByb2dyYW0gaGVyZSBzbyB3ZSBjYW4gZ2V0IHVuaWZvcm0gbG9jYXRpb25zXG4gICAgICAgIGdsLnVzZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgICAgIC8vIGZpbmQgYWxsIHVuaWZvcm0gbG9jYXRpb25zIGFuZCBhZGQgdGhlbSB0byB0aGUgZGljdGlvbmFyeVxuICAgICAgICBmb3IgKGNvbnN0IGV4cHIgb2YgdGhpcy5leHBycykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIGV4cHIudW5pZm9ybVZhbENoYW5nZU1hcCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChsb2NhdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb3VsZG4ndCBmaW5kIHVuaWZvcm0gXCIgKyBuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBlbmZvcmNlIHVuaXF1ZSBuYW1lcyBpbiB0aGUgc2FtZSBwcm9ncmFtXG4gICAgICAgICAgICAgICAgaWYgKHVuaWZvcm1Mb2NzW25hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5pZm9ybUxvY3NbbmFtZV0gPSB7IGxvY3M6IFtdLCBjb3VudGVyOiAwIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGFzc2lnbiB0aGUgbmFtZSB0byB0aGUgbG9jYXRpb25cbiAgICAgICAgICAgICAgICB1bmlmb3JtTG9jc1tuYW1lXS5sb2NzLnB1c2gobG9jYXRpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIHNldCB0aGUgdW5pZm9ybSByZXNvbHV0aW9uIChldmVyeSBwcm9ncmFtIGhhcyB0aGlzIHVuaWZvcm0pXG4gICAgICAgIGNvbnN0IHVSZXNvbHV0aW9uID0gZ2wuZ2V0VW5pZm9ybUxvY2F0aW9uKHByb2dyYW0sIFwidVJlc29sdXRpb25cIik7XG4gICAgICAgIGdsLnVuaWZvcm0yZih1UmVzb2x1dGlvbiwgZ2wuZHJhd2luZ0J1ZmZlcldpZHRoLCBnbC5kcmF3aW5nQnVmZmVySGVpZ2h0KTtcbiAgICAgICAgaWYgKHRoaXMudG90YWxOZWVkcy5zY2VuZUJ1ZmZlcikge1xuICAgICAgICAgICAgLy8gVE9ETyBhbGxvdyBmb3IgdGV4dHVyZSBvcHRpb25zIGZvciBzY2VuZSB0ZXh0dXJlXG4gICAgICAgICAgICBjb25zdCBsb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCBcInVTY2VuZVNhbXBsZXJcIik7XG4gICAgICAgICAgICAvLyBwdXQgdGhlIHNjZW5lIGJ1ZmZlciBpbiB0ZXh0dXJlIDEgKDAgaXMgdXNlZCBmb3IgdGhlIGJhY2tidWZmZXIpXG4gICAgICAgICAgICBnbC51bmlmb3JtMWkobG9jYXRpb24sIDEpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldCBhbGwgc2FtcGxlciB1bmlmb3Jtc1xuICAgICAgICBmb3IgKGNvbnN0IGIgb2YgdGhpcy50b3RhbE5lZWRzLmV4dHJhQnVmZmVycykge1xuICAgICAgICAgICAgY29uc3QgbG9jYXRpb24gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSwgY2hhbm5lbFNhbXBsZXJOYW1lKGIpKTtcbiAgICAgICAgICAgIC8vIG9mZnNldCB0aGUgdGV4dHVyZSBsb2NhdGlvbiBieSAyICgwIGFuZCAxIGFyZSB1c2VkIGZvciBzY2VuZSBhbmQgb3JpZ2luYWwpXG4gICAgICAgICAgICBnbC51bmlmb3JtMWkobG9jYXRpb24sIGIgKyAyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBnZXQgYXR0cmlidXRlXG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgXCJhUG9zaXRpb25cIik7XG4gICAgICAgIC8vIGVuYWJsZSB0aGUgYXR0cmlidXRlXG4gICAgICAgIGdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHBvc2l0aW9uKTtcbiAgICAgICAgLy8gcG9pbnRzIHRvIHRoZSB2ZXJ0aWNlcyBpbiB0aGUgbGFzdCBib3VuZCBhcnJheSBidWZmZXJcbiAgICAgICAgZ2wudmVydGV4QXR0cmliUG9pbnRlcihwb3NpdGlvbiwgMiwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcbiAgICAgICAgcmV0dXJuIG5ldyB3ZWJnbHByb2dyYW1sb29wXzEuV2ViR0xQcm9ncmFtTG9vcChuZXcgd2ViZ2xwcm9ncmFtbG9vcF8xLldlYkdMUHJvZ3JhbUxlYWYocHJvZ3JhbSwgdGhpcy50b3RhbE5lZWRzLCB0aGlzLmV4cHJzKSwgdGhpcy5iYXNlTG9vcC5sb29wSW5mbywgZ2wpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29kZUJ1aWxkZXIgPSBDb2RlQnVpbGRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hMSA9IGV4cG9ydHMuQXJpdHkxSG9tb2dlbm91c0V4cHIgPSB2b2lkIDA7XG5jb25zdCBleHByXzEgPSByZXF1aXJlKFwiLi9leHByXCIpO1xuLyoqIEBpZ25vcmUgKi9cbmZ1bmN0aW9uIGdlbkFyaXR5MVNvdXJjZUxpc3QobmFtZSwgdmFsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2VjdGlvbnM6IFtuYW1lICsgXCIoXCIsIFwiKVwiXSxcbiAgICAgICAgdmFsdWVzOiBbdmFsXSxcbiAgICB9O1xufVxuLyoqIGFyaXR5IDEgaG9tb2dlbm91cyBmdW5jdGlvbiBleHByZXNzaW9uICovXG5jbGFzcyBBcml0eTFIb21vZ2Vub3VzRXhwciBleHRlbmRzIGV4cHJfMS5PcGVyYXRvciB7XG4gICAgY29uc3RydWN0b3IodmFsLCBvcGVyYXRpb24pIHtcbiAgICAgICAgc3VwZXIodmFsLCBnZW5Bcml0eTFTb3VyY2VMaXN0KG9wZXJhdGlvbiwgdmFsKSwgW1widVZhbFwiXSk7XG4gICAgICAgIHRoaXMudmFsID0gdmFsO1xuICAgIH1cbiAgICAvKiogc2V0IHRoZSB2YWx1ZSBiZWluZyBwYXNzZWQgaW50byB0aGUgYXJpdHkgMSBob21vZ2Vub3VzIGZ1bmN0aW9uICovXG4gICAgc2V0VmFsKHZhbCkge1xuICAgICAgICB0aGlzLnNldFVuaWZvcm0oXCJ1VmFsXCIgKyB0aGlzLmlkLCB2YWwpO1xuICAgICAgICB0aGlzLnZhbCA9IGV4cHJfMS53cmFwSW5WYWx1ZSh2YWwpO1xuICAgIH1cbn1cbmV4cG9ydHMuQXJpdHkxSG9tb2dlbm91c0V4cHIgPSBBcml0eTFIb21vZ2Vub3VzRXhwcjtcbi8qKlxuICogYnVpbHQtaW4gZnVuY3Rpb25zIHRoYXQgdGFrZSBpbiBvbmUgYGdlblR5cGUgeGAgYW5kIHJldHVybiBhIGBnZW5UeXBlIHhgXG4gKiBAcGFyYW0gbmFtZSBmdW5jdGlvbiBuYW1lIChzZWUgW1tBcml0eTFIb21vZ2Vub3VzTmFtZV1dIGZvciB2YWxpZCBmdW5jdGlvbiBuYW1lcylcbiAqIEBwYXJhbSB2YWwgdGhlIGBnZW5UeXBlIHhgIGFyZ3VtZW50XG4gKi9cbmZ1bmN0aW9uIGExKG5hbWUsIHZhbCkge1xuICAgIHJldHVybiBuZXcgQXJpdHkxSG9tb2dlbm91c0V4cHIoZXhwcl8xLndyYXBJblZhbHVlKHZhbCksIG5hbWUpO1xufVxuZXhwb3J0cy5hMSA9IGExO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmEyID0gZXhwb3J0cy5Bcml0eTJIb21vZ2Vub3VzRXhwciA9IHZvaWQgMDtcbmNvbnN0IGV4cHJfMSA9IHJlcXVpcmUoXCIuL2V4cHJcIik7XG4vKiogQGlnbm9yZSAqL1xuZnVuY3Rpb24gZ2VuQXJpdHkxU291cmNlTGlzdChuYW1lLCB2YWwxLCB2YWwyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2VjdGlvbnM6IFtuYW1lICsgXCIoXCIsIFwiLFwiLCBcIilcIl0sXG4gICAgICAgIHZhbHVlczogW3ZhbDEsIHZhbDJdLFxuICAgIH07XG59XG4vKiogYXJpdHkgMiBob21vZ2Vub3VzIGZ1bmN0aW9uIGV4cHJlc3Npb24gKi9cbmNsYXNzIEFyaXR5MkhvbW9nZW5vdXNFeHByIGV4dGVuZHMgZXhwcl8xLk9wZXJhdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lLCB2YWwxLCB2YWwyKSB7XG4gICAgICAgIHN1cGVyKHZhbDEsIGdlbkFyaXR5MVNvdXJjZUxpc3QobmFtZSwgdmFsMSwgdmFsMiksIFtcInVWYWwxXCIsIFwidVZhbDJcIl0pO1xuICAgICAgICB0aGlzLnZhbDEgPSB2YWwxO1xuICAgICAgICB0aGlzLnZhbDIgPSB2YWwyO1xuICAgIH1cbiAgICAvKiogc2V0IHRoZSBmaXJzdCB2YWx1ZSBiZWluZyBwYXNzZWQgaW50byB0aGUgYXJpdHkgMiBob21vZ2Vub3VzIGZ1bmN0aW9uICovXG4gICAgc2V0Rmlyc3RWYWwodmFsMSkge1xuICAgICAgICB0aGlzLnNldFVuaWZvcm0oXCJ1VmFsMVwiICsgdGhpcy5pZCwgdmFsMSk7XG4gICAgICAgIHRoaXMudmFsMSA9IGV4cHJfMS53cmFwSW5WYWx1ZSh2YWwxKTtcbiAgICB9XG4gICAgLyoqIHNldCB0aGUgc2Vjb25kIHZhbHVlIGJlaW5nIHBhc3NlZCBpbnRvIHRoZSBhcml0eSAyIGhvbW9nZW5vdXMgZnVuY3Rpb24gKi9cbiAgICBzZXRTZWNvbmRWYWwodmFsMikge1xuICAgICAgICB0aGlzLnNldFVuaWZvcm0oXCJ1VmFsMlwiICsgdGhpcy5pZCwgdmFsMik7XG4gICAgICAgIHRoaXMudmFsMiA9IGV4cHJfMS53cmFwSW5WYWx1ZSh2YWwyKTtcbiAgICB9XG59XG5leHBvcnRzLkFyaXR5MkhvbW9nZW5vdXNFeHByID0gQXJpdHkySG9tb2dlbm91c0V4cHI7XG4vLyBpbXBsZW1lbnRhdGlvblxuLyoqXG4gKiBidWlsdC1pbiBmdW5jdGlvbnMgdGhhdCB0YWtlIGluIHR3byBgZ2VuVHlwZSB4YCBhcmd1bWVudHMgYW5kIHJldHVybiBhIGBnZW5UeXBlIHhgXG4gKiBAcGFyYW0gbmFtZSBmdW5jdGlvbiBuYW1lIChzZWUgW1tBcml0eTJIb21vZ2Vub3VzTmFtZV1dIGZvciB2YWxpZCBmdW5jdGlvbiBuYW1lcylcbiAqIEBwYXJhbSB2YWwxIHRoZSBmaXJzdCBgZ2VuVHlwZSB4YCBhcmd1bWVudFxuICogQHBhcmFtIHZhbDIgdGhlIHNlY29uZCBgZ2VuVHlwZSB4YCBhcmd1bWVudFxuICovXG5mdW5jdGlvbiBhMihuYW1lLCB2YWwxLCB2YWwyKSB7XG4gICAgcmV0dXJuIG5ldyBBcml0eTJIb21vZ2Vub3VzRXhwcihuYW1lLCBleHByXzEud3JhcEluVmFsdWUodmFsMSksIGV4cHJfMS53cmFwSW5WYWx1ZSh2YWwyKSk7XG59XG5leHBvcnRzLmEyID0gYTI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYmxvb20gPSBleHBvcnRzLkJsb29tTG9vcCA9IHZvaWQgMDtcbmNvbnN0IG1lcmdlcGFzc18xID0gcmVxdWlyZShcIi4uL21lcmdlcGFzc1wiKTtcbmNvbnN0IGFyaXR5Ml8xID0gcmVxdWlyZShcIi4vYXJpdHkyXCIpO1xuY29uc3QgYmx1cmV4cHJfMSA9IHJlcXVpcmUoXCIuL2JsdXJleHByXCIpO1xuY29uc3QgYnJpZ2h0bmVzc2V4cHJfMSA9IHJlcXVpcmUoXCIuL2JyaWdodG5lc3NleHByXCIpO1xuY29uc3QgY29udHJhc3RleHByXzEgPSByZXF1aXJlKFwiLi9jb250cmFzdGV4cHJcIik7XG5jb25zdCBleHByXzEgPSByZXF1aXJlKFwiLi9leHByXCIpO1xuY29uc3QgZnJhZ2NvbG9yZXhwcl8xID0gcmVxdWlyZShcIi4vZnJhZ2NvbG9yZXhwclwiKTtcbmNvbnN0IG9wZXhwcl8xID0gcmVxdWlyZShcIi4vb3BleHByXCIpO1xuY29uc3Qgc2NlbmVzYW1wbGVleHByXzEgPSByZXF1aXJlKFwiLi9zY2VuZXNhbXBsZWV4cHJcIik7XG5jb25zdCBzZXRjb2xvcmV4cHJfMSA9IHJlcXVpcmUoXCIuL3NldGNvbG9yZXhwclwiKTtcbmNvbnN0IHZlY2V4cHJzXzEgPSByZXF1aXJlKFwiLi92ZWNleHByc1wiKTtcbi8qKiBibG9vbSBsb29wICovXG5jbGFzcyBCbG9vbUxvb3AgZXh0ZW5kcyBtZXJnZXBhc3NfMS5FZmZlY3RMb29wIHtcbiAgICBjb25zdHJ1Y3Rvcih0aHJlc2hvbGQgPSBleHByXzEuZmxvYXQoZXhwcl8xLm11dCgwLjQpKSwgaG9yaXpvbnRhbCA9IGV4cHJfMS5mbG9hdChleHByXzEubXV0KDEpKSwgdmVydGljYWwgPSBleHByXzEuZmxvYXQoZXhwcl8xLm11dCgxKSksIGJvb3N0ID0gZXhwcl8xLmZsb2F0KGV4cHJfMS5tdXQoMS4zKSksIHRhcHMgPSA5LCByZXBzID0gMykge1xuICAgICAgICAvL2NvbnN0IGJyaWdodCA9IGdldGNvbXAocmdiMmhzdihmY29sb3IoKSksIFwielwiKTtcbiAgICAgICAgY29uc3QgYnJpZ2h0ID0gZXhwcl8xLmNmbG9hdChleHByXzEudGFnIGAoKCR7ZnJhZ2NvbG9yZXhwcl8xLmZjb2xvcigpfS5yICsgJHtmcmFnY29sb3JleHByXzEuZmNvbG9yKCl9LmcgKyAke2ZyYWdjb2xvcmV4cHJfMS5mY29sb3IoKX0uYikgLyAzLilgKTtcbiAgICAgICAgY29uc3Qgc3RlcCA9IGFyaXR5Ml8xLmEyKFwic3RlcFwiLCBicmlnaHQsIHRocmVzaG9sZCk7XG4gICAgICAgIGNvbnN0IGNvbCA9IGV4cHJfMS5jdmVjNChleHByXzEudGFnIGB2ZWM0KCR7ZnJhZ2NvbG9yZXhwcl8xLmZjb2xvcigpfS5yZ2IgKiAoMS4gLSAke3N0ZXB9KSwgMS4pYCk7XG4gICAgICAgIC8vY29uc3QgY29udHJhc3RCb29zdCA9IGNvbnRyYXN0KG11dCgxLjMpKTtcbiAgICAgICAgY29uc3QgbGlzdCA9IFtcbiAgICAgICAgICAgIHNldGNvbG9yZXhwcl8xLnNldGNvbG9yKGNvbCksXG4gICAgICAgICAgICBtZXJnZXBhc3NfMS5sb29wKFtcbiAgICAgICAgICAgICAgICBibHVyZXhwcl8xLmdhdXNzKHZlY2V4cHJzXzEudmVjMihob3Jpem9udGFsLCAwKSwgdGFwcyksXG4gICAgICAgICAgICAgICAgYmx1cmV4cHJfMS5nYXVzcyh2ZWNleHByc18xLnZlYzIoMCwgdmVydGljYWwpLCB0YXBzKSxcbiAgICAgICAgICAgICAgICBicmlnaHRuZXNzZXhwcl8xLmJyaWdodG5lc3MoMC4xKSxcbiAgICAgICAgICAgICAgICBjb250cmFzdGV4cHJfMS5jb250cmFzdChib29zdCksXG4gICAgICAgICAgICBdLCByZXBzKSxcbiAgICAgICAgICAgIHNldGNvbG9yZXhwcl8xLnNldGNvbG9yKG9wZXhwcl8xLm9wKGZyYWdjb2xvcmV4cHJfMS5mY29sb3IoKSwgXCIrXCIsIHNjZW5lc2FtcGxlZXhwcl8xLmlucHV0KCkpKSxcbiAgICAgICAgXTtcbiAgICAgICAgc3VwZXIobGlzdCwgeyBudW06IDEgfSk7XG4gICAgICAgIHRoaXMudGhyZXNob2xkID0gdGhyZXNob2xkO1xuICAgICAgICB0aGlzLmhvcml6b250YWwgPSBob3Jpem9udGFsO1xuICAgICAgICB0aGlzLnZlcnRpY2FsID0gdmVydGljYWw7XG4gICAgICAgIHRoaXMuYm9vc3QgPSBib29zdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogc2V0IHRoZSBob3Jpem9udGFsIHN0cmV0Y2ggb2YgdGhlIGJsdXIgZWZmZWN0IChubyBncmVhdGVyIHRoYW4gMSBmb3IgYmVzdFxuICAgICAqIGVmZmVjdClcbiAgICAgKi9cbiAgICBzZXRIb3Jpem9udGFsKG51bSkge1xuICAgICAgICBpZiAoISh0aGlzLmhvcml6b250YWwgaW5zdGFuY2VvZiBleHByXzEuQmFzaWNGbG9hdCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJob3Jpem9udGFsIGV4cHJlc3Npb24gbm90IGJhc2ljIGZsb2F0XCIpO1xuICAgICAgICB0aGlzLmhvcml6b250YWwuc2V0VmFsKG51bSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHNldCB0aGUgdmVydGljYWwgc3RyZXRjaCBvZiB0aGUgYmx1ciBlZmZlY3QgKG5vIGdyZWF0ZXIgdGhhbiAxIGZvciBiZXN0XG4gICAgICogZWZmZWN0KVxuICAgICAqL1xuICAgIHNldFZlcnRpY2FsKG51bSkge1xuICAgICAgICBpZiAoISh0aGlzLnZlcnRpY2FsIGluc3RhbmNlb2YgZXhwcl8xLkJhc2ljRmxvYXQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidmVydGljYWwgZXhwcmVzc2lvbiBub3QgYmFzaWMgZmxvYXRcIik7XG4gICAgICAgIHRoaXMudmVydGljYWwuc2V0VmFsKG51bSk7XG4gICAgfVxuICAgIC8qKiBzZXQgdGhlIHRyZXNob2xkICovXG4gICAgc2V0VGhyZXNob2xkKG51bSkge1xuICAgICAgICBpZiAoISh0aGlzLnRocmVzaG9sZCBpbnN0YW5jZW9mIGV4cHJfMS5CYXNpY0Zsb2F0KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRocmVzaG9sZCBleHByZXNzaW9uIG5vdCBiYXNpYyBmbG9hdFwiKTtcbiAgICAgICAgdGhpcy50aHJlc2hvbGQuc2V0VmFsKG51bSk7XG4gICAgfVxuICAgIC8qKiBzZXQgdGhlIGNvbnRyYXN0IGJvb3N0ICovXG4gICAgc2V0Qm9vc3QobnVtKSB7XG4gICAgICAgIGlmICghKHRoaXMuYm9vc3QgaW5zdGFuY2VvZiBleHByXzEuQmFzaWNGbG9hdCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJib29zdCBleHByZXNzaW9uIG5vdCBiYXNpYyBmbG9hdFwiKTtcbiAgICAgICAgdGhpcy5ib29zdC5zZXRWYWwobnVtKTtcbiAgICB9XG59XG5leHBvcnRzLkJsb29tTG9vcCA9IEJsb29tTG9vcDtcbi8qKlxuICogY3JlYXRlcyBhIGJsb29tIGxvb3BcbiAqIEBwYXJhbSB0aHJlc2hvbGQgdmFsdWVzIGJlbG93IHRoaXMgYnJpZ2h0bmVzcyBkb24ndCBnZXQgYmx1cnJlZCAoMC40IGlzXG4gKiBhYm91dCByZWFzb25hYmxlLCB3aGljaCBpcyBhbHNvIHRoZSBkZWZhdWx0KVxuICogQHBhcmFtIGhvcml6b250YWwgaG93IG11Y2ggdG8gYmx1ciB2ZXJ0aWNhbGx5IChkZWZhdWx0cyB0byAxIHBpeGVsKVxuICogQHBhcmFtIHZlcnRpY2FsIGhvdyBtdWNoIHRvIGJsdXIgaG9yaXpvbnRhbGx5IChkZWZhdWx0cyB0byAxIHBpeGVsKVxuICogQHBhcmFtIHRhcHMgaG93IG1hbnkgdGFwcyBmb3IgdGhlIGJsdXIgKGRlZmF1bHRzIHRvIDkpXG4gKiBAcGFyYW0gcmVwcyBob3cgbWFueSB0aW1lcyB0byBsb29wIHRoZSBibHVyIChkZWZhdWx0cyB0byAzKVxuICovXG5mdW5jdGlvbiBibG9vbSh0aHJlc2hvbGQsIGhvcml6b250YWwsIHZlcnRpY2FsLCBib29zdCwgdGFwcywgcmVwcykge1xuICAgIHJldHVybiBuZXcgQmxvb21Mb29wKGV4cHJfMS5uMmUodGhyZXNob2xkKSwgZXhwcl8xLm4yZShob3Jpem9udGFsKSwgZXhwcl8xLm4yZSh2ZXJ0aWNhbCksIGV4cHJfMS5uMmUoYm9vc3QpLCB0YXBzLCByZXBzKTtcbn1cbmV4cG9ydHMuYmxvb20gPSBibG9vbTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ibHVyMmQgPSBleHBvcnRzLkJsdXIyZExvb3AgPSB2b2lkIDA7XG5jb25zdCBtZXJnZXBhc3NfMSA9IHJlcXVpcmUoXCIuLi9tZXJnZXBhc3NcIik7XG5jb25zdCBibHVyZXhwcl8xID0gcmVxdWlyZShcIi4vYmx1cmV4cHJcIik7XG5jb25zdCBleHByXzEgPSByZXF1aXJlKFwiLi9leHByXCIpO1xuY29uc3QgdmVjZXhwcnNfMSA9IHJlcXVpcmUoXCIuL3ZlY2V4cHJzXCIpO1xuLyoqIDJEIGJsdXIgbG9vcCAqL1xuY2xhc3MgQmx1cjJkTG9vcCBleHRlbmRzIG1lcmdlcGFzc18xLkVmZmVjdExvb3Age1xuICAgIGNvbnN0cnVjdG9yKGhvcml6b250YWwgPSBleHByXzEuZmxvYXQoZXhwcl8xLm11dCgxKSksIHZlcnRpY2FsID0gZXhwcl8xLmZsb2F0KGV4cHJfMS5tdXQoMSkpLCByZXBzID0gMiwgdGFwcywgc2FtcGxlck51bSkge1xuICAgICAgICBjb25zdCBzaWRlID0gYmx1cmV4cHJfMS5nYXVzcyh2ZWNleHByc18xLnZlYzIoaG9yaXpvbnRhbCwgMCksIHRhcHMsIHNhbXBsZXJOdW0pO1xuICAgICAgICBjb25zdCB1cCA9IGJsdXJleHByXzEuZ2F1c3ModmVjZXhwcnNfMS52ZWMyKDAsIHZlcnRpY2FsKSwgdGFwcywgc2FtcGxlck51bSk7XG4gICAgICAgIHN1cGVyKFtzaWRlLCB1cF0sIHsgbnVtOiByZXBzIH0pO1xuICAgICAgICB0aGlzLmhvcml6b250YWwgPSBob3Jpem9udGFsO1xuICAgICAgICB0aGlzLnZlcnRpY2FsID0gdmVydGljYWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHNldCB0aGUgaG9yaXpvbnRhbCBzdHJldGNoIG9mIHRoZSBibHVyIGVmZmVjdCAobm8gZ3JlYXRlciB0aGFuIDEgZm9yIGJlc3RcbiAgICAgKiBlZmZlY3QpXG4gICAgICovXG4gICAgc2V0SG9yaXpvbnRhbChudW0pIHtcbiAgICAgICAgaWYgKCEodGhpcy5ob3Jpem9udGFsIGluc3RhbmNlb2YgZXhwcl8xLkJhc2ljRmxvYXQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaG9yaXpvbnRhbCBleHByZXNzaW9uIG5vdCBiYXNpYyBmbG9hdFwiKTtcbiAgICAgICAgdGhpcy5ob3Jpem9udGFsLnNldFZhbChudW0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBzZXQgdGhlIHZlcnRpY2FsIHN0cmV0Y2ggb2YgdGhlIGJsdXIgZWZmZWN0IChubyBncmVhdGVyIHRoYW4gMSBmb3IgYmVzdFxuICAgICAqIGVmZmVjdClcbiAgICAgKi9cbiAgICBzZXRWZXJ0aWNhbChudW0pIHtcbiAgICAgICAgaWYgKCEodGhpcy52ZXJ0aWNhbCBpbnN0YW5jZW9mIGV4cHJfMS5CYXNpY0Zsb2F0KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInZlcnRpY2FsIGV4cHJlc3Npb24gbm90IGJhc2ljIGZsb2F0XCIpO1xuICAgICAgICB0aGlzLnZlcnRpY2FsLnNldFZhbChudW0pO1xuICAgIH1cbn1cbmV4cG9ydHMuQmx1cjJkTG9vcCA9IEJsdXIyZExvb3A7XG4vKipcbiAqIGNyZWF0ZXMgYSBsb29wIHRoYXQgcnVucyBhIGhvcml6b250YWwsIHRoZW4gdmVydGljYWwgZ2F1c3NpYW4gYmx1ciAoYW55dGhpbmdcbiAqIG1vcmUgdGhhbiAxIHBpeGVsIGluIHRoZSBob3Jpem9udGFsIG9yIHZlcnRpY2FsIGRpcmVjdGlvbiB3aWxsIGNyZWF0ZSBhXG4gKiBnaG9zdGluZyBlZmZlY3QsIHdoaWNoIGlzIHVzdWFsbHkgbm90IGRlc2lyYWJsZSlcbiAqIEBwYXJhbSBob3Jpem9udGFsRXhwciBmbG9hdCBmb3IgdGhlIGhvcml6b250YWwgYmx1ciAoMSBwaXhlbCBkZWZhdWx0KVxuICogQHBhcmFtIHZlcnRpY2FsRXhwciBmbG9hdCBmb3IgdGhlIHZlcnRpY2FsIGJsdXIgKDEgcGl4ZWwgZGVmYXVsdClcbiAqIEBwYXJhbSByZXBzIGhvdyBtYW55IHBhc3NlcyAoZGVmYXVsdHMgdG8gMilcbiAqIEBwYXJhbSB0YXBzIGhvdyBtYW55IHRhcHMgKGRlZmF1bHRzIHRvIDUpXG4gKiBAcGFyYW0gc2FtcGxlck51bSBjaGFuZ2UgaWYgeW91IHdhbnQgdG8gc2FtcGxlIGZyb20gYSBkaWZmZXJlbnQgY2hhbm5lbCBhbmRcbiAqIHRoZSBvdXRlciBsb29wIGhhcyBhIGRpZmZlcmVudCB0YXJnZXRcbiAqL1xuZnVuY3Rpb24gYmx1cjJkKGhvcml6b250YWxFeHByLCB2ZXJ0aWNhbEV4cHIsIHJlcHMsIHRhcHMsIHNhbXBsZXJOdW0pIHtcbiAgICByZXR1cm4gbmV3IEJsdXIyZExvb3AoZXhwcl8xLm4yZShob3Jpem9udGFsRXhwciksIGV4cHJfMS5uMmUodmVydGljYWxFeHByKSwgcmVwcywgdGFwcywgc2FtcGxlck51bSk7XG59XG5leHBvcnRzLmJsdXIyZCA9IGJsdXIyZDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nYXVzcyA9IGV4cG9ydHMuQmx1ckV4cHIgPSB2b2lkIDA7XG5jb25zdCBnbHNsZnVuY3Rpb25zXzEgPSByZXF1aXJlKFwiLi4vZ2xzbGZ1bmN0aW9uc1wiKTtcbmNvbnN0IGV4cHJfMSA9IHJlcXVpcmUoXCIuL2V4cHJcIik7XG4vKiogQGlnbm9yZSAqL1xuZnVuY3Rpb24gZ2VuQmx1clNvdXJjZShkaXJlY3Rpb24sIHRhcHMsIGJ1ZmZlcikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHNlY3Rpb25zOiBbYGdhdXNzJHt0YXBzfSR7YnVmZmVyID09PSB1bmRlZmluZWQgPyBcIlwiIDogXCJfXCIgKyBidWZmZXJ9KGAsIFwiKVwiXSxcbiAgICAgICAgdmFsdWVzOiBbZGlyZWN0aW9uXSxcbiAgICB9O1xufVxuLyoqIEBpZ25vcmUgKi9cbmZ1bmN0aW9uIHRhcHNUb0Z1bmNTb3VyY2UodGFwcykge1xuICAgIHN3aXRjaCAodGFwcykge1xuICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICByZXR1cm4gZ2xzbGZ1bmN0aW9uc18xLmdsc2xGdW5jcy5nYXVzczU7XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIHJldHVybiBnbHNsZnVuY3Rpb25zXzEuZ2xzbEZ1bmNzLmdhdXNzOTtcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIHJldHVybiBnbHNsZnVuY3Rpb25zXzEuZ2xzbEZ1bmNzLmdhdXNzMTM7XG4gICAgfVxufVxuLyoqIGdhdXNzaWFuIGJsdXIgZXhwcmVzc2lvbiAqL1xuY2xhc3MgQmx1ckV4cHIgZXh0ZW5kcyBleHByXzEuRXhwclZlYzQge1xuICAgIGNvbnN0cnVjdG9yKGRpcmVjdGlvbiwgdGFwcyA9IDUsIHNhbXBsZXJOdW0pIHtcbiAgICAgICAgLy8gdGhpcyBpcyBhbHJlYWR5IGd1YXJhbnRlZWQgYnkgdHlwZXNjcmlwdCwgYnV0IGNyZWF0ZXMgaGVscGZ1bCBlcnJvciBmb3JcbiAgICAgICAgLy8gdXNlIGluIGdpYmJlciBvciBhbnlvbmUganVzdCB1c2luZyBqYXZhc2NyaXB0XG4gICAgICAgIGlmICghWzUsIDksIDEzXS5pbmNsdWRlcyh0YXBzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidGFwcyBmb3IgZ2F1c3MgYmx1ciBjYW4gb25seSBiZSA1LCA5IG9yIDEzXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8gbWFrZSB0aGlzIG1vcmUgZ2VuZXJpY1xuICAgICAgICBzdXBlcihnZW5CbHVyU291cmNlKGRpcmVjdGlvbiwgdGFwcywgc2FtcGxlck51bSksIFtcInVEaXJlY3Rpb25cIl0pO1xuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICAgICAgaWYgKHNhbXBsZXJOdW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5uZWVkcy5uZWlnaGJvclNhbXBsZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmV4dGVybmFsRnVuY3MgPSBbdGFwc1RvRnVuY1NvdXJjZSh0YXBzKV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm5lZWRzLmV4dHJhQnVmZmVycyA9IG5ldyBTZXQoW3NhbXBsZXJOdW1dKTtcbiAgICAgICAgICAgIHRoaXMuZXh0ZXJuYWxGdW5jcyA9IFtcbiAgICAgICAgICAgICAgICBnbHNsZnVuY3Rpb25zXzEucmVwbGFjZVNhbXBsZXIodGFwc1RvRnVuY1NvdXJjZSh0YXBzKSwgL3ZlYzRcXHNnYXVzc1swLTldKy9nLCBzYW1wbGVyTnVtKSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIHNldCB0aGUgYmx1ciBkaXJlY3Rpb24gKGtlZXAgbWFnbml0dWRlIG5vIGdyZWF0ZXIgdGhhbiAxIGZvciBiZXN0IGVmZmVjdCkgKi9cbiAgICBzZXREaXJlY3Rpb24oZGlyZWN0aW9uKSB7XG4gICAgICAgIHRoaXMuc2V0VW5pZm9ybShcInVEaXJlY3Rpb25cIiArIHRoaXMuaWQsIGRpcmVjdGlvbik7XG4gICAgICAgIHRoaXMuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgIH1cbn1cbmV4cG9ydHMuQmx1ckV4cHIgPSBCbHVyRXhwcjtcbi8qKlxuICogY3JlYXRlcyBleHByZXNzaW9uIHRoYXQgcGVyZm9ybXMgb25lIHBhc3Mgb2YgYSBnYXVzc2lhbiBibHVyXG4gKiBAcGFyYW0gZGlyZWN0aW9uIGRpcmVjdGlvbiB0byBibHVyIChrZWVwIG1hZ25pdHVkZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gMVxuICogZm9yIGJlc3QgZWZmZWN0KVxuICogQHBhcmFtIHRhcHMgbnVtYmVyIG9mIHRhcHMgKGRlZmF1bHRzIHRvIDUpXG4gKiBAcGFyYW0gc2FtcGxlck51bSB3aGljaCBjaGFubmVsIHRvIHNhbXBsZSBmcm9tIChkZWZhdWx0IDApXG4gKi9cbmZ1bmN0aW9uIGdhdXNzKGRpcmVjdGlvbiwgdGFwcyA9IDUsIHNhbXBsZXJOdW0pIHtcbiAgICByZXR1cm4gbmV3IEJsdXJFeHByKGRpcmVjdGlvbiwgdGFwcywgc2FtcGxlck51bSk7XG59XG5leHBvcnRzLmdhdXNzID0gZ2F1c3M7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYnJpZ2h0bmVzcyA9IGV4cG9ydHMuQnJpZ2h0bmVzcyA9IHZvaWQgMDtcbmNvbnN0IGdsc2xmdW5jdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi9nbHNsZnVuY3Rpb25zXCIpO1xuY29uc3QgZXhwcl8xID0gcmVxdWlyZShcIi4vZXhwclwiKTtcbmNvbnN0IGZyYWdjb2xvcmV4cHJfMSA9IHJlcXVpcmUoXCIuL2ZyYWdjb2xvcmV4cHJcIik7XG4vKiogYnJpZ2h0bmVzcyBleHByZXNzaW9uICovXG5jbGFzcyBCcmlnaHRuZXNzIGV4dGVuZHMgZXhwcl8xLkV4cHJWZWM0IHtcbiAgICBjb25zdHJ1Y3RvcihicmlnaHRuZXNzLCBjb2wgPSBmcmFnY29sb3JleHByXzEuZmNvbG9yKCkpIHtcbiAgICAgICAgc3VwZXIoZXhwcl8xLnRhZyBgYnJpZ2h0bmVzcygke2JyaWdodG5lc3N9LCAke2NvbH0pYCwgW1widUJyaWdodG5lc3NcIiwgXCJ1Q29sb3JcIl0pO1xuICAgICAgICB0aGlzLmJyaWdodG5lc3MgPSBicmlnaHRuZXNzO1xuICAgICAgICB0aGlzLmV4dGVybmFsRnVuY3MgPSBbZ2xzbGZ1bmN0aW9uc18xLmdsc2xGdW5jcy5icmlnaHRuZXNzXTtcbiAgICB9XG4gICAgLyoqIHNldCB0aGUgYnJpZ2h0bmVzcyAoc2hvdWxkIHByb2JhYmx5IGJlIGJldHdlZW4gLTEgYW5kIDEpICovXG4gICAgc2V0QnJpZ2h0bmVzcyhicmlnaHRuZXNzKSB7XG4gICAgICAgIHRoaXMuc2V0VW5pZm9ybShcInVCcmlnaHRuZXNzXCIgKyB0aGlzLmlkLCBicmlnaHRuZXNzKTtcbiAgICAgICAgdGhpcy5icmlnaHRuZXNzID0gZXhwcl8xLm4yZShicmlnaHRuZXNzKTtcbiAgICB9XG59XG5leHBvcnRzLkJyaWdodG5lc3MgPSBCcmlnaHRuZXNzO1xuLyoqXG4gKiBjaGFuZ2VzIHRoZSBicmlnaHRuZXNzIG9mIGEgY29sb3JcbiAqIEBwYXJhbSB2YWwgZmxvYXQgZm9yIGhvdyBtdWNoIHRvIGNoYW5nZSB0aGUgYnJpZ2h0bmVzcyBieSAoc2hvdWxkIHByb2JhYmx5IGJlXG4gKiBiZXR3ZWVuIC0xIGFuZCAxKVxuICogQHBhcmFtIGNvbCB0aGUgY29sb3IgdG8gaW5jcmVhc2UgdGhlIGJyaWdodG5lc3Mgb2YgKGRlZmF1bHRzIHRvIGN1cnJlbnRcbiAqIGZyYWdtZW50IGNvbG9yKVxuICovXG5mdW5jdGlvbiBicmlnaHRuZXNzKHZhbCwgY29sKSB7XG4gICAgcmV0dXJuIG5ldyBCcmlnaHRuZXNzKGV4cHJfMS5uMmUodmFsKSwgY29sKTtcbn1cbmV4cG9ydHMuYnJpZ2h0bmVzcyA9IGJyaWdodG5lc3M7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY2hhbmdlY29tcCA9IGV4cG9ydHMuQ2hhbmdlQ29tcEV4cHIgPSB2b2lkIDA7XG5jb25zdCBleHByXzEgPSByZXF1aXJlKFwiLi9leHByXCIpO1xuY29uc3QgZ2V0Y29tcGV4cHJfMSA9IHJlcXVpcmUoXCIuL2dldGNvbXBleHByXCIpO1xuLyoqIEBpZ25vcmUgKi9cbmZ1bmN0aW9uIGdldENoYW5nZUZ1bmModHlwLCBpZCwgc2V0dGVyLCBjb21wcywgb3AgPSBcIlwiKSB7XG4gICAgcmV0dXJuIGAke3R5cH0gY2hhbmdlY29tcF8ke2lkfSgke3R5cH0gY29sLCAke3NldHRlci50eXBlU3RyaW5nKCl9IHNldHRlcikge1xuICBjb2wuJHtjb21wc30gJHtvcH09IHNldHRlcjtcbiAgcmV0dXJuIGNvbDtcbn1gO1xufVxuLyoqXG4gKiB0aHJvd3MgYSBydW50aW1lIGVycm9yIGlmIGNvbXBvbmVudCBhY2Nlc3MgaXMgbm90IHZhbGlkLCBhbmQgZGlzYWxsb3dzXG4gKiBkdXBsaWNhdGUgY29tcG9uZW50cyBiZWNhdXNlIGR1cGxpY2F0ZSBjb21wb25lbnRzIGNhbiBub3QgYmUgaW4gYSBsZWZ0XG4gKiBleHByZXNzaW9uLiAoZm9yIGV4YW1wbGUgYHYueHl4ID0gdmVjMygxLiwgMi4sIDMuKWAgaXMgaWxsZWdhbCwgYnV0IGB2MS54eXpcbiAqID0gdjIueHl4YCBpcyBsZWdhbC4pIGFsc28gY2hlY2tzIGZvciB0eXBlIGVycm9ycyBzdWNoIGFzIGB2MS54eSA9IHZlYzMoMS4sXG4gKiAyLiwgMy4pYDsgdGhlIHJpZ2h0IGhhbmQgc2lkZSBjYW4gb25seSBiZSBhIGB2ZWMyYCBpZiBvbmx5IHR3byBjb21wb25lbnRzXG4gKiBhcmUgc3VwcGxpZWRcbiAqIEBwYXJhbSBjb21wcyBjb21wb25lbnQgc3RyaW5nXG4gKiBAcGFyYW0gc2V0dGVyIGhvdyB0aGUgY29tcG9uZW50cyBhcmUgYmVpbmcgY2hhbmdlZFxuICogQHBhcmFtIHZlYyB0aGUgdmVjdG9yIHdoZXJlIGNvbXBvbmVudHMgYXJlIGJlaW5nIGFjY2Vzc2VkXG4gKi9cbmZ1bmN0aW9uIGNoZWNrQ2hhbmdlQ29tcG9uZW50cyhjb21wcywgc2V0dGVyLCB2ZWMpIHtcbiAgICAvLyBzZXR0ZXIgaGFzIGRpZmZlcmVudCBsZW5ndGggdGhhbiBjb21wb25lbnRzXG4gICAgaWYgKGNvbXBzLmxlbmd0aCAhPT0gZ2V0Y29tcGV4cHJfMS50eXBlU3RyaW5nVG9MZW5ndGgoc2V0dGVyLnR5cGVTdHJpbmcoKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY29tcG9uZW50cyBsZW5ndGggbXVzdCBiZSBlcXVhbCB0byB0aGUgdGFyZ2V0IGZsb2F0L3ZlY1wiKTtcbiAgICB9XG4gICAgLy8gZHVwbGljYXRlIGNvbXBvbmVudHNcbiAgICBpZiAoZHVwbGljYXRlQ29tcG9uZW50cyhjb21wcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZHVwbGljYXRlIGNvbXBvbmVudHMgbm90IGFsbG93ZWQgb24gbGVmdCBzaWRlXCIpO1xuICAgIH1cbiAgICAvLyBsZWdhbCBjb21wb25lbnRzXG4gICAgZ2V0Y29tcGV4cHJfMS5jaGVja0xlZ2FsQ29tcG9uZW50cyhjb21wcywgdmVjKTtcbn1cbi8qKiBAaWdub3JlICovXG5mdW5jdGlvbiBkdXBsaWNhdGVDb21wb25lbnRzKGNvbXBzKSB7XG4gICAgcmV0dXJuIG5ldyBTZXQoY29tcHMuc3BsaXQoXCJcIikpLnNpemUgIT09IGNvbXBzLmxlbmd0aDtcbn1cbi8qKiBjaGFuZ2UgY29tcG9uZW50IGV4cHJlc3Npb24gKi9cbmNsYXNzIENoYW5nZUNvbXBFeHByIGV4dGVuZHMgZXhwcl8xLk9wZXJhdG9yIHtcbiAgICBjb25zdHJ1Y3Rvcih2ZWMsIHNldHRlciwgY29tcHMsIG9wKSB7XG4gICAgICAgIGNoZWNrQ2hhbmdlQ29tcG9uZW50cyhjb21wcywgc2V0dGVyLCB2ZWMpO1xuICAgICAgICAvLyBwYXJ0IG9mIG5hbWUgb2YgY3VzdG9tIGZ1bmN0aW9uXG4gICAgICAgIGNvbnN0IHN1ZmZpeCA9IGAke3ZlYy50eXBlU3RyaW5nKCl9XyR7c2V0dGVyLnR5cGVTdHJpbmcoKX1fJHtjb21wc31gO1xuICAgICAgICBzdXBlcih2ZWMsIHsgc2VjdGlvbnM6IFtgY2hhbmdlY29tcF8ke3N1ZmZpeH0oYCwgXCIsIFwiLCBcIilcIl0sIHZhbHVlczogW3ZlYywgc2V0dGVyXSB9LCBbXCJ1T3JpZ2luYWxcIiwgXCJ1TmV3XCJdKTtcbiAgICAgICAgdGhpcy5vcmlnaW5hbFZlYyA9IHZlYztcbiAgICAgICAgdGhpcy5uZXdWYWwgPSBzZXR0ZXI7XG4gICAgICAgIHRoaXMuZXh0ZXJuYWxGdW5jcyA9IFtcbiAgICAgICAgICAgIGdldENoYW5nZUZ1bmModmVjLnR5cGVTdHJpbmcoKSwgc3VmZml4LCBzZXR0ZXIsIGNvbXBzLCBvcCksXG4gICAgICAgIF07XG4gICAgfVxuICAgIC8qKiBzZXQgdGhlIG9yaWdpbmFsIHZlY3RvciAqL1xuICAgIHNldE9yaWdpbmFsKG9yaWdpbmFsVmVjKSB7XG4gICAgICAgIHRoaXMuc2V0VW5pZm9ybShcInVPcmlnaW5hbFwiICsgdGhpcy5pZCwgb3JpZ2luYWxWZWMpO1xuICAgICAgICB0aGlzLm9yaWdpbmFsVmVjID0gb3JpZ2luYWxWZWM7XG4gICAgfVxuICAgIC8qKiBzZXQgdGhlIG5ld3cgdmVjdG9yICovXG4gICAgc2V0TmV3KG5ld1ZhbCkge1xuICAgICAgICB0aGlzLnNldFVuaWZvcm0oXCJ1TmV3XCIgKyB0aGlzLmlkLCBuZXdWYWwpO1xuICAgICAgICB0aGlzLm5ld1ZhbCA9IGV4cHJfMS53cmFwSW5WYWx1ZShuZXdWYWwpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2hhbmdlQ29tcEV4cHIgPSBDaGFuZ2VDb21wRXhwcjtcbi8qKlxuICogY2hhbmdlIHRoZSBjb21wb25lbnRzIG9mIGEgdmVjdG9yXG4gKiBAcGFyYW0gdmVjIHRoZSB2ZWN0b3IgdG8gYXVnbWVudCBjb21wb25lbnRzIG9mXG4gKiBAcGFyYW0gc2V0dGVyIHRoZSB2ZWN0b3IgKG9yIGZsb2F0LCBpZiBvbmx5IG9uZSBjb21wb25lbnQgaXMgY2hhbmdlZCkgZm9yXG4gKiBob3cgdG8gY2hhbmdlIHRoZSBjb21wb25lbnRzXG4gKiBAcGFyYW0gY29tcHMgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY29tcG9uZW50cyB0byBjaGFuZ2UgKGUuZy4gYFwieHlcImAgb3JcbiAqIGBcInJcImAgb3IgYFwic3RwcVwiYC4pXG4gKiBAcGFyYW0gb3Agb3B0aW9uYWxseSBwZXJmb3JtIGFuIG9wZXJhdGlvbiBvbiB0aGUgb3JpZ2luYWwgY29tcG9uZW50XG4gKiAoZGVmYXVsdHMgdG8gbm8gb3BlcmF0aW9uLCBqdXN0IGFzc2lnbmluZyB0aGF0IGNvbXBvbmVudCB0byBhIG5ldyB2YWx1ZSlcbiAqL1xuZnVuY3Rpb24gY2hhbmdlY29tcCh2ZWMsIHNldHRlciwgY29tcHMsIG9wKSB7XG4gICAgcmV0dXJuIG5ldyBDaGFuZ2VDb21wRXhwcih2ZWMsIGV4cHJfMS53cmFwSW5WYWx1ZShzZXR0ZXIpLCBjb21wcywgb3ApO1xufVxuZXhwb3J0cy5jaGFuZ2Vjb21wID0gY2hhbmdlY29tcDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jaGFubmVsID0gZXhwb3J0cy5DaGFubmVsU2FtcGxlRXhwciA9IHZvaWQgMDtcbmNvbnN0IGNvZGVidWlsZGVyXzEgPSByZXF1aXJlKFwiLi4vY29kZWJ1aWxkZXJcIik7XG5jb25zdCBleHByXzEgPSByZXF1aXJlKFwiLi9leHByXCIpO1xuY29uc3Qgbm9ybWZyYWdjb29yZGV4cHJfMSA9IHJlcXVpcmUoXCIuL25vcm1mcmFnY29vcmRleHByXCIpO1xuLyoqIEBpZ25vcmUgKi9cbmZ1bmN0aW9uIGdlbkNoYW5uZWxTYW1wbGVTb3VyY2UoYnVmLCBjb29yZCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHNlY3Rpb25zOiBbYHRleHR1cmUyRCgke2NvZGVidWlsZGVyXzEuY2hhbm5lbFNhbXBsZXJOYW1lKGJ1Zil9LCBgLCBgKWBdLFxuICAgICAgICB2YWx1ZXM6IFtjb29yZF0sXG4gICAgfTtcbn1cbi8qKiBjaGFubmVsIHNhbXBsZSBleHByZXNzaW9uICovXG5jbGFzcyBDaGFubmVsU2FtcGxlRXhwciBleHRlbmRzIGV4cHJfMS5FeHByVmVjNCB7XG4gICAgY29uc3RydWN0b3IoYnVmLCBjb29yZCA9IG5vcm1mcmFnY29vcmRleHByXzEucG9zKCkpIHtcbiAgICAgICAgc3VwZXIoZ2VuQ2hhbm5lbFNhbXBsZVNvdXJjZShidWYsIGNvb3JkKSwgW1widVZlY1wiXSk7XG4gICAgICAgIHRoaXMuY29vcmQgPSBjb29yZDtcbiAgICAgICAgdGhpcy5uZWVkcy5leHRyYUJ1ZmZlcnMgPSBuZXcgU2V0KFtidWZdKTtcbiAgICB9XG4gICAgc2V0Q29vcmQoY29vcmQpIHtcbiAgICAgICAgdGhpcy5zZXRVbmlmb3JtKFwidVZlY1wiLCBjb29yZCk7XG4gICAgICAgIHRoaXMuY29vcmQgPSBjb29yZDtcbiAgICB9XG59XG5leHBvcnRzLkNoYW5uZWxTYW1wbGVFeHByID0gQ2hhbm5lbFNhbXBsZUV4cHI7XG4vKipcbiAqIGNyZWF0ZXMgYW4gZXhwcmVzc2lvbiB0aGF0IHNhbXBsZXMgZnJvbSBvbmUgb2YgdGhlIHVzZXItZGVmaW5lZCBjaGFubmVscy5cbiAqIGRvbid0IHNhbXBsZSBmcm9tIHRoZSBzYW1lIGNoYW5uZWwgdGhhdCB5b3UgYXJlIHVzaW5nIFtbdGFyZ2V0XV0gb24gaW4gYVxuICogbG9vcCwganVzdCB1c2UgW1tmY29sb3JdXVxuICogQHBhcmFtIGNoYW5uZWwgd2hpY2ggY2hhbm5lbCB0byBzYW1wbGUgZnJvbVxuICogQHBhcmFtIHZlYyB3aGVyZSB0byBzYW1wbGUgdGhlIGNoYW5uZWwgdGV4dHVyZSAoZGVmYXVsdHMgdG8gdGhlIG5vcm1hbGl6ZWRcbiAqIGZyYWcgY29vcmQpXG4gKi9cbmZ1bmN0aW9uIGNoYW5uZWwoY2hhbm5lbCwgdmVjKSB7XG4gICAgcmV0dXJuIG5ldyBDaGFubmVsU2FtcGxlRXhwcihjaGFubmVsLCB2ZWMpO1xufVxuZXhwb3J0cy5jaGFubmVsID0gY2hhbm5lbDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jb250cmFzdCA9IGV4cG9ydHMuQ29udHJhc3RFeHByID0gdm9pZCAwO1xuY29uc3QgZ2xzbGZ1bmN0aW9uc18xID0gcmVxdWlyZShcIi4uL2dsc2xmdW5jdGlvbnNcIik7XG5jb25zdCBleHByXzEgPSByZXF1aXJlKFwiLi9leHByXCIpO1xuY29uc3QgZnJhZ2NvbG9yZXhwcl8xID0gcmVxdWlyZShcIi4vZnJhZ2NvbG9yZXhwclwiKTtcbmNsYXNzIENvbnRyYXN0RXhwciBleHRlbmRzIGV4cHJfMS5FeHByVmVjNCB7XG4gICAgY29uc3RydWN0b3IoY29udHJhc3QsIGNvbCA9IGZyYWdjb2xvcmV4cHJfMS5mY29sb3IoKSkge1xuICAgICAgICBzdXBlcihleHByXzEudGFnIGBjb250cmFzdCgke2NvbnRyYXN0fSwgJHtjb2x9KWAsIFtcInVWYWxcIiwgXCJ1Q29sXCJdKTtcbiAgICAgICAgdGhpcy5jb250cmFzdCA9IGNvbnRyYXN0O1xuICAgICAgICB0aGlzLmV4dGVybmFsRnVuY3MgPSBbZ2xzbGZ1bmN0aW9uc18xLmdsc2xGdW5jcy5jb250cmFzdF07XG4gICAgfVxuICAgIC8qKiBzZXRzIHRoZSBjb250cmFzdCAqL1xuICAgIHNldENvbnRyYXN0KGNvbnRyYXN0KSB7XG4gICAgICAgIHRoaXMuc2V0VW5pZm9ybShcInVDb250cmFzdFwiICsgdGhpcy5pZCwgY29udHJhc3QpO1xuICAgICAgICB0aGlzLmNvbnRyYXN0ID0gZXhwcl8xLm4ycChjb250cmFzdCk7XG4gICAgfVxufVxuZXhwb3J0cy5Db250cmFzdEV4cHIgPSBDb250cmFzdEV4cHI7XG4vKipcbiAqIGNoYW5nZXMgdGhlIGNvbnRyYXN0IG9mIGEgY29sb3JcbiAqIEBwYXJhbSB2YWwgZmxvYXQgZm9yIGhvdyBtdWNoIHRvIGNoYW5nZSB0aGUgY29udHJhc3QgYnkgKHNob3VsZCBwcm9iYWJseSBiZVxuICogYmV0d2VlbiAtMSBhbmQgMSlcbiAqIEBwYXJhbSBjb2wgdGhlIGNvbG9yIHRvIGluY3JlYXNlIHRoZSBjb250cmFzdCBvZiAoZGVmYXVsdHMgdG8gY3VycmVudFxuICogZnJhZ21lbnQgY29sb3IpXG4gKi9cbmZ1bmN0aW9uIGNvbnRyYXN0KHZhbCwgY29sKSB7XG4gICAgcmV0dXJuIG5ldyBDb250cmFzdEV4cHIoZXhwcl8xLm4yZSh2YWwpLCBjb2wpO1xufVxuZXhwb3J0cy5jb250cmFzdCA9IGNvbnRyYXN0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlcHRoMm9jY2x1c2lvbiA9IGV4cG9ydHMuRGVwdGhUb09jY2x1c2lvbkV4cHIgPSB2b2lkIDA7XG5jb25zdCBjaGFubmVsc2FtcGxlZXhwcl8xID0gcmVxdWlyZShcIi4vY2hhbm5lbHNhbXBsZWV4cHJcIik7XG5jb25zdCBleHByXzEgPSByZXF1aXJlKFwiLi9leHByXCIpO1xuY29uc3QgdmVjZXhwcnNfMSA9IHJlcXVpcmUoXCIuL3ZlY2V4cHJzXCIpO1xuLyoqIGRlcHRoIGluZm8gdG8gb2NjbHVzc2lvbiBpbmZvIGV4cHJlc3Npb24gKi9cbmNsYXNzIERlcHRoVG9PY2NsdXNpb25FeHByIGV4dGVuZHMgZXhwcl8xLkV4cHJWZWM0IHtcbiAgICBjb25zdHJ1Y3RvcihkZXB0aENvbCA9IGNoYW5uZWxzYW1wbGVleHByXzEuY2hhbm5lbCgwKSwgbmV3Q29sID0gZXhwcl8xLm11dCh2ZWNleHByc18xLnB2ZWM0KDEsIDEsIDEsIDEpKSwgdGhyZXNob2xkID0gZXhwcl8xLm11dChleHByXzEucGZsb2F0KDAuMDEpKSkge1xuICAgICAgICBzdXBlcihleHByXzEudGFnIGBkZXB0aDJvY2NsdXNpb24oJHtkZXB0aENvbH0sICR7bmV3Q29sfSwgJHt0aHJlc2hvbGR9KWAsIFtcbiAgICAgICAgICAgIFwidURlcHRoXCIsXG4gICAgICAgICAgICBcInVOZXdDb2xcIixcbiAgICAgICAgICAgIFwidVRocmVzaG9sZFwiLFxuICAgICAgICBdKTtcbiAgICAgICAgdGhpcy5kZXB0aENvbCA9IGRlcHRoQ29sO1xuICAgICAgICB0aGlzLm5ld0NvbCA9IG5ld0NvbDtcbiAgICAgICAgdGhpcy50aHJlc2hvbGQgPSB0aHJlc2hvbGQ7XG4gICAgfVxuICAgIHNldERlcHRoQ29sb3IoZGVwdGhDb2wpIHtcbiAgICAgICAgdGhpcy5zZXRVbmlmb3JtKFwidURlcHRoXCIgKyB0aGlzLmlkLCBkZXB0aENvbCk7XG4gICAgICAgIHRoaXMuZGVwdGhDb2wgPSBkZXB0aENvbDtcbiAgICB9XG4gICAgc2V0TmV3Q29sb3IobmV3Q29sKSB7XG4gICAgICAgIHRoaXMuc2V0VW5pZm9ybShcInVOZXdDb2xcIiArIHRoaXMuaWQsIG5ld0NvbCk7XG4gICAgICAgIHRoaXMubmV3Q29sID0gbmV3Q29sO1xuICAgIH1cbiAgICBzZXRUaHJlc2hvbGQodGhyZXNob2xkKSB7XG4gICAgICAgIHRoaXMuc2V0VW5pZm9ybShcInVUaHJlc2hvbGRcIiArIHRoaXMuaWQsIHRocmVzaG9sZCk7XG4gICAgICAgIHRoaXMudGhyZXNob2xkID0gZXhwcl8xLm4ycCh0aHJlc2hvbGQpO1xuICAgIH1cbn1cbmV4cG9ydHMuRGVwdGhUb09jY2x1c2lvbkV4cHIgPSBEZXB0aFRvT2NjbHVzaW9uRXhwcjtcbi8qKlxuICogY29udmVydHMgYSBgMSAvIGRpc3RhbmNlYCBkZXB0aCB0ZXh0dXJlIHRvIGFuIG9jY2x1c2lvbiB0ZXh0dXJlLCB3aXRoIGFsbFxuICogb2NjbHVkZWQgZ2VvbWV0cnkgYmVpbmcgcmVuZGVyZWQgYXMgYmxhY2tcbiAqIEBwYXJhbSBkZXB0aENvbCB0aGUgY29sb3IgcmVwcmVzZW50aW5nIHRoZSBpbnZlcnNlIGRlcHRoIChkZWZhdWx0cyB0b1xuICogc2FtcGxpbmcgZnJvbSBjaGFubmVsIDApXG4gKiBAcGFyYW0gbmV3Q29sIHRoZSBjb2xvciB0byByZXBsYWNlIHVub2NjbHVkZWQgYXJlYXMgYnkgKGRlZmF1bHRzIHRvIHdoaXRlXG4gKiBhbmQgaXMgbXV0YWJsZSBieSBkZWZhdWx0KVxuICogQHBhcmFtIHRocmVzaG9sZCB2YWx1ZXMgYmVsb3cgdGhpcyBhcmUgbm90IG9jY2x1ZGVkIChzZXQgdG8gc29tZXRoaW5nIGxvdyxcbiAqIGxpa2UgMC4xIG9yIGxvd2VyOyBkZWZhdWx0cyB0byAwLjAxIGFuZCBpcyBtdXRhYmxlIGJ5IGRlZmF1bHQpXG4gKi9cbmZ1bmN0aW9uIGRlcHRoMm9jY2x1c2lvbihkZXB0aENvbCwgbmV3Q29sLCB0aHJlc2hvbGQpIHtcbiAgICByZXR1cm4gbmV3IERlcHRoVG9PY2NsdXNpb25FeHByKGRlcHRoQ29sLCBuZXdDb2wsIGV4cHJfMS5uMmUodGhyZXNob2xkKSk7XG59XG5leHBvcnRzLmRlcHRoMm9jY2x1c2lvbiA9IGRlcHRoMm9jY2x1c2lvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kb2YgPSBleHBvcnRzLkRvRkxvb3AgPSB2b2lkIDA7XG5jb25zdCBtZXJnZXBhc3NfMSA9IHJlcXVpcmUoXCIuLi9tZXJnZXBhc3NcIik7XG5jb25zdCBibHVyZXhwcl8xID0gcmVxdWlyZShcIi4vYmx1cmV4cHJcIik7XG5jb25zdCBjaGFubmVsc2FtcGxlZXhwcl8xID0gcmVxdWlyZShcIi4vY2hhbm5lbHNhbXBsZWV4cHJcIik7XG5jb25zdCBleHByXzEgPSByZXF1aXJlKFwiLi9leHByXCIpO1xuY29uc3QgZ2F1c3NpYW5leHByXzEgPSByZXF1aXJlKFwiLi9nYXVzc2lhbmV4cHJcIik7XG5jb25zdCBnZXRjb21wZXhwcl8xID0gcmVxdWlyZShcIi4vZ2V0Y29tcGV4cHJcIik7XG5jb25zdCBvcGV4cHJfMSA9IHJlcXVpcmUoXCIuL29wZXhwclwiKTtcbmNvbnN0IGFyaXR5Ml8xID0gcmVxdWlyZShcIi4vYXJpdHkyXCIpO1xuY29uc3QgdmVjZXhwcnNfMSA9IHJlcXVpcmUoXCIuL3ZlY2V4cHJzXCIpO1xuY2xhc3MgRG9GTG9vcCBleHRlbmRzIG1lcmdlcGFzc18xLkVmZmVjdExvb3Age1xuICAgIGNvbnN0cnVjdG9yKGRlcHRoID0gZXhwcl8xLm11dChleHByXzEucGZsb2F0KDAuMykpLCByYWQgPSBleHByXzEubXV0KGV4cHJfMS5wZmxvYXQoMC4wMSkpLCBkZXB0aEluZm8gPSBnZXRjb21wZXhwcl8xLmdldGNvbXAoY2hhbm5lbHNhbXBsZWV4cHJfMS5jaGFubmVsKDApLCBcInJcIiksIHJlcHMgPSAyLCB0YXBzID0gMTMpIHtcbiAgICAgICAgbGV0IGd1YXNzaWFuRXhwciA9IGdhdXNzaWFuZXhwcl8xLmdhdXNzaWFuKGRlcHRoSW5mbywgZGVwdGgsIHJhZCk7XG4gICAgICAgIGNvbnN0IHNpZGUgPSBibHVyZXhwcl8xLmdhdXNzKHZlY2V4cHJzXzEudmVjMihhcml0eTJfMS5hMihcInBvd1wiLCBvcGV4cHJfMS5vcCgxLCBcIi1cIiwgZ3Vhc3NpYW5FeHByKSwgNCksIDApLCB0YXBzKTtcbiAgICAgICAgY29uc3QgdXAgPSBibHVyZXhwcl8xLmdhdXNzKHZlY2V4cHJzXzEudmVjMigwLCBhcml0eTJfMS5hMihcInBvd1wiLCBvcGV4cHJfMS5vcCgxLCBcIi1cIiwgZ3Vhc3NpYW5FeHByKSwgNCkpLCB0YXBzKTtcbiAgICAgICAgc3VwZXIoW3NpZGUsIHVwXSwgeyBudW06IHJlcHMgfSk7XG4gICAgICAgIHRoaXMuZ2F1c3NpYW4gPSBndWFzc2lhbkV4cHI7XG4gICAgfVxuICAgIHNldERlcHRoKGRlcHRoKSB7XG4gICAgICAgIC8vIHRoaXMgdHJhbnNsYXRlcyB0aGUgZ2F1c3NpYW4gY3VydmUgdG8gdGhlIHNpZGVcbiAgICAgICAgdGhpcy5nYXVzc2lhbi5zZXRBKGRlcHRoKTtcbiAgICB9XG4gICAgc2V0UmFkaXVzKHJhZGl1cykge1xuICAgICAgICAvLyB0aGlzIHNjYWxlcyB0aGUgZ2F1c3NpYW4gY3VydmUgdG8gZm9jdXMgb24gYSBsYXJnZXIgYmFuZCBvZiBkZXB0aFxuICAgICAgICB0aGlzLmdhdXNzaWFuLnNldEIocmFkaXVzKTtcbiAgICB9XG59XG5leHBvcnRzLkRvRkxvb3AgPSBEb0ZMb29wO1xuLyoqXG4gKiBjcmVhdGVzIGRlcHRoIG9mIGZpZWxkIGV4cHJlc3Npb247IGFsbCB2YWx1ZXMgYXJlIG11dGFibGUgYnkgZGVmYXVsdFxuICogQHBhcmFtIGRlcHRoIGZsb2F0IGZvciB3aGF0IGludmVyc2UgZGVwdGggdG8gZm9jdXMgb24gKDEgb24gdG9wIG9mIHRoZVxuICogY2FtZXJhOyAwIGlzIGluZmluaXR5KVxuICogQHBhcmFtIHJhZCBmbG9hdCBmb3IgaG93IGRlZXAgdGhlIGJhbmQgb2YgaW4tZm9jdXMgZ2VvbWV0cnkgaXMgKGEgdmFsdWVcbiAqIGJldHdlZW4gMC4wMSBhbmQgMC4xIGlzIHJlYXNvbmFibGUpXG4gKiBAcGFyYW0gZGVwdGhJbmZvIGZsb2F0IHRoZSBleHByZXNzaW9uIHRoYXQgcmVwcmVzZW50cyB0aGUgaW52ZXJzZSBkZXB0aFxuICogKGRlZmF1bHRzIHRvIHNhbXBsaW5nIHRoZSByZWQgY29tcG9uZW50IGZyb20gY2hhbm5lbCAwKVxuICogQHBhcmFtIHJlcHMgaG93IG1hbnkgdGltZXMgdG8gcmVwZWF0IHRoZSBnYXVzc2lhbiBibHVyXG4gKi9cbmZ1bmN0aW9uIGRvZihkZXB0aCwgcmFkLCBkZXB0aEluZm8sIHJlcHMpIHtcbiAgICByZXR1cm4gbmV3IERvRkxvb3AoZXhwcl8xLm4yZShkZXB0aCksIGV4cHJfMS5uMmUocmFkKSwgZXhwcl8xLm4yZShkZXB0aEluZm8pLCByZXBzKTtcbn1cbmV4cG9ydHMuZG9mID0gZG9mO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRhZyA9IGV4cG9ydHMud3JhcEluVmFsdWUgPSBleHBvcnRzLnBmbG9hdCA9IGV4cG9ydHMubjJwID0gZXhwb3J0cy5uMmUgPSBleHBvcnRzLk9wZXJhdG9yID0gZXhwb3J0cy5FeHByVmVjNCA9IGV4cG9ydHMuRXhwclZlYzMgPSBleHBvcnRzLkV4cHJWZWMyID0gZXhwb3J0cy5mbG9hdCA9IGV4cG9ydHMuRXhwckZsb2F0ID0gZXhwb3J0cy5CYXNpY0Zsb2F0ID0gZXhwb3J0cy5FeHByVmVjID0gZXhwb3J0cy5CYXNpY1ZlYzQgPSBleHBvcnRzLkJhc2ljVmVjMyA9IGV4cG9ydHMuQmFzaWNWZWMyID0gZXhwb3J0cy5CYXNpY1ZlYyA9IGV4cG9ydHMuUHJpbWl0aXZlVmVjNCA9IGV4cG9ydHMuUHJpbWl0aXZlVmVjMyA9IGV4cG9ydHMuUHJpbWl0aXZlVmVjMiA9IGV4cG9ydHMuUHJpbWl0aXZlVmVjID0gZXhwb3J0cy5QcmltaXRpdmVGbG9hdCA9IGV4cG9ydHMuUHJpbWl0aXZlID0gZXhwb3J0cy5tdXQgPSBleHBvcnRzLk11dGFibGUgPSBleHBvcnRzLmN2ZWM0ID0gZXhwb3J0cy5jdmVjMyA9IGV4cG9ydHMuY3ZlYzIgPSBleHBvcnRzLmNmbG9hdCA9IGV4cG9ydHMuRXhwciA9IHZvaWQgMDtcbmNvbnN0IG1lcmdlcGFzc18xID0gcmVxdWlyZShcIi4uL21lcmdlcGFzc1wiKTtcbmNvbnN0IHdlYmdscHJvZ3JhbWxvb3BfMSA9IHJlcXVpcmUoXCIuLi93ZWJnbHByb2dyYW1sb29wXCIpO1xuLyoqXG4gKiBhZGRzIGEgYC5gIGFmdGVyIGEgbnVtYmVyIGlmIG5lZWRlZCAoZS5nIGNvbnZlcnRzIGAxYCB0byBgXCIxLlwiYCBidXQgbGVhdmVzXG4gKiBgMS4yYCBhcyBgXCIxLjJcImApXG4gKiBAcGFyYW0gbnVtIG51bWJlciB0byBjb252ZXJ0XG4gKi9cbmZ1bmN0aW9uIHRvR0xTTEZsb2F0U3RyaW5nKG51bSkge1xuICAgIGxldCBzdHIgPSBcIlwiICsgbnVtO1xuICAgIGlmICghc3RyLmluY2x1ZGVzKFwiLlwiKSlcbiAgICAgICAgc3RyICs9IFwiLlwiO1xuICAgIHJldHVybiBzdHI7XG59XG5jbGFzcyBFeHByIHtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2VMaXN0cywgZGVmYXVsdE5hbWVzKSB7XG4gICAgICAgIHRoaXMubmVlZHMgPSB7XG4gICAgICAgICAgICBuZWlnaGJvclNhbXBsZTogZmFsc2UsXG4gICAgICAgICAgICBjZW50ZXJTYW1wbGU6IGZhbHNlLFxuICAgICAgICAgICAgc2NlbmVCdWZmZXI6IGZhbHNlLFxuICAgICAgICAgICAgdGltZVVuaWZvcm06IGZhbHNlLFxuICAgICAgICAgICAgbW91c2VVbmlmb3JtOiBmYWxzZSxcbiAgICAgICAgICAgIGV4dHJhQnVmZmVyczogbmV3IFNldCgpLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVuaWZvcm1WYWxDaGFuZ2VNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5kZWZhdWx0TmFtZU1hcCA9IHt9O1xuICAgICAgICB0aGlzLmV4dGVybmFsRnVuY3MgPSBbXTtcbiAgICAgICAgdGhpcy5zb3VyY2VDb2RlID0gXCJcIjtcbiAgICAgICAgdGhpcy5pZCA9IFwiX2lkX1wiICsgRXhwci5jb3VudDtcbiAgICAgICAgRXhwci5jb3VudCsrO1xuICAgICAgICBpZiAoc291cmNlTGlzdHMuc2VjdGlvbnMubGVuZ3RoIC0gc291cmNlTGlzdHMudmFsdWVzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICAgICAgLy8gdGhpcyBjYW5ub3QgaGFwcGVuIGlmIHlvdSB1c2UgYHRhZ2AgdG8gZGVzdHJ1Y3R1cmUgYSB0ZW1wbGF0ZSBzdHJpbmdcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIndyb25nIGxlbmd0aHMgZm9yIHNvdXJjZSBhbmQgdmFsdWVzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3VyY2VMaXN0cy52YWx1ZXMubGVuZ3RoICE9PSBkZWZhdWx0TmFtZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkZWZhdWx0IG5hbWVzIGxpc3QgbGVuZ3RoIGRvZXNuJ3QgbWF0Y2ggdmFsdWVzIGxpc3QgbGVuZ3RoXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc291cmNlTGlzdHMgPSBzb3VyY2VMaXN0cztcbiAgICAgICAgdGhpcy5kZWZhdWx0TmFtZXMgPSBkZWZhdWx0TmFtZXM7XG4gICAgfVxuICAgIGFwcGx5VW5pZm9ybXMoZ2wsIHVuaWZvcm1Mb2NzKSB7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiB0aGlzLnVuaWZvcm1WYWxDaGFuZ2VNYXApIHtcbiAgICAgICAgICAgIGNvbnN0IGxvYyA9IHVuaWZvcm1Mb2NzW25hbWVdO1xuICAgICAgICAgICAgaWYgKHRoaXMudW5pZm9ybVZhbENoYW5nZU1hcFtuYW1lXS5jaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgLy90aGlzLnVuaWZvcm1WYWxDaGFuZ2VNYXBbbmFtZV0uY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMudW5pZm9ybVZhbENoYW5nZU1hcFtuYW1lXS52YWwuYXBwbHlVbmlmb3JtKGdsLCBsb2MubG9jc1tsb2MuY291bnRlcl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaW5jcmVtZW50IGFuZCByZXNldCB0aGUgY291bnRlciB0byB3cmFwIGJhY2sgYXJvdW5kIHRvIGZpcnN0IGxvY2F0aW9uXG4gICAgICAgICAgICBsb2MuY291bnRlcisrO1xuICAgICAgICAgICAgbG9jLmNvdW50ZXIgJT0gbG9jLmxvY3MubGVuZ3RoO1xuICAgICAgICAgICAgLy8gb25jZSB3ZSBoYXZlIHdyYXBwZWQgdGhlbiB3ZSBrbm93IGFsbCB1bmlmb3JtcyBoYXZlIGJlZW4gY2hhbmdlZFxuICAgICAgICAgICAgaWYgKGxvYy5jb3VudGVyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bmlmb3JtVmFsQ2hhbmdlTWFwW25hbWVdLmNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRTYW1wbGVOdW0obXVsdCA9IDEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmVlZHMubmVpZ2hib3JTYW1wbGUgPyBtdWx0IDogMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogc2V0IGEgdW5pZm9ybSBieSBuYW1lIGRpcmVjdGx5XG4gICAgICogQHBhcmFtIG5hbWUgdW5pZm9ybSBuYW1lIGluIHRoZSBzb3VyY2UgY29kZVxuICAgICAqIEBwYXJhbSBuZXdWYWwgdmFsdWUgdG8gc2V0IHRoZSB1bmlmb3JtIHRvXG4gICAgICovXG4gICAgc2V0VW5pZm9ybShuYW1lLCBuZXdWYWwpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgbmV3VmFsID0gd3JhcEluVmFsdWUobmV3VmFsKTtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxOYW1lID0gbmFtZTtcbiAgICAgICAgaWYgKHR5cGVvZiBuZXdWYWwgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIG5ld1ZhbCA9IG4ycChuZXdWYWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKG5ld1ZhbCBpbnN0YW5jZW9mIFByaW1pdGl2ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBzZXQgYSBub24tcHJpbWl0aXZlXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIG5hbWUgZG9lcyBub3QgZXhpc3QsIHRyeSBtYXBwaW5nIGRlZmF1bHQgbmFtZSB0byBuZXcgbmFtZVxuICAgICAgICBpZiAoKChfYSA9IHRoaXMudW5pZm9ybVZhbENoYW5nZU1hcFtuYW1lXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnZhbCkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbmFtZSA9IHRoaXMuZGVmYXVsdE5hbWVNYXBbbmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2xkVmFsID0gKF9iID0gdGhpcy51bmlmb3JtVmFsQ2hhbmdlTWFwW25hbWVdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudmFsO1xuICAgICAgICBpZiAob2xkVmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gZ2V0IHJpZCBvZiB0aGlzXG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmRlZmF1bHROYW1lTWFwKTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyaWVkIHRvIHNldCB1bmlmb3JtIFwiICtcbiAgICAgICAgICAgICAgICBuYW1lICtcbiAgICAgICAgICAgICAgICBcIiB3aGljaCBkb2Vzbid0IGV4aXN0LiBvcmlnaW5hbCBuYW1lOiBcIiArXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2xkVmFsLnR5cGVTdHJpbmcoKSAhPT0gbmV3VmFsLnR5cGVTdHJpbmcoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJpZWQgdG8gc2V0IHVuaWZvcm0gXCIgKyBuYW1lICsgXCIgdG8gYSBuZXcgdHlwZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVuaWZvcm1WYWxDaGFuZ2VNYXBbbmFtZV0udmFsID0gbmV3VmFsO1xuICAgICAgICB0aGlzLnVuaWZvcm1WYWxDaGFuZ2VNYXBbbmFtZV0uY2hhbmdlZCA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHBhcnNlcyB0aGlzIGV4cHJlc3Npb24gaW50byBhIHN0cmluZywgYWRkaW5nIGluZm8gYXMgaXQgcmVjdXJzZXMgaW50b1xuICAgICAqIG5lc3RlZCBleHByZXNzaW9uc1xuICAgICAqL1xuICAgIHBhcnNlKGJ1aWxkSW5mbykge1xuICAgICAgICB0aGlzLnNvdXJjZUNvZGUgPSBcIlwiO1xuICAgICAgICBidWlsZEluZm8uZXhwcnMucHVzaCh0aGlzKTtcbiAgICAgICAgYnVpbGRJbmZvLm5lZWRzID0gd2ViZ2xwcm9ncmFtbG9vcF8xLnVwZGF0ZU5lZWRzKGJ1aWxkSW5mby5uZWVkcywgdGhpcy5uZWVkcyk7XG4gICAgICAgIC8vIGFkZCBlYWNoIG9mIHRoZSBleHRlcm5hbCBmdW5jcyB0byB0aGUgYnVpbGRlclxuICAgICAgICB0aGlzLmV4dGVybmFsRnVuY3MuZm9yRWFjaCgoZnVuYykgPT4gYnVpbGRJbmZvLmV4dGVybmFsRnVuY3MuYWRkKGZ1bmMpKTtcbiAgICAgICAgLy8gcHV0IGFsbCBvZiB0aGUgdmFsdWVzIGJldHdlZW4gYWxsIG9mIHRoZSBzb3VyY2Ugc2VjdGlvbnNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNvdXJjZUxpc3RzLnZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5zb3VyY2VDb2RlICs9XG4gICAgICAgICAgICAgICAgdGhpcy5zb3VyY2VMaXN0cy5zZWN0aW9uc1tpXSArXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc291cmNlTGlzdHMudmFsdWVzW2ldLnBhcnNlKGJ1aWxkSW5mbywgdGhpcy5kZWZhdWx0TmFtZXNbaV0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8gZG9lcyBzb3VyY2VDb2RlIGhhdmUgdG8gYmUgYSBtZW1iZXI/XG4gICAgICAgIHRoaXMuc291cmNlQ29kZSArPSB0aGlzLnNvdXJjZUxpc3RzLnNlY3Rpb25zW3RoaXMuc291cmNlTGlzdHMuc2VjdGlvbnMubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiB0aGlzLnNvdXJjZUNvZGU7XG4gICAgfVxuICAgIGFkZEZ1bmNzKGZ1bmNzKSB7XG4gICAgICAgIHRoaXMuZXh0ZXJuYWxGdW5jcy5wdXNoKC4uLmZ1bmNzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuZXhwb3J0cy5FeHByID0gRXhwcjtcbi8qKlxuICogaW5jcmVtZW50cyBmb3IgZWFjaCBleHByZXNzaW9uIGNyZWF0ZWQ7IHVzZWQgdG8gdW5pcXVlbHkgaWQgZWFjaCBleHByZXNzaW9uXG4gKi9cbkV4cHIuY291bnQgPSAwO1xuZnVuY3Rpb24gZ2VuQ3VzdG9tTmFtZXMoc291cmNlTGlzdHMpIHtcbiAgICBjb25zdCBuYW1lcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlTGlzdHMudmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5hbWVzLnB1c2goXCJ1Q3VzdG9tTmFtZVwiICsgaSk7XG4gICAgfVxuICAgIHJldHVybiBuYW1lcztcbn1cbi8qKiBjcmVhdGUgYSBjdXN0b20gZmxvYXQgZnVuY3Rpb24gKHVzZSB3aXRoIFtbdGFnXV0pICovXG5mdW5jdGlvbiBjZmxvYXQoc291cmNlTGlzdHMsIGV4dGVybmFsRnVuY3MgPSBbXSkge1xuICAgIHJldHVybiBuZXcgRXhwckZsb2F0KHNvdXJjZUxpc3RzLCBnZW5DdXN0b21OYW1lcyhzb3VyY2VMaXN0cykpLmFkZEZ1bmNzKGV4dGVybmFsRnVuY3MpO1xufVxuZXhwb3J0cy5jZmxvYXQgPSBjZmxvYXQ7XG4vKiogY3JlYXRlIGEgY3VzdG9tIHZlYzIgZnVuY3Rpb24gKHVzZSB3aXRoIFtbdGFnXV0pICovXG5mdW5jdGlvbiBjdmVjMihzb3VyY2VMaXN0cywgZXh0ZXJuYWxGdW5jcyA9IFtdKSB7XG4gICAgcmV0dXJuIG5ldyBFeHByVmVjMihzb3VyY2VMaXN0cywgZ2VuQ3VzdG9tTmFtZXMoc291cmNlTGlzdHMpKS5hZGRGdW5jcyhleHRlcm5hbEZ1bmNzKTtcbn1cbmV4cG9ydHMuY3ZlYzIgPSBjdmVjMjtcbi8qKiBjcmVhdGUgYSBjdXN0b20gdmVjMyBmdW5jdGlvbiAodXNlIHdpdGggW1t0YWddXSkgKi9cbmZ1bmN0aW9uIGN2ZWMzKHNvdXJjZUxpc3RzLCBleHRlcm5hbEZ1bmNzID0gW10pIHtcbiAgICByZXR1cm4gbmV3IEV4cHJWZWMzKHNvdXJjZUxpc3RzLCBnZW5DdXN0b21OYW1lcyhzb3VyY2VMaXN0cykpLmFkZEZ1bmNzKGV4dGVybmFsRnVuY3MpO1xufVxuZXhwb3J0cy5jdmVjMyA9IGN2ZWMzO1xuLyoqIGNyZWF0ZSBhIGN1c3RvbSB2ZWM0IGZ1bmN0aW9uICh1c2Ugd2l0aCBbW3RhZ11dKSAqL1xuZnVuY3Rpb24gY3ZlYzQoc291cmNlTGlzdHMsIGV4dGVybmFsRnVuY3MgPSBbXSkge1xuICAgIHJldHVybiBuZXcgRXhwclZlYzQoc291cmNlTGlzdHMsIGdlbkN1c3RvbU5hbWVzKHNvdXJjZUxpc3RzKSkuYWRkRnVuY3MoZXh0ZXJuYWxGdW5jcyk7XG59XG5leHBvcnRzLmN2ZWM0ID0gY3ZlYzQ7XG5jbGFzcyBNdXRhYmxlIHtcbiAgICBjb25zdHJ1Y3RvcihwcmltaXRpdmUsIG5hbWUpIHtcbiAgICAgICAgdGhpcy5wcmltaXRpdmUgPSBwcmltaXRpdmU7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgfVxuICAgIHBhcnNlKGJ1aWxkSW5mbywgZGVmYXVsdE5hbWUsIGVuYykge1xuICAgICAgICBpZiAoZW5jID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyaWVkIHRvIHB1dCBhIG11dGFibGUgZXhwcmVzc2lvbiBhdCB0aGUgdG9wIGxldmVsXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFjY2VwdCB0aGUgZGVmYXVsdCBuYW1lIGlmIGdpdmVuIG5vIG5hbWVcbiAgICAgICAgaWYgKHRoaXMubmFtZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhpcy5uYW1lID0gZGVmYXVsdE5hbWUgKyBlbmMuaWQ7XG4gICAgICAgIC8vIHNldCB0byB0cnVlIHNvIHRoZXkgYXJlIHNldCB0byB0aGVpciBkZWZhdWx0IHZhbHVlcyBvbiBmaXJzdCBkcmF3XG4gICAgICAgIGJ1aWxkSW5mby51bmlmb3JtVHlwZXNbdGhpcy5uYW1lXSA9IHRoaXMucHJpbWl0aXZlLnR5cGVTdHJpbmcoKTtcbiAgICAgICAgLy8gYWRkIHRoZSBuYW1lIG1hcHBpbmdcbiAgICAgICAgZW5jLnVuaWZvcm1WYWxDaGFuZ2VNYXBbdGhpcy5uYW1lXSA9IHtcbiAgICAgICAgICAgIHZhbDogdGhpcy5wcmltaXRpdmUsXG4gICAgICAgICAgICBjaGFuZ2VkOiB0cnVlLFxuICAgICAgICB9O1xuICAgICAgICAvLyBhZGQgdGhlIG5ldyB0eXBlIHRvIHRoZSBtYXBcbiAgICAgICAgZW5jLmRlZmF1bHROYW1lTWFwW2RlZmF1bHROYW1lICsgZW5jLmlkXSA9IHRoaXMubmFtZTtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZTtcbiAgICB9XG4gICAgYXBwbHlVbmlmb3JtKGdsLCBsb2MpIHtcbiAgICAgICAgdGhpcy5wcmltaXRpdmUuYXBwbHlVbmlmb3JtKGdsLCBsb2MpO1xuICAgIH1cbiAgICB0eXBlU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcmltaXRpdmUudHlwZVN0cmluZygpO1xuICAgIH1cbn1cbmV4cG9ydHMuTXV0YWJsZSA9IE11dGFibGU7XG4vKipcbiAqIG1ha2VzIGEgcHJpbWl0aXZlIHZhbHVlIG11dGFibGUuIHdyYXBwaW5nIGEgW1tQcmltaXRpdmVWZWNdXSBvclxuICogW1tQcmltaXRpdmVGbG9hdF1dIGluIFtbbXV0XV0gYmVmb3JlIHBhc3NpbmcgaXQgaW50byBhbiBleHByZXNzaW9uIHdpbGxcbiAqIGFsbG93IHlvdSB0byB1c2UgdGhlIHNldHRlcnMgb24gdGhhdCBleHByZXNzaW9uIHRvIGNoYW5nZSB0aG9zZSB2YWx1ZXMgYXRcbiAqIHJ1bnRpbWVcbiAqIEBwYXJhbSB2YWwgdGhlIHByaW1pdGl2ZSBmbG9hdCBvciBwcmltaXRpdmUgdmVjIHRvIG1ha2UgbXV0YWJsZVxuICogQHBhcmFtIG5hbWUgdGhlIG9wdGlvbmFsIG5hbWUgZm9yIHRoZSB1bmlmb3JtXG4gKi9cbmZ1bmN0aW9uIG11dCh2YWwsIG5hbWUpIHtcbiAgICBjb25zdCBwcmltaXRpdmUgPSB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiID8gbjJwKHZhbCkgOiB2YWw7XG4gICAgcmV0dXJuIG5ldyBNdXRhYmxlKHByaW1pdGl2ZSwgbmFtZSk7XG59XG5leHBvcnRzLm11dCA9IG11dDtcbmNsYXNzIFByaW1pdGl2ZSB7XG4gICAgcGFyc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKCk7XG4gICAgfVxufVxuZXhwb3J0cy5QcmltaXRpdmUgPSBQcmltaXRpdmU7XG5jbGFzcyBQcmltaXRpdmVGbG9hdCBleHRlbmRzIFByaW1pdGl2ZSB7XG4gICAgY29uc3RydWN0b3IobnVtKSB7XG4gICAgICAgIGlmICghaXNGaW5pdGUobnVtKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm51bWJlciBub3QgZmluaXRlXCIpO1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnZhbHVlID0gbnVtO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHN0ciA9IFwiXCIgKyB0aGlzLnZhbHVlO1xuICAgICAgICBpZiAoIXN0ci5pbmNsdWRlcyhcIi5cIikpXG4gICAgICAgICAgICBzdHIgKz0gXCIuXCI7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIHR5cGVTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBcImZsb2F0XCI7XG4gICAgfVxuICAgIGFwcGx5VW5pZm9ybShnbCwgbG9jKSB7XG4gICAgICAgIGdsLnVuaWZvcm0xZihsb2MsIHRoaXMudmFsdWUpO1xuICAgIH1cbn1cbmV4cG9ydHMuUHJpbWl0aXZlRmxvYXQgPSBQcmltaXRpdmVGbG9hdDtcbmNsYXNzIFByaW1pdGl2ZVZlYyBleHRlbmRzIFByaW1pdGl2ZSB7XG4gICAgY29uc3RydWN0b3IoY29tcHMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSBjb21wcztcbiAgICB9XG4gICAgdHlwZVN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIChcInZlY1wiICsgdGhpcy52YWx1ZXMubGVuZ3RoKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLnR5cGVTdHJpbmd9KCR7dGhpcy52YWx1ZXNcbiAgICAgICAgICAgIC5tYXAoKG4pID0+IHRvR0xTTEZsb2F0U3RyaW5nKG4pKVxuICAgICAgICAgICAgLmpvaW4oXCIsIFwiKX0pYDtcbiAgICB9XG59XG5leHBvcnRzLlByaW1pdGl2ZVZlYyA9IFByaW1pdGl2ZVZlYztcbmNsYXNzIFByaW1pdGl2ZVZlYzIgZXh0ZW5kcyBQcmltaXRpdmVWZWMge1xuICAgIGFwcGx5VW5pZm9ybShnbCwgbG9jKSB7XG4gICAgICAgIGdsLnVuaWZvcm0yZihsb2MsIHRoaXMudmFsdWVzWzBdLCB0aGlzLnZhbHVlc1sxXSk7XG4gICAgfVxufVxuZXhwb3J0cy5QcmltaXRpdmVWZWMyID0gUHJpbWl0aXZlVmVjMjtcbmNsYXNzIFByaW1pdGl2ZVZlYzMgZXh0ZW5kcyBQcmltaXRpdmVWZWMge1xuICAgIGFwcGx5VW5pZm9ybShnbCwgbG9jKSB7XG4gICAgICAgIGdsLnVuaWZvcm0zZihsb2MsIHRoaXMudmFsdWVzWzBdLCB0aGlzLnZhbHVlc1sxXSwgdGhpcy52YWx1ZXNbMl0pO1xuICAgIH1cbn1cbmV4cG9ydHMuUHJpbWl0aXZlVmVjMyA9IFByaW1pdGl2ZVZlYzM7XG5jbGFzcyBQcmltaXRpdmVWZWM0IGV4dGVuZHMgUHJpbWl0aXZlVmVjIHtcbiAgICBhcHBseVVuaWZvcm0oZ2wsIGxvYykge1xuICAgICAgICBnbC51bmlmb3JtNGYobG9jLCB0aGlzLnZhbHVlc1swXSwgdGhpcy52YWx1ZXNbMV0sIHRoaXMudmFsdWVzWzJdLCB0aGlzLnZhbHVlc1szXSk7XG4gICAgfVxufVxuZXhwb3J0cy5QcmltaXRpdmVWZWM0ID0gUHJpbWl0aXZlVmVjNDtcbmNsYXNzIEJhc2ljVmVjIGV4dGVuZHMgRXhwciB7XG4gICAgY29uc3RydWN0b3Ioc291cmNlTGlzdHMsIGRlZmF1bHROYW1lcykge1xuICAgICAgICBzdXBlcihzb3VyY2VMaXN0cywgZGVmYXVsdE5hbWVzKTtcbiAgICAgICAgLy8gdGhpcyBjYXN0IGlzIGZpbmUgYXMgbG9uZyBhcyB5b3Ugb25seSBpbnN0YW50aWF0ZSB0aGVzZSB3aXRoIHRoZVxuICAgICAgICAvLyBzaG9ydGhhbmQgdmVyc2lvbiBhbmQgbm90IHRoZSBjb25zdHJ1Y3RvclxuICAgICAgICBjb25zdCB2YWx1ZXMgPSBzb3VyY2VMaXN0cy52YWx1ZXM7XG4gICAgICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xuICAgICAgICB0aGlzLmRlZmF1bHROYW1lcyA9IGRlZmF1bHROYW1lcztcbiAgICB9XG4gICAgdHlwZVN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIChcInZlY1wiICsgdGhpcy52YWx1ZXMubGVuZ3RoKTtcbiAgICB9XG4gICAgLyoqIHNldHMgYSBjb21wb25lbnQgb2YgdGhlIHZlY3RvciAqL1xuICAgIHNldENvbXAoaW5kZXgsIHByaW1pdGl2ZSkge1xuICAgICAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID49IHRoaXMudmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwib3V0IG9mIGJvdW5kcyBvZiBzZXR0aW5nIGNvbXBvbmVudFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldFVuaWZvcm0odGhpcy5kZWZhdWx0TmFtZXNbaW5kZXhdICsgdGhpcy5pZCwgbjJwKHByaW1pdGl2ZSkpO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzaWNWZWMgPSBCYXNpY1ZlYztcbmNsYXNzIEJhc2ljVmVjMiBleHRlbmRzIEJhc2ljVmVjIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5idmVjMiA9IHVuZGVmaW5lZDsgLy8gYnJhbmQgZm9yIG5vbWluYWwgdHlwaW5nXG4gICAgfVxufVxuZXhwb3J0cy5CYXNpY1ZlYzIgPSBCYXNpY1ZlYzI7XG5jbGFzcyBCYXNpY1ZlYzMgZXh0ZW5kcyBCYXNpY1ZlYyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuYnZlYzMgPSB1bmRlZmluZWQ7IC8vIGJyYW5kIGZvciBub21pbmFsIHR5cGluZ1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzaWNWZWMzID0gQmFzaWNWZWMzO1xuY2xhc3MgQmFzaWNWZWM0IGV4dGVuZHMgQmFzaWNWZWMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmJ2ZWM0ID0gdW5kZWZpbmVkOyAvLyBicmFuZCBmb3Igbm9taW5hbCB0eXBpbmdcbiAgICB9XG59XG5leHBvcnRzLkJhc2ljVmVjNCA9IEJhc2ljVmVjNDtcbmNsYXNzIEV4cHJWZWMgZXh0ZW5kcyBFeHByIHtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2VMaXN0cywgZGVmYXVsdE5hbWVzKSB7XG4gICAgICAgIHN1cGVyKHNvdXJjZUxpc3RzLCBkZWZhdWx0TmFtZXMpO1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBzb3VyY2VMaXN0cy52YWx1ZXM7XG4gICAgICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xuICAgICAgICB0aGlzLmRlZmF1bHROYW1lcyA9IGRlZmF1bHROYW1lcztcbiAgICB9XG59XG5leHBvcnRzLkV4cHJWZWMgPSBFeHByVmVjO1xuY2xhc3MgQmFzaWNGbG9hdCBleHRlbmRzIEV4cHIge1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZUxpc3RzLCBkZWZhdWx0TmFtZXMpIHtcbiAgICAgICAgc3VwZXIoc291cmNlTGlzdHMsIGRlZmF1bHROYW1lcyk7XG4gICAgICAgIHRoaXMuZmxvYXQgPSB1bmRlZmluZWQ7IC8vIGJyYW5kIGZvciBub21pbmFsIHR5cGluZ1xuICAgIH1cbiAgICBzZXRWYWwocHJpbWl0aXZlKSB7XG4gICAgICAgIHRoaXMuc2V0VW5pZm9ybShcInVGbG9hdFwiICsgdGhpcy5pZCwgbjJwKHByaW1pdGl2ZSkpO1xuICAgIH1cbiAgICB0eXBlU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gXCJmbG9hdFwiO1xuICAgIH1cbn1cbmV4cG9ydHMuQmFzaWNGbG9hdCA9IEJhc2ljRmxvYXQ7XG5jbGFzcyBFeHByRmxvYXQgZXh0ZW5kcyBFeHByIHtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2VMaXN0cywgZGVmYXVsdE5hbWVzKSB7XG4gICAgICAgIHN1cGVyKHNvdXJjZUxpc3RzLCBkZWZhdWx0TmFtZXMpO1xuICAgICAgICB0aGlzLmZsb2F0ID0gdW5kZWZpbmVkOyAvLyBicmFuZCBmb3Igbm9taW5hbCB0eXBpbmdcbiAgICB9XG4gICAgc2V0VmFsKHByaW1pdGl2ZSkge1xuICAgICAgICB0aGlzLnNldFVuaWZvcm0oXCJ1RmxvYXRcIiArIHRoaXMuaWQsIG4ycChwcmltaXRpdmUpKTtcbiAgICB9XG4gICAgdHlwZVN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFwiZmxvYXRcIjtcbiAgICB9XG59XG5leHBvcnRzLkV4cHJGbG9hdCA9IEV4cHJGbG9hdDtcbmZ1bmN0aW9uIGZsb2F0KHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgdmFsdWUgPSBuMnAodmFsdWUpO1xuICAgIHJldHVybiBuZXcgQmFzaWNGbG9hdCh7IHNlY3Rpb25zOiBbXCJcIiwgXCJcIl0sIHZhbHVlczogW3ZhbHVlXSB9LCBbXCJ1RmxvYXRcIl0pO1xufVxuZXhwb3J0cy5mbG9hdCA9IGZsb2F0O1xuY2xhc3MgRXhwclZlYzIgZXh0ZW5kcyBFeHByVmVjIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy52ZWMyID0gdW5kZWZpbmVkOyAvLyBicmFuZCBmb3Igbm9taW5hbCB0eXBpbmdcbiAgICB9XG4gICAgdHlwZVN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIFwidmVjMlwiO1xuICAgIH1cbn1cbmV4cG9ydHMuRXhwclZlYzIgPSBFeHByVmVjMjtcbmNsYXNzIEV4cHJWZWMzIGV4dGVuZHMgRXhwclZlYyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudmVjMyA9IHVuZGVmaW5lZDsgLy8gYnJhbmQgZm9yIG5vbWluYWwgdHlwaW5nXG4gICAgfVxuICAgIHR5cGVTdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBcInZlYzNcIjtcbiAgICB9XG59XG5leHBvcnRzLkV4cHJWZWMzID0gRXhwclZlYzM7XG5jbGFzcyBFeHByVmVjNCBleHRlbmRzIEV4cHJWZWMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZlYzQgPSB1bmRlZmluZWQ7IC8vIGJyYW5kIGZvciBub21pbmFsIHR5cGluZ1xuICAgIH1cbiAgICByZXBlYXQobnVtKSB7XG4gICAgICAgIHJldHVybiBuZXcgbWVyZ2VwYXNzXzEuRWZmZWN0TG9vcChbdGhpc10sIHsgbnVtOiBudW0gfSk7XG4gICAgfVxuICAgIGdlblByb2dyYW1zKGdsLCB2U2hhZGVyLCB1bmlmb3JtTG9jcywgc2hhZGVycykge1xuICAgICAgICByZXR1cm4gbmV3IG1lcmdlcGFzc18xLkVmZmVjdExvb3AoW3RoaXNdLCB7IG51bTogMSB9KS5nZW5Qcm9ncmFtcyhnbCwgdlNoYWRlciwgdW5pZm9ybUxvY3MsIHNoYWRlcnMpO1xuICAgIH1cbiAgICB0eXBlU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gXCJ2ZWM0XCI7XG4gICAgfVxufVxuZXhwb3J0cy5FeHByVmVjNCA9IEV4cHJWZWM0O1xuY2xhc3MgT3BlcmF0b3IgZXh0ZW5kcyBFeHByIHtcbiAgICBjb25zdHJ1Y3RvcihyZXQsIHNvdXJjZUxpc3RzLCBkZWZhdWx0TmFtZXMpIHtcbiAgICAgICAgc3VwZXIoc291cmNlTGlzdHMsIGRlZmF1bHROYW1lcyk7XG4gICAgICAgIHRoaXMucmV0ID0gcmV0O1xuICAgIH1cbiAgICB0eXBlU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXQudHlwZVN0cmluZygpO1xuICAgIH1cbn1cbmV4cG9ydHMuT3BlcmF0b3IgPSBPcGVyYXRvcjtcbmZ1bmN0aW9uIG4yZShudW0pIHtcbiAgICBpZiAobnVtID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgaWYgKG51bSBpbnN0YW5jZW9mIFByaW1pdGl2ZUZsb2F0IHx8XG4gICAgICAgIG51bSBpbnN0YW5jZW9mIEV4cHJGbG9hdCB8fFxuICAgICAgICBudW0gaW5zdGFuY2VvZiBPcGVyYXRvciB8fFxuICAgICAgICBudW0gaW5zdGFuY2VvZiBNdXRhYmxlIHx8XG4gICAgICAgIG51bSBpbnN0YW5jZW9mIEJhc2ljRmxvYXQpXG4gICAgICAgIHJldHVybiBudW07XG4gICAgcmV0dXJuIG5ldyBQcmltaXRpdmVGbG9hdChudW0pO1xufVxuZXhwb3J0cy5uMmUgPSBuMmU7XG4vLyBUT0RPIHNlZSBpZiB3ZSBuZWVkIHRoaXNcbi8qKiBudW1iZXIgdG8gcHJpbWl0aXZlIGZsb2F0ICovXG5mdW5jdGlvbiBuMnAobnVtKSB7XG4gICAgaWYgKG51bSBpbnN0YW5jZW9mIFByaW1pdGl2ZUZsb2F0KVxuICAgICAgICByZXR1cm4gbnVtO1xuICAgIHJldHVybiBuZXcgUHJpbWl0aXZlRmxvYXQobnVtKTtcbn1cbmV4cG9ydHMubjJwID0gbjJwO1xuLyoqIGNyZWF0ZXMgYSBwcmltaXRpdmUgZmxvYXQgKi9cbmZ1bmN0aW9uIHBmbG9hdChudW0pIHtcbiAgICByZXR1cm4gbmV3IFByaW1pdGl2ZUZsb2F0KG51bSk7XG59XG5leHBvcnRzLnBmbG9hdCA9IHBmbG9hdDtcbi8qKiBAaWdub3JlICovXG5mdW5jdGlvbiB3cmFwSW5WYWx1ZShudW0pIHtcbiAgICBpZiAodHlwZW9mIG51bSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgcmV0dXJuIHBmbG9hdChudW0pO1xuICAgIHJldHVybiBudW07XG59XG5leHBvcnRzLndyYXBJblZhbHVlID0gd3JhcEluVmFsdWU7XG4vKiogQGlnbm9yZSAqL1xuZnVuY3Rpb24gdGFnKHN0cmluZ3MsIC4uLnZhbHVlcykge1xuICAgIHJldHVybiB7IHNlY3Rpb25zOiBzdHJpbmdzLmNvbmNhdChbXSksIHZhbHVlczogdmFsdWVzIH07XG59XG5leHBvcnRzLnRhZyA9IHRhZztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5mY29sb3IgPSBleHBvcnRzLkZyYWdDb2xvckV4cHIgPSB2b2lkIDA7XG5jb25zdCBleHByXzEgPSByZXF1aXJlKFwiLi9leHByXCIpO1xuLyoqIGZyYWdtZW50IGNvbG9yIGV4cHJlc3Npb24gKi9cbmNsYXNzIEZyYWdDb2xvckV4cHIgZXh0ZW5kcyBleHByXzEuRXhwclZlYzQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihleHByXzEudGFnIGBnbF9GcmFnQ29sb3JgLCBbXSk7XG4gICAgICAgIHRoaXMubmVlZHMuY2VudGVyU2FtcGxlID0gdHJ1ZTtcbiAgICB9XG59XG5leHBvcnRzLkZyYWdDb2xvckV4cHIgPSBGcmFnQ29sb3JFeHByO1xuLyoqIGNyZWF0ZXMgYW4gZXhwcmVzc2lvbiB0aGF0IGV2YWx1YXRlcyB0byB0aGUgZnJhZ21lbnQgY29sb3IgKi9cbmZ1bmN0aW9uIGZjb2xvcigpIHtcbiAgICByZXR1cm4gbmV3IEZyYWdDb2xvckV4cHIoKTtcbn1cbmV4cG9ydHMuZmNvbG9yID0gZmNvbG9yO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBpeGVsID0gZXhwb3J0cy5GcmFnQ29vcmRFeHByID0gdm9pZCAwO1xuY29uc3QgZXhwcl8xID0gcmVxdWlyZShcIi4vZXhwclwiKTtcbi8qKiBmcmFnIGNvb3JkIGV4cHJlc3Npb24gKHh5IGNvbXBvbmVudHMgb25seSkgKi9cbmNsYXNzIEZyYWdDb29yZEV4cHIgZXh0ZW5kcyBleHByXzEuRXhwclZlYzIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihleHByXzEudGFnIGBnbF9GcmFnQ29vcmQueHlgLCBbXSk7XG4gICAgfVxufVxuZXhwb3J0cy5GcmFnQ29vcmRFeHByID0gRnJhZ0Nvb3JkRXhwcjtcbi8qKlxuICogY3JlYXRlcyBhbiBleHByZXNzaW9uIHRoYXQgZXZhbHVhdGVzIHRvIHRoZSBmcmFnIGNvb3JkIGluIHBpeGVscyAoc2FtcGxlcnNcbiAqIHRha2Ugbm9ybWFsaXplZCBjb29yZGluYXRlcywgc28geW91IG1pZ2h0IHdhbnQgW1tuZmNvb3JkXV0gaW5zdGVhZClcbiAqL1xuZnVuY3Rpb24gcGl4ZWwoKSB7XG4gICAgcmV0dXJuIG5ldyBGcmFnQ29vcmRFeHByKCk7XG59XG5leHBvcnRzLnBpeGVsID0gcGl4ZWw7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZnhhYSA9IHZvaWQgMDtcbmNvbnN0IGV4cHJfMSA9IHJlcXVpcmUoXCIuL2V4cHJcIik7XG5jb25zdCBnbHNsZnVuY3Rpb25zXzEgPSByZXF1aXJlKFwiLi4vZ2xzbGZ1bmN0aW9uc1wiKTtcbi8qKiBGWEFBIGV4cHJlc3Npb24gKi9cbmNsYXNzIEZYQUFFeHByIGV4dGVuZHMgZXhwcl8xLkV4cHJWZWM0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoZXhwcl8xLnRhZyBgZnhhYSgpYCwgW10pO1xuICAgICAgICB0aGlzLmV4dGVybmFsRnVuY3MgPSBbZ2xzbGZ1bmN0aW9uc18xLmdsc2xGdW5jcy5meGFhXTtcbiAgICAgICAgdGhpcy5uZWVkcy5uZWlnaGJvclNhbXBsZSA9IHRydWU7XG4gICAgfVxufVxuLyoqIEZYQUEgYW50YWxpYXNpbmcgZXhwcmVzc2lvbiAqL1xuZnVuY3Rpb24gZnhhYSgpIHtcbiAgICByZXR1cm4gbmV3IEZYQUFFeHByKCk7XG59XG5leHBvcnRzLmZ4YWEgPSBmeGFhO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdhdXNzaWFuID0gZXhwb3J0cy5HYXVzc2lhbkV4cHIgPSB2b2lkIDA7XG5jb25zdCBnbHNsZnVuY3Rpb25zXzEgPSByZXF1aXJlKFwiLi4vZ2xzbGZ1bmN0aW9uc1wiKTtcbmNvbnN0IGV4cHJfMSA9IHJlcXVpcmUoXCIuL2V4cHJcIik7XG4vKiogZ2F1c3NpYW4gZXhwcmVzc2lvbiAqL1xuY2xhc3MgR2F1c3NpYW5FeHByIGV4dGVuZHMgZXhwcl8xLkV4cHJGbG9hdCB7XG4gICAgY29uc3RydWN0b3IoeCwgYSwgYikge1xuICAgICAgICBzdXBlcihleHByXzEudGFnIGBnYXVzc2lhbigke3h9LCAke2F9LCAke2J9KWAsIFtcInVGbG9hdFhcIiwgXCJ1RmxvYXRBXCIsIFwidUZsb2F0QlwiXSk7XG4gICAgICAgIHRoaXMueCA9IHg7XG4gICAgICAgIHRoaXMuYSA9IGE7XG4gICAgICAgIHRoaXMuYiA9IGI7XG4gICAgICAgIHRoaXMuZXh0ZXJuYWxGdW5jcyA9IFtnbHNsZnVuY3Rpb25zXzEuZ2xzbEZ1bmNzLmdhdXNzaWFuXTtcbiAgICB9XG4gICAgc2V0WCh4KSB7XG4gICAgICAgIHRoaXMuc2V0VW5pZm9ybShcInVGbG9hdFhcIiArIHRoaXMuaWQsIHgpO1xuICAgICAgICB0aGlzLnggPSBleHByXzEubjJwKHgpO1xuICAgIH1cbiAgICBzZXRBKGEpIHtcbiAgICAgICAgdGhpcy5zZXRVbmlmb3JtKFwidUZsb2F0QVwiICsgdGhpcy5pZCwgYSk7XG4gICAgICAgIHRoaXMuYSA9IGV4cHJfMS5uMnAoYSk7XG4gICAgfVxuICAgIHNldEIoYikge1xuICAgICAgICB0aGlzLnNldFVuaWZvcm0oXCJ1RmxvYXRCXCIgKyB0aGlzLmlkLCBiKTtcbiAgICAgICAgdGhpcy5iID0gZXhwcl8xLm4ycChiKTtcbiAgICB9XG59XG5leHBvcnRzLkdhdXNzaWFuRXhwciA9IEdhdXNzaWFuRXhwcjtcbi8qKlxuICogZ2F1c3NpYW4gZnVuY3Rpb24gdGhhdCBkZWZhdWx0cyB0byBub3JtYWwgZGlzdHJpYnV0aW9uXG4gKiBAcGFyYW0geCB4IHBvc2l0aW9uIGluIHRoZSBjdXJ2ZVxuICogQHBhcmFtIGEgaG9yaXpvbnRhbCBwb3NpdGlvbiBvZiBwZWFrIChkZWZhdWx0cyB0byAwIGZvciBub3JtYWwgZGlzdHJpYnV0aW9uKVxuICogQHBhcmFtIGIgaG9yaXpvbnRhbCBzdHJldGNoIG9mIHRoZSBjdXJ2ZSAoZGVmYXVsdHMgdG8gMSBmb3Igbm9ybWFsIGRpc3RyaWJ1dGlvbilcbiAqL1xuZnVuY3Rpb24gZ2F1c3NpYW4oeCwgYSA9IDAsIGIgPSAxKSB7XG4gICAgcmV0dXJuIG5ldyBHYXVzc2lhbkV4cHIoZXhwcl8xLm4yZSh4KSwgZXhwcl8xLm4yZShhKSwgZXhwcl8xLm4yZShiKSk7XG59XG5leHBvcnRzLmdhdXNzaWFuID0gZ2F1c3NpYW47XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2V0NGNvbXAgPSBleHBvcnRzLmdldDNjb21wID0gZXhwb3J0cy5nZXQyY29tcCA9IGV4cG9ydHMuZ2V0Y29tcCA9IGV4cG9ydHMuR2V0NENvbXBFeHByID0gZXhwb3J0cy5HZXQzQ29tcEV4cHIgPSBleHBvcnRzLkdldDJDb21wRXhwciA9IGV4cG9ydHMuR2V0Q29tcEV4cHIgPSBleHBvcnRzLmNoZWNrTGVnYWxDb21wb25lbnRzID0gZXhwb3J0cy50eXBlU3RyaW5nVG9MZW5ndGggPSB2b2lkIDA7XG5jb25zdCBleHByXzEgPSByZXF1aXJlKFwiLi9leHByXCIpO1xuLy8gVE9ETyB0aGlzIHNob3VsZCBwcm9iYWJseSBiZSBzb21ld2hlcmUgZWxzZVxuLyoqIEBpZ25vcmUgKi9cbmZ1bmN0aW9uIHR5cGVTdHJpbmdUb0xlbmd0aChzdHIpIHtcbiAgICBzd2l0Y2ggKHN0cikge1xuICAgICAgICBjYXNlIFwiZmxvYXRcIjpcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICBjYXNlIFwidmVjMlwiOlxuICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIGNhc2UgXCJ2ZWMzXCI6XG4gICAgICAgICAgICByZXR1cm4gMztcbiAgICAgICAgY2FzZSBcInZlYzRcIjpcbiAgICAgICAgICAgIHJldHVybiA0O1xuICAgIH1cbn1cbmV4cG9ydHMudHlwZVN0cmluZ1RvTGVuZ3RoID0gdHlwZVN0cmluZ1RvTGVuZ3RoO1xuLyoqIEBpZ25vcmUgKi9cbmZ1bmN0aW9uIGdlbkNvbXBTb3VyY2UodmVjLCBjb21wb25lbnRzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2VjdGlvbnM6IFtcIlwiLCBcIi5cIiArIGNvbXBvbmVudHNdLFxuICAgICAgICB2YWx1ZXM6IFt2ZWNdLFxuICAgIH07XG59XG4vKipcbiAqIGNoZWNrcyBpZiBjb21wb25lbnRzIGFjY2Vzc2luZyBhIHZlY3RvciBhcmUgbGVnYWwuIGNvbXBvbmVudHMgY2FuIGJlIGlsbGVnYWxcbiAqIGlmIHRoZXkgbWl4IHNldHMgKGUuZy4gYHYucmd6d2ApIG9yIGNvbnRhaW4gY2hhcmFjdGVycyBvdXRzaWRlIG9mIGFueSBzZXRcbiAqIChlLmcuIGB2Lmxtbm9gKVxuICogQHBhcmFtIGNvbXBzIGNvbXBvbmVudHMgc3RyaW5nXG4gKiBAcGFyYW0gdmVjIHZlY3RvciBiZWluZyBhY2Nlc3NlZFxuICovXG5mdW5jdGlvbiBjaGVja0xlZ2FsQ29tcG9uZW50cyhjb21wcywgdmVjKSB7XG4gICAgY29uc3QgY2hlY2sgPSAocmFuZ2UsIGRvbWFpbikgPT4ge1xuICAgICAgICBsZXQgaW5zaWRlID0gMDtcbiAgICAgICAgbGV0IG91dHNpZGUgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IGMgb2YgcmFuZ2UpIHtcbiAgICAgICAgICAgIGRvbWFpbi5pbmNsdWRlcyhjKSA/IGluc2lkZSsrIDogb3V0c2lkZSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnNpZGUgPT09IGluc2lkZSAmJiAhb3V0c2lkZTtcbiAgICB9O1xuICAgIGNvbnN0IGluTGVuID0gdHlwZVN0cmluZ1RvTGVuZ3RoKHZlYy50eXBlU3RyaW5nKCkpO1xuICAgIGNvbnN0IHJnYmFDaGVjayA9IGNoZWNrKGNvbXBzLCBcInJnYmFcIi5zdWJzdHIoMCwgaW5MZW4pKTtcbiAgICBjb25zdCB4eXp3Q2hlY2sgPSBjaGVjayhjb21wcywgXCJ4eXp3XCIuc3Vic3RyKDAsIGluTGVuKSk7XG4gICAgY29uc3Qgc3RwcUNoZWNrID0gY2hlY2soY29tcHMsIFwic3RwcVwiLnN1YnN0cigwLCBpbkxlbikpO1xuICAgIGlmICghKHJnYmFDaGVjayB8fCB4eXp3Q2hlY2sgfHwgc3RwcUNoZWNrKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb21wb25lbnQgc2V0cyBhcmUgbWl4ZWQgb3IgaW5jb3JyZWN0IGVudGlyZWx5XCIpO1xuICAgIH1cbn1cbmV4cG9ydHMuY2hlY2tMZWdhbENvbXBvbmVudHMgPSBjaGVja0xlZ2FsQ29tcG9uZW50cztcbi8qKlxuICogcGVyZm9ybXMgYWxsIHZhbGlkaXR5IGNoZWNrcyBvZiBbW2NoZWNrTGVnYWxDb21wb25lbnRzXV0gYW5kIGNoZWNrcyBpZiB0aGVcbiAqIG51bWJlciBvZiBhY2Nlc3NlZCBjb21wb25lbnRzIGRvZXMgbm90IGV4Y2VlZCB0aGUgc2l6ZSBvZiB0aGUgdmVjdG9yIGJlaW5nXG4gKiBhc3NpZ25lZCB0b1xuICogQHBhcmFtIGNvbXBzIGNvbXBvbmVudHMgc3RyaW5nXG4gKiBAcGFyYW0gb3V0TGVuIGxlbmd0aCBvZiB0aGUgcmVzdWx0YW50IHZlY3RvclxuICogQHBhcmFtIHZlYyB2ZWN0b3IgYmVpbmcgYWNjZXNzZWRcbiAqL1xuZnVuY3Rpb24gY2hlY2tHZXRDb21wb25lbnRzKGNvbXBzLCBvdXRMZW4sIHZlYykge1xuICAgIGlmIChjb21wcy5sZW5ndGggPiBvdXRMZW4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInRvbyBtYW55IGNvbXBvbmVudHNcIik7XG4gICAgY2hlY2tMZWdhbENvbXBvbmVudHMoY29tcHMsIHZlYyk7XG59XG4vKiogZ2V0IGNvbXBvbmVudCBleHByZXNzaW9uICovXG5jbGFzcyBHZXRDb21wRXhwciBleHRlbmRzIGV4cHJfMS5FeHByRmxvYXQge1xuICAgIGNvbnN0cnVjdG9yKHZlYywgY29tcHMpIHtcbiAgICAgICAgY2hlY2tHZXRDb21wb25lbnRzKGNvbXBzLCAxLCB2ZWMpO1xuICAgICAgICBzdXBlcihnZW5Db21wU291cmNlKHZlYywgY29tcHMpLCBbXCJ1VmVjMU1pblwiXSk7XG4gICAgICAgIHRoaXMudmVjMU1pbiA9IHZlYztcbiAgICB9XG4gICAgc2V0VmVjKHZlYykge1xuICAgICAgICB0aGlzLnNldFVuaWZvcm0oXCJ1VmVjMU1pblwiLCB2ZWMpO1xuICAgICAgICB0aGlzLnZlYzFNaW4gPSB2ZWM7XG4gICAgfVxufVxuZXhwb3J0cy5HZXRDb21wRXhwciA9IEdldENvbXBFeHByO1xuLyoqIGdldCAyIGNvbXBvbmVudHMgZXhwcmVzc2lvbiAqL1xuY2xhc3MgR2V0MkNvbXBFeHByIGV4dGVuZHMgZXhwcl8xLkV4cHJWZWMyIHtcbiAgICBjb25zdHJ1Y3Rvcih2ZWMsIGNvbXBzKSB7XG4gICAgICAgIGNoZWNrR2V0Q29tcG9uZW50cyhjb21wcywgMiwgdmVjKTtcbiAgICAgICAgc3VwZXIoZ2VuQ29tcFNvdXJjZSh2ZWMsIGNvbXBzKSwgW1widVZlYzJNaW5cIl0pO1xuICAgICAgICB0aGlzLnZlYzJNaW4gPSB2ZWM7XG4gICAgfVxuICAgIHNldFZlYyh2ZWMpIHtcbiAgICAgICAgdGhpcy5zZXRVbmlmb3JtKFwidVZlYzJNaW5cIiwgdmVjKTtcbiAgICAgICAgdGhpcy52ZWMyTWluID0gdmVjO1xuICAgIH1cbn1cbmV4cG9ydHMuR2V0MkNvbXBFeHByID0gR2V0MkNvbXBFeHByO1xuLyoqIGdldCAzIGNvbXBvbmVudHMgZXhwcmVzc2lvbiAqL1xuY2xhc3MgR2V0M0NvbXBFeHByIGV4dGVuZHMgZXhwcl8xLkV4cHJWZWMzIHtcbiAgICBjb25zdHJ1Y3Rvcih2ZWMsIGNvbXBzKSB7XG4gICAgICAgIGNoZWNrR2V0Q29tcG9uZW50cyhjb21wcywgMywgdmVjKTtcbiAgICAgICAgc3VwZXIoZ2VuQ29tcFNvdXJjZSh2ZWMsIGNvbXBzKSwgW1widVZlYzNNaW5cIl0pO1xuICAgICAgICB0aGlzLnZlYzNNaW4gPSB2ZWM7XG4gICAgfVxuICAgIHNldFZlYyh2ZWMpIHtcbiAgICAgICAgdGhpcy5zZXRVbmlmb3JtKFwidVZlYzNNaW5cIiwgdmVjKTtcbiAgICAgICAgdGhpcy52ZWMzTWluID0gdmVjO1xuICAgIH1cbn1cbmV4cG9ydHMuR2V0M0NvbXBFeHByID0gR2V0M0NvbXBFeHByO1xuLyoqIGdldCAzIGNvbXBvbmVudHMgZXhwcmVzc2lvbiAqL1xuY2xhc3MgR2V0NENvbXBFeHByIGV4dGVuZHMgZXhwcl8xLkV4cHJWZWM0IHtcbiAgICBjb25zdHJ1Y3Rvcih2ZWMsIGNvbXBzKSB7XG4gICAgICAgIGNoZWNrR2V0Q29tcG9uZW50cyhjb21wcywgNCwgdmVjKTtcbiAgICAgICAgc3VwZXIoZ2VuQ29tcFNvdXJjZSh2ZWMsIGNvbXBzKSwgW1widVZlYzRNaW5cIl0pO1xuICAgICAgICB0aGlzLnZlYzRNaW4gPSB2ZWM7XG4gICAgfVxuICAgIHNldFZlYyh2ZWMpIHtcbiAgICAgICAgdGhpcy5zZXRVbmlmb3JtKFwidVZlYzRNaW5cIiwgdmVjKTtcbiAgICAgICAgdGhpcy52ZWM0TWluID0gdmVjO1xuICAgIH1cbn1cbmV4cG9ydHMuR2V0NENvbXBFeHByID0gR2V0NENvbXBFeHByO1xuLyoqXG4gKiBjcmVhdGVzIGFuIGV4cHJlc3Npb24gdGhhdCBnZXRzIDEgY29tcG9uZW50IGZyb20gYSB2ZWN0b3JcbiAqIEBwYXJhbSB2ZWMgdGhlIHZlY3RvciB0byBnZXQgY29tcG9uZW50cyBvZlxuICogQHBhcmFtIGNvbXBzIGNvbXBvbmVudHMgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGdldGNvbXAodmVjLCBjb21wcykge1xuICAgIHJldHVybiBuZXcgR2V0Q29tcEV4cHIodmVjLCBjb21wcyk7XG59XG5leHBvcnRzLmdldGNvbXAgPSBnZXRjb21wO1xuLyoqXG4gKiBjcmVhdGVzIGFuIGV4cHJlc3Npb24gdGhhdCBnZXRzIDIgY29tcG9uZW50cyBmcm9tIGEgdmVjdG9yXG4gKiBAcGFyYW0gdmVjIHRoZSB2ZWN0b3IgdG8gZ2V0IGNvbXBvbmVudHMgb2ZcbiAqIEBwYXJhbSBjb21wcyBjb21wb25lbnRzIHN0cmluZ1xuICovXG5mdW5jdGlvbiBnZXQyY29tcCh2ZWMsIGNvbXBzKSB7XG4gICAgcmV0dXJuIG5ldyBHZXQyQ29tcEV4cHIodmVjLCBjb21wcyk7XG59XG5leHBvcnRzLmdldDJjb21wID0gZ2V0MmNvbXA7XG4vKipcbiAqIGNyZWF0ZXMgYW4gZXhwcmVzc2lvbiB0aGF0IGdldHMgMyBjb21wb25lbnRzIGZyb20gYSB2ZWN0b3JcbiAqIEBwYXJhbSB2ZWMgdGhlIHZlY3RvciB0byBnZXQgY29tcG9uZW50cyBvZlxuICogQHBhcmFtIGNvbXBzIGNvbXBvbmVudHMgc3RyaW5nXG4gKi9cbmZ1bmN0aW9uIGdldDNjb21wKHZlYywgY29tcHMpIHtcbiAgICByZXR1cm4gbmV3IEdldDNDb21wRXhwcih2ZWMsIGNvbXBzKTtcbn1cbmV4cG9ydHMuZ2V0M2NvbXAgPSBnZXQzY29tcDtcbi8qKlxuICogY3JlYXRlcyBhbiBleHByZXNzaW9uIHRoYXQgZ2V0cyA0IGNvbXBvbmVudHMgZnJvbSBhIHZlY3RvclxuICogQHBhcmFtIHZlYyB0aGUgdmVjdG9yIHRvIGdldCBjb21wb25lbnRzIG9mXG4gKiBAcGFyYW0gY29tcHMgY29tcG9uZW50cyBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gZ2V0NGNvbXAodmVjLCBjb21wcykge1xuICAgIHJldHVybiBuZXcgR2V0NENvbXBFeHByKHZlYywgY29tcHMpO1xufVxuZXhwb3J0cy5nZXQ0Y29tcCA9IGdldDRjb21wO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdvZHJheXMgPSBleHBvcnRzLkdvZFJheXNFeHByID0gdm9pZCAwO1xuY29uc3QgZ2xzbGZ1bmN0aW9uc18xID0gcmVxdWlyZShcIi4uL2dsc2xmdW5jdGlvbnNcIik7XG5jb25zdCBleHByXzEgPSByZXF1aXJlKFwiLi9leHByXCIpO1xuY29uc3QgZnJhZ2NvbG9yZXhwcl8xID0gcmVxdWlyZShcIi4vZnJhZ2NvbG9yZXhwclwiKTtcbmNvbnN0IHZlY2V4cHJzXzEgPSByZXF1aXJlKFwiLi92ZWNleHByc1wiKTtcbi8qKiBnb2RyYXlzIGV4cHJlc3Npb24gKi9cbmNsYXNzIEdvZFJheXNFeHByIGV4dGVuZHMgZXhwcl8xLkV4cHJWZWM0IHtcbiAgICAvLyBzYW5lIGdvZHJheSBkZWZhdWx0cyBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9FcmthbWFuL2dsc2wtZ29kcmF5cy9ibG9iL21hc3Rlci9leGFtcGxlL2luZGV4LmpzXG4gICAgY29uc3RydWN0b3IoY29sID0gZnJhZ2NvbG9yZXhwcl8xLmZjb2xvcigpLCBleHBvc3VyZSA9IGV4cHJfMS5tdXQoMS4wKSwgZGVjYXkgPSBleHByXzEubXV0KDEuMCksIGRlbnNpdHkgPSBleHByXzEubXV0KDEuMCksIHdlaWdodCA9IGV4cHJfMS5tdXQoMC4wMSksIGxpZ2h0UG9zID0gZXhwcl8xLm11dCh2ZWNleHByc18xLnB2ZWMyKDAuNSwgMC41KSksIHNhbXBsZXJOdW0gPSAwLCBjb252ZXJ0RGVwdGgpIHtcbiAgICAgICAgLy8gVE9ETyB0aGUgbWV0YXByb2dyYW1taW5nIGhlcmUgaXMgbm90IHNvIGdvb2QhXG4gICAgICAgIC8vIGxlYXZpbmcgb2ZmIHRoZSBmdW5jdGlvbiBjYWxsIHNlY3Rpb24gZm9yIG5vd1xuICAgICAgICBjb25zdCBzb3VyY2VMaXN0cyA9IGV4cHJfMS50YWcgYCR7Y29sfSwgJHtleHBvc3VyZX0sICR7ZGVjYXl9LCAke2RlbnNpdHl9LCAke3dlaWdodH0sICR7bGlnaHRQb3N9LCAke2NvbnZlcnREZXB0aCAhPT0gdW5kZWZpbmVkID8gY29udmVydERlcHRoLnRocmVzaG9sZCA6IGV4cHJfMS5mbG9hdCgwKX0sICR7Y29udmVydERlcHRoICE9PSB1bmRlZmluZWQgPyBjb252ZXJ0RGVwdGgubmV3Q29sb3IgOiB2ZWNleHByc18xLnZlYzQoMCwgMCwgMCwgMCl9KWA7XG4gICAgICAgIC8vIFRPRE8gbWFrZSB0aGlzIG1vcmUgZ2VuZXJpY1xuICAgICAgICAvLyBhcHBlbmQgdGhlIF88bnVtPiBvbnRvIHRoZSBmdW5jdGlvbiBuYW1lXG4gICAgICAgIC8vIGFsc28gYWRkIF9kZXB0aCBpZiB0aGlzIGlzIGEgdmVyc2lvbiBvZiB0aGUgZnVuY3Rpb24gdGhhdCB1c2VzIGRlcHRoIGJ1ZmZlclxuICAgICAgICBzb3VyY2VMaXN0cy5zZWN0aW9uc1swXSArPSBgZ29kcmF5c18ke3NhbXBsZXJOdW19JHtjb252ZXJ0RGVwdGggIT09IHVuZGVmaW5lZCA/IFwiX2RlcHRoXCIgOiBcIlwifShgO1xuICAgICAgICBzdXBlcihzb3VyY2VMaXN0cywgW1xuICAgICAgICAgICAgXCJ1Q29sXCIsXG4gICAgICAgICAgICBcInVFeHBvc3VyZVwiLFxuICAgICAgICAgICAgXCJ1RGVjYXlcIixcbiAgICAgICAgICAgIFwidURlbnNpdHlcIixcbiAgICAgICAgICAgIFwidVdlaWdodFwiLFxuICAgICAgICAgICAgXCJ1TGlnaHRQb3NcIixcbiAgICAgICAgICAgIFwidVRocmVzaG9sZFwiLFxuICAgICAgICAgICAgXCJ1TmV3Q29sb3JcIixcbiAgICAgICAgXSk7XG4gICAgICAgIHRoaXMuY29sID0gY29sO1xuICAgICAgICB0aGlzLmV4cG9zdXJlID0gZXhwb3N1cmU7XG4gICAgICAgIHRoaXMuZGVjYXkgPSBkZWNheTtcbiAgICAgICAgdGhpcy5kZW5zaXR5ID0gZGVuc2l0eTtcbiAgICAgICAgdGhpcy53ZWlnaHQgPSB3ZWlnaHQ7XG4gICAgICAgIHRoaXMubGlnaHRQb3MgPSBsaWdodFBvcztcbiAgICAgICAgdGhpcy50aHJlc2hvbGQgPSBjb252ZXJ0RGVwdGggPT09IG51bGwgfHwgY29udmVydERlcHRoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb252ZXJ0RGVwdGgudGhyZXNob2xkO1xuICAgICAgICB0aGlzLm5ld0NvbG9yID0gY29udmVydERlcHRoID09PSBudWxsIHx8IGNvbnZlcnREZXB0aCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udmVydERlcHRoLm5ld0NvbG9yO1xuICAgICAgICBsZXQgY3VzdG9tR29kUmF5RnVuYyA9IGdsc2xmdW5jdGlvbnNfMS5yZXBsYWNlU2FtcGxlcihnbHNsZnVuY3Rpb25zXzEuZ2xzbEZ1bmNzLmdvZHJheXMsIC92ZWM0XFxzZ29kcmF5cy9nLCBzYW1wbGVyTnVtLCBjb252ZXJ0RGVwdGggPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IFwiX2RlcHRoXCIpO1xuICAgICAgICBpZiAoY29udmVydERlcHRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHVuY29tbWVudCB0aGUgbGluZSB0aGF0IGRvZXMgdGhlIGNvbnZlcnNpb25cbiAgICAgICAgICAgIC8vIFRPRE8gcmVwbGFjZSB0aGlzIHdpdGggYSBtb3JlIGdlbmVyaWMgI2lmZGVmIGFuZCAjaWZuZGVmIGtpbmQgb2ZcbiAgICAgICAgICAgIC8vIGxpa2UgdGhlIEMgcHJlcHJvY2Vzc29yXG4gICAgICAgICAgICBjdXN0b21Hb2RSYXlGdW5jID0gY3VzdG9tR29kUmF5RnVuYy5yZXBsYWNlKC9cXC9cXC91bmNvbW1lbnRcXHMvZywgXCJcIik7XG4gICAgICAgICAgICB0aGlzLmV4dGVybmFsRnVuY3MucHVzaChnbHNsZnVuY3Rpb25zXzEuZ2xzbEZ1bmNzLmRlcHRoMm9jY2x1c2lvbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5leHRlcm5hbEZ1bmNzLnB1c2goY3VzdG9tR29kUmF5RnVuYyk7XG4gICAgICAgIHRoaXMubmVlZHMuZXh0cmFCdWZmZXJzID0gbmV3IFNldChbMF0pO1xuICAgIH1cbiAgICAvKiogc2V0cyB0aGUgbGlnaHQgY29sb3IgKi9cbiAgICBzZXRDb2xvcihjb2xvcikge1xuICAgICAgICB0aGlzLnNldFVuaWZvcm0oXCJ1Q29sXCIgKyB0aGlzLmlkLCBjb2xvcik7XG4gICAgICAgIHRoaXMuY29sID0gY29sb3I7XG4gICAgfVxuICAgIC8qKiBzZXRzIHRoZSBleHBvc3VyZSAqL1xuICAgIHNldEV4cG9zdXJlKGV4cG9zdXJlKSB7XG4gICAgICAgIHRoaXMuc2V0VW5pZm9ybShcInVFeHBvc3VyZVwiICsgdGhpcy5pZCwgZXhwb3N1cmUpO1xuICAgICAgICB0aGlzLmV4cG9zdXJlID0gZXhwcl8xLm4ycChleHBvc3VyZSk7XG4gICAgfVxuICAgIC8qKiBzZXRzIHRoZSBkZWNheSAqL1xuICAgIHNldERlY2F5KGRlY2F5KSB7XG4gICAgICAgIHRoaXMuc2V0VW5pZm9ybShcInVEZWNheVwiICsgdGhpcy5pZCwgZGVjYXkpO1xuICAgICAgICB0aGlzLmRlY2F5ID0gZXhwcl8xLm4ycChkZWNheSk7XG4gICAgfVxuICAgIC8qKiBzZXRzIHRoZSBkZW5zaXR5ICovXG4gICAgc2V0RGVuc2l0eShkZW5zaXR5KSB7XG4gICAgICAgIHRoaXMuc2V0VW5pZm9ybShcInVEZW5zaXR5XCIgKyB0aGlzLmlkLCBkZW5zaXR5KTtcbiAgICAgICAgdGhpcy5kZW5zaXR5ID0gZXhwcl8xLm4ycChkZW5zaXR5KTtcbiAgICB9XG4gICAgLyoqIHNldHMgdGhlIHdlaWdodCAqL1xuICAgIHNldFdlaWdodCh3ZWlnaHQpIHtcbiAgICAgICAgdGhpcy5zZXRVbmlmb3JtKFwidVdlaWdodFwiICsgdGhpcy5pZCwgd2VpZ2h0KTtcbiAgICAgICAgdGhpcy53ZWlnaHQgPSBleHByXzEubjJwKHdlaWdodCk7XG4gICAgfVxuICAgIC8qKiBzZXRzIHRoZSBsaWdodCBwb3NpdGlvbiAqL1xuICAgIHNldExpZ2h0UG9zKGxpZ2h0UG9zKSB7XG4gICAgICAgIHRoaXMuc2V0VW5pZm9ybShcInVMaWdodFBvc1wiICsgdGhpcy5pZCwgbGlnaHRQb3MpO1xuICAgICAgICB0aGlzLmxpZ2h0UG9zID0gbGlnaHRQb3M7XG4gICAgfVxuICAgIC8vIHRoZXNlIG9ubHkgbWF0dGVyIHdoZW4geW91J3JlIHVzaW5nIGEgZGVwdGggYnVmZmVyIGFuZCBub3QgYW4gb2NjbHVzaW9uXG4gICAgLy8gYnVmZmVyIChhbHRob3VnaCByaWdodCBub3csIHlvdSdsbCBzdGlsbCBiZSBhYmxlIHRvIHNldCB0aGVtKVxuICAgIHNldFRocmVzaG9sZCh0aHJlc2hvbGQpIHtcbiAgICAgICAgdGhpcy5zZXRVbmlmb3JtKFwidVRocmVzaG9sZFwiICsgdGhpcy5pZCwgdGhyZXNob2xkKTtcbiAgICAgICAgdGhpcy50aHJlc2hvbGQgPSBleHByXzEubjJwKHRocmVzaG9sZCk7XG4gICAgfVxuICAgIHNldE5ld0NvbG9yKG5ld0NvbG9yKSB7XG4gICAgICAgIHRoaXMuc2V0VW5pZm9ybShcInVOZXdDb2xvclwiICsgdGhpcy5pZCwgbmV3Q29sb3IpO1xuICAgICAgICB0aGlzLm5ld0NvbG9yID0gbmV3Q29sb3I7XG4gICAgfVxufVxuZXhwb3J0cy5Hb2RSYXlzRXhwciA9IEdvZFJheXNFeHByO1xuLyoqXG4gKiBjcmVhdGUgYSBnb2RyYXlzIGV4cHJlc3Npb24gd2hpY2ggcmVxdWlyZXMgYW4gb2NjbHVzaW9uIG1hcDsgYWxsIHZhbHVlcyBhcmVcbiAqIG11dGFibGUgYnkgZGVmYXVsdFxuICogQHBhcmFtIG9wdGlvbnMgb2JqZWN0IHRoYXQgZGVmaW5lcyBnb2RyYXlzIHByb3BlcnRpZXMgKGhhcyBzYW5lIGRlZmF1bHRzKVxuICovXG5mdW5jdGlvbiBnb2RyYXlzKG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBuZXcgR29kUmF5c0V4cHIob3B0aW9ucy5jb2xvciwgZXhwcl8xLm4yZShvcHRpb25zLmV4cG9zdXJlKSwgZXhwcl8xLm4yZShvcHRpb25zLmRlY2F5KSwgZXhwcl8xLm4yZShvcHRpb25zLmRlbnNpdHkpLCBleHByXzEubjJlKG9wdGlvbnMud2VpZ2h0KSwgb3B0aW9ucy5saWdodFBvcywgb3B0aW9ucy5zYW1wbGVyTnVtLCBvcHRpb25zLmNvbnZlcnREZXB0aCA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgIDoge1xuICAgICAgICAgICAgdGhyZXNob2xkOiBleHByXzEubjJlKG9wdGlvbnMuY29udmVydERlcHRoLnRocmVzaG9sZCksXG4gICAgICAgICAgICBuZXdDb2xvcjogb3B0aW9ucy5jb252ZXJ0RGVwdGgubmV3Q29sb3IsXG4gICAgICAgIH0pO1xufVxuZXhwb3J0cy5nb2RyYXlzID0gZ29kcmF5cztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ncmFpbiA9IGV4cG9ydHMuR3JhaW5FeHByID0gdm9pZCAwO1xuY29uc3QgZ2xzbGZ1bmN0aW9uc18xID0gcmVxdWlyZShcIi4uL2dsc2xmdW5jdGlvbnNcIik7XG5jb25zdCBleHByXzEgPSByZXF1aXJlKFwiLi9leHByXCIpO1xuLy8gVE9ETyBjb25zaWRlciBnZXR0aW5nIHJpZCBvZiB0aGlzIHNpbmNlIGl0J3MgZWFzeSB0byBtYWtlIHlvdXIgb3duIHdpdGggYHJhbmRvbWAgYW5kIGBicmlnaHRuZXNzYFxuLyoqIGdyYWluIGV4cHJlc3Npb24gKi9cbmNsYXNzIEdyYWluRXhwciBleHRlbmRzIGV4cHJfMS5FeHByVmVjNCB7XG4gICAgY29uc3RydWN0b3IoZ3JhaW4pIHtcbiAgICAgICAgc3VwZXIoZXhwcl8xLnRhZyBgdmVjNCgoMS4wIC0gJHtncmFpbn0gKiByYW5kb20oZ2xfRnJhZ0Nvb3JkLnh5KSkgKiBnbF9GcmFnQ29sb3IucmdiLCBnbF9GcmFnQ29sb3IuYSk7YCwgW1widUdyYWluXCJdKTtcbiAgICAgICAgdGhpcy5ncmFpbiA9IGdyYWluO1xuICAgICAgICB0aGlzLmV4dGVybmFsRnVuY3MgPSBbZ2xzbGZ1bmN0aW9uc18xLmdsc2xGdW5jcy5yYW5kb21dO1xuICAgICAgICB0aGlzLm5lZWRzLmNlbnRlclNhbXBsZSA9IHRydWU7XG4gICAgfVxuICAgIC8qKiBzZXRzIHRoZSBncmFpbiBsZXZlbCAgKi9cbiAgICBzZXRHcmFpbihncmFpbikge1xuICAgICAgICB0aGlzLnNldFVuaWZvcm0oXCJ1R3JhaW5cIiArIHRoaXMuaWQsIGdyYWluKTtcbiAgICAgICAgdGhpcy5ncmFpbiA9IGV4cHJfMS5uMmUoZ3JhaW4pO1xuICAgIH1cbn1cbmV4cG9ydHMuR3JhaW5FeHByID0gR3JhaW5FeHByO1xuLyoqXG4gKiBjcmVhdGVzIGFuIGV4cHJlc3Npb24gdGhhdCBhZGRzIHJhbmRvbSBncmFpblxuICogQHBhcmFtIHZhbCBob3cgbXVjaCB0aGUgZ3JhaW4gc2hvdWxkIGltcGFjdCB0aGUgaW1hZ2UgKDAgdG8gMSBpcyByZWFzb25hYmxlKVxuICovXG5mdW5jdGlvbiBncmFpbih2YWwpIHtcbiAgICByZXR1cm4gbmV3IEdyYWluRXhwcihleHByXzEubjJlKHZhbCkpO1xufVxuZXhwb3J0cy5ncmFpbiA9IGdyYWluO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmhzdjJyZ2IgPSBleHBvcnRzLkhTVlRvUkdCRXhwciA9IHZvaWQgMDtcbmNvbnN0IGV4cHJfMSA9IHJlcXVpcmUoXCIuL2V4cHJcIik7XG5jb25zdCBnbHNsZnVuY3Rpb25zXzEgPSByZXF1aXJlKFwiLi4vZ2xzbGZ1bmN0aW9uc1wiKTtcbi8qKiBIU1YgdG8gUkdCIGV4cHJlc3Npb24gKi9cbmNsYXNzIEhTVlRvUkdCRXhwciBleHRlbmRzIGV4cHJfMS5FeHByVmVjNCB7XG4gICAgY29uc3RydWN0b3IoY29sb3IpIHtcbiAgICAgICAgc3VwZXIoZXhwcl8xLnRhZyBgaHN2MnJnYigke2NvbG9yfSlgLCBbXCJ1SFNWQ29sXCJdKTtcbiAgICAgICAgdGhpcy5jb2xvciA9IGNvbG9yO1xuICAgICAgICB0aGlzLmV4dGVybmFsRnVuY3MgPSBbZ2xzbGZ1bmN0aW9uc18xLmdsc2xGdW5jcy5oc3YycmdiXTtcbiAgICB9XG4gICAgLyoqIHNldHMgdGhlIGNvbG9yIHRvIGNvbnZlcnQgKi9cbiAgICBzZXRDb2xvcihjb2xvcikge1xuICAgICAgICB0aGlzLnNldFVuaWZvcm0oXCJ1SFNWQ29sXCIsIGNvbG9yKTtcbiAgICAgICAgdGhpcy5jb2xvciA9IGNvbG9yO1xuICAgIH1cbn1cbmV4cG9ydHMuSFNWVG9SR0JFeHByID0gSFNWVG9SR0JFeHByO1xuLyoqXG4gKiBjb252ZXJ0cyBhIGNvbG9yICh3aXRoIGFuIGFscGhhIGNvbXBvbWVudCkgZnJvbSBoc3YgdG8gcmdiXG4gKiBAcGFyYW0gY29sIHRoZSBoc3ZhIGNvbG9yIHRvIGNvbnZlcnQgdG8gcmdiYVxuICovXG5mdW5jdGlvbiBoc3YycmdiKGNvbCkge1xuICAgIHJldHVybiBuZXcgSFNWVG9SR0JFeHByKGNvbCk7XG59XG5leHBvcnRzLmhzdjJyZ2IgPSBoc3YycmdiO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmludmVydCA9IGV4cG9ydHMuSW52ZXJ0RXhwciA9IHZvaWQgMDtcbmNvbnN0IGV4cHJfMSA9IHJlcXVpcmUoXCIuL2V4cHJcIik7XG5jb25zdCBnbHNsZnVuY3Rpb25zXzEgPSByZXF1aXJlKFwiLi4vZ2xzbGZ1bmN0aW9uc1wiKTtcbi8qKiBpbnZlcnQgZXhwcmVzc2lvbiAqL1xuY2xhc3MgSW52ZXJ0RXhwciBleHRlbmRzIGV4cHJfMS5FeHByVmVjNCB7XG4gICAgY29uc3RydWN0b3IoY29sb3IpIHtcbiAgICAgICAgc3VwZXIoZXhwcl8xLnRhZyBgaW52ZXJ0KCR7Y29sb3J9KWAsIFtcInVDb2xvclwiXSk7XG4gICAgICAgIHRoaXMuZXh0ZXJuYWxGdW5jcyA9IFtnbHNsZnVuY3Rpb25zXzEuZ2xzbEZ1bmNzLmludmVydF07XG4gICAgICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcbiAgICB9XG4gICAgLyoqIHNldHMgdGhlIGNvbG9yICovXG4gICAgc2V0Q29sb3IoY29sb3IpIHtcbiAgICAgICAgdGhpcy5zZXRVbmlmb3JtKFwidUNvbG9yXCIsIGNvbG9yKTtcbiAgICAgICAgdGhpcy5jb2xvciA9IGNvbG9yO1xuICAgIH1cbn1cbmV4cG9ydHMuSW52ZXJ0RXhwciA9IEludmVydEV4cHI7XG4vKipcbiAqIGNyZWF0ZXMgYW4gZXhwcmVzc2lvbiB0aGF0IGludmVydHMgdGhlIGNvbG9yLCBrZWVwaW5nIHRoZSBvcmlnaW5hbCBhbHBoYVxuICovXG5mdW5jdGlvbiBpbnZlcnQoY29sKSB7XG4gICAgcmV0dXJuIG5ldyBJbnZlcnRFeHByKGNvbCk7XG59XG5leHBvcnRzLmludmVydCA9IGludmVydDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5sZW4gPSBleHBvcnRzLkxlbkV4cHIgPSB2b2lkIDA7XG5jb25zdCBleHByXzEgPSByZXF1aXJlKFwiLi9leHByXCIpO1xuLyoqIGxlbmd0aCBleHByZXNzaW9uICovXG5jbGFzcyBMZW5FeHByIGV4dGVuZHMgZXhwcl8xLkV4cHJGbG9hdCB7XG4gICAgY29uc3RydWN0b3IodmVjKSB7XG4gICAgICAgIHN1cGVyKGV4cHJfMS50YWcgYGxlbmd0aCgke3ZlY30pYCwgW1widVZlY1wiXSk7XG4gICAgICAgIHRoaXMudmVjID0gdmVjO1xuICAgIH1cbiAgICBzZXRWZWModmVjKSB7XG4gICAgICAgIHRoaXMuc2V0VW5pZm9ybShcInVWZWNcIiArIHRoaXMuaWQsIHZlYyk7XG4gICAgICAgIHRoaXMudmVjID0gdmVjO1xuICAgIH1cbn1cbmV4cG9ydHMuTGVuRXhwciA9IExlbkV4cHI7XG4vKiogY3JlYXRlcyBhbiBleHByZWVzc2lvbiB0aGF0IGNhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiBhIHZlY3RvciAqL1xuZnVuY3Rpb24gbGVuKHZlYykge1xuICAgIHJldHVybiBuZXcgTGVuRXhwcih2ZWMpO1xufVxuZXhwb3J0cy5sZW4gPSBsZW47XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubW9ub2Nocm9tZSA9IGV4cG9ydHMuTW9ub2Nocm9tZUV4cHIgPSB2b2lkIDA7XG5jb25zdCBleHByXzEgPSByZXF1aXJlKFwiLi9leHByXCIpO1xuY29uc3QgZ2xzbGZ1bmN0aW9uc18xID0gcmVxdWlyZShcIi4uL2dsc2xmdW5jdGlvbnNcIik7XG4vKiogbW9ub2Nocm9tZSBleHByZXNzaW9uICovXG5jbGFzcyBNb25vY2hyb21lRXhwciBleHRlbmRzIGV4cHJfMS5FeHByVmVjNCB7XG4gICAgY29uc3RydWN0b3IoY29sb3IpIHtcbiAgICAgICAgc3VwZXIoZXhwcl8xLnRhZyBgbW9ub2Nocm9tZSgke2NvbG9yfSlgLCBbXCJ1Q29sb3JcIl0pO1xuICAgICAgICB0aGlzLmV4dGVybmFsRnVuY3MgPSBbZ2xzbGZ1bmN0aW9uc18xLmdsc2xGdW5jcy5tb25vY2hyb21lXTtcbiAgICAgICAgdGhpcy5jb2xvciA9IGNvbG9yO1xuICAgIH1cbiAgICAvKiogc2V0cyB0aGUgY29sb3IgKi9cbiAgICBzZXRDb2xvcihjb2xvcikge1xuICAgICAgICB0aGlzLnNldFVuaWZvcm0oXCJ1Q29sb3JcIiwgY29sb3IpO1xuICAgICAgICB0aGlzLmNvbG9yID0gY29sb3I7XG4gICAgfVxufVxuZXhwb3J0cy5Nb25vY2hyb21lRXhwciA9IE1vbm9jaHJvbWVFeHByO1xuLyoqXG4gKiBjcmVhdGVzIGFuIGV4cHJlc3Npb24gdGhhdCBjb252ZXJ0cyBhIGNvbG9yIGludG8gZ3JheXNjYWxlLCBrZWVwaW5nIHRoZVxuICogb3JpZ2luYWwgYWxwaGFcbiAqL1xuZnVuY3Rpb24gbW9ub2Nocm9tZShjb2wpIHtcbiAgICByZXR1cm4gbmV3IE1vbm9jaHJvbWVFeHByKGNvbCk7XG59XG5leHBvcnRzLm1vbm9jaHJvbWUgPSBtb25vY2hyb21lO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm1vdGlvbmJsdXIgPSBleHBvcnRzLk1vdGlvbkJsdXJMb29wID0gdm9pZCAwO1xuY29uc3QgbWVyZ2VwYXNzXzEgPSByZXF1aXJlKFwiLi4vbWVyZ2VwYXNzXCIpO1xuY29uc3QgY2hhbm5lbHNhbXBsZWV4cHJfMSA9IHJlcXVpcmUoXCIuL2NoYW5uZWxzYW1wbGVleHByXCIpO1xuY29uc3QgZXhwcl8xID0gcmVxdWlyZShcIi4vZXhwclwiKTtcbmNvbnN0IGZyYWdjb2xvcmV4cHJfMSA9IHJlcXVpcmUoXCIuL2ZyYWdjb2xvcmV4cHJcIik7XG5jb25zdCBvcGV4cHJfMSA9IHJlcXVpcmUoXCIuL29wZXhwclwiKTtcbmNvbnN0IHNldGNvbG9yZXhwcl8xID0gcmVxdWlyZShcIi4vc2V0Y29sb3JleHByXCIpO1xuLyoqIGZyYW1lIGF2ZXJhZ2luZyBtb3Rpb24gYmx1ciBsb29wICovXG5jbGFzcyBNb3Rpb25CbHVyTG9vcCBleHRlbmRzIG1lcmdlcGFzc18xLkVmZmVjdExvb3Age1xuICAgIGNvbnN0cnVjdG9yKHRhcmdldCA9IDAsIHBlcnNpc3RlbmNlID0gZXhwcl8xLmZsb2F0KGV4cHJfMS5tdXQoMC4zKSkpIHtcbiAgICAgICAgY29uc3QgY29sMSA9IG9wZXhwcl8xLm9wKGNoYW5uZWxzYW1wbGVleHByXzEuY2hhbm5lbCh0YXJnZXQpLCBcIipcIiwgcGVyc2lzdGVuY2UpO1xuICAgICAgICBjb25zdCBjb2wyID0gb3BleHByXzEub3AoZnJhZ2NvbG9yZXhwcl8xLmZjb2xvcigpLCBcIipcIiwgb3BleHByXzEub3AoMSwgXCItXCIsIHBlcnNpc3RlbmNlKSk7XG4gICAgICAgIGNvbnN0IGVmZmVjdHMgPSBbXG4gICAgICAgICAgICBtZXJnZXBhc3NfMS5sb29wKFtzZXRjb2xvcmV4cHJfMS5zZXRjb2xvcihvcGV4cHJfMS5vcChjb2wxLCBcIitcIiwgY29sMikpXSkudGFyZ2V0KHRhcmdldCksXG4gICAgICAgICAgICBjaGFubmVsc2FtcGxlZXhwcl8xLmNoYW5uZWwodGFyZ2V0KSxcbiAgICAgICAgXTtcbiAgICAgICAgc3VwZXIoZWZmZWN0cywgeyBudW06IDEgfSk7XG4gICAgICAgIHRoaXMucGVyc2lzdGVuY2UgPSBwZXJzaXN0ZW5jZTtcbiAgICB9XG4gICAgLyoqIHNldCB0aGUgcGVyc2lzdGVuY2UgKGtlZXAgYmV0d2VlbiAwIGFuZCAxKSAqL1xuICAgIHNldFBlcnNpc3RlbmNlKGZsb2F0KSB7XG4gICAgICAgIGlmICghKHRoaXMucGVyc2lzdGVuY2UgaW5zdGFuY2VvZiBleHByXzEuQmFzaWNGbG9hdCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwZXJzaXN0ZW5jZSBleHByZXNzaW9uIG5vdCBiYXNpYyBmbG9hdFwiKTtcbiAgICAgICAgdGhpcy5wZXJzaXN0ZW5jZS5zZXRWYWwoZmxvYXQpO1xuICAgIH1cbn1cbmV4cG9ydHMuTW90aW9uQmx1ckxvb3AgPSBNb3Rpb25CbHVyTG9vcDtcbi8qKlxuICogY3JlYXRlcyBhIGZyYW1lIGF2ZXJhZ2luZyBtb3Rpb24gYmx1ciBlZmZlY3RcbiAqIEBwYXJhbSB0YXJnZXQgdGhlIGNoYW5uZWwgd2hlcmUgeW91ciBhY2N1bXVsYXRpb24gYnVmZmVyIGlzIChkZWZhdWx0cyB0byAwLFxuICogd2hpY2ggeW91IG1pZ2h0IGJlIHVzaW5nIGZvciBzb21ldGhpbmcgbGlrZSB0aGUgZGVwdGggdGV4dHVyZSwgc28gYmUgc3VyZSB0b1xuICogY2hhbmdlIHRoaXMgdG8gc3VpdCB5b3VyIG5lZWRzKVxuICogQHBhcmFtIHBlcnNpc3RlbmNlIGNsb3NlIHRvIDAgaXMgbW9yZSBnaG9zdGx5LCBhbmQgY2xvc2UgdG8gMSBpcyBuZWFybHkgbm9cbiAqIG1vdGlvbiBibHVyIGF0IGFsbCAoZGVmYXVsdHMgdG8gMC4zKVxuICovXG5mdW5jdGlvbiBtb3Rpb25ibHVyKHRhcmdldCwgcGVyc2lzdGVuY2UpIHtcbiAgICByZXR1cm4gbmV3IE1vdGlvbkJsdXJMb29wKHRhcmdldCwgZXhwcl8xLm4yZShwZXJzaXN0ZW5jZSkpO1xufVxuZXhwb3J0cy5tb3Rpb25ibHVyID0gbW90aW9uYmx1cjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5tb3VzZSA9IGV4cG9ydHMuTW91c2VFeHByID0gdm9pZCAwO1xuY29uc3QgZXhwcl8xID0gcmVxdWlyZShcIi4vZXhwclwiKTtcbi8qKiBtb3VzZSBwb3NpdGlvbiBleHByZXNzaW9uICovXG5jbGFzcyBNb3VzZUV4cHIgZXh0ZW5kcyBleHByXzEuRXhwclZlYzIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihleHByXzEudGFnIGB1TW91c2VgLCBbXSk7XG4gICAgICAgIHRoaXMubmVlZHMubW91c2VVbmlmb3JtID0gdHJ1ZTtcbiAgICB9XG59XG5leHBvcnRzLk1vdXNlRXhwciA9IE1vdXNlRXhwcjtcbi8qKlxuICogY3JlYXRlcyBhbiBleHByZXNzaW9uIHRoYXQgZXZhbHVhdGVzIHRvIGEgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgbW91c2VcbiAqIHBvc2l0aW9uIGluIHBpeGVsc1xuICovXG5mdW5jdGlvbiBtb3VzZSgpIHtcbiAgICByZXR1cm4gbmV3IE1vdXNlRXhwcigpO1xufVxuZXhwb3J0cy5tb3VzZSA9IG1vdXNlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNlbnRlciA9IGV4cG9ydHMuTm9ybUNlbnRlckZyYWdDb29yZEV4cHIgPSB2b2lkIDA7XG5jb25zdCBleHByXzEgPSByZXF1aXJlKFwiLi9leHByXCIpO1xuLyoqIG5vcm1hbGl6ZWQgY2VudGVyZWQgZnJhZyBjb29yZCBleHByZXNzaW9uICovXG5jbGFzcyBOb3JtQ2VudGVyRnJhZ0Nvb3JkRXhwciBleHRlbmRzIGV4cHJfMS5FeHByVmVjMiB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKGV4cHJfMS50YWcgYChnbF9GcmFnQ29vcmQueHkgLyB1UmVzb2x1dGlvbiAtIDAuNSlgLCBbXSk7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3JtQ2VudGVyRnJhZ0Nvb3JkRXhwciA9IE5vcm1DZW50ZXJGcmFnQ29vcmRFeHByO1xuLyoqXG4gKiBjcmVhdGVzIGFuIGV4cHJlc3Npb24gdGhhdCBjYWxjdWxhdGVzIHRoZSBub3JtYWxpemVkIGNlbnRlcmVkIGNvb3JkXG4gKiAoY29vcmRpbmF0ZXMgcmFuZ2UgZnJvbSAtMC41IHRvIDAuNSlcbiAqL1xuZnVuY3Rpb24gY2VudGVyKCkge1xuICAgIHJldHVybiBuZXcgTm9ybUNlbnRlckZyYWdDb29yZEV4cHIoKTtcbn1cbmV4cG9ydHMuY2VudGVyID0gY2VudGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm5vcm0gPSBleHBvcnRzLk5vcm1FeHByID0gdm9pZCAwO1xuY29uc3QgZXhwcl8xID0gcmVxdWlyZShcIi4vZXhwclwiKTtcbi8qKiBub3JtYWxpemUgZXhwcmVzc2lvbiAqL1xuY2xhc3MgTm9ybUV4cHIgZXh0ZW5kcyBleHByXzEuT3BlcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKHZlYykge1xuICAgICAgICBzdXBlcih2ZWMsIGV4cHJfMS50YWcgYG5vcm1hbGl6ZSgke3ZlY30pYCwgW1widVZlY1wiXSk7XG4gICAgICAgIHRoaXMudmVjID0gdmVjO1xuICAgIH1cbiAgICAvKiogc2V0cyB0aGUgdmVjIHRvIG5vcm1hbGl6ZSAqL1xuICAgIHNldFZlYyh2ZWMpIHtcbiAgICAgICAgdGhpcy5zZXRVbmlmb3JtKFwidVZlY1wiICsgdGhpcy5pZCwgdmVjKTtcbiAgICAgICAgdGhpcy52ZWMgPSB2ZWM7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3JtRXhwciA9IE5vcm1FeHByO1xuLyoqIGNyZWF0ZXMgYW4gZXhwcmVzc2lvbiB0aGF0IG5vcm1hbGl6ZXMgYSB2ZWN0b3IgKi9cbmZ1bmN0aW9uIG5vcm0odmVjKSB7XG4gICAgcmV0dXJuIG5ldyBOb3JtRXhwcih2ZWMpO1xufVxuZXhwb3J0cy5ub3JtID0gbm9ybTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wb3MgPSBleHBvcnRzLk5vcm1GcmFnQ29vcmRFeHByID0gdm9pZCAwO1xuY29uc3QgZXhwcl8xID0gcmVxdWlyZShcIi4vZXhwclwiKTtcbi8qKiBub3JtYWxpemVkIGZyYWcgY29vcmQgZXhwcmVzc2lvbiAqL1xuY2xhc3MgTm9ybUZyYWdDb29yZEV4cHIgZXh0ZW5kcyBleHByXzEuRXhwclZlYzIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihleHByXzEudGFnIGBnbF9GcmFnQ29vcmQueHkgLyB1UmVzb2x1dGlvbmAsIFtdKTtcbiAgICB9XG59XG5leHBvcnRzLk5vcm1GcmFnQ29vcmRFeHByID0gTm9ybUZyYWdDb29yZEV4cHI7XG4vKipcbiAqIGNyZWF0ZXMgYW4gZXhwcmVzc2lvbiB0aGF0IGNhbGN1bGF0ZXMgdGhlIG5vcm1hbGl6ZWQgZnJhZyBjb29yZCAoY29vcmRpbmF0ZXNcbiAqIHJhbmdlIGZyb20gMCB0byAxKVxuICovXG5mdW5jdGlvbiBwb3MoKSB7XG4gICAgcmV0dXJuIG5ldyBOb3JtRnJhZ0Nvb3JkRXhwcigpO1xufVxuZXhwb3J0cy5wb3MgPSBwb3M7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubm1vdXNlID0gZXhwb3J0cy5Ob3JtTW91c2VFeHByID0gdm9pZCAwO1xuY29uc3QgZXhwcl8xID0gcmVxdWlyZShcIi4vZXhwclwiKTtcbi8qKiBub3JtYWxpemVkIG1vdXNlIHBvc2l0aW9uIGV4cHJlc3Npb24gKi9cbmNsYXNzIE5vcm1Nb3VzZUV4cHIgZXh0ZW5kcyBleHByXzEuRXhwclZlYzIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihleHByXzEudGFnIGAodU1vdXNlIC8gdVJlc29sdXRpb24ueHkpYCwgW10pO1xuICAgICAgICB0aGlzLm5lZWRzLm1vdXNlVW5pZm9ybSA9IHRydWU7XG4gICAgfVxufVxuZXhwb3J0cy5Ob3JtTW91c2VFeHByID0gTm9ybU1vdXNlRXhwcjtcbi8qKlxuICogY3JlYXRlcyBhbiBleHByZXNzaW9uIHRoYXQgY2FsY3VsYXRlcyB0aGUgbm9ybWFsaXplZCBtb3VzZSBwb3NpdGlvblxuICogKGNvb3JkaW5hdGVzIHJhbmdlIGZyb20gMCB0byAxKVxuICovXG5mdW5jdGlvbiBubW91c2UoKSB7XG4gICAgcmV0dXJuIG5ldyBOb3JtTW91c2VFeHByKCk7XG59XG5leHBvcnRzLm5tb3VzZSA9IG5tb3VzZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5vcCA9IGV4cG9ydHMuT3BFeHByID0gdm9pZCAwO1xuY29uc3QgZXhwcl8xID0gcmVxdWlyZShcIi4vZXhwclwiKTtcbmZ1bmN0aW9uIGdlbk9wU291cmNlTGlzdChsZWZ0LCBvcCwgcmlnaHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzZWN0aW9uczogW1wiKFwiLCBgICR7b3B9IGAsIFwiKVwiXSxcbiAgICAgICAgdmFsdWVzOiBbbGVmdCwgcmlnaHRdLFxuICAgIH07XG59XG5jbGFzcyBPcEV4cHIgZXh0ZW5kcyBleHByXzEuT3BlcmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGxlZnQsIG9wLCByaWdodCkge1xuICAgICAgICBzdXBlcihsZWZ0LCBnZW5PcFNvdXJjZUxpc3QobGVmdCwgb3AsIHJpZ2h0KSwgW1widUxlZnRcIiwgXCJ1UmlnaHRcIl0pO1xuICAgICAgICB0aGlzLmxlZnQgPSBsZWZ0O1xuICAgICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQ7XG4gICAgfVxuICAgIHNldExlZnQobGVmdCkge1xuICAgICAgICB0aGlzLnNldFVuaWZvcm0oXCJ1TGVmdFwiICsgdGhpcy5pZCwgbGVmdCk7XG4gICAgICAgIHRoaXMubGVmdCA9IGV4cHJfMS53cmFwSW5WYWx1ZShsZWZ0KTtcbiAgICB9XG4gICAgc2V0UmlnaHQocmlnaHQpIHtcbiAgICAgICAgdGhpcy5zZXRVbmlmb3JtKFwidVJpZ2h0XCIgKyB0aGlzLmlkLCByaWdodCk7XG4gICAgICAgIHRoaXMucmlnaHQgPSBleHByXzEud3JhcEluVmFsdWUocmlnaHQpO1xuICAgIH1cbn1cbmV4cG9ydHMuT3BFeHByID0gT3BFeHByO1xuLy8gaW1wbGVtZW50YXRpb25cbi8qKlxuICogY3JlYXRlcyBhbiBhcml0aG1ldGljIG9wZXJhdG9yIGV4cHJlc3Npb25cbiAqIEBwYXJhbSBsZWZ0IGV4cHJlc3Npb24gbGVmdCBvZiBvcGVyYXRvclxuICogQHBhcmFtIG9wIHN0cmluZyByZXByZXNlbnRpbmcgYXJpdGhtZXRpYyBvcGVyYXRvclxuICogQHBhcmFtIHJpZ2h0IGV4cHJlc3Npb24gcmlnaHQgb2Ygb3BlcmF0b3JcbiAqL1xuZnVuY3Rpb24gb3AobGVmdCwgb3AsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIG5ldyBPcEV4cHIoZXhwcl8xLndyYXBJblZhbHVlKGxlZnQpLCBvcCwgZXhwcl8xLndyYXBJblZhbHVlKHJpZ2h0KSk7XG59XG5leHBvcnRzLm9wID0gb3A7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZnJhY3RhbGl6ZSA9IGV4cG9ydHMucGVybGluID0gZXhwb3J0cy5QZXJsaW5FeHByID0gdm9pZCAwO1xuY29uc3QgZ2xzbGZ1bmN0aW9uc18xID0gcmVxdWlyZShcIi4uL2dsc2xmdW5jdGlvbnNcIik7XG5jb25zdCBleHByXzEgPSByZXF1aXJlKFwiLi9leHByXCIpO1xuY29uc3Qgb3BleHByXzEgPSByZXF1aXJlKFwiLi9vcGV4cHJcIik7XG4vKiogUGVybGluIG5vaXNlIGV4cHJlc3Npb24gKi9cbmNsYXNzIFBlcmxpbkV4cHIgZXh0ZW5kcyBleHByXzEuRXhwckZsb2F0IHtcbiAgICAvLyBUT0RPIGluY2x1ZGUgYSBkZWZhdWx0XG4gICAgY29uc3RydWN0b3IocG9zKSB7XG4gICAgICAgIHN1cGVyKGV4cHJfMS50YWcgYGdyYWRpZW50bm9pc2UoJHtwb3N9KWAsIFtcInVQb3NcIl0pO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5leHRlcm5hbEZ1bmNzID0gW2dsc2xmdW5jdGlvbnNfMS5nbHNsRnVuY3MucmFuZG9tMiwgZ2xzbGZ1bmN0aW9uc18xLmdsc2xGdW5jcy5ncmFkaWVudG5vaXNlXTtcbiAgICB9XG4gICAgLyoqIHNldHMgdGhlIHBvc2l0aW9uIHRvIGNhbGN1bGF0ZSBub2lzZSB2YWx1ZSBvZiAqL1xuICAgIHNldFBvcyhwb3MpIHtcbiAgICAgICAgdGhpcy5zZXRVbmlmb3JtKFwidVBvc1wiLCBwb3MpO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICB9XG59XG5leHBvcnRzLlBlcmxpbkV4cHIgPSBQZXJsaW5FeHByO1xuLyoqXG4gKiBjcmVhdGVzIGEgcGVybGluIG5vaXNlIGV4cHJlc3Npb247IHZhbHVlcyByYW5nZSBmcm9tIC0xIHRvIDEgYnV0IHRoZXkgdGVuZFxuICogdG8gYmUgZ3JheWVyIHRoYW4gdGhlIFtbc2ltcGxleF1dIGltcGxlbWVudGF0aW9uXG4gKiBAcGFyYW0gcG9zIHBvc2l0aW9uXG4gKi9cbmZ1bmN0aW9uIHBlcmxpbihwb3MpIHtcbiAgICByZXR1cm4gbmV3IFBlcmxpbkV4cHIocG9zKTtcbn1cbmV4cG9ydHMucGVybGluID0gcGVybGluO1xuLyoqXG4gKiB0YWtlIGFueSBmdW5jdGlvbiBmcm9tIGEgcG9zaXRpb24gdG8gYSBmbG9hdCwgYW5kIHJlcGVhdGVkbHkgc3VtIGNhbGxzIHRvIGl0XG4gKiB3aXRoIGRvdWJsaW5nIGZyZXF1ZW5jeSBhbmQgaGFsdmluZyBhbXBsaXR1ZGUgKHdvcmtzIHdlbGwgd2l0aCBbW3NpbXBsZXhdXVxuICogYW5kIFtbcGVybGluXV0pXG4gKiBAcGFyYW0gcG9zIHBvc2l0aW9uXG4gKiBAcGFyYW0gb2N0YXZlcyBob3cgbWFueSBsYXllcnMgZGVlcCB0byBtYWtlIHRoZSBmcmFjdGFsXG4gKiBAcGFyYW0gZnVuYyB0aGUgZnVuY3Rpb24gdG8gZnJhY3RhbGl6ZVxuICovXG5mdW5jdGlvbiBmcmFjdGFsaXplKHBvcywgb2N0YXZlcywgZnVuYykge1xuICAgIGlmIChvY3RhdmVzIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwib2N0YXZlcyBjYW4ndCBiZSA8IDBcIik7XG4gICAgY29uc3QgcmVjdXJzZSA9IChwb3MsIHNpemUsIGxldmVsKSA9PiB7XG4gICAgICAgIGlmIChsZXZlbCA8PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGV4cHJfMS5wZmxvYXQoMCk7XG4gICAgICAgIHJldHVybiBvcGV4cHJfMS5vcChmdW5jKG9wZXhwcl8xLm9wKHBvcywgXCIvXCIsIHNpemUgKiAyKSksIFwiK1wiLCByZWN1cnNlKHBvcywgc2l6ZSAvIDIsIGxldmVsIC0gMSkpO1xuICAgIH07XG4gICAgcmV0dXJuIHJlY3Vyc2UocG9zLCAwLjUsIG9jdGF2ZXMpO1xufVxuZXhwb3J0cy5mcmFjdGFsaXplID0gZnJhY3RhbGl6ZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wYmx1ciA9IGV4cG9ydHMuUG93ZXJCbHVyTG9vcCA9IHZvaWQgMDtcbmNvbnN0IG1lcmdlcGFzc18xID0gcmVxdWlyZShcIi4uL21lcmdlcGFzc1wiKTtcbmNvbnN0IGJsdXJleHByXzEgPSByZXF1aXJlKFwiLi9ibHVyZXhwclwiKTtcbmNvbnN0IHZlY2V4cHJzXzEgPSByZXF1aXJlKFwiLi92ZWNleHByc1wiKTtcbmNvbnN0IGV4cHJfMSA9IHJlcXVpcmUoXCIuL2V4cHJcIik7XG5jb25zdCBiYXNlTG9nID0gKHgsIHkpID0+IE1hdGgubG9nKHkpIC8gTWF0aC5sb2coeCk7XG4vLyBUT0RPIGNvbnNpZGVyIGdldHRpbmcgcmlkIG9mIHRoaXMsIGFzIGl0IHByZXR0eSBtdWNoIG5ldmVyIGxvb2tzIGdvb2Rcbi8qKiBwb3dlciBibHVyIGxvb3AgKi9cbmNsYXNzIFBvd2VyQmx1ckxvb3AgZXh0ZW5kcyBtZXJnZXBhc3NfMS5FZmZlY3RMb29wIHtcbiAgICBjb25zdHJ1Y3RvcihzaXplKSB7XG4gICAgICAgIGNvbnN0IHNpZGUgPSBibHVyZXhwcl8xLmdhdXNzKGV4cHJfMS5tdXQodmVjZXhwcnNfMS5wdmVjMihzaXplLCAwKSkpO1xuICAgICAgICBjb25zdCB1cCA9IGJsdXJleHByXzEuZ2F1c3MoZXhwcl8xLm11dCh2ZWNleHByc18xLnB2ZWMyKDAsIHNpemUpKSk7XG4gICAgICAgIGNvbnN0IHJlcHMgPSBNYXRoLmNlaWwoYmFzZUxvZygyLCBzaXplKSk7XG4gICAgICAgIHN1cGVyKFtzaWRlLCB1cF0sIHtcbiAgICAgICAgICAgIG51bTogcmVwcyArIDEsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgICAgICB0aGlzLmxvb3BJbmZvLmZ1bmMgPSAoaSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSB0aGlzLnNpemUgLyBNYXRoLnBvdygyLCBpKTtcbiAgICAgICAgICAgIHVwLnNldERpcmVjdGlvbih2ZWNleHByc18xLnB2ZWMyKDAsIGRpc3RhbmNlKSk7XG4gICAgICAgICAgICBzaWRlLnNldERpcmVjdGlvbih2ZWNleHByc18xLnB2ZWMyKGRpc3RhbmNlLCAwKSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKiBzZXRzIHRoZSBzaXplIG9mIHRoZSByYWRpdXMgKi9cbiAgICBzZXRTaXplKHNpemUpIHtcbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICAgICAgdGhpcy5sb29wSW5mby5udW0gPSBNYXRoLmNlaWwoYmFzZUxvZygyLCBzaXplKSk7XG4gICAgfVxufVxuZXhwb3J0cy5Qb3dlckJsdXJMb29wID0gUG93ZXJCbHVyTG9vcDtcbi8qKlxuICogZmFzdCBhcHByb3hpbWF0ZSBibHVyIGZvciBsYXJnZSBibHVyIHJhZGl1cyB0aGF0IG1pZ2h0IGxvb2sgZ29vZCBpbiBzb21lIGNhc2VzXG4gKiBAcGFyYW0gc2l6ZSB0aGUgcmFkaXVzIG9mIHRoZSBibHVyXG4gKi9cbmZ1bmN0aW9uIHBibHVyKHNpemUpIHtcbiAgICByZXR1cm4gbmV3IFBvd2VyQmx1ckxvb3Aoc2l6ZSk7XG59XG5leHBvcnRzLnBibHVyID0gcGJsdXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmFuZG9tID0gZXhwb3J0cy5SYW5kb21FeHByID0gdm9pZCAwO1xuY29uc3QgZ2xzbGZ1bmN0aW9uc18xID0gcmVxdWlyZShcIi4uL2dsc2xmdW5jdGlvbnNcIik7XG5jb25zdCBleHByXzEgPSByZXF1aXJlKFwiLi9leHByXCIpO1xuY29uc3Qgbm9ybWZyYWdjb29yZGV4cHJfMSA9IHJlcXVpcmUoXCIuL25vcm1mcmFnY29vcmRleHByXCIpO1xuLyoqIHBzdWVkb3JhbmRvbSBudW1iZXIgZXhwcmVzc2lvbiAqL1xuY2xhc3MgUmFuZG9tRXhwciBleHRlbmRzIGV4cHJfMS5FeHByRmxvYXQge1xuICAgIGNvbnN0cnVjdG9yKHNlZWQgPSBub3JtZnJhZ2Nvb3JkZXhwcl8xLnBvcygpKSB7XG4gICAgICAgIHN1cGVyKGV4cHJfMS50YWcgYHJhbmRvbSgke3NlZWR9KWAsIFtcInVTZWVkXCJdKTtcbiAgICAgICAgdGhpcy5zZWVkID0gc2VlZDtcbiAgICAgICAgdGhpcy5leHRlcm5hbEZ1bmNzID0gW2dsc2xmdW5jdGlvbnNfMS5nbHNsRnVuY3MucmFuZG9tXTtcbiAgICB9XG4gICAgLyoqIHNldHMgdGhlIHNlZWQgKHZhcnkgdGhpcyBvdmVyIHRpbWUgdG8gZ2V0IGEgbW92aW5nIGVmZmVjdCkgKi9cbiAgICBzZXRTZWVkKHNlZWQpIHtcbiAgICAgICAgdGhpcy5zZXRVbmlmb3JtKFwidVNlZWRcIiwgc2VlZCk7XG4gICAgICAgIHRoaXMuc2VlZCA9IHNlZWQ7XG4gICAgfVxufVxuZXhwb3J0cy5SYW5kb21FeHByID0gUmFuZG9tRXhwcjtcbi8qKlxuICogY3JlYXRlcyBleHByZXNzaW9uIHRoYXQgZXZhbHVhdGVzIHRvIGEgcHNldWRvcmFuZG9tIG51bWJlciBiZXR3ZWVuIDAgYW5kIDFcbiAqIEBwYXJhbSBzZWVkIHZlYzIgdG8gdG8gc2VlZCB0aGUgcmFuZG9tIG51bWJlciAoZGVmYXVsdHMgdG8gdGhlIG5vcm1hbGl6ZWRcbiAqIGZyYWcgY29vcmQpXG4gKi9cbmZ1bmN0aW9uIHJhbmRvbShzZWVkKSB7XG4gICAgcmV0dXJuIG5ldyBSYW5kb21FeHByKHNlZWQpO1xufVxuZXhwb3J0cy5yYW5kb20gPSByYW5kb207XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVzb2x1dGlvbiA9IGV4cG9ydHMuUmVzb2x1dGlvbkV4cHIgPSB2b2lkIDA7XG5jb25zdCBleHByXzEgPSByZXF1aXJlKFwiLi9leHByXCIpO1xuLyoqIHJlc29sdXRpb24gZXhwcmVzc2lvbiAqL1xuY2xhc3MgUmVzb2x1dGlvbkV4cHIgZXh0ZW5kcyBleHByXzEuRXhwclZlYzIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihleHByXzEudGFnIGB1UmVzb2x1dGlvbmAsIFtdKTtcbiAgICB9XG59XG5leHBvcnRzLlJlc29sdXRpb25FeHByID0gUmVzb2x1dGlvbkV4cHI7XG4vKiogY3JlYXRlcyBhbiBleHByZXNzaW9uIHRoYXQgZXZhbHVhdGVzIHRvIGEgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgcmVzb2x1dGlvbiAqL1xuZnVuY3Rpb24gcmVzb2x1dGlvbigpIHtcbiAgICByZXR1cm4gbmV3IFJlc29sdXRpb25FeHByKCk7XG59XG5leHBvcnRzLnJlc29sdXRpb24gPSByZXNvbHV0aW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJnYjJoc3YgPSBleHBvcnRzLlJHQlRvSFNWRXhwciA9IHZvaWQgMDtcbmNvbnN0IGV4cHJfMSA9IHJlcXVpcmUoXCIuL2V4cHJcIik7XG5jb25zdCBnbHNsZnVuY3Rpb25zXzEgPSByZXF1aXJlKFwiLi4vZ2xzbGZ1bmN0aW9uc1wiKTtcbi8qKiBSR0IgdG8gSFNWIGV4cHJlc3Npb24gKi9cbmNsYXNzIFJHQlRvSFNWRXhwciBleHRlbmRzIGV4cHJfMS5FeHByVmVjNCB7XG4gICAgY29uc3RydWN0b3IoY29sb3IpIHtcbiAgICAgICAgc3VwZXIoZXhwcl8xLnRhZyBgcmdiMmhzdigke2NvbG9yfSlgLCBbXCJ1UkdCQ29sXCJdKTtcbiAgICAgICAgdGhpcy5jb2xvciA9IGNvbG9yO1xuICAgICAgICB0aGlzLmV4dGVybmFsRnVuY3MgPSBbZ2xzbGZ1bmN0aW9uc18xLmdsc2xGdW5jcy5yZ2IyaHN2XTtcbiAgICB9XG4gICAgLyoqIHNldHMgdGhlIGNvbG9yIHRvIGNvbnZlcnQgKi9cbiAgICBzZXRDb2xvcihjb2xvcikge1xuICAgICAgICB0aGlzLnNldFVuaWZvcm0oXCJ1UkdCQ29sXCIsIGNvbG9yKTtcbiAgICAgICAgdGhpcy5jb2xvciA9IGNvbG9yO1xuICAgIH1cbn1cbmV4cG9ydHMuUkdCVG9IU1ZFeHByID0gUkdCVG9IU1ZFeHByO1xuLyoqXG4gKiBjcmVhdGVzIGFuIGV4cHJlc3Npb24gdGhhdCBjb252ZXJ0cyBhIGNvbG9yICh3aXRoIGFuIGFscGhhIGNvbXBvbmVudCkgZnJvbVxuICogcmdiIHRvIGhzdlxuICogQHBhcmFtIGNvbCB0aGUgcmdiYSBjb2xvciB0byBjb252ZXJ0IHRvIGhzdmFcbiAqL1xuZnVuY3Rpb24gcmdiMmhzdihjb2wpIHtcbiAgICByZXR1cm4gbmV3IFJHQlRvSFNWRXhwcihjb2wpO1xufVxuZXhwb3J0cy5yZ2IyaHN2ID0gcmdiMmhzdjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yb3RhdGUgPSBleHBvcnRzLlJvdGF0ZUV4cHIgPSB2b2lkIDA7XG5jb25zdCBleHByXzEgPSByZXF1aXJlKFwiLi9leHByXCIpO1xuY29uc3QgZ2xzbGZ1bmN0aW9uc18xID0gcmVxdWlyZShcIi4uL2dsc2xmdW5jdGlvbnNcIik7XG4vKiogcm90YXRlIGV4cHJlc3Npb24gKi9cbmNsYXNzIFJvdGF0ZUV4cHIgZXh0ZW5kcyBleHByXzEuRXhwclZlYzIge1xuICAgIGNvbnN0cnVjdG9yKHZlYywgYW5nbGUpIHtcbiAgICAgICAgc3VwZXIoZXhwcl8xLnRhZyBgcm90YXRlMmQoJHt2ZWN9LCAke2FuZ2xlfSlgLCBbXCJ1VmVjXCIsIFwidUFuZ2xlXCJdKTtcbiAgICAgICAgdGhpcy52ZWMgPSB2ZWM7XG4gICAgICAgIHRoaXMuYW5nbGUgPSBhbmdsZTtcbiAgICAgICAgdGhpcy5leHRlcm5hbEZ1bmNzID0gW2dsc2xmdW5jdGlvbnNfMS5nbHNsRnVuY3Mucm90YXRlMmRdO1xuICAgIH1cbiAgICAvKiogc2V0IHRoZSB2ZWN0b3IgdG8gcm90YXRlICovXG4gICAgc2V0VmVjKHZlYykge1xuICAgICAgICB0aGlzLnNldFVuaWZvcm0oXCJ1VmVjXCIgKyB0aGlzLmlkLCB2ZWMpO1xuICAgICAgICB0aGlzLnZlYyA9IHZlYztcbiAgICB9XG4gICAgLyoqIHNldCB0aGUgYW5nbGUgdG8gcm90YXRlIGJ5ICovXG4gICAgc2V0QW5nbGUoYW5nbGUpIHtcbiAgICAgICAgdGhpcy5zZXRVbmlmb3JtKFwidUFuZ2xlXCIgKyB0aGlzLmlkLCBleHByXzEubjJlKGFuZ2xlKSk7XG4gICAgICAgIHRoaXMuYW5nbGUgPSBleHByXzEubjJlKGFuZ2xlKTtcbiAgICB9XG59XG5leHBvcnRzLlJvdGF0ZUV4cHIgPSBSb3RhdGVFeHByO1xuLyoqXG4gKiBjcmVhdGVzIGFuIGV4cHJlc3Npb24gdGhhdCByb3RhdGVzIGEgdmVjdG9yIGJ5IGEgZ2l2ZW4gYW5nbGVcbiAqIEBwYXJhbSB2ZWMgdGhlIHZlY3RvciB0byByb3RhdGVcbiAqIEBwYXJhbSBhbmdsZSByYWRpYW5zIHRvIHJvdGF0ZSB2ZWN0b3IgYnlcbiAqL1xuZnVuY3Rpb24gcm90YXRlKHZlYywgYW5nbGUpIHtcbiAgICByZXR1cm4gbmV3IFJvdGF0ZUV4cHIodmVjLCBleHByXzEubjJlKGFuZ2xlKSk7XG59XG5leHBvcnRzLnJvdGF0ZSA9IHJvdGF0ZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pbnB1dCA9IGV4cG9ydHMuU2NlbmVTYW1wbGVFeHByID0gdm9pZCAwO1xuY29uc3QgZXhwcl8xID0gcmVxdWlyZShcIi4vZXhwclwiKTtcbmNvbnN0IG5vcm1mcmFnY29vcmRleHByXzEgPSByZXF1aXJlKFwiLi9ub3JtZnJhZ2Nvb3JkZXhwclwiKTtcbi8qKiBzY2VuZSBzYW1wbGUgZXhwcmVzc2lvbiAqL1xuY2xhc3MgU2NlbmVTYW1wbGVFeHByIGV4dGVuZHMgZXhwcl8xLkV4cHJWZWM0IHtcbiAgICBjb25zdHJ1Y3Rvcihjb29yZCA9IG5vcm1mcmFnY29vcmRleHByXzEucG9zKCkpIHtcbiAgICAgICAgc3VwZXIoZXhwcl8xLnRhZyBgdGV4dHVyZTJEKHVTY2VuZVNhbXBsZXIsICR7Y29vcmR9KWAsIFtcInVDb29yZFwiXSk7XG4gICAgICAgIHRoaXMuY29vcmQgPSBjb29yZDtcbiAgICAgICAgdGhpcy5uZWVkcy5zY2VuZUJ1ZmZlciA9IHRydWU7XG4gICAgfVxuICAgIC8qKiBzZXRzIGNvb3JkaW5hdGUgd2hlcmUgc2NlbmUgaXMgYmVpbmcgc2FtcGxlZCBmcm9tICovXG4gICAgc2V0Q29vcmQoY29vcmQpIHtcbiAgICAgICAgdGhpcy5zZXRVbmlmb3JtKFwidUNvb3JkXCIsIGNvb3JkKTtcbiAgICAgICAgdGhpcy5jb29yZCA9IGNvb3JkO1xuICAgIH1cbn1cbmV4cG9ydHMuU2NlbmVTYW1wbGVFeHByID0gU2NlbmVTYW1wbGVFeHByO1xuLyoqXG4gKiBjcmVhdGVzIGFuIGV4cHJlc3Npb24gdGhhdCBzYW1wbGVzIHRoZSBvcmlnaW5hbCBzY2VuZVxuICogQHBhcmFtIHZlYyB3aGVyZSB0byBzYW1wbGUgdGhlIG9yaWdpbmFsIHNjZW5lIHRleHR1cmUgKGRlZmF1bHRzIHRvIHRoZVxuICogbm9ybWFsaXplZCBmcmFnIGNvb3JkLCBidXQgY2hhbmdlIHRoaXMgaWYgeW91IHdhbnQgdG8gdHJhbnNmb3JtIHRoZVxuICogY29vcmRpbmF0ZSBzcGFjZSBvZiB0aGUgb3JpZ2luYWwgaW1hZ2UpXG4gKi9cbmZ1bmN0aW9uIGlucHV0KHZlYykge1xuICAgIHJldHVybiBuZXcgU2NlbmVTYW1wbGVFeHByKHZlYyk7XG59XG5leHBvcnRzLmlucHV0ID0gaW5wdXQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2V0Y29sb3IgPSBleHBvcnRzLlNldENvbG9yRXhwciA9IHZvaWQgMDtcbmNvbnN0IGV4cHJfMSA9IHJlcXVpcmUoXCIuL2V4cHJcIik7XG4vLyBUT0RPIHRoZSBvbmx5IHJlYXNvbiB0aGlzIGNsYXNzIGV4aXN0cyBpcyBiZWNhdXNlIGBPcGVyYXRvcjxFeHByVmVjND5gIGlzIG5vdFxuLy8gYWN0dWFsbHkgYSBzdWJjbGFzcyBvZiBFeHByVmVjNCwgc28gaXQgZG9lc24ndCBoYXZlIGBnZW5Qcm9ncmFtc2Bcbi8qKiBzZXQgZnJhZ21lbnQgY29sb3IgZXhwcmVzc2lvbiAqL1xuY2xhc3MgU2V0Q29sb3JFeHByIGV4dGVuZHMgZXhwcl8xLkV4cHJWZWM0IHtcbiAgICBjb25zdHJ1Y3Rvcih2ZWMpIHtcbiAgICAgICAgc3VwZXIoZXhwcl8xLnRhZyBgKCR7dmVjfSlgLCBbXCJ1VmFsXCJdKTtcbiAgICAgICAgdGhpcy52ZWMgPSB2ZWM7XG4gICAgfVxuICAgIC8qKiBzZXRzIHRoZSB2YWx1ZSB3aGljaCB3aWxsIGJlIHNldCB0byB0aGUgY29sb3IgKi9cbiAgICBzZXRWYWwodmVjKSB7XG4gICAgICAgIHRoaXMuc2V0VW5pZm9ybShcInVWYWxcIiwgdmVjKTtcbiAgICAgICAgdGhpcy52ZWMgPSB2ZWM7XG4gICAgfVxufVxuZXhwb3J0cy5TZXRDb2xvckV4cHIgPSBTZXRDb2xvckV4cHI7XG4vKipcbiAqIHNldHMgdGhlIGZyYWcgY29sb3IgdG8gYSBuZXcgY29sb3JcbiAqIEBwYXJhbSB2YWwgdGhlIGNvbG9yIHRvIHNldCB0aGUgZnJhZyBjb2xvciB0b1xuICovXG5mdW5jdGlvbiBzZXRjb2xvcih2YWwpIHtcbiAgICByZXR1cm4gbmV3IFNldENvbG9yRXhwcih2YWwpO1xufVxuZXhwb3J0cy5zZXRjb2xvciA9IHNldGNvbG9yO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNpbXBsZXggPSBleHBvcnRzLlNpbXBsZXhOb2lzZSA9IHZvaWQgMDtcbmNvbnN0IGdsc2xmdW5jdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi9nbHNsZnVuY3Rpb25zXCIpO1xuY29uc3QgZXhwcl8xID0gcmVxdWlyZShcIi4vZXhwclwiKTtcbi8qKiBzaW1wbGV4IG5vaXNlIGV4cHJlc3Npb24gKi9cbmNsYXNzIFNpbXBsZXhOb2lzZSBleHRlbmRzIGV4cHJfMS5FeHByRmxvYXQge1xuICAgIGNvbnN0cnVjdG9yKHBvcykge1xuICAgICAgICBzdXBlcihleHByXzEudGFnIGBzaW1wbGV4bm9pc2UoJHtwb3N9KWAsIFtcInVQb3NcIl0pO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5leHRlcm5hbEZ1bmNzID0gW2dsc2xmdW5jdGlvbnNfMS5nbHNsRnVuY3Muc2ltcGxleGhlbHBlcnMsIGdsc2xmdW5jdGlvbnNfMS5nbHNsRnVuY3Muc2ltcGxleG5vaXNlXTtcbiAgICB9XG4gICAgc2V0UG9zKHBvcykge1xuICAgICAgICB0aGlzLnNldFVuaWZvcm0oXCJ1UG9zXCIsIHBvcyk7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgIH1cbn1cbmV4cG9ydHMuU2ltcGxleE5vaXNlID0gU2ltcGxleE5vaXNlO1xuLyoqXG4gKiBjcmVhdGVzIGEgc2ltcGxleCBub2lzZSBleHByZXNzaW9uOyB2YWx1ZXMgcmFuZ2UgZnJvbSAtMSB0byAxXG4gKiBAcGFyYW0gcG9zIHBvc2l0aW9uXG4gKi9cbmZ1bmN0aW9uIHNpbXBsZXgocG9zKSB7XG4gICAgcmV0dXJuIG5ldyBTaW1wbGV4Tm9pc2UocG9zKTtcbn1cbmV4cG9ydHMuc2ltcGxleCA9IHNpbXBsZXg7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZWRnZSA9IGV4cG9ydHMuc29iZWwgPSBleHBvcnRzLlNvYmVsRXhwciA9IHZvaWQgMDtcbmNvbnN0IGdsc2xmdW5jdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi9nbHNsZnVuY3Rpb25zXCIpO1xuY29uc3QgZXhwcl8xID0gcmVxdWlyZShcIi4vZXhwclwiKTtcbmNvbnN0IGJyaWdodG5lc3NleHByXzEgPSByZXF1aXJlKFwiLi9icmlnaHRuZXNzZXhwclwiKTtcbmNvbnN0IG9wZXhwcl8xID0gcmVxdWlyZShcIi4vb3BleHByXCIpO1xuY29uc3QgZ2V0Y29tcGV4cHJfMSA9IHJlcXVpcmUoXCIuL2dldGNvbXBleHByXCIpO1xuY29uc3QgaW52ZXJ0ZXhwcl8xID0gcmVxdWlyZShcIi4vaW52ZXJ0ZXhwclwiKTtcbmNvbnN0IG1vbm9jaHJvbWVleHByXzEgPSByZXF1aXJlKFwiLi9tb25vY2hyb21lZXhwclwiKTtcbi8qKiBAaWdub3JlICovXG5mdW5jdGlvbiBnZW5Tb2JlbFNvdXJjZShzYW1wbGVyTnVtKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2VjdGlvbnM6IFtgc29iZWwke3NhbXBsZXJOdW0gPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBcIl9cIiArIHNhbXBsZXJOdW19KClgXSxcbiAgICAgICAgdmFsdWVzOiBbXSxcbiAgICB9O1xufVxuLyoqIHNvYmVsIGV4cHJlc3Npb24gKi9cbmNsYXNzIFNvYmVsRXhwciBleHRlbmRzIGV4cHJfMS5FeHByVmVjNCB7XG4gICAgY29uc3RydWN0b3Ioc2FtcGxlck51bSkge1xuICAgICAgICBzdXBlcihnZW5Tb2JlbFNvdXJjZShzYW1wbGVyTnVtKSwgW10pO1xuICAgICAgICBpZiAoc2FtcGxlck51bSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLm5lZWRzLm5laWdoYm9yU2FtcGxlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZXh0ZXJuYWxGdW5jcyA9IFtnbHNsZnVuY3Rpb25zXzEuZ2xzbEZ1bmNzLnNvYmVsXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubmVlZHMuZXh0cmFCdWZmZXJzID0gbmV3IFNldChbc2FtcGxlck51bV0pO1xuICAgICAgICAgICAgdGhpcy5leHRlcm5hbEZ1bmNzID0gW1xuICAgICAgICAgICAgICAgIGdsc2xmdW5jdGlvbnNfMS5yZXBsYWNlU2FtcGxlcihnbHNsZnVuY3Rpb25zXzEuZ2xzbEZ1bmNzLnNvYmVsLCAvdmVjNFxcc3NvYmVsWzAtOV0rL2csIHNhbXBsZXJOdW0pLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuU29iZWxFeHByID0gU29iZWxFeHByO1xuLy8gVE9ETyB0ZXN0IHNhbXBsZXIgbnVtXG5mdW5jdGlvbiBzb2JlbChzYW1wbGVyTnVtKSB7XG4gICAgcmV0dXJuIG5ldyBTb2JlbEV4cHIoc2FtcGxlck51bSk7XG59XG5leHBvcnRzLnNvYmVsID0gc29iZWw7XG4vKipcbiAqIHJldHVybnMgYW4gZXhwcmVzc2lvbiBoaWdobGlnaHRzIGVkZ2VzIHdoZXJlIHRoZXkgYXBwZWFyXG4gKiBAcGFyYW0gc3R5bGUgYFwiZGFya1wiYCBmb3IgZGFyayBlZGdlcyBhbmQgYFwibGlnaHRcImAgZm9yIGxpZ2h0IGVkZ2VzLCBvciBhXG4gKiBjdXN0b20gbnVtYmVyIChiZXR3ZWVuIC0xIGFuZCAxKSBmb3IgYSBtb3JlIGdyYXkgc3R5bGUgb2YgZWRnZVxuICogQHBhcmFtIHNhbXBsZXJOdW0gd2hlcmUgdG8gc2FtcGxlIGZyb21cbiAqL1xuZnVuY3Rpb24gZWRnZShzdHlsZSA9IFwiZGFya1wiLCBzYW1wbGVyTnVtKSB7XG4gICAgY29uc3QgbXVsdCA9IHN0eWxlID09PSBcImRhcmtcIiA/IC0xIDogc3R5bGUgPT09IFwibGlnaHRcIiA/IDEgOiBzdHlsZTtcbiAgICByZXR1cm4gYnJpZ2h0bmVzc2V4cHJfMS5icmlnaHRuZXNzKG9wZXhwcl8xLm9wKGdldGNvbXBleHByXzEuZ2V0Y29tcChpbnZlcnRleHByXzEuaW52ZXJ0KG1vbm9jaHJvbWVleHByXzEubW9ub2Nocm9tZShzb2JlbChzYW1wbGVyTnVtKSkpLCBcInJcIiksIFwiKlwiLCBtdWx0KSk7XG59XG5leHBvcnRzLmVkZ2UgPSBlZGdlO1xuLypcbmV4cG9ydCBmdW5jdGlvbiBlZGdlY29sb3IoY29sb3I6IFZlYzQsIHNhbXBsZXJOdW0/OiBudW1iZXIpIHtcbiAgcmV0dXJuIGN2ZWM0KFxuICAgIHRhZ2BtaXgoJHtmY29sb3IoKX0sICR7Y29sb3J9LCAke21vbm9jaHJvbWUoc29iZWwoc2FtcGxlck51bSkpfSlgXG4gICk7XG4gIC8vZ2V0Y29tcChtb25vY2hyb21lKHNvYmVsKHNhbXBsZXJOdW0pKSwgXCJyXCIpO1xufVxuKi9cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy50aW1lID0gZXhwb3J0cy5UaW1lRXhwciA9IHZvaWQgMDtcbmNvbnN0IGV4cHJfMSA9IHJlcXVpcmUoXCIuL2V4cHJcIik7XG4vKiogdGltZSBleHByZXNzaW9uICovXG5jbGFzcyBUaW1lRXhwciBleHRlbmRzIGV4cHJfMS5FeHByRmxvYXQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihleHByXzEudGFnIGB1VGltZWAsIFtdKTtcbiAgICAgICAgdGhpcy5uZWVkcy50aW1lVW5pZm9ybSA9IHRydWU7XG4gICAgfVxufVxuZXhwb3J0cy5UaW1lRXhwciA9IFRpbWVFeHByO1xuLyoqIGNyZWF0ZXMgYSB0aW1lIGV4cHJlc3Npb24gdGhhdCBldmFsdWF0ZXMgdG8gdGhlIGN1cnJlbnQgdGltZSAqL1xuZnVuY3Rpb24gdGltZSgpIHtcbiAgICByZXR1cm4gbmV3IFRpbWVFeHByKCk7XG59XG5leHBvcnRzLnRpbWUgPSB0aW1lO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRyYW5zbGF0ZSA9IGV4cG9ydHMuVHJhbnNsYXRlRXhwciA9IHZvaWQgMDtcbmNvbnN0IGV4cHJfMSA9IHJlcXVpcmUoXCIuL2V4cHJcIik7XG4vLyByZWFsbHkganVzdCBhZGRpbmcgdHdvIHZlY3MgdG9nZXRoZXIsIGJ1dCBpdCBtaWdodCBiZSBjb25mdXNpbmcgdGhhdCB0aGVyZSdzXG4vLyByb3RhdGUgYnV0IG5vIHRyYW5zbGF0ZSwgc28gdGhpcyBpcyBpbmNsdWRlZC4gYWxzbyBpdCBjb3VsZCBtYWtlIHNvbWVcbi8vIG9wZXJhdGlvbnMgbW9yZSByZWFkYWJsZVxuLyoqIHNldHMgdGhlIHRyYW5zbGF0ZSBleHByZXNzaW9uICovXG5jbGFzcyBUcmFuc2xhdGVFeHByIGV4dGVuZHMgZXhwcl8xLkV4cHJWZWMyIHtcbiAgICBjb25zdHJ1Y3Rvcih2ZWMsIHBvcykge1xuICAgICAgICBzdXBlcihleHByXzEudGFnIGAoJHt2ZWN9ICsgJHtwb3N9KWAsIFtcInVWZWNcIiwgXCJ1UG9zXCJdKTtcbiAgICAgICAgdGhpcy52ZWMgPSB2ZWM7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgIH1cbiAgICAvKiogc2V0cyB0aGUgc3RhcnRpbmcgcG9zaXRpb24gKi9cbiAgICBzZXRWZWModmVjKSB7XG4gICAgICAgIHRoaXMuc2V0VW5pZm9ybShcInVWZWNcIiArIHRoaXMuaWQsIHZlYyk7XG4gICAgICAgIHRoaXMudmVjID0gdmVjO1xuICAgIH1cbiAgICAvKiogc2V0cyBob3cgZmFyIHRoZSB2ZWN0b3Igd2lsbCBiZSB0cmFuc2xhdGVkICovXG4gICAgc2V0UG9zKHBvcykge1xuICAgICAgICB0aGlzLnNldFVuaWZvcm0oXCJ1UG9zXCIgKyB0aGlzLmlkLCBwb3MpO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICB9XG59XG5leHBvcnRzLlRyYW5zbGF0ZUV4cHIgPSBUcmFuc2xhdGVFeHByO1xuLyoqIHRyYW5zbGF0ZXMgdGhlIHBvc2l0aW9uIG9mIGEgdmVjdG9yIGJ5IGFub3RoZXIgdmVjdG9yICovXG5mdW5jdGlvbiB0cmFuc2xhdGUodmVjLCBwb3MpIHtcbiAgICByZXR1cm4gbmV3IFRyYW5zbGF0ZUV4cHIodmVjLCBwb3MpO1xufVxuZXhwb3J0cy50cmFuc2xhdGUgPSB0cmFuc2xhdGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudHJ1ZWRlcHRoID0gZXhwb3J0cy5UcnVlRGVwdGhFeHByID0gdm9pZCAwO1xuY29uc3QgZXhwcl8xID0gcmVxdWlyZShcIi4vZXhwclwiKTtcbmNvbnN0IGdsc2xmdW5jdGlvbnNfMSA9IHJlcXVpcmUoXCIuLi9nbHNsZnVuY3Rpb25zXCIpO1xuLyoqIHRydWUgZGVwdGggZXhwcmVzc2lvbiAqL1xuY2xhc3MgVHJ1ZURlcHRoRXhwciBleHRlbmRzIGV4cHJfMS5FeHByRmxvYXQge1xuICAgIGNvbnN0cnVjdG9yKGRlcHRoKSB7XG4gICAgICAgIHN1cGVyKGV4cHJfMS50YWcgYHRydWVkZXB0aCgke2RlcHRofSlgLCBbXCJ1RGlzdFwiXSk7XG4gICAgICAgIHRoaXMuZGVwdGggPSBkZXB0aDtcbiAgICAgICAgdGhpcy5leHRlcm5hbEZ1bmNzID0gW2dsc2xmdW5jdGlvbnNfMS5nbHNsRnVuY3MudHJ1ZWRlcHRoXTtcbiAgICB9XG4gICAgLyoqIHNldHMgdGhlIGRpc3RhbmNlIHRvIGNvbnZlcnQgdG8gdGhlIHRydWUgZGVwdGggKi9cbiAgICBzZXREaXN0KGRlcHRoKSB7XG4gICAgICAgIHRoaXMuc2V0VW5pZm9ybShcInVEaXN0XCIsIGRlcHRoKTtcbiAgICAgICAgdGhpcy5kZXB0aCA9IGV4cHJfMS5uMmUoZGVwdGgpO1xuICAgIH1cbn1cbmV4cG9ydHMuVHJ1ZURlcHRoRXhwciA9IFRydWVEZXB0aEV4cHI7XG4vKiogY2FsY3VsYXRlcyB0aGUgbGluZWFyIGRlcHRoIGZyb20gaW52ZXJzZSBkZXB0aCB2YWx1ZSBgMSAvIGRpc3RhbmNlYCAqL1xuZnVuY3Rpb24gdHJ1ZWRlcHRoKGRlcHRoKSB7XG4gICAgcmV0dXJuIG5ldyBUcnVlRGVwdGhFeHByKGV4cHJfMS5uMmUoZGVwdGgpKTtcbn1cbmV4cG9ydHMudHJ1ZWRlcHRoID0gdHJ1ZWRlcHRoO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnB2ZWM0ID0gZXhwb3J0cy5wdmVjMyA9IGV4cG9ydHMucHZlYzIgPSBleHBvcnRzLnZlYzQgPSBleHBvcnRzLnZlYzMgPSBleHBvcnRzLnZlYzIgPSB2b2lkIDA7XG5jb25zdCBleHByXzEgPSByZXF1aXJlKFwiLi9leHByXCIpO1xuLyoqIEBpZ25vcmUgKi9cbmZ1bmN0aW9uIHZlY1NvdXJjZUxpc3QoLi4uY29tcG9uZW50cykge1xuICAgIGNvbnN0IHNlY3Rpb25zID0gW1widmVjXCIgKyBjb21wb25lbnRzLmxlbmd0aCArIFwiKFwiXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbXBvbmVudHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIHNlY3Rpb25zLnB1c2goXCIsIFwiKTtcbiAgICB9XG4gICAgY29uc3QgZGVmYXVsdE5hbWVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb21wb25lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRlZmF1bHROYW1lcy5wdXNoKFwidUNvbXBcIiArIGkpO1xuICAgIH1cbiAgICBzZWN0aW9ucy5wdXNoKFwiKVwiKTtcbiAgICByZXR1cm4gW3sgc2VjdGlvbnM6IHNlY3Rpb25zLCB2YWx1ZXM6IGNvbXBvbmVudHMgfSwgZGVmYXVsdE5hbWVzXTtcbn1cbi8vIGV4cHJlc3Npb24gdmVjdG9yIHNob3J0aGFuZHNcbi8qKiBjcmVhdGVzIGEgYmFzaWMgdmVjMiBleHByZXNzaW9uICovXG5mdW5jdGlvbiB2ZWMyKGNvbXAxLCBjb21wMikge1xuICAgIHJldHVybiBuZXcgZXhwcl8xLkJhc2ljVmVjMiguLi52ZWNTb3VyY2VMaXN0KC4uLltjb21wMSwgY29tcDJdLm1hcCgoYykgPT4gZXhwcl8xLm4yZShjKSkpKTtcbn1cbmV4cG9ydHMudmVjMiA9IHZlYzI7XG4vKiogY3JlYXRlcyBhIGJhc2ljIHZlYzMgZXhwcmVzc2lvbiAqL1xuZnVuY3Rpb24gdmVjMyhjb21wMSwgY29tcDIsIGNvbXAzKSB7XG4gICAgcmV0dXJuIG5ldyBleHByXzEuQmFzaWNWZWMzKC4uLnZlY1NvdXJjZUxpc3QoLi4uW2NvbXAxLCBjb21wMiwgY29tcDNdLm1hcCgoYykgPT4gZXhwcl8xLm4yZShjKSkpKTtcbn1cbmV4cG9ydHMudmVjMyA9IHZlYzM7XG4vKiogY3JlYXRlcyBhIGJhc2ljIHZlYzQgZXhwcmVzc2lvbiAqL1xuZnVuY3Rpb24gdmVjNChjb21wMSwgY29tcDIsIGNvbXAzLCBjb21wNCkge1xuICAgIHJldHVybiBuZXcgZXhwcl8xLkJhc2ljVmVjNCguLi52ZWNTb3VyY2VMaXN0KC4uLltjb21wMSwgY29tcDIsIGNvbXAzLCBjb21wNF0ubWFwKChjKSA9PiBleHByXzEubjJlKGMpKSkpO1xufVxuZXhwb3J0cy52ZWM0ID0gdmVjNDtcbi8vIHByaW1pdGl2ZSB2ZWN0b3Igc2hvcnRoYW5kc1xuLyoqIGNyZWF0ZXMgYSBwcmltaXRpdmUgdmVjMiBleHByZXNzaW9uICovXG5mdW5jdGlvbiBwdmVjMihjb21wMSwgY29tcDIpIHtcbiAgICByZXR1cm4gbmV3IGV4cHJfMS5QcmltaXRpdmVWZWMyKFtjb21wMSwgY29tcDJdKTtcbn1cbmV4cG9ydHMucHZlYzIgPSBwdmVjMjtcbi8qKiBjcmVhdGVzIGEgcHJpbWl0aXZlIHZlYzMgZXhwcmVzc2lvbiAqL1xuZnVuY3Rpb24gcHZlYzMoY29tcDEsIGNvbXAyLCBjb21wMykge1xuICAgIHJldHVybiBuZXcgZXhwcl8xLlByaW1pdGl2ZVZlYzMoW2NvbXAxLCBjb21wMiwgY29tcDNdKTtcbn1cbmV4cG9ydHMucHZlYzMgPSBwdmVjMztcbi8qKiBjcmVhdGVzIGEgcHJpbWl0aXZlIHZlYzQgZXhwcmVzc2lvbiAqL1xuZnVuY3Rpb24gcHZlYzQoY29tcDEsIGNvbXAyLCBjb21wMywgY29tcDQpIHtcbiAgICByZXR1cm4gbmV3IGV4cHJfMS5QcmltaXRpdmVWZWM0KFtjb21wMSwgY29tcDIsIGNvbXAzLCBjb21wNF0pO1xufVxuZXhwb3J0cy5wdmVjNCA9IHB2ZWM0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVwbGFjZVNhbXBsZXIgPSBleHBvcnRzLmNhcHR1cmVBbmRBcHBlbmQgPSBleHBvcnRzLmdsc2xGdW5jcyA9IHZvaWQgMDtcbi8vIGFkYXB0ZWQgZnJvbSBUaGUgQm9vayBvZiBTaGFkZXJzXG4vKiogZ2xzbCBzb3VyY2UgY29kZSBmb3IgZXh0ZXJuYWwgZnVuY3Rpb25zICovXG5leHBvcnRzLmdsc2xGdW5jcyA9IHtcbiAgICAvLyBUT0RPIHJlcGxhY2Ugd2l0aCBhIGJldHRlciBvbmVcbiAgICAvLyBhZGFwdGVkIGZyb20gVGhlIEJvb2sgb2YgU2hhZGVyc1xuICAgIHJhbmRvbTogYGZsb2F0IHJhbmRvbSh2ZWMyIHN0KSB7XG4gIHJldHVybiBmcmFjdChzaW4oZG90KHN0Lnh5IC8gOTkuLCB2ZWMyKDEyLjk4OTgsIDc4LjIzMykpKSAqIDQzNzU4LjU0NTMxMjMpO1xufWAsXG4gICAgLy8gYWRhcHRlZCBmcm9tIFRoZSBCb29rIG9mIFNoYWRlcnNcbiAgICByYW5kb20yOiBgdmVjMiByYW5kb20yKHZlYzIgc3QpIHtcbiAgc3QgPSB2ZWMyKGRvdChzdCx2ZWMyKDEyNy4xLDMxMS43KSksIGRvdChzdCx2ZWMyKDI2OS41LDE4My4zKSkpO1xuICByZXR1cm4gLTEuMCArIDIuMCpmcmFjdChzaW4oc3QpKjQzNzU4LjU0NTMxMjMpO1xufWAsXG4gICAgcm90YXRlMmQ6IGB2ZWMyIHJvdGF0ZTJkKHZlYzIgdiwgZmxvYXQgYW5nbGUpIHtcbiAgcmV0dXJuIG1hdDIoY29zKGFuZ2xlKSwgLXNpbihhbmdsZSksIHNpbihhbmdsZSksIGNvcyhhbmdsZSkpICogdjtcbn1gLFxuICAgIC8vIGFkYXB0ZWQgZnJvbSBUaGUgQm9vayBvZiBTaGFkZXJzXG4gICAgaHN2MnJnYjogYHZlYzQgaHN2MnJnYih2ZWM0IGNvKXtcbiAgdmVjMyBjID0gY28ueHl6O1xuICB2ZWMzIHJnYiA9IGNsYW1wKGFicyhtb2QoXG4gICAgYy54ICogNi4wICsgdmVjMygwLjAsIDQuMCwgMi4wKSwgNi4wKSAtIDMuMCkgLSAxLjAsIDAuMCwgMS4wKTtcbiAgcmdiID0gcmdiICogcmdiICogKDMuMCAtIDIuMCAqIHJnYik7XG4gIHZlYzMgaHN2ID0gYy56ICogbWl4KHZlYzMoMS4wKSwgcmdiLCBjLnkpO1xuICByZXR1cm4gdmVjNChoc3YueCwgaHN2LnksIGhzdi56LCBjby5hKTtcbn1gLFxuICAgIC8vIGFkYXB0ZWQgZnJvbSBUaGUgQm9vayBvZiBTaGFkZXJzXG4gICAgcmdiMmhzdjogYHZlYzQgcmdiMmhzdih2ZWM0IGNvKXtcbiAgdmVjMyBjID0gY28ucmdiO1xuICB2ZWM0IEsgPSB2ZWM0KDAuMCwgLTEuMCAvIDMuMCwgMi4wIC8gMy4wLCAtMS4wKTtcbiAgdmVjNCBwID0gbWl4KHZlYzQoYy5iZywgSy53eiksIHZlYzQoYy5nYiwgSy54eSksIHN0ZXAoYy5iLCBjLmcpKTtcbiAgdmVjNCBxID0gbWl4KHZlYzQocC54eXcsIGMuciksIHZlYzQoYy5yLCBwLnl6eCksIHN0ZXAocC54LCBjLnIpKTtcbiAgZmxvYXQgZCA9IHEueCAtIG1pbihxLncsIHEueSk7XG4gIGZsb2F0IGUgPSAxLjBlLTEwO1xuICByZXR1cm4gdmVjNChhYnMocS56ICsgKHEudyAtIHEueSkgLyAoNi4wICogZCArIGUpKSxcbiAgICAgICAgICAgICAgZCAvIChxLnggKyBlKSxcbiAgICAgICAgICAgICAgcS54LCBjby5hKTtcbn1gLFxuICAgIC8vIGFsbCBnYXVzc2lhbiBibHVycyBhZGFwdGVkIGZyb206XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0phbTMvZ2xzbC1mYXN0LWdhdXNzaWFuLWJsdXIvYmxvYi9tYXN0ZXIvNS5nbHNsXG4gICAgZ2F1c3M1OiBgdmVjNCBnYXVzczUodmVjMiBkaXIpIHtcbiAgdmVjMiB1diA9IGdsX0ZyYWdDb29yZC54eSAvIHVSZXNvbHV0aW9uO1xuICB2ZWM0IGNvbCA9IHZlYzQoMC4wKTtcbiAgdmVjMiBvZmYxID0gdmVjMigxLjMzMzMzMzMzMzMzMzMzMzMpICogZGlyO1xuICBjb2wgKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB1dikgKiAwLjI5NDExNzY0NzA1ODgyMzU0O1xuICBjb2wgKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB1diArIChvZmYxIC8gdVJlc29sdXRpb24pKSAqIDAuMzUyOTQxMTc2NDcwNTg4MjY7XG4gIGNvbCArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHV2IC0gKG9mZjEgLyB1UmVzb2x1dGlvbikpICogMC4zNTI5NDExNzY0NzA1ODgyNjtcbiAgcmV0dXJuIGNvbDtcbn1gLFxuICAgIGdhdXNzOTogYHZlYzQgZ2F1c3M5KHZlYzIgZGlyKSB7XG4gIHZlYzIgdXYgPSBnbF9GcmFnQ29vcmQueHkgLyB1UmVzb2x1dGlvbjtcbiAgdmVjNCBjb2wgPSB2ZWM0KDAuMCk7XG4gIHZlYzIgb2ZmMSA9IHZlYzIoMS4zODQ2MTUzODQ2KSAqIGRpcjtcbiAgdmVjMiBvZmYyID0gdmVjMigzLjIzMDc2OTIzMDgpICogZGlyO1xuICBjb2wgKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB1dikgKiAwLjIyNzAyNzAyNzA7XG4gIGNvbCArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHV2ICsgKG9mZjEgLyB1UmVzb2x1dGlvbikpICogMC4zMTYyMTYyMTYyO1xuICBjb2wgKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB1diAtIChvZmYxIC8gdVJlc29sdXRpb24pKSAqIDAuMzE2MjE2MjE2MjtcbiAgY29sICs9IHRleHR1cmUyRCh1U2FtcGxlciwgdXYgKyAob2ZmMiAvIHVSZXNvbHV0aW9uKSkgKiAwLjA3MDI3MDI3MDM7XG4gIGNvbCArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHV2IC0gKG9mZjIgLyB1UmVzb2x1dGlvbikpICogMC4wNzAyNzAyNzAzO1xuICByZXR1cm4gY29sO1xufWAsXG4gICAgZ2F1c3MxMzogYHZlYzQgZ2F1c3MxMyh2ZWMyIGRpcikge1xuICB2ZWMyIHV2ID0gZ2xfRnJhZ0Nvb3JkLnh5IC8gdVJlc29sdXRpb247XG4gIHZlYzQgY29sID0gdmVjNCgwLjApO1xuICB2ZWMyIG9mZjEgPSB2ZWMyKDEuNDExNzY0NzA1ODgyMzUzKSAqIGRpcjtcbiAgdmVjMiBvZmYyID0gdmVjMigzLjI5NDExNzY0NzA1ODgyMzQpICogZGlyO1xuICB2ZWMyIG9mZjMgPSB2ZWMyKDUuMTc2NDcwNTg4MjM1Mjk0KSAqIGRpcjtcbiAgY29sICs9IHRleHR1cmUyRCh1U2FtcGxlciwgdXYpICogMC4xOTY0ODI1NTAxNTExNDA0O1xuICBjb2wgKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB1diArIChvZmYxIC8gdVJlc29sdXRpb24pKSAqIDAuMjk2OTA2OTY0NjcyODM0NDtcbiAgY29sICs9IHRleHR1cmUyRCh1U2FtcGxlciwgdXYgLSAob2ZmMSAvIHVSZXNvbHV0aW9uKSkgKiAwLjI5NjkwNjk2NDY3MjgzNDQ7XG4gIGNvbCArPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHV2ICsgKG9mZjIgLyB1UmVzb2x1dGlvbikpICogMC4wOTQ0NzAzOTc4NTA0NDczMjtcbiAgY29sICs9IHRleHR1cmUyRCh1U2FtcGxlciwgdXYgLSAob2ZmMiAvIHVSZXNvbHV0aW9uKSkgKiAwLjA5NDQ3MDM5Nzg1MDQ0NzMyO1xuICBjb2wgKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB1diArIChvZmYzIC8gdVJlc29sdXRpb24pKSAqIDAuMDEwMzgxMzYyNDAxMTQ4MDU3O1xuICBjb2wgKz0gdGV4dHVyZTJEKHVTYW1wbGVyLCB1diAtIChvZmYzIC8gdVJlc29sdXRpb24pKSAqIDAuMDEwMzgxMzYyNDAxMTQ4MDU3O1xuICByZXR1cm4gY29sO1xufWAsXG4gICAgY29udHJhc3Q6IGB2ZWM0IGNvbnRyYXN0KGZsb2F0IHZhbCwgdmVjNCBjb2wpIHtcbiAgY29sLnJnYiAvPSBjb2wuYTtcbiAgY29sLnJnYiA9ICgoY29sLnJnYiAtIDAuNSkgKiB2YWwpICsgMC41O1xuICBjb2wucmdiICo9IGNvbC5hO1xuICByZXR1cm4gY29sO1xufWAsXG4gICAgYnJpZ2h0bmVzczogYHZlYzQgYnJpZ2h0bmVzcyhmbG9hdCB2YWwsIHZlYzQgY29sKSB7XG4gIGNvbC5yZ2IgLz0gY29sLmE7XG4gIGNvbC5yZ2IgKz0gdmFsO1xuICBjb2wucmdiICo9IGNvbC5hO1xuICByZXR1cm4gY29sO1xufWAsXG4gICAgLy8gYWRhcHRlZCBmcm9tIGh0dHBzOi8vd3d3LnNoYWRlcnRveS5jb20vdmlldy9sczNHV1Mgd2hpY2ggd2FzIGFkYXB0ZWQgZnJvbVxuICAgIC8vIGh0dHA6Ly93d3cuZ2Vla3MzZC5jb20vMjAxMTA0MDUvZnhhYS1mYXN0LWFwcHJveGltYXRlLWFudGktYWxpYXNpbmctZGVtby1nbHNsLW9wZW5nbC10ZXN0LXJhZGVvbi1nZWZvcmNlLzMvXG4gICAgLy8gb3JpZ2luYWwgYWxnb3JpdGhtIGNyZWF0ZWQgYnkgVGltb3RoeSBMb3R0ZXNcbiAgICBmeGFhOiBgdmVjNCBmeGFhKCkge1xuICBmbG9hdCBGWEFBX1NQQU5fTUFYID0gOC4wO1xuICBmbG9hdCBGWEFBX1JFRFVDRV9NVUwgPSAxLjAgLyBGWEFBX1NQQU5fTUFYO1xuICBmbG9hdCBGWEFBX1JFRFVDRV9NSU4gPSAxLjAgLyAxMjguMDtcbiAgZmxvYXQgRlhBQV9TVUJQSVhfU0hJRlQgPSAxLjAgLyA0LjA7XG5cbiAgdmVjMiByY3BGcmFtZSA9IDEuIC8gdVJlc29sdXRpb24ueHk7XG4gIHZlYzIgdF91diA9IGdsX0ZyYWdDb29yZC54eSAvIHVSZXNvbHV0aW9uLnh5OyBcbiAgdmVjNCB1diA9IHZlYzQodF91diwgdF91diAtIChyY3BGcmFtZSAqICgwLjUgKyBGWEFBX1NVQlBJWF9TSElGVCkpKTtcblxuICB2ZWMzIHJnYk5XID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB1di56dykueHl6O1xuICB2ZWMzIHJnYk5FID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB1di56dyArIHZlYzIoMSwwKSAqIHJjcEZyYW1lLnh5KS54eXo7XG4gIHZlYzMgcmdiU1cgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHV2Lnp3ICsgdmVjMigwLDEpICogcmNwRnJhbWUueHkpLnh5ejtcbiAgdmVjMyByZ2JTRSA9IHRleHR1cmUyRCh1U2FtcGxlciwgdXYuencgKyB2ZWMyKDEsMSkgKiByY3BGcmFtZS54eSkueHl6O1xuICB2ZWM0IHJnYk1mdWxsID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB1di54eSk7XG4gIHZlYzMgcmdiTSA9IHJnYk1mdWxsLnh5ejtcbiAgZmxvYXQgYWxwaGEgPSByZ2JNZnVsbC5hO1xuXG4gIHZlYzMgbHVtYSA9IHZlYzMoMC4yOTksIDAuNTg3LCAwLjExNCk7XG4gIGZsb2F0IGx1bWFOVyA9IGRvdChyZ2JOVywgbHVtYSk7XG4gIGZsb2F0IGx1bWFORSA9IGRvdChyZ2JORSwgbHVtYSk7XG4gIGZsb2F0IGx1bWFTVyA9IGRvdChyZ2JTVywgbHVtYSk7XG4gIGZsb2F0IGx1bWFTRSA9IGRvdChyZ2JTRSwgbHVtYSk7XG4gIGZsb2F0IGx1bWFNID0gZG90KHJnYk0sICBsdW1hKTtcblxuICBmbG9hdCBsdW1hTWluID0gbWluKGx1bWFNLCBtaW4obWluKGx1bWFOVywgbHVtYU5FKSwgbWluKGx1bWFTVywgbHVtYVNFKSkpO1xuICBmbG9hdCBsdW1hTWF4ID0gbWF4KGx1bWFNLCBtYXgobWF4KGx1bWFOVywgbHVtYU5FKSwgbWF4KGx1bWFTVywgbHVtYVNFKSkpO1xuXG4gIHZlYzIgZGlyO1xuICBkaXIueCA9IC0oKGx1bWFOVyArIGx1bWFORSkgLSAobHVtYVNXICsgbHVtYVNFKSk7XG4gIGRpci55ID0gKChsdW1hTlcgKyBsdW1hU1cpIC0gKGx1bWFORSArIGx1bWFTRSkpO1xuXG4gIGZsb2F0IGRpclJlZHVjZSA9IG1heChcbiAgICAobHVtYU5XICsgbHVtYU5FICsgbHVtYVNXICsgbHVtYVNFKSAqICgwLjI1ICogRlhBQV9SRURVQ0VfTVVMKSwgRlhBQV9SRURVQ0VfTUlOKTtcbiAgZmxvYXQgcmNwRGlyTWluID0gMS4wLyhtaW4oYWJzKGRpci54KSwgYWJzKGRpci55KSkgKyBkaXJSZWR1Y2UpO1xuXG4gIGRpciA9IG1pbih2ZWMyKEZYQUFfU1BBTl9NQVgsICBGWEFBX1NQQU5fTUFYKSxcbiAgICBtYXgodmVjMigtRlhBQV9TUEFOX01BWCwgLUZYQUFfU1BBTl9NQVgpLFxuICAgIGRpciAqIHJjcERpck1pbikpICogcmNwRnJhbWUueHk7XG5cbiAgdmVjMyByZ2JBID0gKDEuMCAvIDIuMCkgKiAoXG4gICAgdGV4dHVyZTJEKHVTYW1wbGVyLCB1di54eSArIGRpciAqICgxLjAgLyAzLjAgLSAwLjUpKS54eXogK1xuICAgIHRleHR1cmUyRCh1U2FtcGxlciwgdXYueHkgKyBkaXIgKiAoMi4wIC8gMy4wIC0gMC41KSkueHl6KTtcbiAgdmVjMyByZ2JCID0gcmdiQSAqICgxLjAgLyAyLjApICsgKDEuMCAvIDQuMCkgKiAoXG4gICAgdGV4dHVyZTJEKHVTYW1wbGVyLCB1di54eSArIGRpciAqICgwLjAgLyAzLjAgLSAwLjUpKS54eXogK1xuICAgIHRleHR1cmUyRCh1U2FtcGxlciwgdXYueHkgKyBkaXIgKiAoMy4wIC8gMy4wIC0gMC41KSkueHl6KTtcblxuICBmbG9hdCBsdW1hQiA9IGRvdChyZ2JCLCBsdW1hKTtcblxuICBpZihsdW1hQiA8IGx1bWFNaW4gfHwgbHVtYUIgPiBsdW1hTWF4KSB7XG4gICAgcmV0dXJuIHZlYzQocmdiQS5yLCByZ2JBLmcsIHJnYkEuYiwgYWxwaGEpO1xuICB9XG5cbiAgcmV0dXJuIHZlYzQocmdiQi5yLCByZ2JCLmcsIHJnYkIuYiwgYWxwaGEpO1xufWAsXG4gICAgLy8gbm9ybWFsIGN1cnZlIGlzIGEgPSAwIGFuZCBiID0gMVxuICAgIGdhdXNzaWFuOiBgZmxvYXQgZ2F1c3NpYW4oZmxvYXQgeCwgZmxvYXQgYSwgZmxvYXQgYikge1xuICBmbG9hdCBlID0gMi43MTgyODtcbiAgcmV0dXJuIHBvdyhlLCAtcG93KHggLSBhLCAyLikgLyBiKTtcbn1gLFxuICAgIC8vIGZvciBjYWxjdWxhdGluZyB0aGUgdHJ1ZSBkaXN0YW5jZSBmcm9tIDAgdG8gMSBkZXB0aCBidWZmZXJcbiAgICAvLyB0aGUgc21hbGwgZGVsdGEgaXMgdG8gcHJldmVudCBkaXZpc2lvbiBieSB6ZXJvLCB3aGljaCBpcyB1bmRlZmluZWQgYmVoYXZpb3JcbiAgICB0cnVlZGVwdGg6IGBmbG9hdCB0cnVlZGVwdGgoZmxvYXQgaSkge1xuICBpID0gbWF4KGksIDAuMDAwMDAwMDEpO1xuICByZXR1cm4gKDEuIC0gaSkgLyBpO1xufWAsXG4gICAgLy8gYmFzZWQgb2ZmIG9mIGh0dHBzOi8vZmFiaWVuc2FuZ2xhcmQubmV0L2xpZ2h0U2NhdHRlcmluZy9pbmRleC5waHBcbiAgICBnb2RyYXlzOiBgdmVjNCBnb2RyYXlzKFxuICB2ZWM0IGNvbCxcbiAgZmxvYXQgZXhwb3N1cmUsXG4gIGZsb2F0IGRlY2F5LFxuICBmbG9hdCBkZW5zaXR5LFxuICBmbG9hdCB3ZWlnaHQsXG4gIHZlYzIgbGlnaHRQb3MsXG4gIGZsb2F0IHRocmVzaG9sZCxcbiAgdmVjNCBuZXdDb2xvclxuKSB7XG4gIHZlYzIgdGV4Q29vcmQgPSBnbF9GcmFnQ29vcmQueHkgLyB1UmVzb2x1dGlvbjtcbiAgdmVjMiBkZWx0YVRleENvb3JkID0gdGV4Q29vcmQgLSBsaWdodFBvcztcblxuICBjb25zdCBpbnQgTlVNX1NBTVBMRVMgPSAxMDA7XG4gIGRlbHRhVGV4Q29vcmQgKj0gMS4gLyBmbG9hdChOVU1fU0FNUExFUykgKiBkZW5zaXR5O1xuICBmbG9hdCBpbGx1bWluYXRpb25EZWNheSA9IDEuMDtcblxuICBmb3IgKGludCBpPTA7IGkgPCBOVU1fU0FNUExFUzsgaSsrKSB7XG4gICAgdGV4Q29vcmQgLT0gZGVsdGFUZXhDb29yZDtcbiAgICB2ZWM0IHNhbXBsZSA9IHRleHR1cmUyRCh1U2FtcGxlciwgdGV4Q29vcmQpO1xuICAgIC8vdW5jb21tZW50IHNhbXBsZSA9IGRlcHRoMm9jY2x1c2lvbihzYW1wbGUsIG5ld0NvbG9yLCB0aHJlc2hvbGQpO1xuICAgIHNhbXBsZSAqPSBpbGx1bWluYXRpb25EZWNheSAqIHdlaWdodDtcbiAgICBjb2wgKz0gc2FtcGxlO1xuICAgIGlsbHVtaW5hdGlvbkRlY2F5ICo9IGRlY2F5O1xuICB9XG4gIHJldHVybiBjb2wgKiBleHBvc3VyZTtcbn1gLFxuICAgIGRlcHRoMm9jY2x1c2lvbjogYHZlYzQgZGVwdGgyb2NjbHVzaW9uKHZlYzQgZGVwdGhDb2wsIHZlYzQgbmV3Q29sLCBmbG9hdCB0aHJlc2hvbGQpIHtcbiAgZmxvYXQgcmVkID0gMS4gLSBjZWlsKGRlcHRoQ29sLnIgLSB0aHJlc2hvbGQpO1xuICByZXR1cm4gdmVjNChuZXdDb2wucmdiICogcmVkLCAxLjApO1xufWAsXG4gICAgLy8gYWRhcHRlZCBmcm9tIFRoZSBCb29rIG9mIFNoYWRlcnMsIHdoaWNoIHdhcyBhZGFwdGVkIGZyb20gSW5pZ28gUXVpbGV6XG4gICAgLy8gZnJvbSB0aGlzIGV4YW1wbGU6IGh0dHBzOi8vd3d3LnNoYWRlcnRveS5jb20vdmlldy9YZFhHVzhcbiAgICBncmFkaWVudG5vaXNlOiBgZmxvYXQgZ3JhZGllbnRub2lzZSh2ZWMyIHN0KSB7XG4gIHZlYzIgaSA9IGZsb29yKHN0KTtcbiAgdmVjMiBmID0gZnJhY3Qoc3QpO1xuXG4gIHZlYzIgdSA9IGYgKiBmICogKDMuMCAtIDIuMCAqIGYpO1xuXG4gIHJldHVybiBtaXgobWl4KGRvdChyYW5kb20yKGkgKyB2ZWMyKDAuMCwwLjApKSwgZiAtIHZlYzIoMC4wLCAwLjApKSxcbiAgICAgICAgICAgICAgICAgICAgIGRvdChyYW5kb20yKGkgKyB2ZWMyKDEuMCwwLjApKSwgZiAtIHZlYzIoMS4wLCAwLjApKSwgdS54KSxcbiAgICAgICAgICAgICBtaXgoZG90KHJhbmRvbTIoaSArIHZlYzIoMC4wLDEuMCkpLCBmIC0gdmVjMigwLjAsIDEuMCkpLFxuICAgICAgICAgICAgICAgICBkb3QocmFuZG9tMihpICsgdmVjMigxLjAsMS4wKSksIGYgLSB2ZWMyKDEuMCwgMS4wKSksIHUueCksIHUueSk7XG59YCxcbiAgICAvLyBhZGFwdGVkIGZyb20gVGhlIEJvb2sgb2YgU2hhZGVyc1xuICAgIC8vIGh0dHBzOi8vdGhlYm9va29mc2hhZGVycy5jb20vZWRpdC5waHAjMTEvMmQtc25vaXNlLWNsZWFyLmZyYWdcbiAgICAvLyB0aGlzIHdhcyBhZGFwdGVkIGZyb20gdGhpcyBmYXN0IGltcGxlbWVudGF0aW9uXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FzaGltYS93ZWJnbC1ub2lzZVxuICAgIC8vIHNpbXBsZXggbm9pc2UgaW52ZW50ZWQgYnkgS2VuIFBlcmxpblxuICAgIHNpbXBsZXhub2lzZTogYGZsb2F0IHNpbXBsZXhub2lzZSh2ZWMyIHYpIHtcbiAgLy8gUHJlY29tcHV0ZSB2YWx1ZXMgZm9yIHNrZXdlZCB0cmlhbmd1bGFyIGdyaWRcbiAgY29uc3QgdmVjNCBDID0gdmVjNCgwLjIxMTMyNDg2NTQwNTE4NyxcbiAgICAgICAgICAgICAgICAgICAgICAvLyAoMy4wLXNxcnQoMy4wKSkvNi4wXG4gICAgICAgICAgICAgICAgICAgICAgMC4zNjYwMjU0MDM3ODQ0MzksXG4gICAgICAgICAgICAgICAgICAgICAgLy8gMC41KihzcXJ0KDMuMCktMS4wKVxuICAgICAgICAgICAgICAgICAgICAgIC0wLjU3NzM1MDI2OTE4OTYyNixcbiAgICAgICAgICAgICAgICAgICAgICAvLyAtMS4wICsgMi4wICogQy54XG4gICAgICAgICAgICAgICAgICAgICAgMC4wMjQzOTAyNDM5MDI0MzkpO1xuICAgICAgICAgICAgICAgICAgICAgIC8vIDEuMCAvIDQxLjBcblxuICAvLyBGaXJzdCBjb3JuZXIgKHgwKVxuICB2ZWMyIGkgID0gZmxvb3IodiArIGRvdCh2LCBDLnl5KSk7XG4gIHZlYzIgeDAgPSB2IC0gaSArIGRvdChpLCBDLnh4KTtcblxuICAvLyBPdGhlciB0d28gY29ybmVycyAoeDEsIHgyKVxuICB2ZWMyIGkxID0gdmVjMigwLjApO1xuICBpMSA9ICh4MC54ID4geDAueSk/IHZlYzIoMS4wLCAwLjApOnZlYzIoMC4wLCAxLjApO1xuICB2ZWMyIHgxID0geDAueHkgKyBDLnh4IC0gaTE7XG4gIHZlYzIgeDIgPSB4MC54eSArIEMueno7XG5cbiAgLy8gRG8gc29tZSBwZXJtdXRhdGlvbnMgdG8gYXZvaWRcbiAgLy8gdHJ1bmNhdGlvbiBlZmZlY3RzIGluIHBlcm11dGF0aW9uXG4gIGkgPSBtb2QyODlfMihpKTtcbiAgdmVjMyBwID0gcGVybXV0ZShcbiAgICAgICAgICBwZXJtdXRlKCBpLnkgKyB2ZWMzKDAuMCwgaTEueSwgMS4wKSlcbiAgICAgICAgICAgICAgKyBpLnggKyB2ZWMzKDAuMCwgaTEueCwgMS4wICkpO1xuXG4gIHZlYzMgbSA9IG1heCgwLjUgLSB2ZWMzKFxuICAgICAgICAgICAgICAgICAgICAgIGRvdCh4MCx4MCksXG4gICAgICAgICAgICAgICAgICAgICAgZG90KHgxLHgxKSxcbiAgICAgICAgICAgICAgICAgICAgICBkb3QoeDIseDIpXG4gICAgICAgICAgICAgICAgICAgICAgKSwgMC4wKTtcblxuICBtID0gbSptIDtcbiAgbSA9IG0qbSA7XG5cbiAgLy8gR3JhZGllbnRzOlxuICAvLyAgNDEgcHRzIHVuaWZvcm1seSBvdmVyIGEgbGluZSwgbWFwcGVkIG9udG8gYSBkaWFtb25kXG4gIC8vICBUaGUgcmluZyBzaXplIDE3KjE3ID0gMjg5IGlzIGNsb3NlIHRvIGEgbXVsdGlwbGVcbiAgLy8gICAgICBvZiA0MSAoNDEqNyA9IDI4NylcblxuICB2ZWMzIHggPSAyLjAgKiBmcmFjdChwICogQy53d3cpIC0gMS4wO1xuICB2ZWMzIGggPSBhYnMoeCkgLSAwLjU7XG4gIHZlYzMgb3ggPSBmbG9vcih4ICsgMC41KTtcbiAgdmVjMyBhMCA9IHggLSBveDtcblxuICAvLyBOb3JtYWxpc2UgZ3JhZGllbnRzIGltcGxpY2l0bHkgYnkgc2NhbGluZyBtXG4gIC8vIEFwcHJveGltYXRpb24gb2Y6IG0gKj0gaW52ZXJzZXNxcnQoYTAqYTAgKyBoKmgpO1xuICBtICo9IDEuNzkyODQyOTE0MDAxNTkgLSAwLjg1MzczNDcyMDk1MzE0ICogKGEwKmEwK2gqaCk7XG5cbiAgLy8gQ29tcHV0ZSBmaW5hbCBub2lzZSB2YWx1ZSBhdCBQXG4gIHZlYzMgZyA9IHZlYzMoMC4wKTtcbiAgZy54ICA9IGEwLnggICogeDAueCAgKyBoLnggICogeDAueTtcbiAgZy55eiA9IGEwLnl6ICogdmVjMih4MS54LHgyLngpICsgaC55eiAqIHZlYzIoeDEueSx4Mi55KTtcbiAgcmV0dXJuIDEzMC4wICogZG90KG0sIGcpO1xufWAsXG4gICAgLy8gb25seSB1c2VmdWwgZm9yIHNpbXBsZXggbm9pc2VcbiAgICBzaW1wbGV4aGVscGVyczogYHZlYzMgbW9kMjg5XzModmVjMyB4KSB7IHJldHVybiB4IC0gZmxvb3IoeCAqICgxLjAgLyAyODkuMCkpICogMjg5LjA7IH1cbnZlYzIgbW9kMjg5XzIodmVjMiB4KSB7IHJldHVybiB4IC0gZmxvb3IoeCAqICgxLjAgLyAyODkuMCkpICogMjg5LjA7IH1cbnZlYzMgcGVybXV0ZSh2ZWMzIHgpIHsgcmV0dXJuIG1vZDI4OV8zKCgoeCozNC4wKSsxLjApKngpOyB9YCxcbiAgICAvLyBzb2JlbCBhZGFwdGVkIGZyb20gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vSGViYWxpLzZlYmZjNjYxMDY0NTlhYWNlZTZhOWZhYzAyOWQwMTE1XG4gICAgc29iZWw6IGB2ZWM0IHNvYmVsKCkge1xuICB2ZWMyIHV2ID0gZ2xfRnJhZ0Nvb3JkLnh5IC8gdVJlc29sdXRpb247XG4gIHZlYzQga1s4XTtcblxuICBmbG9hdCB3ID0gMS4gLyB1UmVzb2x1dGlvbi54O1xuICBmbG9hdCBoID0gMS4gLyB1UmVzb2x1dGlvbi55O1xuXG4gIGtbMF0gPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHV2ICsgdmVjMigtdywgLWgpKTtcbiAga1sxXSA9IHRleHR1cmUyRCh1U2FtcGxlciwgdXYgKyB2ZWMyKDAuLCAtaCkpO1xuICBrWzJdID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB1diArIHZlYzIodywgLWgpKTtcbiAga1szXSA9IHRleHR1cmUyRCh1U2FtcGxlciwgdXYgKyB2ZWMyKC13LCAwLikpO1xuXG4gIGtbNF0gPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHV2ICsgdmVjMih3LCAwLikpO1xuICBrWzVdID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB1diArIHZlYzIoLXcsIGgpKTtcbiAga1s2XSA9IHRleHR1cmUyRCh1U2FtcGxlciwgdXYgKyB2ZWMyKDAuLCBoKSk7XG4gIGtbN10gPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHV2ICsgdmVjMih3LCBoKSk7XG5cbiAgdmVjNCBlZGdlX2ggPSBrWzJdICsgKDIuICoga1s0XSkgKyBrWzddIC0gKGtbMF0gKyAoMi4gKiBrWzNdKSArIGtbNV0pO1xuICB2ZWM0IGVkZ2VfdiA9IGtbMF0gKyAoMi4gKiBrWzFdKSArIGtbMl0gLSAoa1s1XSArICgyLiAqIGtbNl0pICsga1s3XSk7XG4gIHZlYzQgc29iZWwgPSBzcXJ0KGVkZ2VfaCAqIGVkZ2VfaCArIGVkZ2VfdiAqIGVkZ2Vfdik7XG5cbiAgcmV0dXJuIHZlYzQoMS4gLSBzb2JlbC5yZ2IsIDEuKTtcbn1gLFxuICAgIC8vIGlubGluaW5nIGEgc2ltaWxhciBmdW5jdGlvbiB3aWxsIHN1YnN0aXR1dGUgaW4gdGhlIGZ1bGwgZXhwcmVzc2lvbiBmb3JcbiAgICAvLyBldmVyeSBjb21wb25lbnQsIHNvIGl0J3MgbW9yZSBlZmZpY2llbnQgdG8gaGF2ZSBhIGZ1bmN0aW9uXG4gICAgbW9ub2Nocm9tZTogYHZlYzQgbW9ub2Nocm9tZSh2ZWM0IGNvbCkge1xuICByZXR1cm4gdmVjNCh2ZWMzKChjb2wuciArIGNvbC5nICsgY29sLmIpIC8gMy4pLCBjb2wuYSk7XG59YCxcbiAgICBpbnZlcnQ6IGB2ZWM0IGludmVydCh2ZWM0IGNvbCkge1xuICByZXR1cm4gdmVjNCh2ZWMzKDEuLCAxLiwgMS4pIC0gY29sLnJnYiwgY29sLmEpO1xufWAsXG59O1xuLyoqIEBpZ25vcmUgKi9cbmZ1bmN0aW9uIGNhcHR1cmVBbmRBcHBlbmQoc3RyLCByZWcsIHN1ZmZpeCkge1xuICAgIGNvbnN0IG1hdGNoZXMgPSBzdHIubWF0Y2gocmVnKTtcbiAgICBpZiAobWF0Y2hlcyA9PT0gbnVsbClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm8gbWF0Y2ggaW4gdGhlIGdpdmVuIHN0cmluZ1wiKTtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UocmVnLCBtYXRjaGVzWzBdICsgc3VmZml4KTtcbn1cbmV4cG9ydHMuY2FwdHVyZUFuZEFwcGVuZCA9IGNhcHR1cmVBbmRBcHBlbmQ7XG4vKiogQGlnbm9yZSAqL1xuZnVuY3Rpb24gcmVwbGFjZVNhbXBsZXIoZnVsbFN0cmluZywgZnVuY1JlZ0V4cCwgc2FtcGxlck51bSwgZXh0cmEpIHtcbiAgICByZXR1cm4gY2FwdHVyZUFuZEFwcGVuZChmdWxsU3RyaW5nLnJlcGxhY2UoL3VTYW1wbGVyL2csIFwidUJ1ZmZlclNhbXBsZXJcIiArIHNhbXBsZXJOdW0pLCBmdW5jUmVnRXhwLCBcIl9cIiArIHNhbXBsZXJOdW0gKyAoZXh0cmEgPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBleHRyYSkpO1xufVxuZXhwb3J0cy5yZXBsYWNlU2FtcGxlciA9IHJlcGxhY2VTYW1wbGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fZXhwb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19leHBvcnRTdGFyKSB8fCBmdW5jdGlvbihtLCBleHBvcnRzKSB7XG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vbWVyZ2VwYXNzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9leHBydHlwZXNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2dsc2xmdW5jdGlvbnNcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2V4cHJzL2JsdXJleHByXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9leHBycy9mcmFnY29sb3JleHByXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9leHBycy92ZWNleHByc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZXhwcnMvb3BleHByXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9leHBycy9wb3dlcmJsdXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2V4cHJzL2JsdXIyZGxvb3BcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2V4cHJzL2xlbmV4cHJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2V4cHJzL25vcm1leHByXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9leHBycy9mcmFnY29vcmRleHByXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9leHBycy9ub3JtZnJhZ2Nvb3JkZXhwclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZXhwcnMvbm9ybWNlbnRlcmZyYWdjb29yZGV4cHJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2V4cHJzL3NjZW5lc2FtcGxlZXhwclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZXhwcnMvYnJpZ2h0bmVzc2V4cHJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2V4cHJzL3NldGNvbG9yZXhwclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZXhwcnMvY29udHJhc3RleHByXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9leHBycy9ncmFpbmV4cHJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2V4cHJzL2dldGNvbXBleHByXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9leHBycy9jaGFuZ2Vjb21wZXhwclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZXhwcnMvcmdidG9oc3ZleHByXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9leHBycy9oc3Z0b3JnYmV4cHJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2V4cHJzL3RpbWVleHByXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9leHBycy9hcml0eTFcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2V4cHJzL2FyaXR5MlwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZXhwcnMvZnhhYWV4cHJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2V4cHJzL2NoYW5uZWxzYW1wbGVleHByXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9leHBycy9kb2Zsb29wXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9leHBycy90cnVlZGVwdGhleHByXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9leHBycy9nb2RyYXlzZXhwclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZXhwcnMvZGVwdGh0b29jY2x1c2lvbmV4cHJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2V4cHJzL3Jlc29sdXRpb25leHByXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9leHBycy9tb3VzZWV4cHJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2V4cHJzL3JvdGF0ZWV4cHJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2V4cHJzL3RyYW5zbGF0ZWV4cHJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2V4cHJzL25vcm1tb3VzZWV4cHJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2V4cHJzL3BlcmxpbmV4cHJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2V4cHJzL3NpbXBsZXhleHByXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9leHBycy9tb3Rpb25ibHVybG9vcFwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZXhwcnMvcmFuZG9tZXhwclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZXhwcnMvc29iZWxleHByXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9leHBycy9ibG9vbWxvb3BcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2V4cHJzL21vbm9jaHJvbWVleHByXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9leHBycy9pbnZlcnRleHByXCIpLCBleHBvcnRzKTtcbi8vIFRPRE8gbW92ZSB0aGlzIG91dCBvZiBleHByZXNzaW9uc1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2V4cHJzL2V4cHJcIiksIGV4cG9ydHMpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNlbmRUZXh0dXJlID0gZXhwb3J0cy5tYWtlVGV4dHVyZSA9IGV4cG9ydHMuTWVyZ2VyID0gZXhwb3J0cy5sb29wID0gZXhwb3J0cy5FZmZlY3RMb29wID0gZXhwb3J0cy5FZmZlY3REaWN0aW9uYXJ5ID0gdm9pZCAwO1xuY29uc3QgY29kZWJ1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL2NvZGVidWlsZGVyXCIpO1xuY29uc3Qgd2ViZ2xwcm9ncmFtbG9vcF8xID0gcmVxdWlyZShcIi4vd2ViZ2xwcm9ncmFtbG9vcFwiKTtcbmNvbnN0IF8xID0gcmVxdWlyZShcIi5cIik7XG5jbGFzcyBFZmZlY3REaWN0aW9uYXJ5IHtcbiAgICBjb25zdHJ1Y3RvcihlZmZlY3RNYXApIHtcbiAgICAgICAgdGhpcy5lZmZlY3RNYXAgPSBlZmZlY3RNYXA7XG4gICAgfVxuICAgIHRvUHJvZ3JhbU1hcChnbCwgdlNoYWRlciwgdW5pZm9ybUxvY3MsIGZTaGFkZXJzKSB7XG4gICAgICAgIGNvbnN0IHByb2dyYW1NYXAgPSB7fTtcbiAgICAgICAgbGV0IG5lZWRzID0ge1xuICAgICAgICAgICAgbmVpZ2hib3JTYW1wbGU6IGZhbHNlLFxuICAgICAgICAgICAgY2VudGVyU2FtcGxlOiBmYWxzZSxcbiAgICAgICAgICAgIHNjZW5lQnVmZmVyOiBmYWxzZSxcbiAgICAgICAgICAgIHRpbWVVbmlmb3JtOiBmYWxzZSxcbiAgICAgICAgICAgIG1vdXNlVW5pZm9ybTogZmFsc2UsXG4gICAgICAgICAgICBleHRyYUJ1ZmZlcnM6IG5ldyBTZXQoKSxcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIHRoaXMuZWZmZWN0TWFwKSB7XG4gICAgICAgICAgICBjb25zdCBlZmZlY3RzID0gdGhpcy5lZmZlY3RNYXBbbmFtZV07XG4gICAgICAgICAgICAvLyB3cmFwIHRoZSBnaXZlbiBsaXN0IG9mIGVmZmVjdHMgYXMgYSBsb29wIGlmIG5lZWQgYmVcbiAgICAgICAgICAgIGNvbnN0IGVmZmVjdExvb3AgPSBuZXcgRWZmZWN0TG9vcChlZmZlY3RzLCB7IG51bTogMSB9KTtcbiAgICAgICAgICAgIGlmIChlZmZlY3RMb29wLmVmZmVjdHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibGlzdCBvZiBlZmZlY3RzIHdhcyBlbXB0eVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHByb2dyYW1Mb29wID0gZWZmZWN0TG9vcC5nZW5Qcm9ncmFtcyhnbCwgdlNoYWRlciwgdW5pZm9ybUxvY3MsIGZTaGFkZXJzKTtcbiAgICAgICAgICAgIC8vIHdhbGsgdGhlIHRyZWUgdG8gdGhlIGZpbmFsIHByb2dyYW1cbiAgICAgICAgICAgIGxldCBhdEJvdHRvbSA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IGN1cnJQcm9ncmFtTG9vcCA9IHByb2dyYW1Mb29wO1xuICAgICAgICAgICAgd2hpbGUgKCFhdEJvdHRvbSkge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyUHJvZ3JhbUxvb3AucHJvZ3JhbUVsZW1lbnQgaW5zdGFuY2VvZiB3ZWJnbHByb2dyYW1sb29wXzEuV2ViR0xQcm9ncmFtTGVhZikge1xuICAgICAgICAgICAgICAgICAgICAvLyB3ZSB0cmF2ZWxlZCByaWdodCBhbmQgaGl0IGEgcHJvZ3JhbSwgc28gaXQgbXVzdCBiZSB0aGUgbGFzdFxuICAgICAgICAgICAgICAgICAgICBjdXJyUHJvZ3JhbUxvb3AubGFzdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGF0Qm90dG9tID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNldCB0aGUgY3VycmVudCBwcm9ncmFtIGxvb3AgdG8gdGhlIGxhc3QgaW4gdGhlIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgY3VyclByb2dyYW1Mb29wID1cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJQcm9ncmFtTG9vcC5wcm9ncmFtRWxlbWVudFtjdXJyUHJvZ3JhbUxvb3AucHJvZ3JhbUVsZW1lbnQubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmVlZHMgPSB3ZWJnbHByb2dyYW1sb29wXzEudXBkYXRlTmVlZHMobmVlZHMsIHByb2dyYW1Mb29wLmdldFRvdGFsTmVlZHMoKSk7XG4gICAgICAgICAgICBwcm9ncmFtTWFwW25hbWVdID0gcHJvZ3JhbUxvb3A7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgcHJvZ3JhbU1hcCwgbmVlZHMgfTtcbiAgICB9XG59XG5leHBvcnRzLkVmZmVjdERpY3Rpb25hcnkgPSBFZmZlY3REaWN0aW9uYXJ5O1xuLyoqIGVmZmVjdCBsb29wLCB3aGljaCBjYW4gbG9vcCBvdmVyIG90aGVyIGVmZmVjdHMgb3IgZWZmZWN0IGxvb3BzICovXG5jbGFzcyBFZmZlY3RMb29wIHtcbiAgICBjb25zdHJ1Y3RvcihlZmZlY3RzLCBsb29wSW5mbykge1xuICAgICAgICB0aGlzLmVmZmVjdHMgPSBlZmZlY3RzO1xuICAgICAgICB0aGlzLmxvb3BJbmZvID0gbG9vcEluZm87XG4gICAgfVxuICAgIC8qKiBAaWdub3JlICovXG4gICAgZ2V0U2FtcGxlTnVtKG11bHQgPSAxLCBzbGljZVN0YXJ0ID0gMCwgc2xpY2VFbmQgPSB0aGlzLmVmZmVjdHMubGVuZ3RoKSB7XG4gICAgICAgIG11bHQgKj0gdGhpcy5sb29wSW5mby5udW07XG4gICAgICAgIGxldCBhY2MgPSAwO1xuICAgICAgICBjb25zdCBzbGljZWQgPSB0aGlzLmVmZmVjdHMuc2xpY2Uoc2xpY2VTdGFydCwgc2xpY2VFbmQpO1xuICAgICAgICBmb3IgKGNvbnN0IGUgb2Ygc2xpY2VkKSB7XG4gICAgICAgICAgICBhY2MgKz0gZS5nZXRTYW1wbGVOdW0obXVsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGlnbm9yZVxuICAgICAqIHBsYWNlcyBlZmZlY3RzIGludG8gbG9vcHMgYnJva2VuIHVwIGJ5IHNhbXBsaW5nIGVmZmVjdHNcbiAgICAgKi9cbiAgICByZWdyb3VwKCkge1xuICAgICAgICBsZXQgc2FtcGxlQ291bnQgPSAwO1xuICAgICAgICAvKiogbnVtYmVyIG9mIHNhbXBsZXMgaW4gYWxsIHByZXZpb3VzICovXG4gICAgICAgIGxldCBwcmV2U2FtcGxlQ291bnQgPSAwO1xuICAgICAgICBsZXQgcHJldkVmZmVjdHMgPSBbXTtcbiAgICAgICAgY29uc3QgcmVncm91cGVkRWZmZWN0cyA9IFtdO1xuICAgICAgICBsZXQgcHJldlRhcmdldDtcbiAgICAgICAgbGV0IGN1cnJUYXJnZXQ7XG4gICAgICAgIGxldCBtdXN0QnJlYWtDb3VudGVyID0gMDtcbiAgICAgICAgY29uc3QgYnJlYWtPZmYgPSAoKSA9PiB7XG4gICAgICAgICAgICBtdXN0QnJlYWtDb3VudGVyLS07XG4gICAgICAgICAgICBpZiAocHJldkVmZmVjdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIGJyZWFrIG9mZiBhbGwgcHJldmlvdXMgZWZmZWN0cyBpbnRvIHRoZWlyIG93biBsb29wXG4gICAgICAgICAgICAgICAgaWYgKHByZXZFZmZlY3RzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIHRvIHByZXZlbnQgd3JhcHBpbmcgaW4gYW5vdGhlciBlZmZlY3QgbG9vcFxuICAgICAgICAgICAgICAgICAgICByZWdyb3VwZWRFZmZlY3RzLnB1c2gocHJldkVmZmVjdHNbMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVncm91cGVkRWZmZWN0cy5wdXNoKG5ldyBFZmZlY3RMb29wKHByZXZFZmZlY3RzLCB7IG51bTogMSB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNhbXBsZUNvdW50IC09IHByZXZTYW1wbGVDb3VudDtcbiAgICAgICAgICAgICAgICBwcmV2RWZmZWN0cyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKGNvbnN0IGUgb2YgdGhpcy5lZmZlY3RzKSB7XG4gICAgICAgICAgICBjb25zdCBzYW1wbGVOdW0gPSBlLmdldFNhbXBsZU51bSgpO1xuICAgICAgICAgICAgcHJldlNhbXBsZUNvdW50ID0gc2FtcGxlQ291bnQ7XG4gICAgICAgICAgICBzYW1wbGVDb3VudCArPSBzYW1wbGVOdW07XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVmZmVjdExvb3ApIHtcbiAgICAgICAgICAgICAgICBjdXJyVGFyZ2V0ID0gZS5sb29wSW5mby50YXJnZXQ7XG4gICAgICAgICAgICAgICAgaWYgKGUuaGFzVGFyZ2V0U3dpdGNoKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbXVzdEJyZWFrQ291bnRlciA9IDI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgaXQncyBub3QgYSBsb29wIGl0J3MgYXNzdW1lZCB0aGUgdGFyZ2V0IGlzIHRoYXQgb2Ygb3V0ZXIgbG9vcFxuICAgICAgICAgICAgICAgIGN1cnJUYXJnZXQgPSB0aGlzLmxvb3BJbmZvLnRhcmdldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzYW1wbGVDb3VudCA+IDAgfHxcbiAgICAgICAgICAgICAgICBjdXJyVGFyZ2V0ICE9PSBwcmV2VGFyZ2V0IHx8XG4gICAgICAgICAgICAgICAgbXVzdEJyZWFrQ291bnRlciA+IDApIHtcbiAgICAgICAgICAgICAgICBicmVha09mZigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldkVmZmVjdHMucHVzaChlKTtcbiAgICAgICAgICAgIHByZXZUYXJnZXQgPSBjdXJyVGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIC8vIHB1c2ggb24gYWxsIHRoZSBzdHJhZ2dsaW5nIGVmZmVjdHMgYWZ0ZXIgdGhlIGdyb3VwaW5nIGlzIGRvbmVcbiAgICAgICAgYnJlYWtPZmYoKTtcbiAgICAgICAgcmV0dXJuIHJlZ3JvdXBlZEVmZmVjdHM7XG4gICAgfVxuICAgIGdlblByb2dyYW1zKGdsLCB2U2hhZGVyLCB1bmlmb3JtTG9jcywgc2hhZGVycykge1xuICAgICAgICAvLyB2YWxpZGF0ZVxuICAgICAgICBjb25zdCBmdWxsU2FtcGxlTnVtID0gdGhpcy5nZXRTYW1wbGVOdW0oKSAvIHRoaXMubG9vcEluZm8ubnVtO1xuICAgICAgICBjb25zdCBmaXJzdFNhbXBsZU51bSA9IHRoaXMuZ2V0U2FtcGxlTnVtKHVuZGVmaW5lZCwgMCwgMSkgLyB0aGlzLmxvb3BJbmZvLm51bTtcbiAgICAgICAgY29uc3QgcmVzdFNhbXBsZU51bSA9IHRoaXMuZ2V0U2FtcGxlTnVtKHVuZGVmaW5lZCwgMSkgLyB0aGlzLmxvb3BJbmZvLm51bTtcbiAgICAgICAgaWYgKCF0aGlzLmhhc1RhcmdldFN3aXRjaCgpICYmXG4gICAgICAgICAgICAoZnVsbFNhbXBsZU51bSA9PT0gMCB8fCAoZmlyc3RTYW1wbGVOdW0gPT09IDEgJiYgcmVzdFNhbXBsZU51bSA9PT0gMCkpKSB7XG4gICAgICAgICAgICBjb25zdCBjb2RlQnVpbGRlciA9IG5ldyBjb2RlYnVpbGRlcl8xLkNvZGVCdWlsZGVyKHRoaXMpO1xuICAgICAgICAgICAgY29uc3QgcHJvZ3JhbSA9IGNvZGVCdWlsZGVyLmNvbXBpbGVQcm9ncmFtKGdsLCB2U2hhZGVyLCB1bmlmb3JtTG9jcywgc2hhZGVycyk7XG4gICAgICAgICAgICByZXR1cm4gcHJvZ3JhbTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPIGdldCByaWQgb2YgdGhpc1xuICAgICAgICAvKlxuICAgICAgICBjb25zb2xlLmxvZyhcIiFoYXMgdGFyZ2V0IHN3aXRjaFwiLCAhdGhpcy5oYXNUYXJnZXRTd2l0Y2goKSk7XG4gICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgIFwic2FtcGxlc1wiLFxuICAgICAgICAgIGZ1bGxTYW1wbGVOdW0gPT09IDAgfHwgKGZpcnN0U2FtcGxlTnVtID09PSAxICYmIHJlc3RTYW1wbGVOdW0gPT09IDApXG4gICAgICAgICk7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiZWZmZWN0c1wiLCB0aGlzLmVmZmVjdHMpO1xuICAgICAgICAqL1xuICAgICAgICAvL2NvbnNvbGUubG9nKFwibm90IHZhbGlkXCIpO1xuICAgICAgICAvLyBvdGhlcndpc2UsIHJlZ3JvdXAgYW5kIHRyeSBhZ2FpbiBvbiByZWdyb3VwZWQgbG9vcHNcbiAgICAgICAgdGhpcy5lZmZlY3RzID0gdGhpcy5yZWdyb3VwKCk7XG4gICAgICAgIHJldHVybiBuZXcgd2ViZ2xwcm9ncmFtbG9vcF8xLldlYkdMUHJvZ3JhbUxvb3AodGhpcy5lZmZlY3RzLm1hcCgoZSkgPT4gZS5nZW5Qcm9ncmFtcyhnbCwgdlNoYWRlciwgdW5pZm9ybUxvY3MsIHNoYWRlcnMpKSwgdGhpcy5sb29wSW5mbywgZ2wpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBjaGFuZ2VzIHRoZSByZW5kZXIgdGFyZ2V0IG9mIGFuIGVmZmVjdCBsb29wICgtMSB0YXJnZXN0IHRoZSBzY2VuZSB0ZXh0dXJlO1xuICAgICAqIHRoaXMgaXMgdXNlZCBpbnRlcm5hbGx5KVxuICAgICAqL1xuICAgIHRhcmdldChudW0pIHtcbiAgICAgICAgdGhpcy5sb29wSW5mby50YXJnZXQgPSBudW07XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKiogQGlnbm9yZSAqL1xuICAgIGhhc1RhcmdldFN3aXRjaCgpIHtcbiAgICAgICAgZm9yIChjb25zdCBlIG9mIHRoaXMuZWZmZWN0cykge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFZmZlY3RMb29wKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUubG9vcEluZm8udGFyZ2V0ICE9PSB0aGlzLmxvb3BJbmZvLnRhcmdldCB8fCBlLmhhc1RhcmdldFN3aXRjaCgpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0cy5FZmZlY3RMb29wID0gRWZmZWN0TG9vcDtcbi8qKiBjcmVhdGVzIGFuIGVmZmVjdCBsb29wICovXG5mdW5jdGlvbiBsb29wKGVmZmVjdHMsIHJlcCA9IDEpIHtcbiAgICByZXR1cm4gbmV3IEVmZmVjdExvb3AoZWZmZWN0cywgeyBudW06IHJlcCB9KTtcbn1cbmV4cG9ydHMubG9vcCA9IGxvb3A7XG4vKiogQGlnbm9yZSAqL1xuY29uc3QgVl9TT1VSQ0UgPSBgYXR0cmlidXRlIHZlYzIgYVBvc2l0aW9uO1xudm9pZCBtYWluKCkge1xuICBnbF9Qb3NpdGlvbiA9IHZlYzQoYVBvc2l0aW9uLCAwLjAsIDEuMCk7XG59XFxuYDtcbi8qKiBjbGFzcyB0aGF0IGNhbiBtZXJnZSBlZmZlY3RzICovXG5jbGFzcyBNZXJnZXIge1xuICAgIC8qKlxuICAgICAqIGNvbnN0cnVjdHMgdGhlIG9iamVjdCB0aGF0IHJ1bnMgdGhlIGVmZmVjdHNcbiAgICAgKiBAcGFyYW0gZWZmZWN0cyBsaXN0IG9mIGVmZmVjdHMgdGhhdCBkZWZpbmUgdGhlIGZpbmFsIGVmZmVjdFxuICAgICAqIEBwYXJhbSBzb3VyY2UgdGhlIHNvdXJjZSBpbWFnZSBvciB0ZXh0dXJlXG4gICAgICogQHBhcmFtIGdsIHRoZSB0YXJnZXQgcmVuZGVyaW5nIGNvbnRleHRcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBhZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSB0ZXh0dXJlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZWZmZWN0cywgc291cmNlLCBnbCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnVuaWZvcm1Mb2NzID0ge307XG4gICAgICAgIC8qKiBhZGRpdGlvbmFsIGNoYW5uZWxzICovXG4gICAgICAgIHRoaXMuY2hhbm5lbHMgPSBbXTtcbiAgICAgICAgdGhpcy5mU2hhZGVycyA9IFtdO1xuICAgICAgICB0aGlzLnRleHR1cmVNb2RlID0gc291cmNlIGluc3RhbmNlb2YgV2ViR0xUZXh0dXJlO1xuICAgICAgICAvLyBzZXQgY2hhbm5lbHMgaWYgcHJvdmlkZWQgd2l0aCBjaGFubmVsc1xuICAgICAgICBpZiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jaGFubmVscykgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHMgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuY2hhbm5lbHM7XG4gICAgICAgIGlmICghKGVmZmVjdHMgaW5zdGFuY2VvZiBFZmZlY3REaWN0aW9uYXJ5KSkge1xuICAgICAgICAgICAgZWZmZWN0cyA9IG5ldyBFZmZlY3REaWN0aW9uYXJ5KHsgZGVmYXVsdDogZWZmZWN0cyB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBhZGQgdGhlIGNvcHkgdG8gc2NlbmUgdGV4dHVyZSBpZiBpbiB0ZXh0dXJlIG1vZGVcbiAgICAgICAgaWYgKHRoaXMudGV4dHVyZU1vZGUpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gZ2V0IHJpZCBvZiB0aGlzXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIndlIGFyZSBpbiB0ZXh0dXJlIG1vZGUhXCIpO1xuICAgICAgICAgICAgLy8gVE9ETyBzZWUgaWYgaXQgbmVlZHMgc2NlbmUgdGV4dHVyZSBiZWZvcmUgZG9pbmcgdGhpc1xuICAgICAgICAgICAgLy8gY2FuIHdlIGV2ZW4gZG8gdGhpcz8gbWF5YmUganVzdCBhbHdheXMgbWFrZSB0aGUgc2NlbmUgdGV4dHVyZVxuICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIGVmZmVjdHMuZWZmZWN0TWFwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGlzdCA9IGVmZmVjdHMuZWZmZWN0TWFwW25hbWVdO1xuICAgICAgICAgICAgICAgIGxpc3QudW5zaGlmdChsb29wKFtfMS5pbnB1dCgpXSkudGFyZ2V0KC0xKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMuZ2wgPSBnbDtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgLy8gc2V0IHRoZSB2aWV3cG9ydFxuICAgICAgICB0aGlzLmdsLnZpZXdwb3J0KDAsIDAsIHRoaXMuZ2wuZHJhd2luZ0J1ZmZlcldpZHRoLCB0aGlzLmdsLmRyYXdpbmdCdWZmZXJIZWlnaHQpO1xuICAgICAgICAvLyBzZXQgdXAgdGhlIHZlcnRleCBidWZmZXJcbiAgICAgICAgY29uc3QgdmVydGV4QnVmZmVyID0gdGhpcy5nbC5jcmVhdGVCdWZmZXIoKTtcbiAgICAgICAgaWYgKHZlcnRleEJ1ZmZlciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicHJvYmxlbSBjcmVhdGluZyB2ZXJ0ZXggYnVmZmVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZ2wuYmluZEJ1ZmZlcih0aGlzLmdsLkFSUkFZX0JVRkZFUiwgdmVydGV4QnVmZmVyKTtcbiAgICAgICAgY29uc3QgdmVydGV4QXJyYXkgPSBbLTEsIC0xLCAxLCAtMSwgLTEsIDEsIC0xLCAxLCAxLCAtMSwgMSwgMV07XG4gICAgICAgIGNvbnN0IHRyaWFuZ2xlcyA9IG5ldyBGbG9hdDMyQXJyYXkodmVydGV4QXJyYXkpO1xuICAgICAgICB0aGlzLmdsLmJ1ZmZlckRhdGEodGhpcy5nbC5BUlJBWV9CVUZGRVIsIHRyaWFuZ2xlcywgdGhpcy5nbC5TVEFUSUNfRFJBVyk7XG4gICAgICAgIC8vIHNhdmUgdGhlIHZlcnRleCBidWZmZXIgcmVmZXJlbmNlIGp1c3Qgc28gd2UgY2FuIGRlbGV0ZSBpdCBsYXRlclxuICAgICAgICB0aGlzLnZlcnRleEJ1ZmZlciA9IHZlcnRleEJ1ZmZlcjtcbiAgICAgICAgLy8gY29tcGlsZSB0aGUgc2ltcGxlIHZlcnRleCBzaGFkZXIgKDIgYmlnIHRyaWFuZ2xlcylcbiAgICAgICAgY29uc3QgdlNoYWRlciA9IHRoaXMuZ2wuY3JlYXRlU2hhZGVyKHRoaXMuZ2wuVkVSVEVYX1NIQURFUik7XG4gICAgICAgIGlmICh2U2hhZGVyID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwcm9ibGVtIGNyZWF0aW5nIHRoZSB2ZXJ0ZXggc2hhZGVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNhdmUgdGhlIHZlcnRleCBzaGFkZXIgcmVmZXJlbmNlIGp1c3Qgc28gd2UgY2FuIGRlbGV0ZSBpdCBsYXRlclxuICAgICAgICB0aGlzLnZTaGFkZXIgPSB2U2hhZGVyO1xuICAgICAgICB0aGlzLmdsLnNoYWRlclNvdXJjZSh2U2hhZGVyLCBWX1NPVVJDRSk7XG4gICAgICAgIHRoaXMuZ2wuY29tcGlsZVNoYWRlcih2U2hhZGVyKTtcbiAgICAgICAgLy8gbWFrZSB0ZXh0dXJlc1xuICAgICAgICB0aGlzLnRleCA9IHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIGZyb250IHRleHR1cmUgdGhlIHNvdXJjZSBpZiB3ZSdyZSBnaXZlbiBhIHRleHR1cmUgaW5zdGVhZCBvZlxuICAgICAgICAgICAgLy8gYW4gaW1hZ2VcbiAgICAgICAgICAgIGJhY2s6IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIm9yaWdfYmFja1wiLFxuICAgICAgICAgICAgICAgIHRleDogc291cmNlIGluc3RhbmNlb2YgV2ViR0xUZXh0dXJlXG4gICAgICAgICAgICAgICAgICAgID8gc291cmNlXG4gICAgICAgICAgICAgICAgICAgIDogbWFrZVRleHR1cmUodGhpcy5nbCwgdGhpcy5vcHRpb25zKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmcm9udDogeyBuYW1lOiBcIm9yaWdfZnJvbnRcIiwgdGV4OiBtYWtlVGV4dHVyZSh0aGlzLmdsLCB0aGlzLm9wdGlvbnMpIH0sXG4gICAgICAgICAgICBzY2VuZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgYnVmVGV4dHVyZXM6IFtdLFxuICAgICAgICB9O1xuICAgICAgICAvLyBjcmVhdGUgdGhlIGZyYW1lYnVmZmVyXG4gICAgICAgIGNvbnN0IGZyYW1lYnVmZmVyID0gZ2wuY3JlYXRlRnJhbWVidWZmZXIoKTtcbiAgICAgICAgaWYgKGZyYW1lYnVmZmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwcm9ibGVtIGNyZWF0aW5nIHRoZSBmcmFtZWJ1ZmZlclwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZyYW1lYnVmZmVyID0gZnJhbWVidWZmZXI7XG4gICAgICAgIGNvbnN0IHsgcHJvZ3JhbU1hcCwgbmVlZHMgfSA9IGVmZmVjdHMudG9Qcm9ncmFtTWFwKHRoaXMuZ2wsIHRoaXMudlNoYWRlciwgdGhpcy51bmlmb3JtTG9jcywgdGhpcy5mU2hhZGVycyk7XG4gICAgICAgIHRoaXMucHJvZ3JhbU1hcCA9IHByb2dyYW1NYXA7XG4gICAgICAgIGlmIChuZWVkcy5zY2VuZUJ1ZmZlciB8fCB0aGlzLnRleHR1cmVNb2RlKSB7XG4gICAgICAgICAgICAvLyB3ZSBhbHdheXMgY3JlYXRlIGEgc2NlbmUgdGV4dHVyZSBpZiB3ZSdyZSBpbiB0ZXh0dXJlIG1vZGVcbiAgICAgICAgICAgIHRoaXMudGV4LnNjZW5lID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IFwic2NlbmVcIixcbiAgICAgICAgICAgICAgICB0ZXg6IG1ha2VUZXh0dXJlKHRoaXMuZ2wsIHRoaXMub3B0aW9ucyksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9ncmFtTWFwW1wiZGVmYXVsdFwiXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJubyBkZWZhdWx0IHByb2dyYW1cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm9ncmFtTG9vcCA9IHByb2dyYW1NYXBbXCJkZWZhdWx0XCJdO1xuICAgICAgICAvLyBjcmVhdGUgeCBhbW91bnQgb2YgZW1wdHkgdGV4dHVyZXMgYmFzZWQgb24gYnVmZmVycyBuZWVkZWRcbiAgICAgICAgY29uc3QgY2hhbm5lbHNOZWVkZWQgPSBNYXRoLm1heCguLi5uZWVkcy5leHRyYUJ1ZmZlcnMpICsgMTtcbiAgICAgICAgY29uc3QgY2hhbm5lbHNTdXBwbGllZCA9IHRoaXMuY2hhbm5lbHMubGVuZ3RoO1xuICAgICAgICBpZiAoY2hhbm5lbHNOZWVkZWQgPiBjaGFubmVsc1N1cHBsaWVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgZW5vdWdoIGNoYW5uZWxzIHN1cHBsaWVkIGZvciB0aGlzIGVmZmVjdFwiKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hhbm5lbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHRleE9ySW1hZ2UgPSB0aGlzLmNoYW5uZWxzW2ldO1xuICAgICAgICAgICAgaWYgKCEodGV4T3JJbWFnZSBpbnN0YW5jZW9mIFdlYkdMVGV4dHVyZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgYSBuZXcgdGV4dHVyZTsgd2Ugd2lsbCB1cGRhdGUgdGhpcyB3aXRoIHRoZSBpbWFnZSBzb3VyY2UgZXZlcnkgZHJhd1xuICAgICAgICAgICAgICAgIGNvbnN0IHRleHR1cmUgPSBtYWtlVGV4dHVyZSh0aGlzLmdsLCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHRoaXMudGV4LmJ1ZlRleHR1cmVzLnB1c2goeyBuYW1lOiBcInRleF9jaGFubmVsX1wiICsgaSwgdGV4OiB0ZXh0dXJlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcyBpcyBhbHJlYWR5IGEgdGV4dHVyZTsgdGhlIHVzZXIgd2lsbCBoYW5kbGUgdXBkYXRpbmcgdGhpc1xuICAgICAgICAgICAgICAgIHRoaXMudGV4LmJ1ZlRleHR1cmVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcImltZ19jaGFubmVsX1wiICsgaSxcbiAgICAgICAgICAgICAgICAgICAgdGV4OiB0ZXhPckltYWdlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKHRoaXMucHJvZ3JhbU1hcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHVzZSB0aGUgc291cmNlIGFuZCBjaGFubmVscyB0byBkcmF3IGVmZmVjdCB0byB0YXJnZXQgY29udGV4dDsgbW91c2VcbiAgICAgKiBwb3NpdGlvbiAoYXMgd2l0aCBhbGwgcG9zaXRpb25zKSBhcmUgc3RvcmVkIGZyb20gdGhlIGJvdHRvbSBsZWZ0IGNvcm5lciBhc1xuICAgICAqIHRoaXMgaXMgaG93IHRleHR1cmUgZGF0YSBpcyBzdG9yZWRcbiAgICAgKiBAcGFyYW0gdGltZVZhbCBudW1iZXIgdG8gc2V0IHRoZSB0aW1lIHVuaWZvcm0gdG8gKHN1cHBseSB0aGlzIGlmIHlvdSBwbGFuIHRvXG4gICAgICogdXNlIFtbdGltZV1dKVxuICAgICAqIEBwYXJhbSBtb3VzZVggdGhlIHggcG9zaXRpb24gb2YgdGhlIG1vdXNlIChzdXBwbHkgdGhpcyBpZiB5b3UgcGxhbiB0byB1c2VcbiAgICAgKiBbW21vdXNlXV0gb3IgW1tubW91c2VdXSlcbiAgICAgKiBAcGFyYW0gbW91c2VZIHRoZSB5IHBvc2l0aW9uIG9mIHRoZSBtb3VzZSAoc3VwcGx5IHRoaXMgaWYgeW91IHBsYW4gdG8gdXNlXG4gICAgICogW1ttb3VzZV1dIG9yIFtbbm1vdXNlXV0pXG4gICAgICovXG4gICAgZHJhdyh0aW1lVmFsID0gMCwgbW91c2VYID0gMCwgbW91c2VZID0gMCkge1xuICAgICAgICAvLyBUT0RPIGRvdWJsZSBjaGVjayBpZiB0aGlzIGlzIG5lY2Nlc3NhcnlcbiAgICAgICAgLy9jb25zdCBvcmlnaW5hbEZyb250ID0gdGhpcy50ZXguZnJvbnQ7XG4gICAgICAgIC8vY29uc3Qgb3JpZ2luYWxCYWNrID0gdGhpcy50ZXguYmFjaztcbiAgICAgICAgdGhpcy5nbC5hY3RpdmVUZXh0dXJlKHRoaXMuZ2wuVEVYVFVSRTApO1xuICAgICAgICB0aGlzLmdsLmJpbmRUZXh0dXJlKHRoaXMuZ2wuVEVYVFVSRV8yRCwgdGhpcy50ZXguYmFjay50ZXgpO1xuICAgICAgICBzZW5kVGV4dHVyZSh0aGlzLmdsLCB0aGlzLnNvdXJjZSk7XG4gICAgICAgIC8vIFRPRE8gc2VlIGlmIHdlIG5lZWQgdG8gdW5iaW5kXG4gICAgICAgIHRoaXMuZ2wuYmluZFRleHR1cmUodGhpcy5nbC5URVhUVVJFXzJELCBudWxsKTtcbiAgICAgICAgLy8gYmluZCB0aGUgc2NlbmUgYnVmZmVyXG4gICAgICAgIGlmICh0aGlzLnByb2dyYW1Mb29wLmdldFRvdGFsTmVlZHMoKS5zY2VuZUJ1ZmZlciAmJlxuICAgICAgICAgICAgdGhpcy50ZXguc2NlbmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5nbC5hY3RpdmVUZXh0dXJlKHRoaXMuZ2wuVEVYVFVSRTEpO1xuICAgICAgICAgICAgdGhpcy5nbC5iaW5kVGV4dHVyZSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRoaXMudGV4LnNjZW5lLnRleCk7XG4gICAgICAgICAgICBzZW5kVGV4dHVyZSh0aGlzLmdsLCB0aGlzLnNvdXJjZSk7XG4gICAgICAgICAgICAvLyBUT0RPIHNlZSBpZiB3ZSBuZWVkIHRvIHVuYmluZFxuICAgICAgICAgICAgdGhpcy5nbC5iaW5kVGV4dHVyZSh0aGlzLmdsLlRFWFRVUkVfMkQsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJpbmQgdGhlIGFkZGl0aW9uYWwgYnVmZmVyc1xuICAgICAgICBsZXQgY291bnRlciA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgYiBvZiB0aGlzLmNoYW5uZWxzKSB7XG4gICAgICAgICAgICAvLyBUT0RPIGNoZWNrIGZvciB0ZXh0dXJlIGxpbWl0XG4gICAgICAgICAgICB0aGlzLmdsLmFjdGl2ZVRleHR1cmUodGhpcy5nbC5URVhUVVJFMiArIGNvdW50ZXIpO1xuICAgICAgICAgICAgdGhpcy5nbC5iaW5kVGV4dHVyZSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRoaXMudGV4LmJ1ZlRleHR1cmVzW2NvdW50ZXJdLnRleCk7XG4gICAgICAgICAgICBzZW5kVGV4dHVyZSh0aGlzLmdsLCBiKTtcbiAgICAgICAgICAgIC8vIFRPRE8gc2VlIGlmIHdlIG5lZWQgdG8gdW5iaW5kICh0aGlzIGdldHMgcmlkIG9mIHRoZSBlcnJvcilcbiAgICAgICAgICAgIHRoaXMuZ2wuYmluZFRleHR1cmUodGhpcy5nbC5URVhUVVJFXzJELCBudWxsKTtcbiAgICAgICAgICAgIGNvdW50ZXIrKztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByb2dyYW1Mb29wLnJ1bih0aGlzLmdsLCB0aGlzLnRleCwgdGhpcy5mcmFtZWJ1ZmZlciwgdGhpcy51bmlmb3JtTG9jcywgdGhpcy5wcm9ncmFtTG9vcC5sYXN0LCB7IHRpbWVWYWw6IHRpbWVWYWwsIG1vdXNlWDogbW91c2VYLCBtb3VzZVk6IG1vdXNlWSB9KTtcbiAgICAgICAgLy8gbWFrZSBzdXJlIGZyb250IGFuZCBiYWNrIGFyZSBpbiBzYW1lIG9yZGVyXG4gICAgICAgIC8vdGhpcy50ZXguZnJvbnQgPSBvcmlnaW5hbEZyb250O1xuICAgICAgICAvL3RoaXMudGV4LmJhY2sgPSBvcmlnaW5hbEJhY2s7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGRlbGV0ZSBhbGwgcmVzb3VyY2VzIGNyZWF0ZWQgYnkgY29uc3RydWN0aW9uIG9mIHRoaXMgW1tNZXJnZXJdXTsgdXNlIHJpZ2h0IGJlZm9yZVxuICAgICAqIGludGVudGlvbmFsbHkgbG9zaW5nIGEgcmVmZXJlbmNlIHRvIHRoaXMgbWVyZ2VyIG9iamVjdC4gdGhpcyBpcyB1c2VmdWwgaWYgeW91IHdhbnRcbiAgICAgKiB0byBjb25zdHJ1Y3QgYW5vdGhlciBbW01lcmdlcl1dIHRvIHVzZSBuZXcgZWZmZWN0c1xuICAgICAqL1xuICAgIGRlbGV0ZSgpIHtcbiAgICAgICAgLy8gY2FsbCBiaW5kIHdpdGggbnVsbCBvbiBhbGwgdGV4dHVyZXNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyICsgdGhpcy50ZXguYnVmVGV4dHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIC8vIHRoaXMgZ2V0cyByaWQgb2YgZmluYWwgdGV4dHVyZSwgc2NlbmUgdGV4dHVyZSBhbmQgY2hhbm5lbHNcbiAgICAgICAgICAgIHRoaXMuZ2wuYWN0aXZlVGV4dHVyZSh0aGlzLmdsLlRFWFRVUkUwICsgaSk7XG4gICAgICAgICAgICB0aGlzLmdsLmJpbmRUZXh0dXJlKHRoaXMuZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY2FsbCBiaW5kIHdpdGggbnVsbCBvbiBhbGwgdmVydGV4IGJ1ZmZlcnMgKGp1c3QgMSlcbiAgICAgICAgdGhpcy5nbC5iaW5kQnVmZmVyKHRoaXMuZ2wuQVJSQVlfQlVGRkVSLCBudWxsKTtcbiAgICAgICAgLy8gY2FsbCBiaW5kIHdpdGggbnVsbCBvbiBhbGwgZnJhbWUgYnVmZmVycyAoanVzdCAxKVxuICAgICAgICAvLyAodGhpcyBtaWdodCBiZSByZWR1bmRhbnQgYmVjYXVzZSB0aGlzIGhhcHBlbnMgYXQgZW5kIG9mIGRyYXcgY2FsbClcbiAgICAgICAgdGhpcy5nbC5iaW5kRnJhbWVidWZmZXIodGhpcy5nbC5GUkFNRUJVRkZFUiwgbnVsbCk7XG4gICAgICAgIC8vIGRlbGV0ZSBhbGwgcHJvZ3JhbXNcbiAgICAgICAgdGhpcy5wcm9ncmFtTG9vcC5kZWxldGUodGhpcy5nbCk7XG4gICAgICAgIC8vIGRlbGV0ZSBhbGwgdGV4dHVyZXNcbiAgICAgICAgdGhpcy5nbC5kZWxldGVUZXh0dXJlKHRoaXMudGV4LmZyb250LnRleCk7XG4gICAgICAgIHRoaXMuZ2wuZGVsZXRlVGV4dHVyZSh0aGlzLnRleC5iYWNrLnRleCk7XG4gICAgICAgIGZvciAoY29uc3QgYyBvZiB0aGlzLnRleC5idWZUZXh0dXJlcykge1xuICAgICAgICAgICAgdGhpcy5nbC5kZWxldGVUZXh0dXJlKGMudGV4KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkZWxldGUgYWxsIHZlcnRleCBidWZmZXJzIChqdXN0IDEpXG4gICAgICAgIHRoaXMuZ2wuZGVsZXRlQnVmZmVyKHRoaXMudmVydGV4QnVmZmVyKTtcbiAgICAgICAgLy8gZGVsZXRlIGFsbCBmcmFtZSBidWZmZXJzIChqdXN0IDEpXG4gICAgICAgIHRoaXMuZ2wuZGVsZXRlRnJhbWVidWZmZXIodGhpcy5mcmFtZWJ1ZmZlcik7XG4gICAgICAgIC8vIGRlbGV0ZSBhbGwgdmVydGV4IHNoYWRlcnMgKGp1c3QgMSlcbiAgICAgICAgdGhpcy5nbC5kZWxldGVTaGFkZXIodGhpcy52U2hhZGVyKTtcbiAgICAgICAgLy8gZGVsZXRlIGFsbCBmcmFnbWVudCBzaGFkZXJzXG4gICAgICAgIGZvciAoY29uc3QgZiBvZiB0aGlzLmZTaGFkZXJzKSB7XG4gICAgICAgICAgICB0aGlzLmdsLmRlbGV0ZVNoYWRlcihmKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBjaGFuZ2VzIHRoZSBjdXJyZW50IHByb2dyYW0gbG9vcFxuICAgICAqIEBwYXJhbSBzdHIga2V5IGluIHRoZSBwcm9ncmFtIG1hcFxuICAgICAqL1xuICAgIGNoYW5nZVByb2dyYW0oc3RyKSB7XG4gICAgICAgIGlmICh0aGlzLnByb2dyYW1NYXBbc3RyXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHByb2dyYW0gXCIke3N0cn1cIiBkb2Vzbid0IGV4aXN0IG9uIHRoaXMgbWVyZ2VyYCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm9ncmFtTG9vcCA9IHRoaXMucHJvZ3JhbU1hcFtzdHJdO1xuICAgIH1cbn1cbmV4cG9ydHMuTWVyZ2VyID0gTWVyZ2VyO1xuLyoqIGNyZWF0ZXMgYSB0ZXh0dXJlIGdpdmVuIGEgY29udGV4dCBhbmQgb3B0aW9ucyAqL1xuZnVuY3Rpb24gbWFrZVRleHR1cmUoZ2wsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB0ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgIGlmICh0ZXh0dXJlID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInByb2JsZW0gY3JlYXRpbmcgdGV4dHVyZVwiKTtcbiAgICB9XG4gICAgLy8gZmxpcCB0aGUgb3JkZXIgb2YgdGhlIHBpeGVscywgb3IgZWxzZSBpdCBkaXNwbGF5cyB1cHNpZGUgZG93blxuICAgIGdsLnBpeGVsU3RvcmVpKGdsLlVOUEFDS19GTElQX1lfV0VCR0wsIHRydWUpO1xuICAgIC8vIGJpbmQgdGhlIHRleHR1cmUgYWZ0ZXIgY3JlYXRpbmcgaXRcbiAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXh0dXJlKTtcbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLmRyYXdpbmdCdWZmZXJXaWR0aCwgZ2wuZHJhd2luZ0J1ZmZlckhlaWdodCwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG4gICAgY29uc3QgZmlsdGVyTW9kZSA9IChmKSA9PiBmID09PSB1bmRlZmluZWQgfHwgZiA9PT0gXCJsaW5lYXJcIiA/IGdsLkxJTkVBUiA6IGdsLk5FQVJFU1Q7XG4gICAgLy8gaG93IHRvIG1hcCB0ZXh0dXJlIGVsZW1lbnRcbiAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgZmlsdGVyTW9kZShvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWluRmlsdGVyTW9kZSkpO1xuICAgIGdsLnRleFBhcmFtZXRlcmkoZ2wuVEVYVFVSRV8yRCwgZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCBmaWx0ZXJNb2RlKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tYXhGaWx0ZXJNb2RlKSk7XG4gICAgaWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZWRnZU1vZGUpICE9PSBcIndyYXBcIikge1xuICAgICAgICBnbC50ZXhQYXJhbWV0ZXJpKGdsLlRFWFRVUkVfMkQsIGdsLlRFWFRVUkVfV1JBUF9TLCBnbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgZ2wudGV4UGFyYW1ldGVyaShnbC5URVhUVVJFXzJELCBnbC5URVhUVVJFX1dSQVBfVCwgZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0dXJlO1xufVxuZXhwb3J0cy5tYWtlVGV4dHVyZSA9IG1ha2VUZXh0dXJlO1xuLyoqIGNvcGllcyBvbnRvIHRleHR1cmUgKi9cbmZ1bmN0aW9uIHNlbmRUZXh0dXJlKGdsLCBzcmMpIHtcbiAgICAvLyBpZiB5b3UgYXJlIHVzaW5nIHRleHR1cmVzIGluc3RlYWQgb2YgaW1hZ2VzLCB0aGUgdXNlciBpcyByZXNwb25zaWJsZSBmb3JcbiAgICAvLyB1cGRhdGluZyB0aGF0IHRleHR1cmUsIHNvIGp1c3QgcmV0dXJuXG4gICAgaWYgKHNyYyBpbnN0YW5jZW9mIFdlYkdMVGV4dHVyZSB8fCBzcmMgPT09IG51bGwpXG4gICAgICAgIHJldHVybjtcbiAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHNyYyk7XG59XG5leHBvcnRzLnNlbmRUZXh0dXJlID0gc2VuZFRleHR1cmU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV2ViR0xQcm9ncmFtTG9vcCA9IGV4cG9ydHMuV2ViR0xQcm9ncmFtTGVhZiA9IGV4cG9ydHMudXBkYXRlTmVlZHMgPSB2b2lkIDA7XG5sZXQgdGV4dHVyZURlYnVnID0gZmFsc2U7XG4vLyB1cGRhdGUgbWUgb24gY2hhbmdlIHRvIG5lZWRzXG5mdW5jdGlvbiB1cGRhdGVOZWVkcyhhY2MsIGN1cnIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBuZWlnaGJvclNhbXBsZTogYWNjLm5laWdoYm9yU2FtcGxlIHx8IGN1cnIubmVpZ2hib3JTYW1wbGUsXG4gICAgICAgIGNlbnRlclNhbXBsZTogYWNjLmNlbnRlclNhbXBsZSB8fCBjdXJyLmNlbnRlclNhbXBsZSxcbiAgICAgICAgc2NlbmVCdWZmZXI6IGFjYy5zY2VuZUJ1ZmZlciB8fCBjdXJyLnNjZW5lQnVmZmVyLFxuICAgICAgICB0aW1lVW5pZm9ybTogYWNjLnRpbWVVbmlmb3JtIHx8IGN1cnIudGltZVVuaWZvcm0sXG4gICAgICAgIG1vdXNlVW5pZm9ybTogYWNjLm1vdXNlVW5pZm9ybSB8fCBjdXJyLm1vdXNlVW5pZm9ybSxcbiAgICAgICAgZXh0cmFCdWZmZXJzOiBuZXcgU2V0KFsuLi5hY2MuZXh0cmFCdWZmZXJzLCAuLi5jdXJyLmV4dHJhQnVmZmVyc10pLFxuICAgIH07XG59XG5leHBvcnRzLnVwZGF0ZU5lZWRzID0gdXBkYXRlTmVlZHM7XG5jbGFzcyBXZWJHTFByb2dyYW1MZWFmIHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9ncmFtLCB0b3RhbE5lZWRzLCBlZmZlY3RzKSB7XG4gICAgICAgIHRoaXMucHJvZ3JhbSA9IHByb2dyYW07XG4gICAgICAgIHRoaXMudG90YWxOZWVkcyA9IHRvdGFsTmVlZHM7XG4gICAgICAgIHRoaXMuZWZmZWN0cyA9IGVmZmVjdHM7XG4gICAgfVxufVxuZXhwb3J0cy5XZWJHTFByb2dyYW1MZWFmID0gV2ViR0xQcm9ncmFtTGVhZjtcbi8qKiByZWN1cnNpdmUgZGF0YSBzdHJ1Y3R1cmUgb2YgY29tcGlsZWQgcHJvZ3JhbXMgKi9cbmNsYXNzIFdlYkdMUHJvZ3JhbUxvb3Age1xuICAgIGNvbnN0cnVjdG9yKHByb2dyYW1FbGVtZW50LCBsb29wSW5mbywgZ2wpIHtcbiAgICAgICAgLy9lZmZlY3RzOiBFeHByW107XG4gICAgICAgIHRoaXMubGFzdCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnByb2dyYW1FbGVtZW50ID0gcHJvZ3JhbUVsZW1lbnQ7XG4gICAgICAgIHRoaXMubG9vcEluZm8gPSBsb29wSW5mbztcbiAgICAgICAgaWYgKHRoaXMucHJvZ3JhbUVsZW1lbnQgaW5zdGFuY2VvZiBXZWJHTFByb2dyYW1MZWFmKSB7XG4gICAgICAgICAgICBpZiAoZ2wgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInByb2dyYW0gZWxlbWVudCBpcyBhIHByb2dyYW0gYnV0IGNvbnRleHQgaXMgdW5kZWZpbmVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZ2V0IHRoZSB0aW1lIHVuaWZvcm0gbG9jYXRpb25cbiAgICAgICAgICAgIGlmICh0aGlzLnByb2dyYW1FbGVtZW50LnRvdGFsTmVlZHMudGltZVVuaWZvcm0pIHtcbiAgICAgICAgICAgICAgICBnbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbUVsZW1lbnQucHJvZ3JhbSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGltZUxvYyA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW1FbGVtZW50LnByb2dyYW0sIFwidVRpbWVcIik7XG4gICAgICAgICAgICAgICAgaWYgKHRpbWVMb2MgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY291bGQgbm90IGdldCB0aGUgdGltZSB1bmlmb3JtIGxvY2F0aW9uXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVMb2MgPSB0aW1lTG9jO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZ2V0IHRoZSBtb3VzZSB1bmlmb3JtIGxvY2F0aW9uXG4gICAgICAgICAgICBpZiAodGhpcy5wcm9ncmFtRWxlbWVudC50b3RhbE5lZWRzLm1vdXNlVW5pZm9ybSkge1xuICAgICAgICAgICAgICAgIGdsLnVzZVByb2dyYW0odGhpcy5wcm9ncmFtRWxlbWVudC5wcm9ncmFtKTtcbiAgICAgICAgICAgICAgICBjb25zdCBtb3VzZUxvYyA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbih0aGlzLnByb2dyYW1FbGVtZW50LnByb2dyYW0sIFwidU1vdXNlXCIpO1xuICAgICAgICAgICAgICAgIGlmIChtb3VzZUxvYyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb3VsZCBub3QgZ2V0IHRoZSBtb3VzZSB1bmlmb3JtIGxvY2F0aW9uXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm1vdXNlTG9jID0gbW91c2VMb2M7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIGdldCBhbGwgbmVlZHMgZnJvbSBhbGwgcHJvZ3JhbXMgKi9cbiAgICBnZXRUb3RhbE5lZWRzKCkge1xuICAgICAgICAvLyBnbyB0aHJvdWdoIG5lZWRzIG9mIHByb2dyYW0gbG9vcFxuICAgICAgICBpZiAoISh0aGlzLnByb2dyYW1FbGVtZW50IGluc3RhbmNlb2YgV2ViR0xQcm9ncmFtTGVhZikpIHtcbiAgICAgICAgICAgIGNvbnN0IGFsbE5lZWRzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHAgb2YgdGhpcy5wcm9ncmFtRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGFsbE5lZWRzLnB1c2gocC5nZXRUb3RhbE5lZWRzKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFsbE5lZWRzLnJlZHVjZSh1cGRhdGVOZWVkcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvZ3JhbUVsZW1lbnQudG90YWxOZWVkcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogcmVjdXJzaXZlbHkgdXNlcyBhbGwgcHJvZ3JhbXMgaW4gdGhlIGxvb3AsIGJpbmRpbmcgdGhlIGFwcHJvcHJpYXRlXG4gICAgICogdGV4dHVyZXMgYW5kIHNldHRpbmcgdGhlIGFwcHJvcHJpYXRlIHVuaWZvcm1zOyB0aGUgdXNlciBzaG91bGQgb25seSBoYXZlXG4gICAgICogdG8gY2FsbCBbW2RyYXddXSBvbiBbW01lcmdlcl1dIGFuZCBuZXZlciB0aGlzIGZ1bmN0aW9uIGRpcmVjdGx5XG4gICAgICovXG4gICAgcnVuKGdsLCB0ZXgsIGZyYW1lYnVmZmVyLCB1bmlmb3JtTG9jcywgbGFzdCwgZGVmYXVsdFVuaWZvcm1zLCBvdXRlckxvb3ApIHtcbiAgICAgICAgbGV0IHNhdmVkVGV4dHVyZTtcbiAgICAgICAgaWYgKHRoaXMubG9vcEluZm8udGFyZ2V0ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgdGFyZ2V0IHN3aXRjaDpcbiAgICAgICAgICAgIChvdXRlckxvb3AgPT09IG51bGwgfHwgb3V0ZXJMb29wID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvdXRlckxvb3AubG9vcEluZm8udGFyZ2V0KSAhPT0gdGhpcy5sb29wSW5mby50YXJnZXQpIHtcbiAgICAgICAgICAgIC8vIHN3YXAgb3V0IHRoZSBiYWNrIHRleHR1cmUgZm9yIHRoZSBjaGFubmVsIHRleHR1cmUgaWYgdGhpcyBsb29wIGhhc1xuICAgICAgICAgICAgLy8gYW4gYWx0ZXJuYXRlIHJlbmRlciB0YXJnZXRcbiAgICAgICAgICAgIHNhdmVkVGV4dHVyZSA9IHRleC5iYWNrO1xuICAgICAgICAgICAgaWYgKHRoaXMubG9vcEluZm8udGFyZ2V0ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRleC5iYWNrID0gdGV4LmJ1ZlRleHR1cmVzW3RoaXMubG9vcEluZm8udGFyZ2V0XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0ZXguc2NlbmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cmllZCB0byB0YXJnZXQgLTEgYnV0IHNjZW5lIHRleHR1cmUgd2FzIHVuZGVmaW5lZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGV4LmJhY2sgPSB0ZXguc2NlbmU7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBnZXQgcmlkIG9mIHRoaXNcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwicmVuZGVyIHRhcmdldCBpcyAtMVwiKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInRleC5iYWNrXCIsIHRleC5iYWNrKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInNhdmVkIHRleHR1cmVcIiwgc2F2ZWRUZXh0dXJlKTtcbiAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGV4LmJ1ZlRleHR1cmVzW3RoaXMubG9vcEluZm8udGFyZ2V0XSA9IHNhdmVkVGV4dHVyZTtcbiAgICAgICAgICAgIGlmICh0ZXh0dXJlRGVidWcpXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJzYXZlZCB0ZXh0dXJlOiBcIiArIHNhdmVkVGV4dHVyZS5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZXR1cCBmb3IgcHJvZ3JhbSBsZWFmXG4gICAgICAgIGlmICh0aGlzLnByb2dyYW1FbGVtZW50IGluc3RhbmNlb2YgV2ViR0xQcm9ncmFtTGVhZikge1xuICAgICAgICAgICAgLy8gYmluZCB0aGUgc2NlbmUgdGV4dHVyZSBpZiBuZWVkZWRcbiAgICAgICAgICAgIGlmICh0aGlzLnByb2dyYW1FbGVtZW50LnRvdGFsTmVlZHMuc2NlbmVCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAodGV4LnNjZW5lID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibmVlZHMgc2NlbmUgYnVmZmVyLCBidXQgc2NlbmUgdGV4dHVyZSBpcyBzb21laG93IHVuZGVmaW5lZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubG9vcEluZm8udGFyZ2V0ID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiYmluZGluZyBzY2VuZSB0byB0aGUgc2F2ZWQgdGV4dHVyZVwiLCBzYXZlZFRleHR1cmUpO1xuICAgICAgICAgICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBzYXZlZFRleHR1cmUudGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdsLmJpbmRUZXh0dXJlKGdsLlRFWFRVUkVfMkQsIHRleC5zY2VuZS50ZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGJpbmQgYWxsIGV4dHJhIGNoYW5uZWwgdGV4dHVyZXMgaWYgbmVlZGVkXG4gICAgICAgICAgICBmb3IgKGNvbnN0IG4gb2YgdGhpcy5wcm9ncmFtRWxlbWVudC50b3RhbE5lZWRzLmV4dHJhQnVmZmVycykge1xuICAgICAgICAgICAgICAgIGdsLmFjdGl2ZVRleHR1cmUoZ2wuVEVYVFVSRTIgKyBuKTtcbiAgICAgICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0ZXguYnVmVGV4dHVyZXNbbl0udGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHVzZSB0aGUgY3VycmVudCBwcm9ncmFtXG4gICAgICAgICAgICBnbC51c2VQcm9ncmFtKHRoaXMucHJvZ3JhbUVsZW1lbnQucHJvZ3JhbSk7XG4gICAgICAgICAgICAvLyBhcHBseSBhbGwgdW5pZm9ybXNcbiAgICAgICAgICAgIGZvciAoY29uc3QgZWZmZWN0IG9mIHRoaXMucHJvZ3JhbUVsZW1lbnQuZWZmZWN0cykge1xuICAgICAgICAgICAgICAgIGVmZmVjdC5hcHBseVVuaWZvcm1zKGdsLCB1bmlmb3JtTG9jcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzZXQgdGltZSB1bmlmb3JtIGlmIG5lZWRlZFxuICAgICAgICAgICAgaWYgKHRoaXMucHJvZ3JhbUVsZW1lbnQudG90YWxOZWVkcy50aW1lVW5pZm9ybSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRpbWVMb2MgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0VW5pZm9ybXMudGltZVZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRpbWUgb3IgbG9jYXRpb24gaXMgdW5kZWZpbmVkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBnbC51bmlmb3JtMWYodGhpcy50aW1lTG9jLCBkZWZhdWx0VW5pZm9ybXMudGltZVZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzZXQgbW91c2UgdW5pZm9ybXMgaWYgbmVlZGVkXG4gICAgICAgICAgICBpZiAodGhpcy5wcm9ncmFtRWxlbWVudC50b3RhbE5lZWRzLm1vdXNlVW5pZm9ybSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1vdXNlTG9jID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFVuaWZvcm1zLm1vdXNlWCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRVbmlmb3Jtcy5tb3VzZVkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtb3VzZSB1bmlmb3JtIG9yIGxvY2F0aW9uIGlzIHVuZGVmaW5lZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ2wudW5pZm9ybTJmKHRoaXMubW91c2VMb2MsIGRlZmF1bHRVbmlmb3Jtcy5tb3VzZVgsIGRlZmF1bHRVbmlmb3Jtcy5tb3VzZVkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5sb29wSW5mby5udW07IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbmV3TGFzdCA9IGkgPT09IHRoaXMubG9vcEluZm8ubnVtIC0gMTtcbiAgICAgICAgICAgIGlmICh0aGlzLnByb2dyYW1FbGVtZW50IGluc3RhbmNlb2YgV2ViR0xQcm9ncmFtTGVhZikge1xuICAgICAgICAgICAgICAgIGlmIChuZXdMYXN0ICYmIGxhc3QgJiYgdGhpcy5sYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHdlIGFyZSBvbiB0aGUgZmluYWwgcGFzcyBvZiB0aGUgZmluYWwgbG9vcCwgc28gZHJhdyBzY3JlZW4gYnlcbiAgICAgICAgICAgICAgICAgICAgLy8gc2V0dGluZyB0byB0aGUgZGVmYXVsdCBmcmFtZWJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgaGF2ZSB0byBib3VuY2UgYmV0d2VlbiB0d28gdGV4dHVyZXNcbiAgICAgICAgICAgICAgICAgICAgZ2wuYmluZEZyYW1lYnVmZmVyKGdsLkZSQU1FQlVGRkVSLCBmcmFtZWJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgICAgIC8vIHVzZSB0aGUgZnJhbWVidWZmZXIgdG8gd3JpdGUgdG8gZnJvbnQgdGV4dHVyZVxuICAgICAgICAgICAgICAgICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHRleC5mcm9udC50ZXgsIDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBhbGxvd3MgdXMgdG8gcmVhZCBmcm9tIGB0ZXhCYWNrYFxuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHQgc2FtcGxlciBpcyAwLCBzbyBgdVNhbXBsZXJgIHVuaWZvcm0gd2lsbCBhbHdheXMgc2FtcGxlIGZyb20gdGV4dHVyZSAwXG4gICAgICAgICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMCk7XG4gICAgICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgdGV4LmJhY2sudGV4KTtcbiAgICAgICAgICAgICAgICAvLyB1c2Ugb3VyIGxhc3QgcHJvZ3JhbSBhcyB0aGUgZHJhdyBwcm9ncmFtXG4gICAgICAgICAgICAgICAgZ2wuZHJhd0FycmF5cyhnbC5UUklBTkdMRVMsIDAsIDYpO1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0dXJlRGVidWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJpbnRlcm1lZGlhdGUgYmFja1wiLCB0ZXguYmFjay5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJpbnRlcm1lZGlhdGUgZnJvbnRcIiwgdGV4LmZyb250Lm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBzd2FwIGJhY2sgYW5kIGZyb250XG4gICAgICAgICAgICAgICAgW3RleC5iYWNrLCB0ZXguZnJvbnRdID0gW3RleC5mcm9udCwgdGV4LmJhY2tdO1xuICAgICAgICAgICAgICAgIC8vIGRlYWN0aXZhdGUgYW5kIHVuYmluZCBhbGwgdGhlIGNoYW5uZWwgdGV4dHVyZXMgbmVlZGVkXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBuIG9mIHRoaXMucHJvZ3JhbUVsZW1lbnQudG90YWxOZWVkcy5leHRyYUJ1ZmZlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMiArIG4pO1xuICAgICAgICAgICAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ2wuYWN0aXZlVGV4dHVyZShnbC5URVhUVVJFMSk7XG4gICAgICAgICAgICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5sb29wSW5mby5mdW5jICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb29wSW5mby5mdW5jKGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHAgb2YgdGhpcy5wcm9ncmFtRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBwLnJ1bihnbCwgdGV4LCBmcmFtZWJ1ZmZlciwgdW5pZm9ybUxvY3MsIG5ld0xhc3QsIGRlZmF1bHRVbmlmb3JtcywgdGhpcyAvLyB0aGlzIGlzIG5vdyB0aGUgb3V0ZXIgbG9vcFxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBzd2FwIHRoZSB0ZXh0dXJlcyBiYWNrIGlmIHdlIHdlcmUgdGVtcG9yYXJpbHkgdXNpbmcgYSBjaGFubmVsIHRleHR1cmVcbiAgICAgICAgaWYgKHNhdmVkVGV4dHVyZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLmxvb3BJbmZvLnRhcmdldDtcbiAgICAgICAgICAgIGlmICh0ZXh0dXJlRGVidWcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcInByZSBmaW5hbCBiYWNrXCIsIHRleC5iYWNrLm5hbWUpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwicHJlIGZpbmFsIGZyb250XCIsIHRleC5mcm9udC5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGJhY2sgdGV4dHVyZSBpcyByZWFsbHkgdGhlIGZyb250IHRleHR1cmUgYmVjYXVzZSBpdCB3YXMganVzdCBzd2FwcGVkXG4gICAgICAgICAgICBpZiAodGhpcy5sb29wSW5mby50YXJnZXQgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGV4LmJ1ZlRleHR1cmVzW3RhcmdldF0gPSB0ZXguYmFjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0ZXguc2NlbmUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cmllZCB0byByZXBsYWNlIC0xIGJ1dCBzY2VuZSB0ZXh0dXJlIHdhcyB1bmRlZmluZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRleC5zY2VuZSA9IHRleC5iYWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGV4LmJhY2sgPSBzYXZlZFRleHR1cmU7XG4gICAgICAgICAgICBpZiAodGV4dHVyZURlYnVnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJwb3N0IGZpbmFsIGJhY2tcIiwgdGV4LmJhY2submFtZSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJwb3N0IGZpbmFsIGZyb250XCIsIHRleC5mcm9udC5uYW1lKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcImNoYW5uZWwgdGV4dHVyZVwiLCB0ZXguYnVmVGV4dHVyZXNbdGFyZ2V0XS5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWxldGUoZ2wpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvZ3JhbUVsZW1lbnQgaW5zdGFuY2VvZiBXZWJHTFByb2dyYW1MZWFmKSB7XG4gICAgICAgICAgICBnbC5kZWxldGVQcm9ncmFtKHRoaXMucHJvZ3JhbUVsZW1lbnQucHJvZ3JhbSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHAgb2YgdGhpcy5wcm9ncmFtRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHAuZGVsZXRlKGdsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuV2ViR0xQcm9ncmFtTG9vcCA9IFdlYkdMUHJvZ3JhbUxvb3A7XG4iXX0=
